import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class MarketsRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.MarketsRequest", [
      {
        no: 1,
        name: "market_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_statuses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketStatus = "";
    message.quoteDenom = "";
    message.marketStatuses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_status */
        1:
          message.marketStatus = reader.string();
          break;
        case /* string quote_denom */
        2:
          message.quoteDenom = reader.string();
          break;
        case /* repeated string market_statuses */
        3:
          message.marketStatuses.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketStatus !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketStatus);
    if (message.quoteDenom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quoteDenom);
    for (let i = 0; i < message.marketStatuses.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.marketStatuses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketsRequest = new MarketsRequest$Type();
class MarketsResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.MarketsResponse", [
      { no: 1, name: "markets", kind: "message", repeat: 2, T: () => DerivativeMarketInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativeMarketInfo markets */
        1:
          message.markets.push(DerivativeMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.markets.length; i++)
      DerivativeMarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketsResponse = new MarketsResponse$Type();
class DerivativeMarketInfo$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.DerivativeMarketInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "oracle_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "initial_margin_ratio",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "maintenance_margin_ratio",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 11, name: "quote_token_meta", kind: "message", T: () => TokenMeta },
      {
        no: 12,
        name: "maker_fee_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "taker_fee_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "service_provider_fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "is_perpetual",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 16,
        name: "min_price_tick_size",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 17,
        name: "min_quantity_tick_size",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 18, name: "perpetual_market_info", kind: "message", T: () => PerpetualMarketInfo },
      { no: 19, name: "perpetual_market_funding", kind: "message", T: () => PerpetualMarketFunding },
      { no: 20, name: "expiry_futures_market_info", kind: "message", T: () => ExpiryFuturesMarketInfo },
      {
        no: 21,
        name: "min_notional",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 22,
        name: "reduce_margin_ratio",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 23, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.marketStatus = "";
    message.ticker = "";
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleType = "";
    message.oracleScaleFactor = 0;
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.quoteDenom = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.serviceProviderFee = "";
    message.isPerpetual = false;
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.reduceMarginRatio = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string market_status */
        2:
          message.marketStatus = reader.string();
          break;
        case /* string ticker */
        3:
          message.ticker = reader.string();
          break;
        case /* string oracle_base */
        4:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        5:
          message.oracleQuote = reader.string();
          break;
        case /* string oracle_type */
        6:
          message.oracleType = reader.string();
          break;
        case /* uint32 oracle_scale_factor */
        7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* string initial_margin_ratio */
        8:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        9:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string quote_denom */
        10:
          message.quoteDenom = reader.string();
          break;
        case /* injective_derivative_exchange_rpc.TokenMeta quote_token_meta */
        11:
          message.quoteTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.quoteTokenMeta);
          break;
        case /* string maker_fee_rate */
        12:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        13:
          message.takerFeeRate = reader.string();
          break;
        case /* string service_provider_fee */
        14:
          message.serviceProviderFee = reader.string();
          break;
        case /* bool is_perpetual */
        15:
          message.isPerpetual = reader.bool();
          break;
        case /* string min_price_tick_size */
        16:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        17:
          message.minQuantityTickSize = reader.string();
          break;
        case /* injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info */
        18:
          message.perpetualMarketInfo = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.perpetualMarketInfo);
          break;
        case /* injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding */
        19:
          message.perpetualMarketFunding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.perpetualMarketFunding);
          break;
        case /* injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info */
        20:
          message.expiryFuturesMarketInfo = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.expiryFuturesMarketInfo);
          break;
        case /* string min_notional */
        21:
          message.minNotional = reader.string();
          break;
        case /* string reduce_margin_ratio */
        22:
          message.reduceMarginRatio = reader.string();
          break;
        case /* injective_derivative_exchange_rpc.OpenNotionalCap open_notional_cap */
        23:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.marketStatus !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketStatus);
    if (message.ticker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleBase !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleType !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.initialMarginRatio !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.quoteDenom !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.quoteTokenMeta)
      TokenMeta.internalBinaryWrite(message.quoteTokenMeta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.makerFeeRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.serviceProviderFee !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.serviceProviderFee);
    if (message.isPerpetual !== false)
      writer.tag(15, WireType.Varint).bool(message.isPerpetual);
    if (message.minPriceTickSize !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.perpetualMarketInfo)
      PerpetualMarketInfo.internalBinaryWrite(message.perpetualMarketInfo, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.perpetualMarketFunding)
      PerpetualMarketFunding.internalBinaryWrite(message.perpetualMarketFunding, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    if (message.expiryFuturesMarketInfo)
      ExpiryFuturesMarketInfo.internalBinaryWrite(message.expiryFuturesMarketInfo, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    if (message.minNotional !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.minNotional);
    if (message.reduceMarginRatio !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.reduceMarginRatio);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketInfo = new DerivativeMarketInfo$Type();
class TokenMeta$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.TokenMeta", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "logo",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.address = "";
    message.symbol = "";
    message.logo = "";
    message.decimals = 0;
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        case /* string symbol */
        3:
          message.symbol = reader.string();
          break;
        case /* string logo */
        4:
          message.logo = reader.string();
          break;
        case /* sint32 decimals */
        5:
          message.decimals = reader.sint32();
          break;
        case /* sint64 updated_at */
        6:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    if (message.symbol !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.symbol);
    if (message.logo !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.logo);
    if (message.decimals !== 0)
      writer.tag(5, WireType.Varint).sint32(message.decimals);
    if (message.updatedAt !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TokenMeta = new TokenMeta$Type();
class PerpetualMarketInfo$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PerpetualMarketInfo", [
      {
        no: 1,
        name: "hourly_funding_rate_cap",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "hourly_interest_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "next_funding_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "funding_interval",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hourlyFundingRateCap = "";
    message.hourlyInterestRate = "";
    message.nextFundingTimestamp = 0n;
    message.fundingInterval = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string hourly_funding_rate_cap */
        1:
          message.hourlyFundingRateCap = reader.string();
          break;
        case /* string hourly_interest_rate */
        2:
          message.hourlyInterestRate = reader.string();
          break;
        case /* sint64 next_funding_timestamp */
        3:
          message.nextFundingTimestamp = reader.sint64().toBigInt();
          break;
        case /* sint64 funding_interval */
        4:
          message.fundingInterval = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hourlyFundingRateCap !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
    if (message.hourlyInterestRate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.hourlyInterestRate);
    if (message.nextFundingTimestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.nextFundingTimestamp);
    if (message.fundingInterval !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.fundingInterval);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketInfo = new PerpetualMarketInfo$Type();
class PerpetualMarketFunding$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PerpetualMarketFunding", [
      {
        no: 1,
        name: "cumulative_funding",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "cumulative_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "last_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "last_funding_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cumulativeFunding = "";
    message.cumulativePrice = "";
    message.lastTimestamp = 0n;
    message.lastFundingRate = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cumulative_funding */
        1:
          message.cumulativeFunding = reader.string();
          break;
        case /* string cumulative_price */
        2:
          message.cumulativePrice = reader.string();
          break;
        case /* sint64 last_timestamp */
        3:
          message.lastTimestamp = reader.sint64().toBigInt();
          break;
        case /* string last_funding_rate */
        4:
          message.lastFundingRate = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cumulativeFunding !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cumulativeFunding);
    if (message.cumulativePrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
    if (message.lastTimestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.lastTimestamp);
    if (message.lastFundingRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.lastFundingRate);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketFunding = new PerpetualMarketFunding$Type();
class ExpiryFuturesMarketInfo$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo", [
      {
        no: 1,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "settlement_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.expirationTimestamp = 0n;
    message.settlementPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 expiration_timestamp */
        1:
          message.expirationTimestamp = reader.sint64().toBigInt();
          break;
        case /* string settlement_price */
        2:
          message.settlementPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.expirationTimestamp !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.expirationTimestamp);
    if (message.settlementPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.settlementPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExpiryFuturesMarketInfo = new ExpiryFuturesMarketInfo$Type();
class OpenNotionalCap$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OpenNotionalCap", [
      {
        no: 1,
        name: "cap",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cap = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cap */
        1:
          message.cap = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cap !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cap);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenNotionalCap = new OpenNotionalCap$Type();
class MarketRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.MarketRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketRequest = new MarketRequest$Type();
class MarketResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.MarketResponse", [
      { no: 1, name: "market", kind: "message", T: () => DerivativeMarketInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeMarketInfo market */
        1:
          message.market = DerivativeMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      DerivativeMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketResponse = new MarketResponse$Type();
class StreamMarketRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamMarketRequest", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamMarketRequest = new StreamMarketRequest$Type();
class StreamMarketResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamMarketResponse", [
      { no: 1, name: "market", kind: "message", T: () => DerivativeMarketInfo },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeMarketInfo market */
        1:
          message.market = DerivativeMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      DerivativeMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamMarketResponse = new StreamMarketResponse$Type();
class BinaryOptionsMarketsRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest", [
      {
        no: 1,
        name: "market_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketStatus = "";
    message.quoteDenom = "";
    message.skip = 0n;
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_status */
        1:
          message.marketStatus = reader.string();
          break;
        case /* string quote_denom */
        2:
          message.quoteDenom = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketStatus !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketStatus);
    if (message.quoteDenom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarketsRequest = new BinaryOptionsMarketsRequest$Type();
class BinaryOptionsMarketsResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse", [
      { no: 1, name: "markets", kind: "message", repeat: 2, T: () => BinaryOptionsMarketInfo },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets */
        1:
          message.markets.push(BinaryOptionsMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.markets.length; i++)
      BinaryOptionsMarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarketsResponse = new BinaryOptionsMarketsResponse$Type();
class BinaryOptionsMarketInfo$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.BinaryOptionsMarketInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "oracle_symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "oracle_provider",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "oracle_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "settlement_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 11, name: "quote_token_meta", kind: "message", T: () => TokenMeta },
      {
        no: 12,
        name: "maker_fee_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "taker_fee_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "service_provider_fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "min_price_tick_size",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "min_quantity_tick_size",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 17,
        name: "settlement_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 18,
        name: "min_notional",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.marketStatus = "";
    message.ticker = "";
    message.oracleSymbol = "";
    message.oracleProvider = "";
    message.oracleType = "";
    message.oracleScaleFactor = 0;
    message.expirationTimestamp = 0n;
    message.settlementTimestamp = 0n;
    message.quoteDenom = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.serviceProviderFee = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.settlementPrice = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string market_status */
        2:
          message.marketStatus = reader.string();
          break;
        case /* string ticker */
        3:
          message.ticker = reader.string();
          break;
        case /* string oracle_symbol */
        4:
          message.oracleSymbol = reader.string();
          break;
        case /* string oracle_provider */
        5:
          message.oracleProvider = reader.string();
          break;
        case /* string oracle_type */
        6:
          message.oracleType = reader.string();
          break;
        case /* uint32 oracle_scale_factor */
        7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* sint64 expiration_timestamp */
        8:
          message.expirationTimestamp = reader.sint64().toBigInt();
          break;
        case /* sint64 settlement_timestamp */
        9:
          message.settlementTimestamp = reader.sint64().toBigInt();
          break;
        case /* string quote_denom */
        10:
          message.quoteDenom = reader.string();
          break;
        case /* injective_derivative_exchange_rpc.TokenMeta quote_token_meta */
        11:
          message.quoteTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.quoteTokenMeta);
          break;
        case /* string maker_fee_rate */
        12:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        13:
          message.takerFeeRate = reader.string();
          break;
        case /* string service_provider_fee */
        14:
          message.serviceProviderFee = reader.string();
          break;
        case /* string min_price_tick_size */
        15:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        16:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string settlement_price */
        17:
          message.settlementPrice = reader.string();
          break;
        case /* string min_notional */
        18:
          message.minNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.marketStatus !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketStatus);
    if (message.ticker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleSymbol !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.oracleSymbol);
    if (message.oracleProvider !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.oracleProvider);
    if (message.oracleType !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.expirationTimestamp !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.expirationTimestamp);
    if (message.settlementTimestamp !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.settlementTimestamp);
    if (message.quoteDenom !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.quoteTokenMeta)
      TokenMeta.internalBinaryWrite(message.quoteTokenMeta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.makerFeeRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.serviceProviderFee !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.serviceProviderFee);
    if (message.minPriceTickSize !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.settlementPrice !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.settlementPrice);
    if (message.minNotional !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.minNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarketInfo = new BinaryOptionsMarketInfo$Type();
class Paging$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.Paging", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "from",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "to",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "count_by_subaccount",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total = 0n;
    message.from = 0;
    message.to = 0;
    message.countBySubaccount = 0n;
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 total */
        1:
          message.total = reader.sint64().toBigInt();
          break;
        case /* sint32 from */
        2:
          message.from = reader.sint32();
          break;
        case /* sint32 to */
        3:
          message.to = reader.sint32();
          break;
        case /* sint64 count_by_subaccount */
        4:
          message.countBySubaccount = reader.sint64().toBigInt();
          break;
        case /* repeated string next */
        5:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.total);
    if (message.from !== 0)
      writer.tag(2, WireType.Varint).sint32(message.from);
    if (message.to !== 0)
      writer.tag(3, WireType.Varint).sint32(message.to);
    if (message.countBySubaccount !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
    for (let i = 0; i < message.next.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Paging = new Paging$Type();
class BinaryOptionsMarketRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.BinaryOptionsMarketRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarketRequest = new BinaryOptionsMarketRequest$Type();
class BinaryOptionsMarketResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.BinaryOptionsMarketResponse", [
      { no: 1, name: "market", kind: "message", T: () => BinaryOptionsMarketInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market */
        1:
          message.market = BinaryOptionsMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      BinaryOptionsMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarketResponse = new BinaryOptionsMarketResponse$Type();
class OrderbookV2Request$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrderbookV2Request", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "depth",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.depth = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* sint32 depth */
        2:
          message.depth = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.depth !== 0)
      writer.tag(2, WireType.Varint).sint32(message.depth);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookV2Request = new OrderbookV2Request$Type();
class OrderbookV2Response$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrderbookV2Response", [
      { no: 1, name: "orderbook", kind: "message", T: () => DerivativeLimitOrderbookV2 }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook */
        1:
          message.orderbook = DerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderbook)
      DerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookV2Response = new OrderbookV2Response$Type();
class DerivativeLimitOrderbookV2$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2", [
      { no: 1, name: "buys", kind: "message", repeat: 2, T: () => PriceLevel },
      { no: 2, name: "sells", kind: "message", repeat: 2, T: () => PriceLevel },
      {
        no: 3,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.buys = [];
    message.sells = [];
    message.sequence = 0n;
    message.timestamp = 0n;
    message.height = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.PriceLevel buys */
        1:
          message.buys.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_derivative_exchange_rpc.PriceLevel sells */
        2:
          message.sells.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 sequence */
        3:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* sint64 height */
        5:
          message.height = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.buys.length; i++)
      PriceLevel.internalBinaryWrite(message.buys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sells.length; i++)
      PriceLevel.internalBinaryWrite(message.sells[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.sequence !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.sequence);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.height);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeLimitOrderbookV2 = new DerivativeLimitOrderbookV2$Type();
class PriceLevel$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PriceLevel", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceLevel = new PriceLevel$Type();
class OrderbooksV2Request$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrderbooksV2Request", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "depth",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    message.depth = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        case /* sint32 depth */
        2:
          message.depth = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.depth !== 0)
      writer.tag(2, WireType.Varint).sint32(message.depth);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbooksV2Request = new OrderbooksV2Request$Type();
class OrderbooksV2Response$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrderbooksV2Response", [
      { no: 1, name: "orderbooks", kind: "message", repeat: 2, T: () => SingleDerivativeLimitOrderbookV2 }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderbooks = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks */
        1:
          message.orderbooks.push(SingleDerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orderbooks.length; i++)
      SingleDerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbooks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbooksV2Response = new OrderbooksV2Response$Type();
class SingleDerivativeLimitOrderbookV2$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "orderbook", kind: "message", T: () => DerivativeLimitOrderbookV2 }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook */
        2:
          message.orderbook = DerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderbook)
      DerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SingleDerivativeLimitOrderbookV2 = new SingleDerivativeLimitOrderbookV2$Type();
class StreamOrderbookV2Request$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrderbookV2Request", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookV2Request = new StreamOrderbookV2Request$Type();
class StreamOrderbookV2Response$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrderbookV2Response", [
      { no: 1, name: "orderbook", kind: "message", T: () => DerivativeLimitOrderbookV2 },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook */
        1:
          message.orderbook = DerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* string market_id */
        4:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderbook)
      DerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    if (message.marketId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookV2Response = new StreamOrderbookV2Response$Type();
class StreamOrderbookUpdateRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookUpdateRequest = new StreamOrderbookUpdateRequest$Type();
class StreamOrderbookUpdateResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse", [
      { no: 1, name: "orderbook_level_updates", kind: "message", T: () => OrderbookLevelUpdates },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates */
        1:
          message.orderbookLevelUpdates = OrderbookLevelUpdates.internalBinaryRead(reader, reader.uint32(), options, message.orderbookLevelUpdates);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* string market_id */
        4:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderbookLevelUpdates)
      OrderbookLevelUpdates.internalBinaryWrite(message.orderbookLevelUpdates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    if (message.marketId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookUpdateResponse = new StreamOrderbookUpdateResponse$Type();
class OrderbookLevelUpdates$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrderbookLevelUpdates", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "buys", kind: "message", repeat: 2, T: () => PriceLevelUpdate },
      { no: 4, name: "sells", kind: "message", repeat: 2, T: () => PriceLevelUpdate },
      {
        no: 5,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.sequence = 0n;
    message.buys = [];
    message.sells = [];
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* uint64 sequence */
        2:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* repeated injective_derivative_exchange_rpc.PriceLevelUpdate buys */
        3:
          message.buys.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_derivative_exchange_rpc.PriceLevelUpdate sells */
        4:
          message.sells.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 updated_at */
        5:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.sequence !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.sequence);
    for (let i = 0; i < message.buys.length; i++)
      PriceLevelUpdate.internalBinaryWrite(message.buys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sells.length; i++)
      PriceLevelUpdate.internalBinaryWrite(message.sells[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookLevelUpdates = new OrderbookLevelUpdates$Type();
class PriceLevelUpdate$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PriceLevelUpdate", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.isActive = false;
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* bool is_active */
        3:
          message.isActive = reader.bool();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.isActive !== false)
      writer.tag(3, WireType.Varint).bool(message.isActive);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceLevelUpdate = new PriceLevelUpdate$Type();
class OrdersRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "is_conditional",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "include_inactive",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 12,
        name: "subaccount_total_orders",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderSide = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.isConditional = "";
    message.orderType = "";
    message.includeInactive = false;
    message.subaccountTotalOrders = false;
    message.tradeId = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        5:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        6:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        7:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        8:
          message.marketIds.push(reader.string());
          break;
        case /* string is_conditional */
        9:
          message.isConditional = reader.string();
          break;
        case /* string order_type */
        10:
          message.orderType = reader.string();
          break;
        case /* bool include_inactive */
        11:
          message.includeInactive = reader.bool();
          break;
        case /* bool subaccount_total_orders */
        12:
          message.subaccountTotalOrders = reader.bool();
          break;
        case /* string trade_id */
        13:
          message.tradeId = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(5, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.isConditional !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.isConditional);
    if (message.orderType !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.orderType);
    if (message.includeInactive !== false)
      writer.tag(11, WireType.Varint).bool(message.includeInactive);
    if (message.subaccountTotalOrders !== false)
      writer.tag(12, WireType.Varint).bool(message.subaccountTotalOrders);
    if (message.tradeId !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.tradeId);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersRequest = new OrdersRequest$Type();
class OrdersResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrdersResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => DerivativeLimitOrder },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders */
        1:
          message.orders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      DerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersResponse = new OrdersResponse$Type();
class DerivativeLimitOrder$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.DerivativeLimitOrder", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_reduce_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "unfilled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 15,
        name: "order_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 16,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 17,
        name: "is_conditional",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 18,
        name: "trigger_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 19,
        name: "placed_order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 20,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 22,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.orderSide = "";
    message.marketId = "";
    message.subaccountId = "";
    message.isReduceOnly = false;
    message.margin = "";
    message.price = "";
    message.quantity = "";
    message.unfilledQuantity = "";
    message.triggerPrice = "";
    message.feeRecipient = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.orderNumber = 0n;
    message.orderType = "";
    message.isConditional = false;
    message.triggerAt = 0n;
    message.placedOrderHash = "";
    message.executionType = "";
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* bool is_reduce_only */
        5:
          message.isReduceOnly = reader.bool();
          break;
        case /* string margin */
        6:
          message.margin = reader.string();
          break;
        case /* string price */
        7:
          message.price = reader.string();
          break;
        case /* string quantity */
        8:
          message.quantity = reader.string();
          break;
        case /* string unfilled_quantity */
        9:
          message.unfilledQuantity = reader.string();
          break;
        case /* string trigger_price */
        10:
          message.triggerPrice = reader.string();
          break;
        case /* string fee_recipient */
        11:
          message.feeRecipient = reader.string();
          break;
        case /* string state */
        12:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        13:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        14:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* sint64 order_number */
        15:
          message.orderNumber = reader.sint64().toBigInt();
          break;
        case /* string order_type */
        16:
          message.orderType = reader.string();
          break;
        case /* bool is_conditional */
        17:
          message.isConditional = reader.bool();
          break;
        case /* uint64 trigger_at */
        18:
          message.triggerAt = reader.uint64().toBigInt();
          break;
        case /* string placed_order_hash */
        19:
          message.placedOrderHash = reader.string();
          break;
        case /* string execution_type */
        20:
          message.executionType = reader.string();
          break;
        case /* string tx_hash */
        21:
          message.txHash = reader.string();
          break;
        case /* string cid */
        22:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.isReduceOnly !== false)
      writer.tag(5, WireType.Varint).bool(message.isReduceOnly);
    if (message.margin !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.margin);
    if (message.price !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.quantity);
    if (message.unfilledQuantity !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.unfilledQuantity);
    if (message.triggerPrice !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.feeRecipient !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.state !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(14, WireType.Varint).sint64(message.updatedAt);
    if (message.orderNumber !== 0n)
      writer.tag(15, WireType.Varint).sint64(message.orderNumber);
    if (message.orderType !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.orderType);
    if (message.isConditional !== false)
      writer.tag(17, WireType.Varint).bool(message.isConditional);
    if (message.triggerAt !== 0n)
      writer.tag(18, WireType.Varint).uint64(message.triggerAt);
    if (message.placedOrderHash !== "")
      writer.tag(19, WireType.LengthDelimited).string(message.placedOrderHash);
    if (message.executionType !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.executionType);
    if (message.txHash !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
class PositionsRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PositionsRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "subaccount_total_positions",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.direction = "";
    message.subaccountTotalPositions = false;
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        5:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        6:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        7:
          message.marketIds.push(reader.string());
          break;
        case /* string direction */
        8:
          message.direction = reader.string();
          break;
        case /* bool subaccount_total_positions */
        9:
          message.subaccountTotalPositions = reader.bool();
          break;
        case /* string account_address */
        10:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(7, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.direction !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountTotalPositions !== false)
      writer.tag(9, WireType.Varint).bool(message.subaccountTotalPositions);
    if (message.accountAddress !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionsRequest = new PositionsRequest$Type();
class PositionsResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PositionsResponse", [
      { no: 1, name: "positions", kind: "message", repeat: 2, T: () => DerivativePosition },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.positions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativePosition positions */
        1:
          message.positions.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.positions.length; i++)
      DerivativePosition.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionsResponse = new PositionsResponse$Type();
class DerivativePosition$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.DerivativePosition", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "entry_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "liquidation_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "mark_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "aggregate_reduce_only_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "funding_last",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "funding_sum",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "cumulative_funding_entry",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 17,
        name: "effective_cumulative_funding_entry",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.marketId = "";
    message.subaccountId = "";
    message.direction = "";
    message.quantity = "";
    message.entryPrice = "";
    message.margin = "";
    message.liquidationPrice = "";
    message.markPrice = "";
    message.aggregateReduceOnlyQuantity = "";
    message.updatedAt = 0n;
    message.createdAt = 0n;
    message.fundingLast = "";
    message.fundingSum = "";
    message.cumulativeFundingEntry = "";
    message.effectiveCumulativeFundingEntry = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* string quantity */
        5:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        6:
          message.entryPrice = reader.string();
          break;
        case /* string margin */
        7:
          message.margin = reader.string();
          break;
        case /* string liquidation_price */
        8:
          message.liquidationPrice = reader.string();
          break;
        case /* string mark_price */
        9:
          message.markPrice = reader.string();
          break;
        case /* string aggregate_reduce_only_quantity */
        11:
          message.aggregateReduceOnlyQuantity = reader.string();
          break;
        case /* sint64 updated_at */
        12:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        13:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* string funding_last */
        14:
          message.fundingLast = reader.string();
          break;
        case /* string funding_sum */
        15:
          message.fundingSum = reader.string();
          break;
        case /* string cumulative_funding_entry */
        16:
          message.cumulativeFundingEntry = reader.string();
          break;
        case /* string effective_cumulative_funding_entry */
        17:
          message.effectiveCumulativeFundingEntry = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.quantity !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
    if (message.margin !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.margin);
    if (message.liquidationPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
    if (message.markPrice !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
    if (message.aggregateReduceOnlyQuantity !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.aggregateReduceOnlyQuantity);
    if (message.updatedAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.updatedAt);
    if (message.createdAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.createdAt);
    if (message.fundingLast !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.fundingLast);
    if (message.fundingSum !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.fundingSum);
    if (message.cumulativeFundingEntry !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
    if (message.effectiveCumulativeFundingEntry !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.effectiveCumulativeFundingEntry);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativePosition = new DerivativePosition$Type();
class PositionsV2Request$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PositionsV2Request", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "subaccount_total_positions",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.direction = "";
    message.subaccountTotalPositions = false;
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        5:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        6:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        7:
          message.marketIds.push(reader.string());
          break;
        case /* string direction */
        8:
          message.direction = reader.string();
          break;
        case /* bool subaccount_total_positions */
        9:
          message.subaccountTotalPositions = reader.bool();
          break;
        case /* string account_address */
        10:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(7, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.direction !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountTotalPositions !== false)
      writer.tag(9, WireType.Varint).bool(message.subaccountTotalPositions);
    if (message.accountAddress !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionsV2Request = new PositionsV2Request$Type();
class PositionsV2Response$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PositionsV2Response", [
      { no: 1, name: "positions", kind: "message", repeat: 2, T: () => DerivativePositionV2 },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.positions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativePositionV2 positions */
        1:
          message.positions.push(DerivativePositionV2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.positions.length; i++)
      DerivativePositionV2.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionsV2Response = new PositionsV2Response$Type();
class DerivativePositionV2$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.DerivativePositionV2", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "entry_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "liquidation_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "mark_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "funding_last",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "funding_sum",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "cumulative_funding_entry",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "effective_cumulative_funding_entry",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.marketId = "";
    message.subaccountId = "";
    message.direction = "";
    message.quantity = "";
    message.entryPrice = "";
    message.margin = "";
    message.liquidationPrice = "";
    message.markPrice = "";
    message.updatedAt = 0n;
    message.denom = "";
    message.fundingLast = "";
    message.fundingSum = "";
    message.cumulativeFundingEntry = "";
    message.effectiveCumulativeFundingEntry = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* string quantity */
        5:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        6:
          message.entryPrice = reader.string();
          break;
        case /* string margin */
        7:
          message.margin = reader.string();
          break;
        case /* string liquidation_price */
        8:
          message.liquidationPrice = reader.string();
          break;
        case /* string mark_price */
        9:
          message.markPrice = reader.string();
          break;
        case /* sint64 updated_at */
        11:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string denom */
        12:
          message.denom = reader.string();
          break;
        case /* string funding_last */
        13:
          message.fundingLast = reader.string();
          break;
        case /* string funding_sum */
        14:
          message.fundingSum = reader.string();
          break;
        case /* string cumulative_funding_entry */
        15:
          message.cumulativeFundingEntry = reader.string();
          break;
        case /* string effective_cumulative_funding_entry */
        16:
          message.effectiveCumulativeFundingEntry = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.quantity !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
    if (message.margin !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.margin);
    if (message.liquidationPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
    if (message.markPrice !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
    if (message.updatedAt !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.updatedAt);
    if (message.denom !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.denom);
    if (message.fundingLast !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.fundingLast);
    if (message.fundingSum !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.fundingSum);
    if (message.cumulativeFundingEntry !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
    if (message.effectiveCumulativeFundingEntry !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.effectiveCumulativeFundingEntry);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativePositionV2 = new DerivativePositionV2$Type();
class LiquidablePositionsRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.LiquidablePositionsRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        2:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LiquidablePositionsRequest = new LiquidablePositionsRequest$Type();
class LiquidablePositionsResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.LiquidablePositionsResponse", [
      { no: 1, name: "positions", kind: "message", repeat: 2, T: () => DerivativePosition }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.positions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativePosition positions */
        1:
          message.positions.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.positions.length; i++)
      DerivativePosition.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LiquidablePositionsResponse = new LiquidablePositionsResponse$Type();
class FundingPaymentsRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.FundingPaymentsRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    message.endTime = 0n;
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* sint64 end_time */
        5:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        6:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    if (message.endTime !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingPaymentsRequest = new FundingPaymentsRequest$Type();
class FundingPaymentsResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.FundingPaymentsResponse", [
      { no: 1, name: "payments", kind: "message", repeat: 2, T: () => FundingPayment },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.payments = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.FundingPayment payments */
        1:
          message.payments.push(FundingPayment.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.payments.length; i++)
      FundingPayment.internalBinaryWrite(message.payments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingPaymentsResponse = new FundingPaymentsResponse$Type();
class FundingPayment$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.FundingPayment", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.amount = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string amount */
        3:
          message.amount = reader.string();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.amount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.amount);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingPayment = new FundingPayment$Type();
class FundingRatesRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.FundingRatesRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    message.endTime = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        2:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* sint64 end_time */
        4:
          message.endTime = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.endTime !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.endTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingRatesRequest = new FundingRatesRequest$Type();
class FundingRatesResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.FundingRatesResponse", [
      { no: 1, name: "funding_rates", kind: "message", repeat: 2, T: () => FundingRate },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fundingRates = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.FundingRate funding_rates */
        1:
          message.fundingRates.push(FundingRate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.fundingRates.length; i++)
      FundingRate.internalBinaryWrite(message.fundingRates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingRatesResponse = new FundingRatesResponse$Type();
class FundingRate$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.FundingRate", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.rate = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string rate */
        2:
          message.rate = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.rate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.rate);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingRate = new FundingRate$Type();
class StreamPositionsRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamPositionsRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.marketIds = [];
    message.subaccountIds = [];
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* repeated string market_ids */
        3:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        4:
          message.subaccountIds.push(reader.string());
          break;
        case /* string account_address */
        5:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountIds[i]);
    if (message.accountAddress !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamPositionsRequest = new StreamPositionsRequest$Type();
class StreamPositionsResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamPositionsResponse", [
      { no: 1, name: "position", kind: "message", T: () => DerivativePosition },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativePosition position */
        1:
          message.position = DerivativePosition.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.position)
      DerivativePosition.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamPositionsResponse = new StreamPositionsResponse$Type();
class StreamPositionsV2Request$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamPositionsV2Request", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.marketIds = [];
    message.subaccountIds = [];
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* repeated string market_ids */
        3:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        4:
          message.subaccountIds.push(reader.string());
          break;
        case /* string account_address */
        5:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountIds[i]);
    if (message.accountAddress !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamPositionsV2Request = new StreamPositionsV2Request$Type();
class StreamPositionsV2Response$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamPositionsV2Response", [
      { no: 1, name: "position", kind: "message", T: () => DerivativePositionV2 },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativePositionV2 position */
        1:
          message.position = DerivativePositionV2.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.position)
      DerivativePositionV2.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamPositionsV2Response = new StreamPositionsV2Response$Type();
class StreamOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "is_conditional",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "include_inactive",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 12,
        name: "subaccount_total_orders",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderSide = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.isConditional = "";
    message.orderType = "";
    message.includeInactive = false;
    message.subaccountTotalOrders = false;
    message.tradeId = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        5:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        6:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        7:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        8:
          message.marketIds.push(reader.string());
          break;
        case /* string is_conditional */
        9:
          message.isConditional = reader.string();
          break;
        case /* string order_type */
        10:
          message.orderType = reader.string();
          break;
        case /* bool include_inactive */
        11:
          message.includeInactive = reader.bool();
          break;
        case /* bool subaccount_total_orders */
        12:
          message.subaccountTotalOrders = reader.bool();
          break;
        case /* string trade_id */
        13:
          message.tradeId = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(5, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.isConditional !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.isConditional);
    if (message.orderType !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.orderType);
    if (message.includeInactive !== false)
      writer.tag(11, WireType.Varint).bool(message.includeInactive);
    if (message.subaccountTotalOrders !== false)
      writer.tag(12, WireType.Varint).bool(message.subaccountTotalOrders);
    if (message.tradeId !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.tradeId);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersRequest = new StreamOrdersRequest$Type();
class StreamOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrdersResponse", [
      { no: 1, name: "order", kind: "message", T: () => DerivativeLimitOrder },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeLimitOrder order */
        1:
          message.order = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.order)
      DerivativeLimitOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersResponse = new StreamOrdersResponse$Type();
class TradesRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.TradesRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesRequest = new TradesRequest$Type();
class TradesResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.TradesResponse", [
      { no: 1, name: "trades", kind: "message", repeat: 2, T: () => DerivativeTrade },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades */
        1:
          message.trades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.trades.length; i++)
      DerivativeTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesResponse = new TradesResponse$Type();
class DerivativeTrade$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.DerivativeTrade", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "trade_execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_liquidation",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 6, name: "position_delta", kind: "message", T: () => PositionDelta },
      {
        no: 7,
        name: "payout",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "pnl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.subaccountId = "";
    message.marketId = "";
    message.tradeExecutionType = "";
    message.isLiquidation = false;
    message.payout = "";
    message.fee = "";
    message.executedAt = 0n;
    message.feeRecipient = "";
    message.tradeId = "";
    message.executionSide = "";
    message.cid = "";
    message.pnl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string trade_execution_type */
        4:
          message.tradeExecutionType = reader.string();
          break;
        case /* bool is_liquidation */
        5:
          message.isLiquidation = reader.bool();
          break;
        case /* injective_derivative_exchange_rpc.PositionDelta position_delta */
        6:
          message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
          break;
        case /* string payout */
        7:
          message.payout = reader.string();
          break;
        case /* string fee */
        8:
          message.fee = reader.string();
          break;
        case /* sint64 executed_at */
        9:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* string fee_recipient */
        10:
          message.feeRecipient = reader.string();
          break;
        case /* string trade_id */
        11:
          message.tradeId = reader.string();
          break;
        case /* string execution_side */
        12:
          message.executionSide = reader.string();
          break;
        case /* string cid */
        13:
          message.cid = reader.string();
          break;
        case /* string pnl */
        14:
          message.pnl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.tradeExecutionType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
    if (message.isLiquidation !== false)
      writer.tag(5, WireType.Varint).bool(message.isLiquidation);
    if (message.positionDelta)
      PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.payout !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.payout);
    if (message.fee !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.fee);
    if (message.executedAt !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.executedAt);
    if (message.feeRecipient !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.tradeId !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
    if (message.executionSide !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.executionSide);
    if (message.cid !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.cid);
    if (message.pnl !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.pnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeTrade = new DerivativeTrade$Type();
class PositionDelta$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.PositionDelta", [
      {
        no: 1,
        name: "trade_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "execution_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "execution_margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tradeDirection = "";
    message.executionPrice = "";
    message.executionQuantity = "";
    message.executionMargin = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string trade_direction */
        1:
          message.tradeDirection = reader.string();
          break;
        case /* string execution_price */
        2:
          message.executionPrice = reader.string();
          break;
        case /* string execution_quantity */
        3:
          message.executionQuantity = reader.string();
          break;
        case /* string execution_margin */
        4:
          message.executionMargin = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tradeDirection !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tradeDirection);
    if (message.executionPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionPrice);
    if (message.executionQuantity !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionQuantity);
    if (message.executionMargin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.executionMargin);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionDelta = new PositionDelta$Type();
class TradesV2Request$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.TradesV2Request", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesV2Request = new TradesV2Request$Type();
class TradesV2Response$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.TradesV2Response", [
      { no: 1, name: "trades", kind: "message", repeat: 2, T: () => DerivativeTrade },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades */
        1:
          message.trades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.trades.length; i++)
      DerivativeTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesV2Response = new TradesV2Response$Type();
class StreamTradesRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamTradesRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesRequest = new StreamTradesRequest$Type();
class StreamTradesResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamTradesResponse", [
      { no: 1, name: "trade", kind: "message", T: () => DerivativeTrade },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeTrade trade */
        1:
          message.trade = DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.trade)
      DerivativeTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesResponse = new StreamTradesResponse$Type();
class StreamTradesV2Request$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamTradesV2Request", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesV2Request = new StreamTradesV2Request$Type();
class StreamTradesV2Response$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamTradesV2Response", [
      { no: 1, name: "trade", kind: "message", T: () => DerivativeTrade },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeTrade trade */
        1:
          message.trade = DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.trade)
      DerivativeTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesV2Response = new StreamTradesV2Response$Type();
class SubaccountOrdersListRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.SubaccountOrdersListRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrdersListRequest = new SubaccountOrdersListRequest$Type();
class SubaccountOrdersListResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.SubaccountOrdersListResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => DerivativeLimitOrder },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders */
        1:
          message.orders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      DerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrdersListResponse = new SubaccountOrdersListResponse$Type();
class SubaccountTradesListRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.SubaccountTradesListRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.executionType = "";
    message.direction = "";
    message.skip = 0n;
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string execution_type */
        3:
          message.executionType = reader.string();
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.executionType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionType);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountTradesListRequest = new SubaccountTradesListRequest$Type();
class SubaccountTradesListResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.SubaccountTradesListResponse", [
      { no: 1, name: "trades", kind: "message", repeat: 2, T: () => DerivativeTrade }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades */
        1:
          message.trades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.trades.length; i++)
      DerivativeTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountTradesListResponse = new SubaccountTradesListResponse$Type();
class OrdersHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrdersHistoryRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "order_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "is_conditional",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "active_markets_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 16,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    message.orderTypes = [];
    message.direction = "";
    message.startTime = 0n;
    message.endTime = 0n;
    message.isConditional = "";
    message.orderType = "";
    message.state = "";
    message.executionTypes = [];
    message.marketIds = [];
    message.tradeId = "";
    message.activeMarketsOnly = false;
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* repeated string order_types */
        5:
          message.orderTypes.push(reader.string());
          break;
        case /* string direction */
        6:
          message.direction = reader.string();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* string is_conditional */
        9:
          message.isConditional = reader.string();
          break;
        case /* string order_type */
        10:
          message.orderType = reader.string();
          break;
        case /* string state */
        11:
          message.state = reader.string();
          break;
        case /* repeated string execution_types */
        12:
          message.executionTypes.push(reader.string());
          break;
        case /* repeated string market_ids */
        13:
          message.marketIds.push(reader.string());
          break;
        case /* string trade_id */
        14:
          message.tradeId = reader.string();
          break;
        case /* bool active_markets_only */
        15:
          message.activeMarketsOnly = reader.bool();
          break;
        case /* string cid */
        16:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    for (let i = 0; i < message.orderTypes.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.orderTypes[i]);
    if (message.direction !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.direction);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    if (message.isConditional !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.isConditional);
    if (message.orderType !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.orderType);
    if (message.state !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.state);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(12, WireType.LengthDelimited).string(message.executionTypes[i]);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(13, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.tradeId !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.tradeId);
    if (message.activeMarketsOnly !== false)
      writer.tag(15, WireType.Varint).bool(message.activeMarketsOnly);
    if (message.cid !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersHistoryRequest = new OrdersHistoryRequest$Type();
class OrdersHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OrdersHistoryResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => DerivativeOrderHistory },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.DerivativeOrderHistory orders */
        1:
          message.orders.push(DerivativeOrderHistory.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_derivative_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      DerivativeOrderHistory.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersHistoryResponse = new OrdersHistoryResponse$Type();
class DerivativeOrderHistory$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.DerivativeOrderHistory", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "filled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "is_reduce_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 15,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "is_conditional",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 17,
        name: "trigger_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 18,
        name: "placed_order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 19,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 20,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.marketId = "";
    message.isActive = false;
    message.subaccountId = "";
    message.executionType = "";
    message.orderType = "";
    message.price = "";
    message.triggerPrice = "";
    message.quantity = "";
    message.filledQuantity = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.isReduceOnly = false;
    message.direction = "";
    message.isConditional = false;
    message.triggerAt = 0n;
    message.placedOrderHash = "";
    message.margin = "";
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* bool is_active */
        3:
          message.isActive = reader.bool();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* string execution_type */
        5:
          message.executionType = reader.string();
          break;
        case /* string order_type */
        6:
          message.orderType = reader.string();
          break;
        case /* string price */
        7:
          message.price = reader.string();
          break;
        case /* string trigger_price */
        8:
          message.triggerPrice = reader.string();
          break;
        case /* string quantity */
        9:
          message.quantity = reader.string();
          break;
        case /* string filled_quantity */
        10:
          message.filledQuantity = reader.string();
          break;
        case /* string state */
        11:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        12:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        13:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* bool is_reduce_only */
        14:
          message.isReduceOnly = reader.bool();
          break;
        case /* string direction */
        15:
          message.direction = reader.string();
          break;
        case /* bool is_conditional */
        16:
          message.isConditional = reader.bool();
          break;
        case /* uint64 trigger_at */
        17:
          message.triggerAt = reader.uint64().toBigInt();
          break;
        case /* string placed_order_hash */
        18:
          message.placedOrderHash = reader.string();
          break;
        case /* string margin */
        19:
          message.margin = reader.string();
          break;
        case /* string tx_hash */
        20:
          message.txHash = reader.string();
          break;
        case /* string cid */
        21:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.isActive !== false)
      writer.tag(3, WireType.Varint).bool(message.isActive);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.executionType !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.executionType);
    if (message.orderType !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.orderType);
    if (message.price !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.price);
    if (message.triggerPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.quantity !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.quantity);
    if (message.filledQuantity !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
    if (message.state !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.updatedAt);
    if (message.isReduceOnly !== false)
      writer.tag(14, WireType.Varint).bool(message.isReduceOnly);
    if (message.direction !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.direction);
    if (message.isConditional !== false)
      writer.tag(16, WireType.Varint).bool(message.isConditional);
    if (message.triggerAt !== 0n)
      writer.tag(17, WireType.Varint).uint64(message.triggerAt);
    if (message.placedOrderHash !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.placedOrderHash);
    if (message.margin !== "")
      writer.tag(19, WireType.LengthDelimited).string(message.margin);
    if (message.txHash !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeOrderHistory = new DerivativeOrderHistory$Type();
class StreamOrdersHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrdersHistoryRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "order_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.orderTypes = [];
    message.direction = "";
    message.state = "";
    message.executionTypes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* repeated string order_types */
        3:
          message.orderTypes.push(reader.string());
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* string state */
        5:
          message.state = reader.string();
          break;
        case /* repeated string execution_types */
        6:
          message.executionTypes.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.orderTypes.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.orderTypes[i]);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.state !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.state);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.executionTypes[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersHistoryRequest = new StreamOrdersHistoryRequest$Type();
class StreamOrdersHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.StreamOrdersHistoryResponse", [
      { no: 1, name: "order", kind: "message", T: () => DerivativeOrderHistory },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_derivative_exchange_rpc.DerivativeOrderHistory order */
        1:
          message.order = DerivativeOrderHistory.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.order)
      DerivativeOrderHistory.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersHistoryResponse = new StreamOrdersHistoryResponse$Type();
class OpenInterestRequest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OpenInterestRequest", [
      {
        no: 1,
        name: "market_i_ds",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIDs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_i_ds */
        1:
          message.marketIDs.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIDs.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIDs[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenInterestRequest = new OpenInterestRequest$Type();
class OpenInterestResponse$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.OpenInterestResponse", [
      { no: 1, name: "open_interests", kind: "message", repeat: 2, T: () => MarketOpenInterest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.openInterests = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_derivative_exchange_rpc.MarketOpenInterest open_interests */
        1:
          message.openInterests.push(MarketOpenInterest.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.openInterests.length; i++)
      MarketOpenInterest.internalBinaryWrite(message.openInterests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenInterestResponse = new OpenInterestResponse$Type();
class MarketOpenInterest$Type extends MessageType {
  constructor() {
    super("injective_derivative_exchange_rpc.MarketOpenInterest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "open_interest",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.openInterest = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string open_interest */
        2:
          message.openInterest = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.openInterest !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.openInterest);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketOpenInterest = new MarketOpenInterest$Type();
const InjectiveDerivativeExchangeRPC = new ServiceType("injective_derivative_exchange_rpc.InjectiveDerivativeExchangeRPC", [
  { name: "Markets", options: {}, I: MarketsRequest, O: MarketsResponse },
  { name: "Market", options: {}, I: MarketRequest, O: MarketResponse },
  { name: "StreamMarket", serverStreaming: true, options: {}, I: StreamMarketRequest, O: StreamMarketResponse },
  { name: "BinaryOptionsMarkets", options: {}, I: BinaryOptionsMarketsRequest, O: BinaryOptionsMarketsResponse },
  { name: "BinaryOptionsMarket", options: {}, I: BinaryOptionsMarketRequest, O: BinaryOptionsMarketResponse },
  { name: "OrderbookV2", options: {}, I: OrderbookV2Request, O: OrderbookV2Response },
  { name: "OrderbooksV2", options: {}, I: OrderbooksV2Request, O: OrderbooksV2Response },
  { name: "StreamOrderbookV2", serverStreaming: true, options: {}, I: StreamOrderbookV2Request, O: StreamOrderbookV2Response },
  { name: "StreamOrderbookUpdate", serverStreaming: true, options: {}, I: StreamOrderbookUpdateRequest, O: StreamOrderbookUpdateResponse },
  { name: "Orders", options: {}, I: OrdersRequest, O: OrdersResponse },
  { name: "Positions", options: {}, I: PositionsRequest, O: PositionsResponse },
  { name: "PositionsV2", options: {}, I: PositionsV2Request, O: PositionsV2Response },
  { name: "LiquidablePositions", options: {}, I: LiquidablePositionsRequest, O: LiquidablePositionsResponse },
  { name: "FundingPayments", options: {}, I: FundingPaymentsRequest, O: FundingPaymentsResponse },
  { name: "FundingRates", options: {}, I: FundingRatesRequest, O: FundingRatesResponse },
  { name: "StreamPositions", serverStreaming: true, options: {}, I: StreamPositionsRequest, O: StreamPositionsResponse },
  { name: "StreamPositionsV2", serverStreaming: true, options: {}, I: StreamPositionsV2Request, O: StreamPositionsV2Response },
  { name: "StreamOrders", serverStreaming: true, options: {}, I: StreamOrdersRequest, O: StreamOrdersResponse },
  { name: "Trades", options: {}, I: TradesRequest, O: TradesResponse },
  { name: "TradesV2", options: {}, I: TradesV2Request, O: TradesV2Response },
  { name: "StreamTrades", serverStreaming: true, options: {}, I: StreamTradesRequest, O: StreamTradesResponse },
  { name: "StreamTradesV2", serverStreaming: true, options: {}, I: StreamTradesV2Request, O: StreamTradesV2Response },
  { name: "SubaccountOrdersList", options: {}, I: SubaccountOrdersListRequest, O: SubaccountOrdersListResponse },
  { name: "SubaccountTradesList", options: {}, I: SubaccountTradesListRequest, O: SubaccountTradesListResponse },
  { name: "OrdersHistory", options: {}, I: OrdersHistoryRequest, O: OrdersHistoryResponse },
  { name: "StreamOrdersHistory", serverStreaming: true, options: {}, I: StreamOrdersHistoryRequest, O: StreamOrdersHistoryResponse },
  { name: "OpenInterest", options: {}, I: OpenInterestRequest, O: OpenInterestResponse }
]);
export {
  BinaryOptionsMarketInfo,
  BinaryOptionsMarketRequest,
  BinaryOptionsMarketResponse,
  BinaryOptionsMarketsRequest,
  BinaryOptionsMarketsResponse,
  DerivativeLimitOrder,
  DerivativeLimitOrderbookV2,
  DerivativeMarketInfo,
  DerivativeOrderHistory,
  DerivativePosition,
  DerivativePositionV2,
  DerivativeTrade,
  ExpiryFuturesMarketInfo,
  FundingPayment,
  FundingPaymentsRequest,
  FundingPaymentsResponse,
  FundingRate,
  FundingRatesRequest,
  FundingRatesResponse,
  InjectiveDerivativeExchangeRPC,
  LiquidablePositionsRequest,
  LiquidablePositionsResponse,
  MarketOpenInterest,
  MarketRequest,
  MarketResponse,
  MarketsRequest,
  MarketsResponse,
  OpenInterestRequest,
  OpenInterestResponse,
  OpenNotionalCap,
  OrderbookLevelUpdates,
  OrderbookV2Request,
  OrderbookV2Response,
  OrderbooksV2Request,
  OrderbooksV2Response,
  OrdersHistoryRequest,
  OrdersHistoryResponse,
  OrdersRequest,
  OrdersResponse,
  Paging,
  PerpetualMarketFunding,
  PerpetualMarketInfo,
  PositionDelta,
  PositionsRequest,
  PositionsResponse,
  PositionsV2Request,
  PositionsV2Response,
  PriceLevel,
  PriceLevelUpdate,
  SingleDerivativeLimitOrderbookV2,
  StreamMarketRequest,
  StreamMarketResponse,
  StreamOrderbookUpdateRequest,
  StreamOrderbookUpdateResponse,
  StreamOrderbookV2Request,
  StreamOrderbookV2Response,
  StreamOrdersHistoryRequest,
  StreamOrdersHistoryResponse,
  StreamOrdersRequest,
  StreamOrdersResponse,
  StreamPositionsRequest,
  StreamPositionsResponse,
  StreamPositionsV2Request,
  StreamPositionsV2Response,
  StreamTradesRequest,
  StreamTradesResponse,
  StreamTradesV2Request,
  StreamTradesV2Response,
  SubaccountOrdersListRequest,
  SubaccountOrdersListResponse,
  SubaccountTradesListRequest,
  SubaccountTradesListResponse,
  TokenMeta,
  TradesRequest,
  TradesResponse,
  TradesV2Request,
  TradesV2Response
};
