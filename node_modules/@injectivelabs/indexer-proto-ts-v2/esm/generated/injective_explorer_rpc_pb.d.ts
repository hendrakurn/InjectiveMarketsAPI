// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_explorer_rpc.proto" (package "injective_explorer_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveExplorerRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_explorer_rpc.GetAccountTxsRequest
 */
export interface GetAccountTxsRequest {
    /**
     * Address of account
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Return transactions before this block number
     *
     * @generated from protobuf field: uint64 before = 2
     */
    before: bigint;
    /**
     * Return transactions after this block number
     *
     * @generated from protobuf field: uint64 after = 3
     */
    after: bigint;
    /**
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * @generated from protobuf field: string type = 6
     */
    type: string;
    /**
     * @generated from protobuf field: string module = 7
     */
    module: string;
    /**
     * @generated from protobuf field: sint64 from_number = 8
     */
    fromNumber: bigint;
    /**
     * @generated from protobuf field: sint64 to_number = 9
     */
    toNumber: bigint;
    /**
     * The starting timestamp in UNIX milliseconds that the txs must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 10
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the txs must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 11
     */
    endTime: bigint;
    /**
     * The status of the txs to be returned
     *
     * @generated from protobuf field: string status = 12
     */
    status: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetAccountTxsResponse
 */
export interface GetAccountTxsResponse {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxDetailData data = 2
     */
    data: TxDetailData[];
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_explorer_rpc.Paging
 */
export interface Paging {
    /**
     * total number of txs saved in database
     *
     * @generated from protobuf field: sint64 total = 1
     */
    total: bigint;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 from = 2
     */
    from: number;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 to = 3
     */
    to: number;
    /**
     * count entries by subaccount, serving some places on helix
     *
     * @generated from protobuf field: sint64 count_by_subaccount = 4
     */
    countBySubaccount: bigint;
    /**
     * array of tokens to navigate to the next pages
     *
     * @generated from protobuf field: repeated string next = 5
     */
    next: string[];
}
/**
 * TxDetailData wraps tx data includes details information
 *
 * @generated from protobuf message injective_explorer_rpc.TxDetailData
 */
export interface TxDetailData {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: uint64 block_number = 2
     */
    blockNumber: bigint;
    /**
     * @generated from protobuf field: string block_timestamp = 3
     */
    blockTimestamp: string;
    /**
     * @generated from protobuf field: string hash = 4
     */
    hash: string;
    /**
     * @generated from protobuf field: uint32 code = 5
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 6
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string info = 8
     */
    info: string;
    /**
     * @generated from protobuf field: sint64 gas_wanted = 9
     */
    gasWanted: bigint;
    /**
     * @generated from protobuf field: sint64 gas_used = 10
     */
    gasUsed: bigint;
    /**
     * @generated from protobuf field: injective_explorer_rpc.GasFee gas_fee = 11
     */
    gasFee?: GasFee;
    /**
     * @generated from protobuf field: string codespace = 12
     */
    codespace: string;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.Event events = 13
     */
    events: Event[];
    /**
     * @generated from protobuf field: string tx_type = 14
     */
    txType: string;
    /**
     * @generated from protobuf field: bytes messages = 15
     */
    messages: Uint8Array;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.Signature signatures = 16
     */
    signatures: Signature[];
    /**
     * @generated from protobuf field: string memo = 17
     */
    memo: string;
    /**
     * @generated from protobuf field: uint64 tx_number = 18
     */
    txNumber: bigint;
    /**
     * Block timestamp in unix milli
     *
     * @generated from protobuf field: uint64 block_unix_timestamp = 19
     */
    blockUnixTimestamp: bigint;
    /**
     * Transaction log indicating errors
     *
     * @generated from protobuf field: string error_log = 20
     */
    errorLog: string;
    /**
     * transaction event logs
     *
     * @generated from protobuf field: bytes logs = 21
     */
    logs: Uint8Array;
    /**
     * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
     *
     * @generated from protobuf field: repeated sint64 claim_ids = 22
     */
    claimIds: bigint[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GasFee
 */
export interface GasFee {
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.CosmosCoin amount = 1
     */
    amount: CosmosCoin[];
    /**
     * @generated from protobuf field: uint64 gas_limit = 2
     */
    gasLimit: bigint;
    /**
     * @generated from protobuf field: string payer = 3
     */
    payer: string;
    /**
     * @generated from protobuf field: string granter = 4
     */
    granter: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.CosmosCoin
 */
export interface CosmosCoin {
    /**
     * Coin denominator
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * Coin amount (big int)
     *
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: string type = 1
     */
    type: string;
    /**
     * @generated from protobuf field: map<string, string> attributes = 2
     */
    attributes: {
        [key: string]: string;
    };
}
/**
 * Signature wraps tx signature
 *
 * @generated from protobuf message injective_explorer_rpc.Signature
 */
export interface Signature {
    /**
     * @generated from protobuf field: string pubkey = 1
     */
    pubkey: string;
    /**
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * @generated from protobuf field: uint64 sequence = 3
     */
    sequence: bigint;
    /**
     * @generated from protobuf field: string signature = 4
     */
    signature: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetAccountTxsV2Request
 */
export interface GetAccountTxsV2Request {
    /**
     * Address of account
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Comma-separated list of msg types
     *
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * The starting timestamp in UNIX milliseconds that the txs must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 3
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the txs must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 4
     */
    endTime: bigint;
    /**
     * @generated from protobuf field: sint32 per_page = 5
     */
    perPage: number;
    /**
     * Pagination token
     *
     * @generated from protobuf field: string token = 6
     */
    token: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetAccountTxsV2Response
 */
export interface GetAccountTxsV2Response {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
     */
    paging?: Cursor;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxDetailData data = 2
     */
    data: TxDetailData[];
}
/**
 * Cursor Pagination defines the structure for required params for handling
 * pagination
 *
 * @generated from protobuf message injective_explorer_rpc.Cursor
 */
export interface Cursor {
    /**
     * array of tokens to navigate to the next pages
     *
     * @generated from protobuf field: repeated string next = 1
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetContractTxsRequest
 */
export interface GetContractTxsRequest {
    /**
     * Address of contract
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: sint32 limit = 2
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * @generated from protobuf field: sint64 from_number = 4
     */
    fromNumber: bigint;
    /**
     * @generated from protobuf field: sint64 to_number = 5
     */
    toNumber: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetContractTxsResponse
 */
export interface GetContractTxsResponse {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxDetailData data = 2
     */
    data: TxDetailData[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetContractTxsV2Request
 */
export interface GetContractTxsV2Request {
    /**
     * Address of contract
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Height of the block
     *
     * @generated from protobuf field: uint64 height = 2
     */
    height: bigint;
    /**
     * Unix timestamp (UTC) in milliseconds
     *
     * @generated from protobuf field: sint64 from = 3
     */
    from: bigint;
    /**
     * Unix timestamp (UTC) in milliseconds
     *
     * @generated from protobuf field: sint64 to = 4
     */
    to: bigint;
    /**
     * @generated from protobuf field: sint32 per_page = 5
     */
    perPage: number;
    /**
     * Pagination token
     *
     * @generated from protobuf field: string token = 6
     */
    token: string;
    /**
     * The status of the txs to be returned
     *
     * @generated from protobuf field: string status = 7
     */
    status: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetContractTxsV2Response
 */
export interface GetContractTxsV2Response {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
     */
    paging?: Cursor;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxDetailData data = 2
     */
    data: TxDetailData[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlocksRequest
 */
export interface GetBlocksRequest {
    /**
     * @generated from protobuf field: uint64 before = 1
     */
    before: bigint;
    /**
     * @generated from protobuf field: uint64 after = 2
     */
    after: bigint;
    /**
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
    /**
     * Unix timestamp (UTC) in milliseconds
     *
     * @generated from protobuf field: uint64 from = 4
     */
    from: bigint;
    /**
     * Unix timestamp (UTC) in milliseconds
     *
     * @generated from protobuf field: uint64 to = 5
     */
    to: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlocksResponse
 */
export interface GetBlocksResponse {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.BlockInfo data = 2
     */
    data: BlockInfo[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.BlockInfo
 */
export interface BlockInfo {
    /**
     * @generated from protobuf field: uint64 height = 1
     */
    height: bigint;
    /**
     * @generated from protobuf field: string proposer = 2
     */
    proposer: string;
    /**
     * @generated from protobuf field: string moniker = 3
     */
    moniker: string;
    /**
     * @generated from protobuf field: string block_hash = 4
     */
    blockHash: string;
    /**
     * @generated from protobuf field: string parent_hash = 5
     */
    parentHash: string;
    /**
     * @generated from protobuf field: sint64 num_pre_commits = 6
     */
    numPreCommits: bigint;
    /**
     * @generated from protobuf field: sint64 num_txs = 7
     */
    numTxs: bigint;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxDataRPC txs = 8
     */
    txs: TxDataRPC[];
    /**
     * @generated from protobuf field: string timestamp = 9
     */
    timestamp: string;
    /**
     * Block timestamp in unix milli
     *
     * @generated from protobuf field: uint64 block_unix_timestamp = 10
     */
    blockUnixTimestamp: bigint;
}
/**
 * TxData wraps tx data
 *
 * @generated from protobuf message injective_explorer_rpc.TxDataRPC
 */
export interface TxDataRPC {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: uint64 block_number = 2
     */
    blockNumber: bigint;
    /**
     * @generated from protobuf field: string block_timestamp = 3
     */
    blockTimestamp: string;
    /**
     * @generated from protobuf field: string hash = 4
     */
    hash: string;
    /**
     * @generated from protobuf field: string codespace = 5
     */
    codespace: string;
    /**
     * @generated from protobuf field: string messages = 6
     */
    messages: string;
    /**
     * @generated from protobuf field: uint64 tx_number = 7
     */
    txNumber: bigint;
    /**
     * Transaction log indicating errors
     *
     * @generated from protobuf field: string error_log = 8
     */
    errorLog: string;
    /**
     * @generated from protobuf field: uint32 code = 9
     */
    code: number;
    /**
     * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
     *
     * @generated from protobuf field: repeated sint64 claim_ids = 10
     */
    claimIds: bigint[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlocksV2Request
 */
export interface GetBlocksV2Request {
    /**
     * @generated from protobuf field: sint32 per_page = 1
     */
    perPage: number;
    /**
     * @generated from protobuf field: string token = 2
     */
    token: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlocksV2Response
 */
export interface GetBlocksV2Response {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
     */
    paging?: Cursor;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.BlockInfo data = 2
     */
    data: BlockInfo[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlockRequest
 */
export interface GetBlockRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlockResponse
 */
export interface GetBlockResponse {
    /**
     * Status of the response.
     *
     * @generated from protobuf field: string s = 1
     */
    s: string;
    /**
     * Error message.
     *
     * @generated from protobuf field: string errmsg = 2
     */
    errmsg: string;
    /**
     * @generated from protobuf field: injective_explorer_rpc.BlockDetailInfo data = 3
     */
    data?: BlockDetailInfo;
}
/**
 * @generated from protobuf message injective_explorer_rpc.BlockDetailInfo
 */
export interface BlockDetailInfo {
    /**
     * @generated from protobuf field: uint64 height = 1
     */
    height: bigint;
    /**
     * @generated from protobuf field: string proposer = 2
     */
    proposer: string;
    /**
     * @generated from protobuf field: string moniker = 3
     */
    moniker: string;
    /**
     * @generated from protobuf field: string block_hash = 4
     */
    blockHash: string;
    /**
     * @generated from protobuf field: string parent_hash = 5
     */
    parentHash: string;
    /**
     * @generated from protobuf field: sint64 num_pre_commits = 6
     */
    numPreCommits: bigint;
    /**
     * @generated from protobuf field: sint64 num_txs = 7
     */
    numTxs: bigint;
    /**
     * @generated from protobuf field: sint64 total_txs = 8
     */
    totalTxs: bigint;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxData txs = 9
     */
    txs: TxData[];
    /**
     * @generated from protobuf field: string timestamp = 10
     */
    timestamp: string;
    /**
     * Block timestamp in unix milli
     *
     * @generated from protobuf field: uint64 block_unix_timestamp = 11
     */
    blockUnixTimestamp: bigint;
}
/**
 * TxData wraps tx data
 *
 * @generated from protobuf message injective_explorer_rpc.TxData
 */
export interface TxData {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: uint64 block_number = 2
     */
    blockNumber: bigint;
    /**
     * @generated from protobuf field: string block_timestamp = 3
     */
    blockTimestamp: string;
    /**
     * @generated from protobuf field: string hash = 4
     */
    hash: string;
    /**
     * @generated from protobuf field: string codespace = 5
     */
    codespace: string;
    /**
     * @generated from protobuf field: bytes messages = 6
     */
    messages: Uint8Array;
    /**
     * @generated from protobuf field: uint64 tx_number = 7
     */
    txNumber: bigint;
    /**
     * Transaction log indicating errors
     *
     * @generated from protobuf field: string error_log = 8
     */
    errorLog: string;
    /**
     * @generated from protobuf field: uint32 code = 9
     */
    code: number;
    /**
     * @generated from protobuf field: bytes tx_msg_types = 10
     */
    txMsgTypes: Uint8Array;
    /**
     * transaction event logs
     *
     * @generated from protobuf field: bytes logs = 11
     */
    logs: Uint8Array;
    /**
     * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
     *
     * @generated from protobuf field: repeated sint64 claim_ids = 12
     */
    claimIds: bigint[];
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.Signature signatures = 13
     */
    signatures: Signature[];
    /**
     * Block timestamp in unix milli
     *
     * @generated from protobuf field: uint64 block_unix_timestamp = 14
     */
    blockUnixTimestamp: bigint;
    /**
     * @generated from protobuf field: string ethereum_tx_hash_hex = 15
     */
    ethereumTxHashHex: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorsRequest
 */
export interface GetValidatorsRequest {
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorsResponse
 */
export interface GetValidatorsResponse {
    /**
     * Status of the response.
     *
     * @generated from protobuf field: string s = 1
     */
    s: string;
    /**
     * Error message.
     *
     * @generated from protobuf field: string errmsg = 2
     */
    errmsg: string;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.Validator data = 3
     */
    data: Validator[];
}
/**
 * Validator defines the structure for validator information.
 *
 * @generated from protobuf message injective_explorer_rpc.Validator
 */
export interface Validator {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string moniker = 2
     */
    moniker: string;
    /**
     * @generated from protobuf field: string operator_address = 3
     */
    operatorAddress: string;
    /**
     * @generated from protobuf field: string consensus_address = 4
     */
    consensusAddress: string;
    /**
     * @generated from protobuf field: bool jailed = 5
     */
    jailed: boolean;
    /**
     * @generated from protobuf field: sint32 status = 6
     */
    status: number;
    /**
     * @generated from protobuf field: string tokens = 7
     */
    tokens: string;
    /**
     * @generated from protobuf field: string delegator_shares = 8
     */
    delegatorShares: string;
    /**
     * @generated from protobuf field: injective_explorer_rpc.ValidatorDescription description = 9
     */
    description?: ValidatorDescription;
    /**
     * @generated from protobuf field: sint64 unbonding_height = 10
     */
    unbondingHeight: bigint;
    /**
     * @generated from protobuf field: string unbonding_time = 11
     */
    unbondingTime: string;
    /**
     * @generated from protobuf field: string commission_rate = 12
     */
    commissionRate: string;
    /**
     * @generated from protobuf field: string commission_max_rate = 13
     */
    commissionMaxRate: string;
    /**
     * @generated from protobuf field: string commission_max_change_rate = 14
     */
    commissionMaxChangeRate: string;
    /**
     * @generated from protobuf field: string commission_update_time = 15
     */
    commissionUpdateTime: string;
    /**
     * @generated from protobuf field: uint64 proposed = 16
     */
    proposed: bigint;
    /**
     * @generated from protobuf field: uint64 signed = 17
     */
    signed: bigint;
    /**
     * @generated from protobuf field: uint64 missed = 18
     */
    missed: bigint;
    /**
     * @generated from protobuf field: string timestamp = 19
     */
    timestamp: string;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.ValidatorUptime uptimes = 20
     */
    uptimes: ValidatorUptime[];
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.SlashingEvent slashing_events = 21
     */
    slashingEvents: SlashingEvent[];
    /**
     * uptime percentage base on latest 10k block
     *
     * @generated from protobuf field: double uptime_percentage = 22
     */
    uptimePercentage: number;
    /**
     * URL of the validator logo
     *
     * @generated from protobuf field: string image_url = 23
     */
    imageUrl: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.ValidatorDescription
 */
export interface ValidatorDescription {
    /**
     * @generated from protobuf field: string moniker = 1
     */
    moniker: string;
    /**
     * @generated from protobuf field: string identity = 2
     */
    identity: string;
    /**
     * @generated from protobuf field: string website = 3
     */
    website: string;
    /**
     * @generated from protobuf field: string security_contact = 4
     */
    securityContact: string;
    /**
     * @generated from protobuf field: string details = 5
     */
    details: string;
    /**
     * @generated from protobuf field: string image_url = 6
     */
    imageUrl: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.ValidatorUptime
 */
export interface ValidatorUptime {
    /**
     * @generated from protobuf field: uint64 block_number = 1
     */
    blockNumber: bigint;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.SlashingEvent
 */
export interface SlashingEvent {
    /**
     * @generated from protobuf field: uint64 block_number = 1
     */
    blockNumber: bigint;
    /**
     * @generated from protobuf field: string block_timestamp = 2
     */
    blockTimestamp: string;
    /**
     * @generated from protobuf field: string address = 3
     */
    address: string;
    /**
     * @generated from protobuf field: uint64 power = 4
     */
    power: bigint;
    /**
     * @generated from protobuf field: string reason = 5
     */
    reason: string;
    /**
     * @generated from protobuf field: string jailed = 6
     */
    jailed: string;
    /**
     * @generated from protobuf field: uint64 missed_blocks = 7
     */
    missedBlocks: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorRequest
 */
export interface GetValidatorRequest {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorResponse
 */
export interface GetValidatorResponse {
    /**
     * Status of the response.
     *
     * @generated from protobuf field: string s = 1
     */
    s: string;
    /**
     * Error message.
     *
     * @generated from protobuf field: string errmsg = 2
     */
    errmsg: string;
    /**
     * @generated from protobuf field: injective_explorer_rpc.Validator data = 3
     */
    data?: Validator;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorUptimeRequest
 */
export interface GetValidatorUptimeRequest {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorUptimeResponse
 */
export interface GetValidatorUptimeResponse {
    /**
     * Status of the response.
     *
     * @generated from protobuf field: string s = 1
     */
    s: string;
    /**
     * Error message.
     *
     * @generated from protobuf field: string errmsg = 2
     */
    errmsg: string;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.ValidatorUptime data = 3
     */
    data: ValidatorUptime[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxsRequest
 */
export interface GetTxsRequest {
    /**
     * @generated from protobuf field: uint64 before = 1
     */
    before: bigint;
    /**
     * @generated from protobuf field: uint64 after = 2
     */
    after: bigint;
    /**
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
    /**
     * @generated from protobuf field: string type = 5
     */
    type: string;
    /**
     * @generated from protobuf field: string module = 6
     */
    module: string;
    /**
     * @generated from protobuf field: sint64 from_number = 7
     */
    fromNumber: bigint;
    /**
     * @generated from protobuf field: sint64 to_number = 8
     */
    toNumber: bigint;
    /**
     * The starting timestamp in UNIX milliseconds that the txs must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 9
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the txs must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 10
     */
    endTime: bigint;
    /**
     * The status of the txs to be returned
     *
     * @generated from protobuf field: string status = 11
     */
    status: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxsResponse
 */
export interface GetTxsResponse {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxData data = 2
     */
    data: TxData[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxsV2Request
 */
export interface GetTxsV2Request {
    /**
     * Comma-separated list of msg types
     *
     * @generated from protobuf field: string type = 1
     */
    type: string;
    /**
     * The starting timestamp in UNIX milliseconds that the txs must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 2
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the txs must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 3
     */
    endTime: bigint;
    /**
     * @generated from protobuf field: sint32 per_page = 4
     */
    perPage: number;
    /**
     * @generated from protobuf field: string token = 5
     */
    token: string;
    /**
     * The status of the txs to be returned
     *
     * @generated from protobuf field: string status = 6
     */
    status: string;
    /**
     * @generated from protobuf field: uint64 block_number = 7
     */
    blockNumber: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxsV2Response
 */
export interface GetTxsV2Response {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
     */
    paging?: Cursor;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxData data = 2
     */
    data: TxData[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxByTxHashRequest
 */
export interface GetTxByTxHashRequest {
    /**
     * transaction hash
     *
     * @generated from protobuf field: string hash = 1
     */
    hash: string;
    /**
     * Set to true if the provided hash may be an EVM tx hash
     *
     * @generated from protobuf field: bool is_evm_hash = 2
     */
    isEvmHash: boolean;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxByTxHashResponse
 */
export interface GetTxByTxHashResponse {
    /**
     * Status of the response.
     *
     * @generated from protobuf field: string s = 1
     */
    s: string;
    /**
     * Error message.
     *
     * @generated from protobuf field: string errmsg = 2
     */
    errmsg: string;
    /**
     * @generated from protobuf field: injective_explorer_rpc.TxDetailData data = 3
     */
    data?: TxDetailData;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetPeggyDepositTxsRequest
 */
export interface GetPeggyDepositTxsRequest {
    /**
     * Sender address of deposit request
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Address of receiveer upon deposit
     *
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetPeggyDepositTxsResponse
 */
export interface GetPeggyDepositTxsResponse {
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.PeggyDepositTx field = 1
     */
    field: PeggyDepositTx[];
}
/**
 * PeggyDepositTx wraps tx data includes peggy deposit tx details information
 *
 * @generated from protobuf message injective_explorer_rpc.PeggyDepositTx
 */
export interface PeggyDepositTx {
    /**
     * Sender address of deposit request
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Address of receiveer upon deposit
     *
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * The event nonce of WithdrawalClaim event emitted by Ethereum chain upon
     * deposit
     *
     * @generated from protobuf field: uint64 event_nonce = 3
     */
    eventNonce: bigint;
    /**
     * The block height of WithdrawalClaim event emitted by Ethereum chain upon
     * deposit
     *
     * @generated from protobuf field: uint64 event_height = 4
     */
    eventHeight: bigint;
    /**
     * Amount of tokens being deposited
     *
     * @generated from protobuf field: string amount = 5
     */
    amount: string;
    /**
     * Denom of tokens being deposited
     *
     * @generated from protobuf field: string denom = 6
     */
    denom: string;
    /**
     * orchestratorAddress who created batch request
     *
     * @generated from protobuf field: string orchestrator_address = 7
     */
    orchestratorAddress: string;
    /**
     * @generated from protobuf field: string state = 8
     */
    state: string;
    /**
     * The claimType will be DepoistClaim for Deposits
     *
     * @generated from protobuf field: sint32 claim_type = 9
     */
    claimType: number;
    /**
     * @generated from protobuf field: repeated string tx_hashes = 10
     */
    txHashes: string[];
    /**
     * @generated from protobuf field: string created_at = 11
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 12
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetPeggyWithdrawalTxsRequest
 */
export interface GetPeggyWithdrawalTxsRequest {
    /**
     * Sender address of withdrawal request
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Address of receiveer upon withdrawal
     *
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetPeggyWithdrawalTxsResponse
 */
export interface GetPeggyWithdrawalTxsResponse {
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.PeggyWithdrawalTx field = 1
     */
    field: PeggyWithdrawalTx[];
}
/**
 * PeggyWithdrawalTx wraps tx data includes peggy withdrawal tx details
 * information
 *
 * @generated from protobuf message injective_explorer_rpc.PeggyWithdrawalTx
 */
export interface PeggyWithdrawalTx {
    /**
     * Sender address of withdrawal request
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Address of receiveer upon withdrawal
     *
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * Amount of tokens being withdrawan
     *
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
    /**
     * Denom of tokens being withdrawan
     *
     * @generated from protobuf field: string denom = 4
     */
    denom: string;
    /**
     * The bridge fee paid by sender for withdrawal
     *
     * @generated from protobuf field: string bridge_fee = 5
     */
    bridgeFee: string;
    /**
     * A auto incremented unique ID representing the withdrawal request
     *
     * @generated from protobuf field: uint64 outgoing_tx_id = 6
     */
    outgoingTxId: bigint;
    /**
     * The timestamp after which Batch request will be discarded if not processed
     * already
     *
     * @generated from protobuf field: uint64 batch_timeout = 7
     */
    batchTimeout: bigint;
    /**
     * A auto incremented unique ID representing the Withdrawal Batches
     *
     * @generated from protobuf field: uint64 batch_nonce = 8
     */
    batchNonce: bigint;
    /**
     * orchestratorAddress who created batch request
     *
     * @generated from protobuf field: string orchestrator_address = 9
     */
    orchestratorAddress: string;
    /**
     * The event nonce of WithdrawalClaim event emitted by Ethereum chain upon
     * batch withdrawal
     *
     * @generated from protobuf field: uint64 event_nonce = 10
     */
    eventNonce: bigint;
    /**
     * The block height of WithdrawalClaim event emitted by Ethereum chain upon
     * batch withdrawal
     *
     * @generated from protobuf field: uint64 event_height = 11
     */
    eventHeight: bigint;
    /**
     * @generated from protobuf field: string state = 12
     */
    state: string;
    /**
     * The claimType will be WithdrawalClaim for Batch Withdrawals
     *
     * @generated from protobuf field: sint32 claim_type = 13
     */
    claimType: number;
    /**
     * @generated from protobuf field: repeated string tx_hashes = 14
     */
    txHashes: string[];
    /**
     * @generated from protobuf field: string created_at = 15
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 16
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetIBCTransferTxsRequest
 */
export interface GetIBCTransferTxsRequest {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * @generated from protobuf field: string src_channel = 3
     */
    srcChannel: string;
    /**
     * @generated from protobuf field: string src_port = 4
     */
    srcPort: string;
    /**
     * @generated from protobuf field: string dest_channel = 5
     */
    destChannel: string;
    /**
     * @generated from protobuf field: string dest_port = 6
     */
    destPort: string;
    /**
     * @generated from protobuf field: sint32 limit = 7
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 8
     */
    skip: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetIBCTransferTxsResponse
 */
export interface GetIBCTransferTxsResponse {
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.IBCTransferTx field = 1
     */
    field: IBCTransferTx[];
}
/**
 * IBCTransferTx wraps tx data includes ibc transfer tx details information
 *
 * @generated from protobuf message injective_explorer_rpc.IBCTransferTx
 */
export interface IBCTransferTx {
    /**
     * the sender address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the recipient address on the destination chain
     *
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * the port on which the packet will be sent
     *
     * @generated from protobuf field: string source_port = 3
     */
    sourcePort: string;
    /**
     * the channel by which the packet will be sent
     *
     * @generated from protobuf field: string source_channel = 4
     */
    sourceChannel: string;
    /**
     * identifies the port on the receiving chain
     *
     * @generated from protobuf field: string destination_port = 5
     */
    destinationPort: string;
    /**
     * identifies the channel end on the receiving chain
     *
     * @generated from protobuf field: string destination_channel = 6
     */
    destinationChannel: string;
    /**
     * transfer amount
     *
     * @generated from protobuf field: string amount = 7
     */
    amount: string;
    /**
     * transafer denom
     *
     * @generated from protobuf field: string denom = 8
     */
    denom: string;
    /**
     * Timeout height relative to the current block height. The timeout is disabled
     * when set to 0
     *
     * @generated from protobuf field: string timeout_height = 9
     */
    timeoutHeight: string;
    /**
     * Timeout timestamp (in nanoseconds) relative to the current block timestamp
     *
     * @generated from protobuf field: uint64 timeout_timestamp = 10
     */
    timeoutTimestamp: bigint;
    /**
     * number corresponds to the order of sends and receives, where a Packet with
     * an earlier sequence number must be sent and received before a Packet with a
     * later sequence number
     *
     * @generated from protobuf field: uint64 packet_sequence = 11
     */
    packetSequence: bigint;
    /**
     * @generated from protobuf field: bytes data_hex = 12
     */
    dataHex: Uint8Array;
    /**
     * @generated from protobuf field: string state = 13
     */
    state: string;
    /**
     * it's injective chain tx hash array
     *
     * @generated from protobuf field: repeated string tx_hashes = 14
     */
    txHashes: string[];
    /**
     * @generated from protobuf field: string created_at = 15
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 16
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmCodesRequest
 */
export interface GetWasmCodesRequest {
    /**
     * @generated from protobuf field: sint32 limit = 1
     */
    limit: number;
    /**
     * @generated from protobuf field: sint64 from_number = 2
     */
    fromNumber: bigint;
    /**
     * @generated from protobuf field: sint64 to_number = 3
     */
    toNumber: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmCodesResponse
 */
export interface GetWasmCodesResponse {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.WasmCode data = 2
     */
    data: WasmCode[];
}
/**
 * Detail of cosmwasm stored code
 *
 * @generated from protobuf message injective_explorer_rpc.WasmCode
 */
export interface WasmCode {
    /**
     * ID of stored wasmcode, sorted in descending order
     *
     * @generated from protobuf field: uint64 code_id = 1
     */
    codeId: bigint;
    /**
     * Tx hash of store code transaction
     *
     * @generated from protobuf field: string tx_hash = 2
     */
    txHash: string;
    /**
     * Checksum of the cosmwasm code
     *
     * @generated from protobuf field: injective_explorer_rpc.Checksum checksum = 3
     */
    checksum?: Checksum;
    /**
     * Block time when the code is stored, in millisecond
     *
     * @generated from protobuf field: uint64 created_at = 4
     */
    createdAt: bigint;
    /**
     * Contract type of the wasm code
     *
     * @generated from protobuf field: string contract_type = 5
     */
    contractType: string;
    /**
     * version string of the wasm code
     *
     * @generated from protobuf field: string version = 6
     */
    version: string;
    /**
     * describe instantiate permission
     *
     * @generated from protobuf field: injective_explorer_rpc.ContractPermission permission = 7
     */
    permission?: ContractPermission;
    /**
     * code schema preview
     *
     * @generated from protobuf field: string code_schema = 8
     */
    codeSchema: string;
    /**
     * code repo preview, may contain schema folder
     *
     * @generated from protobuf field: string code_view = 9
     */
    codeView: string;
    /**
     * count number of contract instantiation from this code
     *
     * @generated from protobuf field: uint64 instantiates = 10
     */
    instantiates: bigint;
    /**
     * creator of this code
     *
     * @generated from protobuf field: string creator = 11
     */
    creator: string;
    /**
     * monotonic order of the code stored
     *
     * @generated from protobuf field: sint64 code_number = 12
     */
    codeNumber: bigint;
    /**
     * id of the proposal that store this code
     *
     * @generated from protobuf field: sint64 proposal_id = 13
     */
    proposalId: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.Checksum
 */
export interface Checksum {
    /**
     * Algorithm of hash function
     *
     * @generated from protobuf field: string algorithm = 1
     */
    algorithm: string;
    /**
     * Hash if apply algorithm to the cosmwasm bytecode
     *
     * @generated from protobuf field: string hash = 2
     */
    hash: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.ContractPermission
 */
export interface ContractPermission {
    /**
     * Access type of instantiation
     *
     * @generated from protobuf field: sint32 access_type = 1
     */
    accessType: number;
    /**
     * Account address
     *
     * @generated from protobuf field: string address = 2
     */
    address: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmCodeByIDRequest
 */
export interface GetWasmCodeByIDRequest {
    /**
     * Code ID of the code
     *
     * @generated from protobuf field: sint64 code_id = 1
     */
    codeId: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmCodeByIDResponse
 */
export interface GetWasmCodeByIDResponse {
    /**
     * ID of stored wasmcode, sorted in descending order
     *
     * @generated from protobuf field: uint64 code_id = 1
     */
    codeId: bigint;
    /**
     * Tx hash of store code transaction
     *
     * @generated from protobuf field: string tx_hash = 2
     */
    txHash: string;
    /**
     * Checksum of the cosmwasm code
     *
     * @generated from protobuf field: injective_explorer_rpc.Checksum checksum = 3
     */
    checksum?: Checksum;
    /**
     * Block time when the code is stored, in millisecond
     *
     * @generated from protobuf field: uint64 created_at = 4
     */
    createdAt: bigint;
    /**
     * Contract type of the wasm code
     *
     * @generated from protobuf field: string contract_type = 5
     */
    contractType: string;
    /**
     * version string of the wasm code
     *
     * @generated from protobuf field: string version = 6
     */
    version: string;
    /**
     * describe instantiate permission
     *
     * @generated from protobuf field: injective_explorer_rpc.ContractPermission permission = 7
     */
    permission?: ContractPermission;
    /**
     * code schema preview
     *
     * @generated from protobuf field: string code_schema = 8
     */
    codeSchema: string;
    /**
     * code repo preview, may contain schema folder
     *
     * @generated from protobuf field: string code_view = 9
     */
    codeView: string;
    /**
     * count number of contract instantiation from this code
     *
     * @generated from protobuf field: uint64 instantiates = 10
     */
    instantiates: bigint;
    /**
     * creator of this code
     *
     * @generated from protobuf field: string creator = 11
     */
    creator: string;
    /**
     * monotonic order of the code stored
     *
     * @generated from protobuf field: sint64 code_number = 12
     */
    codeNumber: bigint;
    /**
     * id of the proposal that store this code
     *
     * @generated from protobuf field: sint64 proposal_id = 13
     */
    proposalId: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmContractsRequest
 */
export interface GetWasmContractsRequest {
    /**
     * @generated from protobuf field: sint32 limit = 1
     */
    limit: number;
    /**
     * @generated from protobuf field: sint64 code_id = 2
     */
    codeId: bigint;
    /**
     * @generated from protobuf field: sint64 from_number = 3
     */
    fromNumber: bigint;
    /**
     * @generated from protobuf field: sint64 to_number = 4
     */
    toNumber: bigint;
    /**
     * @generated from protobuf field: bool assets_only = 5
     */
    assetsOnly: boolean;
    /**
     * @generated from protobuf field: sint64 skip = 6
     */
    skip: bigint;
    /**
     * Label of the contract
     *
     * @generated from protobuf field: string label = 7
     */
    label: string;
    /**
     * Token name or symbol to filter by
     *
     * @generated from protobuf field: string token = 8
     */
    token: string;
    /**
     * Text to lookup by
     *
     * @generated from protobuf field: string lookup = 9
     */
    lookup: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmContractsResponse
 */
export interface GetWasmContractsResponse {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.WasmContract data = 2
     */
    data: WasmContract[];
}
/**
 * Detail of cosmwasm instantiated contract
 *
 * @generated from protobuf message injective_explorer_rpc.WasmContract
 */
export interface WasmContract {
    /**
     * General name of the contract
     *
     * @generated from protobuf field: string label = 1
     */
    label: string;
    /**
     * Address of the contract
     *
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * hash of the instantiate transaction
     *
     * @generated from protobuf field: string tx_hash = 3
     */
    txHash: string;
    /**
     * Address of the contract creator
     *
     * @generated from protobuf field: string creator = 4
     */
    creator: string;
    /**
     * Number of times call to execute contract
     *
     * @generated from protobuf field: uint64 executes = 5
     */
    executes: bigint;
    /**
     * Block timestamp that contract was instantiated, in millisecond
     *
     * @generated from protobuf field: uint64 instantiated_at = 6
     */
    instantiatedAt: bigint;
    /**
     * init message when this contract was instantiated
     *
     * @generated from protobuf field: string init_message = 7
     */
    initMessage: string;
    /**
     * Block timestamp that contract was called, in millisecond
     *
     * @generated from protobuf field: uint64 last_executed_at = 8
     */
    lastExecutedAt: bigint;
    /**
     * Contract funds
     *
     * @generated from protobuf field: repeated injective_explorer_rpc.ContractFund funds = 9
     */
    funds: ContractFund[];
    /**
     * Code id of the contract
     *
     * @generated from protobuf field: uint64 code_id = 10
     */
    codeId: bigint;
    /**
     * Admin of the contract
     *
     * @generated from protobuf field: string admin = 11
     */
    admin: string;
    /**
     * Latest migrate message of the contract
     *
     * @generated from protobuf field: string current_migrate_message = 12
     */
    currentMigrateMessage: string;
    /**
     * Monotonic contract number in database
     *
     * @generated from protobuf field: sint64 contract_number = 13
     */
    contractNumber: bigint;
    /**
     * Contract version string
     *
     * @generated from protobuf field: string version = 14
     */
    version: string;
    /**
     * Contract type
     *
     * @generated from protobuf field: string type = 15
     */
    type: string;
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cw20Metadata cw20_metadata = 16
     */
    cw20Metadata?: Cw20Metadata;
    /**
     * id of the proposal that instantiate this contract
     *
     * @generated from protobuf field: sint64 proposal_id = 17
     */
    proposalId: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.ContractFund
 */
export interface ContractFund {
    /**
     * Denominator
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * Amount of denom
     *
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * General cw20 metadata
 *
 * @generated from protobuf message injective_explorer_rpc.Cw20Metadata
 */
export interface Cw20Metadata {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cw20TokenInfo token_info = 1
     */
    tokenInfo?: Cw20TokenInfo;
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cw20MarketingInfo marketing_info = 2
     */
    marketingInfo?: Cw20MarketingInfo;
}
/**
 * Token name, symbol, decimal and so on
 *
 * @generated from protobuf message injective_explorer_rpc.Cw20TokenInfo
 */
export interface Cw20TokenInfo {
    /**
     * General name of the token
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * Symbol of then token
     *
     * @generated from protobuf field: string symbol = 2
     */
    symbol: string;
    /**
     * Decimal places of token
     *
     * @generated from protobuf field: sint64 decimals = 3
     */
    decimals: bigint;
    /**
     * Token's total supply
     *
     * @generated from protobuf field: string total_supply = 4
     */
    totalSupply: string;
}
/**
 * Marketing info
 *
 * @generated from protobuf message injective_explorer_rpc.Cw20MarketingInfo
 */
export interface Cw20MarketingInfo {
    /**
     * Project information
     *
     * @generated from protobuf field: string project = 1
     */
    project: string;
    /**
     * Token's description
     *
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * logo (url/embedded)
     *
     * @generated from protobuf field: string logo = 3
     */
    logo: string;
    /**
     * A random field for additional marketing info
     *
     * @generated from protobuf field: bytes marketing = 4
     */
    marketing: Uint8Array;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmContractByAddressRequest
 */
export interface GetWasmContractByAddressRequest {
    /**
     * Contract address
     *
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetWasmContractByAddressResponse
 */
export interface GetWasmContractByAddressResponse {
    /**
     * General name of the contract
     *
     * @generated from protobuf field: string label = 1
     */
    label: string;
    /**
     * Address of the contract
     *
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * hash of the instantiate transaction
     *
     * @generated from protobuf field: string tx_hash = 3
     */
    txHash: string;
    /**
     * Address of the contract creator
     *
     * @generated from protobuf field: string creator = 4
     */
    creator: string;
    /**
     * Number of times call to execute contract
     *
     * @generated from protobuf field: uint64 executes = 5
     */
    executes: bigint;
    /**
     * Block timestamp that contract was instantiated, in millisecond
     *
     * @generated from protobuf field: uint64 instantiated_at = 6
     */
    instantiatedAt: bigint;
    /**
     * init message when this contract was instantiated
     *
     * @generated from protobuf field: string init_message = 7
     */
    initMessage: string;
    /**
     * Block timestamp that contract was called, in millisecond
     *
     * @generated from protobuf field: uint64 last_executed_at = 8
     */
    lastExecutedAt: bigint;
    /**
     * Contract funds
     *
     * @generated from protobuf field: repeated injective_explorer_rpc.ContractFund funds = 9
     */
    funds: ContractFund[];
    /**
     * Code id of the contract
     *
     * @generated from protobuf field: uint64 code_id = 10
     */
    codeId: bigint;
    /**
     * Admin of the contract
     *
     * @generated from protobuf field: string admin = 11
     */
    admin: string;
    /**
     * Latest migrate message of the contract
     *
     * @generated from protobuf field: string current_migrate_message = 12
     */
    currentMigrateMessage: string;
    /**
     * Monotonic contract number in database
     *
     * @generated from protobuf field: sint64 contract_number = 13
     */
    contractNumber: bigint;
    /**
     * Contract version string
     *
     * @generated from protobuf field: string version = 14
     */
    version: string;
    /**
     * Contract type
     *
     * @generated from protobuf field: string type = 15
     */
    type: string;
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cw20Metadata cw20_metadata = 16
     */
    cw20Metadata?: Cw20Metadata;
    /**
     * id of the proposal that instantiate this contract
     *
     * @generated from protobuf field: sint64 proposal_id = 17
     */
    proposalId: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetCw20BalanceRequest
 */
export interface GetCw20BalanceRequest {
    /**
     * address to list balance of
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: sint32 limit = 2
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetCw20BalanceResponse
 */
export interface GetCw20BalanceResponse {
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.WasmCw20Balance field = 1
     */
    field: WasmCw20Balance[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.WasmCw20Balance
 */
export interface WasmCw20Balance {
    /**
     * Address of CW20 contract
     *
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 2
     */
    account: string;
    /**
     * Account balance
     *
     * @generated from protobuf field: string balance = 3
     */
    balance: string;
    /**
     * update timestamp in milisecond
     *
     * @generated from protobuf field: sint64 updated_at = 4
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: injective_explorer_rpc.Cw20Metadata cw20_metadata = 5
     */
    cw20Metadata?: Cw20Metadata;
}
/**
 * @generated from protobuf message injective_explorer_rpc.RelayersRequest
 */
export interface RelayersRequest {
    /**
     * Specify multiple marketIDs to search.
     *
     * @generated from protobuf field: repeated string market_i_ds = 1
     */
    marketIDs: string[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.RelayersResponse
 */
export interface RelayersResponse {
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.RelayerMarkets field = 1
     */
    field: RelayerMarkets[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.RelayerMarkets
 */
export interface RelayerMarkets {
    /**
     * Market ID of the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Relayers list for specified market
     *
     * @generated from protobuf field: repeated injective_explorer_rpc.Relayer relayers = 2
     */
    relayers: Relayer[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.Relayer
 */
export interface Relayer {
    /**
     * Relayer identifier
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * Call to action. A link to the relayer
     *
     * @generated from protobuf field: string cta = 2
     */
    cta: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBankTransfersRequest
 */
export interface GetBankTransfersRequest {
    /**
     * Transfer sender address
     *
     * @generated from protobuf field: repeated string senders = 1
     */
    senders: string[];
    /**
     * Transfer recipient address
     *
     * @generated from protobuf field: repeated string recipients = 2
     */
    recipients: string[];
    /**
     * Returns transfers with the community pool address as either sender or
     * recipient
     *
     * @generated from protobuf field: bool is_community_pool_related = 3
     */
    isCommunityPoolRelated: boolean;
    /**
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * The starting timestamp in UNIX milliseconds that the transfers must be equal
     * or older than
     *
     * @generated from protobuf field: sint64 start_time = 6
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the transfers must be equal
     * or younger than
     *
     * @generated from protobuf field: sint64 end_time = 7
     */
    endTime: bigint;
    /**
     * Transfers where either the sender or the recipient is one of the addresses
     *
     * @generated from protobuf field: repeated string address = 8
     */
    address: string[];
    /**
     * @generated from protobuf field: sint32 per_page = 9
     */
    perPage: number;
    /**
     * @generated from protobuf field: string token = 10
     */
    token: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBankTransfersResponse
 */
export interface GetBankTransfersResponse {
    /**
     * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.BankTransfer data = 2
     */
    data: BankTransfer[];
}
/**
 * Bank transfer represents a transfer
 *
 * @generated from protobuf message injective_explorer_rpc.BankTransfer
 */
export interface BankTransfer {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string recipient = 2
     */
    recipient: string;
    /**
     * Amounts transferred
     *
     * @generated from protobuf field: repeated injective_explorer_rpc.Coin amounts = 3
     */
    amounts: Coin[];
    /**
     * @generated from protobuf field: uint64 block_number = 4
     */
    blockNumber: bigint;
    /**
     * @generated from protobuf field: string block_timestamp = 5
     */
    blockTimestamp: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.Coin
 */
export interface Coin {
    /**
     * Denom of the coin
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * @generated from protobuf field: string usd_value = 3
     */
    usdValue: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.StreamTxsRequest
 */
export interface StreamTxsRequest {
}
/**
 * @generated from protobuf message injective_explorer_rpc.StreamTxsResponse
 */
export interface StreamTxsResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: uint64 block_number = 2
     */
    blockNumber: bigint;
    /**
     * @generated from protobuf field: string block_timestamp = 3
     */
    blockTimestamp: string;
    /**
     * @generated from protobuf field: string hash = 4
     */
    hash: string;
    /**
     * @generated from protobuf field: string codespace = 5
     */
    codespace: string;
    /**
     * @generated from protobuf field: string messages = 6
     */
    messages: string;
    /**
     * @generated from protobuf field: uint64 tx_number = 7
     */
    txNumber: bigint;
    /**
     * Transaction log indicating errors
     *
     * @generated from protobuf field: string error_log = 8
     */
    errorLog: string;
    /**
     * @generated from protobuf field: uint32 code = 9
     */
    code: number;
    /**
     * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
     *
     * @generated from protobuf field: repeated sint64 claim_ids = 10
     */
    claimIds: bigint[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.StreamBlocksRequest
 */
export interface StreamBlocksRequest {
}
/**
 * @generated from protobuf message injective_explorer_rpc.StreamBlocksResponse
 */
export interface StreamBlocksResponse {
    /**
     * @generated from protobuf field: uint64 height = 1
     */
    height: bigint;
    /**
     * @generated from protobuf field: string proposer = 2
     */
    proposer: string;
    /**
     * @generated from protobuf field: string moniker = 3
     */
    moniker: string;
    /**
     * @generated from protobuf field: string block_hash = 4
     */
    blockHash: string;
    /**
     * @generated from protobuf field: string parent_hash = 5
     */
    parentHash: string;
    /**
     * @generated from protobuf field: sint64 num_pre_commits = 6
     */
    numPreCommits: bigint;
    /**
     * @generated from protobuf field: sint64 num_txs = 7
     */
    numTxs: bigint;
    /**
     * @generated from protobuf field: repeated injective_explorer_rpc.TxDataRPC txs = 8
     */
    txs: TxDataRPC[];
    /**
     * @generated from protobuf field: string timestamp = 9
     */
    timestamp: string;
    /**
     * Block timestamp in unix milli
     *
     * @generated from protobuf field: uint64 block_unix_timestamp = 10
     */
    blockUnixTimestamp: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetStatsRequest
 */
export interface GetStatsRequest {
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetStatsResponse
 */
export interface GetStatsResponse {
    /**
     * Total of unique addresses
     *
     * @generated from protobuf field: uint64 addresses = 1
     */
    addresses: bigint;
    /**
     * Total number of assets
     *
     * @generated from protobuf field: uint64 assets = 2
     */
    assets: bigint;
    /**
     * Total circulating supply of INJ
     *
     * @generated from protobuf field: uint64 inj_supply = 3
     */
    injSupply: bigint;
    /**
     * Avg of TX per second in the past 24hs
     *
     * @generated from protobuf field: uint64 txs_ps24_h = 4
     */
    txsPs24H: bigint;
    /**
     * Avg of TX per second in the 100 blocks
     *
     * @generated from protobuf field: uint64 txs_ps100_b = 5
     */
    txsPs100B: bigint;
    /**
     * Total number of TXs
     *
     * @generated from protobuf field: uint64 txs_total = 6
     */
    txsTotal: bigint;
    /**
     * Total number of TXs in the past 24hs
     *
     * @generated from protobuf field: uint64 txs24_h = 7
     */
    txs24H: bigint;
    /**
     * Total number of TXs in the past 30 days
     *
     * @generated from protobuf field: uint64 txs30_d = 8
     */
    txs30D: bigint;
    /**
     * Number of blocks produced in the past 24hs
     *
     * @generated from protobuf field: uint64 block_count24_h = 9
     */
    blockCount24H: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountTxsRequest$Type extends MessageType<GetAccountTxsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetAccountTxsRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "before", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "after", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "module", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "from_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "to_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccountTxsRequest>): GetAccountTxsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.before = 0n;
        message.after = 0n;
        message.limit = 0;
        message.skip = 0n;
        message.type = "";
        message.module = "";
        message.fromNumber = 0n;
        message.toNumber = 0n;
        message.startTime = 0n;
        message.endTime = 0n;
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<GetAccountTxsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountTxsRequest): GetAccountTxsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* uint64 before */ 2:
                    message.before = reader.uint64().toBigInt();
                    break;
                case /* uint64 after */ 3:
                    message.after = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* string type */ 6:
                    message.type = reader.string();
                    break;
                case /* string module */ 7:
                    message.module = reader.string();
                    break;
                case /* sint64 from_number */ 8:
                    message.fromNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 to_number */ 9:
                    message.toNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 start_time */ 10:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 11:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* string status */ 12:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountTxsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* uint64 before = 2; */
        if (message.before !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.before);
        /* uint64 after = 3; */
        if (message.after !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.after);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* string type = 6; */
        if (message.type !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.type);
        /* string module = 7; */
        if (message.module !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.module);
        /* sint64 from_number = 8; */
        if (message.fromNumber !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.fromNumber);
        /* sint64 to_number = 9; */
        if (message.toNumber !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.toNumber);
        /* sint64 start_time = 10; */
        if (message.startTime !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 11; */
        if (message.endTime !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.endTime);
        /* string status = 12; */
        if (message.status !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetAccountTxsRequest
 */
export const GetAccountTxsRequest = new GetAccountTxsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountTxsResponse$Type extends MessageType<GetAccountTxsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetAccountTxsResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxDetailData }
        ]);
    }
    create(value?: PartialMessage<GetAccountTxsResponse>): GetAccountTxsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetAccountTxsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountTxsResponse): GetAccountTxsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.TxDetailData data */ 2:
                    message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountTxsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.TxDetailData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetAccountTxsResponse
 */
export const GetAccountTxsResponse = new GetAccountTxsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Paging$Type extends MessageType<Paging> {
    constructor() {
        super("injective_explorer_rpc.Paging", [
            { no: 1, name: "total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "from", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "to", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "count_by_subaccount", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Paging>): Paging {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0n;
        message.from = 0;
        message.to = 0;
        message.countBySubaccount = 0n;
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<Paging>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Paging): Paging {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 total */ 1:
                    message.total = reader.sint64().toBigInt();
                    break;
                case /* sint32 from */ 2:
                    message.from = reader.sint32();
                    break;
                case /* sint32 to */ 3:
                    message.to = reader.sint32();
                    break;
                case /* sint64 count_by_subaccount */ 4:
                    message.countBySubaccount = reader.sint64().toBigInt();
                    break;
                case /* repeated string next */ 5:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Paging, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 total = 1; */
        if (message.total !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.total);
        /* sint32 from = 2; */
        if (message.from !== 0)
            writer.tag(2, WireType.Varint).sint32(message.from);
        /* sint32 to = 3; */
        if (message.to !== 0)
            writer.tag(3, WireType.Varint).sint32(message.to);
        /* sint64 count_by_subaccount = 4; */
        if (message.countBySubaccount !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
        /* repeated string next = 5; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Paging
 */
export const Paging = new Paging$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxDetailData$Type extends MessageType<TxDetailData> {
    constructor() {
        super("injective_explorer_rpc.TxDetailData", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "block_timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "gas_wanted", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "gas_used", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "gas_fee", kind: "message", T: () => GasFee },
            { no: 12, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event },
            { no: 14, name: "tx_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "messages", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 16, name: "signatures", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Signature },
            { no: 17, name: "memo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "tx_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "block_unix_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "error_log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "logs", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 22, name: "claim_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TxDetailData>): TxDetailData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.blockNumber = 0n;
        message.blockTimestamp = "";
        message.hash = "";
        message.code = 0;
        message.data = new Uint8Array(0);
        message.info = "";
        message.gasWanted = 0n;
        message.gasUsed = 0n;
        message.codespace = "";
        message.events = [];
        message.txType = "";
        message.messages = new Uint8Array(0);
        message.signatures = [];
        message.memo = "";
        message.txNumber = 0n;
        message.blockUnixTimestamp = 0n;
        message.errorLog = "";
        message.logs = new Uint8Array(0);
        message.claimIds = [];
        if (value !== undefined)
            reflectionMergePartial<TxDetailData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxDetailData): TxDetailData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint64 block_number */ 2:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                case /* string block_timestamp */ 3:
                    message.blockTimestamp = reader.string();
                    break;
                case /* string hash */ 4:
                    message.hash = reader.string();
                    break;
                case /* uint32 code */ 5:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 6:
                    message.data = reader.bytes();
                    break;
                case /* string info */ 8:
                    message.info = reader.string();
                    break;
                case /* sint64 gas_wanted */ 9:
                    message.gasWanted = reader.sint64().toBigInt();
                    break;
                case /* sint64 gas_used */ 10:
                    message.gasUsed = reader.sint64().toBigInt();
                    break;
                case /* injective_explorer_rpc.GasFee gas_fee */ 11:
                    message.gasFee = GasFee.internalBinaryRead(reader, reader.uint32(), options, message.gasFee);
                    break;
                case /* string codespace */ 12:
                    message.codespace = reader.string();
                    break;
                case /* repeated injective_explorer_rpc.Event events */ 13:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string tx_type */ 14:
                    message.txType = reader.string();
                    break;
                case /* bytes messages */ 15:
                    message.messages = reader.bytes();
                    break;
                case /* repeated injective_explorer_rpc.Signature signatures */ 16:
                    message.signatures.push(Signature.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string memo */ 17:
                    message.memo = reader.string();
                    break;
                case /* uint64 tx_number */ 18:
                    message.txNumber = reader.uint64().toBigInt();
                    break;
                case /* uint64 block_unix_timestamp */ 19:
                    message.blockUnixTimestamp = reader.uint64().toBigInt();
                    break;
                case /* string error_log */ 20:
                    message.errorLog = reader.string();
                    break;
                case /* bytes logs */ 21:
                    message.logs = reader.bytes();
                    break;
                case /* repeated sint64 claim_ids */ 22:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.claimIds.push(reader.sint64().toBigInt());
                    else
                        message.claimIds.push(reader.sint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxDetailData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint64 block_number = 2; */
        if (message.blockNumber !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockNumber);
        /* string block_timestamp = 3; */
        if (message.blockTimestamp !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
        /* string hash = 4; */
        if (message.hash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hash);
        /* uint32 code = 5; */
        if (message.code !== 0)
            writer.tag(5, WireType.Varint).uint32(message.code);
        /* bytes data = 6; */
        if (message.data.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.data);
        /* string info = 8; */
        if (message.info !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.info);
        /* sint64 gas_wanted = 9; */
        if (message.gasWanted !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.gasWanted);
        /* sint64 gas_used = 10; */
        if (message.gasUsed !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.gasUsed);
        /* injective_explorer_rpc.GasFee gas_fee = 11; */
        if (message.gasFee)
            GasFee.internalBinaryWrite(message.gasFee, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 12; */
        if (message.codespace !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.codespace);
        /* repeated injective_explorer_rpc.Event events = 13; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string tx_type = 14; */
        if (message.txType !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.txType);
        /* bytes messages = 15; */
        if (message.messages.length)
            writer.tag(15, WireType.LengthDelimited).bytes(message.messages);
        /* repeated injective_explorer_rpc.Signature signatures = 16; */
        for (let i = 0; i < message.signatures.length; i++)
            Signature.internalBinaryWrite(message.signatures[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string memo = 17; */
        if (message.memo !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.memo);
        /* uint64 tx_number = 18; */
        if (message.txNumber !== 0n)
            writer.tag(18, WireType.Varint).uint64(message.txNumber);
        /* uint64 block_unix_timestamp = 19; */
        if (message.blockUnixTimestamp !== 0n)
            writer.tag(19, WireType.Varint).uint64(message.blockUnixTimestamp);
        /* string error_log = 20; */
        if (message.errorLog !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.errorLog);
        /* bytes logs = 21; */
        if (message.logs.length)
            writer.tag(21, WireType.LengthDelimited).bytes(message.logs);
        /* repeated sint64 claim_ids = 22; */
        if (message.claimIds.length) {
            writer.tag(22, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.claimIds.length; i++)
                writer.sint64(message.claimIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.TxDetailData
 */
export const TxDetailData = new TxDetailData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GasFee$Type extends MessageType<GasFee> {
    constructor() {
        super("injective_explorer_rpc.GasFee", [
            { no: 1, name: "amount", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CosmosCoin },
            { no: 2, name: "gas_limit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "payer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GasFee>): GasFee {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = [];
        message.gasLimit = 0n;
        message.payer = "";
        message.granter = "";
        if (value !== undefined)
            reflectionMergePartial<GasFee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GasFee): GasFee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_explorer_rpc.CosmosCoin amount */ 1:
                    message.amount.push(CosmosCoin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 gas_limit */ 2:
                    message.gasLimit = reader.uint64().toBigInt();
                    break;
                case /* string payer */ 3:
                    message.payer = reader.string();
                    break;
                case /* string granter */ 4:
                    message.granter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GasFee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_explorer_rpc.CosmosCoin amount = 1; */
        for (let i = 0; i < message.amount.length; i++)
            CosmosCoin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 gas_limit = 2; */
        if (message.gasLimit !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.gasLimit);
        /* string payer = 3; */
        if (message.payer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payer);
        /* string granter = 4; */
        if (message.granter !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.granter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GasFee
 */
export const GasFee = new GasFee$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CosmosCoin$Type extends MessageType<CosmosCoin> {
    constructor() {
        super("injective_explorer_rpc.CosmosCoin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CosmosCoin>): CosmosCoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<CosmosCoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CosmosCoin): CosmosCoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CosmosCoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.CosmosCoin
 */
export const CosmosCoin = new CosmosCoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("injective_explorer_rpc.Event", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attributes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.attributes = {};
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* map<string, string> attributes */ 2:
                    this.binaryReadMap2(message.attributes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Event["attributes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Event["attributes"] | undefined, val: Event["attributes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for injective_explorer_rpc.Event.attributes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* map<string, string> attributes = 2; */
        for (let k of globalThis.Object.keys(message.attributes))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.attributes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Signature$Type extends MessageType<Signature> {
    constructor() {
        super("injective_explorer_rpc.Signature", [
            { no: 1, name: "pubkey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Signature>): Signature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pubkey = "";
        message.address = "";
        message.sequence = 0n;
        message.signature = "";
        if (value !== undefined)
            reflectionMergePartial<Signature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Signature): Signature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pubkey */ 1:
                    message.pubkey = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* string signature */ 4:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pubkey = 1; */
        if (message.pubkey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pubkey);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* uint64 sequence = 3; */
        if (message.sequence !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        /* string signature = 4; */
        if (message.signature !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Signature
 */
export const Signature = new Signature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountTxsV2Request$Type extends MessageType<GetAccountTxsV2Request> {
    constructor() {
        super("injective_explorer_rpc.GetAccountTxsV2Request", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccountTxsV2Request>): GetAccountTxsV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.type = "";
        message.startTime = 0n;
        message.endTime = 0n;
        message.perPage = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetAccountTxsV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountTxsV2Request): GetAccountTxsV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* sint64 start_time */ 3:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 4:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* sint32 per_page */ 5:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 6:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountTxsV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* sint64 start_time = 3; */
        if (message.startTime !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 4; */
        if (message.endTime !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.endTime);
        /* sint32 per_page = 5; */
        if (message.perPage !== 0)
            writer.tag(5, WireType.Varint).sint32(message.perPage);
        /* string token = 6; */
        if (message.token !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetAccountTxsV2Request
 */
export const GetAccountTxsV2Request = new GetAccountTxsV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountTxsV2Response$Type extends MessageType<GetAccountTxsV2Response> {
    constructor() {
        super("injective_explorer_rpc.GetAccountTxsV2Response", [
            { no: 1, name: "paging", kind: "message", T: () => Cursor },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxDetailData }
        ]);
    }
    create(value?: PartialMessage<GetAccountTxsV2Response>): GetAccountTxsV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetAccountTxsV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountTxsV2Response): GetAccountTxsV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Cursor paging */ 1:
                    message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.TxDetailData data */ 2:
                    message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountTxsV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Cursor paging = 1; */
        if (message.paging)
            Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.TxDetailData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetAccountTxsV2Response
 */
export const GetAccountTxsV2Response = new GetAccountTxsV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cursor$Type extends MessageType<Cursor> {
    constructor() {
        super("injective_explorer_rpc.Cursor", [
            { no: 1, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cursor>): Cursor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<Cursor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cursor): Cursor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string next */ 1:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cursor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string next = 1; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Cursor
 */
export const Cursor = new Cursor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetContractTxsRequest$Type extends MessageType<GetContractTxsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetContractTxsRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "from_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "to_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetContractTxsRequest>): GetContractTxsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.limit = 0;
        message.skip = 0n;
        message.fromNumber = 0n;
        message.toNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetContractTxsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetContractTxsRequest): GetContractTxsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* sint32 limit */ 2:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint64 from_number */ 4:
                    message.fromNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 to_number */ 5:
                    message.toNumber = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetContractTxsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* sint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint64 from_number = 4; */
        if (message.fromNumber !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.fromNumber);
        /* sint64 to_number = 5; */
        if (message.toNumber !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.toNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetContractTxsRequest
 */
export const GetContractTxsRequest = new GetContractTxsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetContractTxsResponse$Type extends MessageType<GetContractTxsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetContractTxsResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxDetailData }
        ]);
    }
    create(value?: PartialMessage<GetContractTxsResponse>): GetContractTxsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetContractTxsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetContractTxsResponse): GetContractTxsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.TxDetailData data */ 2:
                    message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetContractTxsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.TxDetailData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetContractTxsResponse
 */
export const GetContractTxsResponse = new GetContractTxsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetContractTxsV2Request$Type extends MessageType<GetContractTxsV2Request> {
    constructor() {
        super("injective_explorer_rpc.GetContractTxsV2Request", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "from", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "to", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetContractTxsV2Request>): GetContractTxsV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.height = 0n;
        message.from = 0n;
        message.to = 0n;
        message.perPage = 0;
        message.token = "";
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<GetContractTxsV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetContractTxsV2Request): GetContractTxsV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* uint64 height */ 2:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* sint64 from */ 3:
                    message.from = reader.sint64().toBigInt();
                    break;
                case /* sint64 to */ 4:
                    message.to = reader.sint64().toBigInt();
                    break;
                case /* sint32 per_page */ 5:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 6:
                    message.token = reader.string();
                    break;
                case /* string status */ 7:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetContractTxsV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* uint64 height = 2; */
        if (message.height !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.height);
        /* sint64 from = 3; */
        if (message.from !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.from);
        /* sint64 to = 4; */
        if (message.to !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.to);
        /* sint32 per_page = 5; */
        if (message.perPage !== 0)
            writer.tag(5, WireType.Varint).sint32(message.perPage);
        /* string token = 6; */
        if (message.token !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.token);
        /* string status = 7; */
        if (message.status !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetContractTxsV2Request
 */
export const GetContractTxsV2Request = new GetContractTxsV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetContractTxsV2Response$Type extends MessageType<GetContractTxsV2Response> {
    constructor() {
        super("injective_explorer_rpc.GetContractTxsV2Response", [
            { no: 1, name: "paging", kind: "message", T: () => Cursor },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxDetailData }
        ]);
    }
    create(value?: PartialMessage<GetContractTxsV2Response>): GetContractTxsV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetContractTxsV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetContractTxsV2Response): GetContractTxsV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Cursor paging */ 1:
                    message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.TxDetailData data */ 2:
                    message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetContractTxsV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Cursor paging = 1; */
        if (message.paging)
            Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.TxDetailData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetContractTxsV2Response
 */
export const GetContractTxsV2Response = new GetContractTxsV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlocksRequest$Type extends MessageType<GetBlocksRequest> {
    constructor() {
        super("injective_explorer_rpc.GetBlocksRequest", [
            { no: 1, name: "before", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "after", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "from", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "to", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetBlocksRequest>): GetBlocksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.before = 0n;
        message.after = 0n;
        message.limit = 0;
        message.from = 0n;
        message.to = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetBlocksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlocksRequest): GetBlocksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 before */ 1:
                    message.before = reader.uint64().toBigInt();
                    break;
                case /* uint64 after */ 2:
                    message.after = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 from */ 4:
                    message.from = reader.uint64().toBigInt();
                    break;
                case /* uint64 to */ 5:
                    message.to = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlocksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 before = 1; */
        if (message.before !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.before);
        /* uint64 after = 2; */
        if (message.after !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.after);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* uint64 from = 4; */
        if (message.from !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.from);
        /* uint64 to = 5; */
        if (message.to !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.to);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlocksRequest
 */
export const GetBlocksRequest = new GetBlocksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlocksResponse$Type extends MessageType<GetBlocksResponse> {
    constructor() {
        super("injective_explorer_rpc.GetBlocksResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo }
        ]);
    }
    create(value?: PartialMessage<GetBlocksResponse>): GetBlocksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetBlocksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlocksResponse): GetBlocksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.BlockInfo data */ 2:
                    message.data.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlocksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.BlockInfo data = 2; */
        for (let i = 0; i < message.data.length; i++)
            BlockInfo.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlocksResponse
 */
export const GetBlocksResponse = new GetBlocksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockInfo$Type extends MessageType<BlockInfo> {
    constructor() {
        super("injective_explorer_rpc.BlockInfo", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "proposer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "moniker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "block_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parent_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "num_pre_commits", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "num_txs", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "txs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxDataRPC },
            { no: 9, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "block_unix_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BlockInfo>): BlockInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.proposer = "";
        message.moniker = "";
        message.blockHash = "";
        message.parentHash = "";
        message.numPreCommits = 0n;
        message.numTxs = 0n;
        message.txs = [];
        message.timestamp = "";
        message.blockUnixTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<BlockInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockInfo): BlockInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* string proposer */ 2:
                    message.proposer = reader.string();
                    break;
                case /* string moniker */ 3:
                    message.moniker = reader.string();
                    break;
                case /* string block_hash */ 4:
                    message.blockHash = reader.string();
                    break;
                case /* string parent_hash */ 5:
                    message.parentHash = reader.string();
                    break;
                case /* sint64 num_pre_commits */ 6:
                    message.numPreCommits = reader.sint64().toBigInt();
                    break;
                case /* sint64 num_txs */ 7:
                    message.numTxs = reader.sint64().toBigInt();
                    break;
                case /* repeated injective_explorer_rpc.TxDataRPC txs */ 8:
                    message.txs.push(TxDataRPC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string timestamp */ 9:
                    message.timestamp = reader.string();
                    break;
                case /* uint64 block_unix_timestamp */ 10:
                    message.blockUnixTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* string proposer = 2; */
        if (message.proposer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.proposer);
        /* string moniker = 3; */
        if (message.moniker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.moniker);
        /* string block_hash = 4; */
        if (message.blockHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.blockHash);
        /* string parent_hash = 5; */
        if (message.parentHash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.parentHash);
        /* sint64 num_pre_commits = 6; */
        if (message.numPreCommits !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.numPreCommits);
        /* sint64 num_txs = 7; */
        if (message.numTxs !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.numTxs);
        /* repeated injective_explorer_rpc.TxDataRPC txs = 8; */
        for (let i = 0; i < message.txs.length; i++)
            TxDataRPC.internalBinaryWrite(message.txs[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string timestamp = 9; */
        if (message.timestamp !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.timestamp);
        /* uint64 block_unix_timestamp = 10; */
        if (message.blockUnixTimestamp !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.blockUnixTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.BlockInfo
 */
export const BlockInfo = new BlockInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxDataRPC$Type extends MessageType<TxDataRPC> {
    constructor() {
        super("injective_explorer_rpc.TxDataRPC", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "block_timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "messages", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "tx_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "error_log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "claim_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TxDataRPC>): TxDataRPC {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.blockNumber = 0n;
        message.blockTimestamp = "";
        message.hash = "";
        message.codespace = "";
        message.messages = "";
        message.txNumber = 0n;
        message.errorLog = "";
        message.code = 0;
        message.claimIds = [];
        if (value !== undefined)
            reflectionMergePartial<TxDataRPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxDataRPC): TxDataRPC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint64 block_number */ 2:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                case /* string block_timestamp */ 3:
                    message.blockTimestamp = reader.string();
                    break;
                case /* string hash */ 4:
                    message.hash = reader.string();
                    break;
                case /* string codespace */ 5:
                    message.codespace = reader.string();
                    break;
                case /* string messages */ 6:
                    message.messages = reader.string();
                    break;
                case /* uint64 tx_number */ 7:
                    message.txNumber = reader.uint64().toBigInt();
                    break;
                case /* string error_log */ 8:
                    message.errorLog = reader.string();
                    break;
                case /* uint32 code */ 9:
                    message.code = reader.uint32();
                    break;
                case /* repeated sint64 claim_ids */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.claimIds.push(reader.sint64().toBigInt());
                    else
                        message.claimIds.push(reader.sint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxDataRPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint64 block_number = 2; */
        if (message.blockNumber !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockNumber);
        /* string block_timestamp = 3; */
        if (message.blockTimestamp !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
        /* string hash = 4; */
        if (message.hash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hash);
        /* string codespace = 5; */
        if (message.codespace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.codespace);
        /* string messages = 6; */
        if (message.messages !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.messages);
        /* uint64 tx_number = 7; */
        if (message.txNumber !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.txNumber);
        /* string error_log = 8; */
        if (message.errorLog !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.errorLog);
        /* uint32 code = 9; */
        if (message.code !== 0)
            writer.tag(9, WireType.Varint).uint32(message.code);
        /* repeated sint64 claim_ids = 10; */
        if (message.claimIds.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.claimIds.length; i++)
                writer.sint64(message.claimIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.TxDataRPC
 */
export const TxDataRPC = new TxDataRPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlocksV2Request$Type extends MessageType<GetBlocksV2Request> {
    constructor() {
        super("injective_explorer_rpc.GetBlocksV2Request", [
            { no: 1, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetBlocksV2Request>): GetBlocksV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.perPage = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetBlocksV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlocksV2Request): GetBlocksV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 per_page */ 1:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlocksV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 per_page = 1; */
        if (message.perPage !== 0)
            writer.tag(1, WireType.Varint).sint32(message.perPage);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlocksV2Request
 */
export const GetBlocksV2Request = new GetBlocksV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlocksV2Response$Type extends MessageType<GetBlocksV2Response> {
    constructor() {
        super("injective_explorer_rpc.GetBlocksV2Response", [
            { no: 1, name: "paging", kind: "message", T: () => Cursor },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo }
        ]);
    }
    create(value?: PartialMessage<GetBlocksV2Response>): GetBlocksV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetBlocksV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlocksV2Response): GetBlocksV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Cursor paging */ 1:
                    message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.BlockInfo data */ 2:
                    message.data.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlocksV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Cursor paging = 1; */
        if (message.paging)
            Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.BlockInfo data = 2; */
        for (let i = 0; i < message.data.length; i++)
            BlockInfo.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlocksV2Response
 */
export const GetBlocksV2Response = new GetBlocksV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlockRequest$Type extends MessageType<GetBlockRequest> {
    constructor() {
        super("injective_explorer_rpc.GetBlockRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetBlockRequest>): GetBlockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetBlockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlockRequest): GetBlockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlockRequest
 */
export const GetBlockRequest = new GetBlockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlockResponse$Type extends MessageType<GetBlockResponse> {
    constructor() {
        super("injective_explorer_rpc.GetBlockResponse", [
            { no: 1, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errmsg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", T: () => BlockDetailInfo }
        ]);
    }
    create(value?: PartialMessage<GetBlockResponse>): GetBlockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.s = "";
        message.errmsg = "";
        if (value !== undefined)
            reflectionMergePartial<GetBlockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlockResponse): GetBlockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string s */ 1:
                    message.s = reader.string();
                    break;
                case /* string errmsg */ 2:
                    message.errmsg = reader.string();
                    break;
                case /* injective_explorer_rpc.BlockDetailInfo data */ 3:
                    message.data = BlockDetailInfo.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string s = 1; */
        if (message.s !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.s);
        /* string errmsg = 2; */
        if (message.errmsg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
        /* injective_explorer_rpc.BlockDetailInfo data = 3; */
        if (message.data)
            BlockDetailInfo.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlockResponse
 */
export const GetBlockResponse = new GetBlockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockDetailInfo$Type extends MessageType<BlockDetailInfo> {
    constructor() {
        super("injective_explorer_rpc.BlockDetailInfo", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "proposer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "moniker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "block_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parent_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "num_pre_commits", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "num_txs", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "total_txs", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "txs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxData },
            { no: 10, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "block_unix_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BlockDetailInfo>): BlockDetailInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.proposer = "";
        message.moniker = "";
        message.blockHash = "";
        message.parentHash = "";
        message.numPreCommits = 0n;
        message.numTxs = 0n;
        message.totalTxs = 0n;
        message.txs = [];
        message.timestamp = "";
        message.blockUnixTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<BlockDetailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockDetailInfo): BlockDetailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* string proposer */ 2:
                    message.proposer = reader.string();
                    break;
                case /* string moniker */ 3:
                    message.moniker = reader.string();
                    break;
                case /* string block_hash */ 4:
                    message.blockHash = reader.string();
                    break;
                case /* string parent_hash */ 5:
                    message.parentHash = reader.string();
                    break;
                case /* sint64 num_pre_commits */ 6:
                    message.numPreCommits = reader.sint64().toBigInt();
                    break;
                case /* sint64 num_txs */ 7:
                    message.numTxs = reader.sint64().toBigInt();
                    break;
                case /* sint64 total_txs */ 8:
                    message.totalTxs = reader.sint64().toBigInt();
                    break;
                case /* repeated injective_explorer_rpc.TxData txs */ 9:
                    message.txs.push(TxData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string timestamp */ 10:
                    message.timestamp = reader.string();
                    break;
                case /* uint64 block_unix_timestamp */ 11:
                    message.blockUnixTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockDetailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* string proposer = 2; */
        if (message.proposer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.proposer);
        /* string moniker = 3; */
        if (message.moniker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.moniker);
        /* string block_hash = 4; */
        if (message.blockHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.blockHash);
        /* string parent_hash = 5; */
        if (message.parentHash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.parentHash);
        /* sint64 num_pre_commits = 6; */
        if (message.numPreCommits !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.numPreCommits);
        /* sint64 num_txs = 7; */
        if (message.numTxs !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.numTxs);
        /* sint64 total_txs = 8; */
        if (message.totalTxs !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.totalTxs);
        /* repeated injective_explorer_rpc.TxData txs = 9; */
        for (let i = 0; i < message.txs.length; i++)
            TxData.internalBinaryWrite(message.txs[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string timestamp = 10; */
        if (message.timestamp !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.timestamp);
        /* uint64 block_unix_timestamp = 11; */
        if (message.blockUnixTimestamp !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.blockUnixTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.BlockDetailInfo
 */
export const BlockDetailInfo = new BlockDetailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxData$Type extends MessageType<TxData> {
    constructor() {
        super("injective_explorer_rpc.TxData", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "block_timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "messages", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "tx_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "error_log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "tx_msg_types", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "logs", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "claim_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "signatures", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Signature },
            { no: 14, name: "block_unix_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "ethereum_tx_hash_hex", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TxData>): TxData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.blockNumber = 0n;
        message.blockTimestamp = "";
        message.hash = "";
        message.codespace = "";
        message.messages = new Uint8Array(0);
        message.txNumber = 0n;
        message.errorLog = "";
        message.code = 0;
        message.txMsgTypes = new Uint8Array(0);
        message.logs = new Uint8Array(0);
        message.claimIds = [];
        message.signatures = [];
        message.blockUnixTimestamp = 0n;
        message.ethereumTxHashHex = "";
        if (value !== undefined)
            reflectionMergePartial<TxData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxData): TxData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint64 block_number */ 2:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                case /* string block_timestamp */ 3:
                    message.blockTimestamp = reader.string();
                    break;
                case /* string hash */ 4:
                    message.hash = reader.string();
                    break;
                case /* string codespace */ 5:
                    message.codespace = reader.string();
                    break;
                case /* bytes messages */ 6:
                    message.messages = reader.bytes();
                    break;
                case /* uint64 tx_number */ 7:
                    message.txNumber = reader.uint64().toBigInt();
                    break;
                case /* string error_log */ 8:
                    message.errorLog = reader.string();
                    break;
                case /* uint32 code */ 9:
                    message.code = reader.uint32();
                    break;
                case /* bytes tx_msg_types */ 10:
                    message.txMsgTypes = reader.bytes();
                    break;
                case /* bytes logs */ 11:
                    message.logs = reader.bytes();
                    break;
                case /* repeated sint64 claim_ids */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.claimIds.push(reader.sint64().toBigInt());
                    else
                        message.claimIds.push(reader.sint64().toBigInt());
                    break;
                case /* repeated injective_explorer_rpc.Signature signatures */ 13:
                    message.signatures.push(Signature.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 block_unix_timestamp */ 14:
                    message.blockUnixTimestamp = reader.uint64().toBigInt();
                    break;
                case /* string ethereum_tx_hash_hex */ 15:
                    message.ethereumTxHashHex = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint64 block_number = 2; */
        if (message.blockNumber !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockNumber);
        /* string block_timestamp = 3; */
        if (message.blockTimestamp !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
        /* string hash = 4; */
        if (message.hash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hash);
        /* string codespace = 5; */
        if (message.codespace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.codespace);
        /* bytes messages = 6; */
        if (message.messages.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.messages);
        /* uint64 tx_number = 7; */
        if (message.txNumber !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.txNumber);
        /* string error_log = 8; */
        if (message.errorLog !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.errorLog);
        /* uint32 code = 9; */
        if (message.code !== 0)
            writer.tag(9, WireType.Varint).uint32(message.code);
        /* bytes tx_msg_types = 10; */
        if (message.txMsgTypes.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.txMsgTypes);
        /* bytes logs = 11; */
        if (message.logs.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.logs);
        /* repeated sint64 claim_ids = 12; */
        if (message.claimIds.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.claimIds.length; i++)
                writer.sint64(message.claimIds[i]);
            writer.join();
        }
        /* repeated injective_explorer_rpc.Signature signatures = 13; */
        for (let i = 0; i < message.signatures.length; i++)
            Signature.internalBinaryWrite(message.signatures[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint64 block_unix_timestamp = 14; */
        if (message.blockUnixTimestamp !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.blockUnixTimestamp);
        /* string ethereum_tx_hash_hex = 15; */
        if (message.ethereumTxHashHex !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.ethereumTxHashHex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.TxData
 */
export const TxData = new TxData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetValidatorsRequest$Type extends MessageType<GetValidatorsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetValidatorsRequest", []);
    }
    create(value?: PartialMessage<GetValidatorsRequest>): GetValidatorsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetValidatorsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetValidatorsRequest): GetValidatorsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetValidatorsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorsRequest
 */
export const GetValidatorsRequest = new GetValidatorsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetValidatorsResponse$Type extends MessageType<GetValidatorsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetValidatorsResponse", [
            { no: 1, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errmsg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Validator }
        ]);
    }
    create(value?: PartialMessage<GetValidatorsResponse>): GetValidatorsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.s = "";
        message.errmsg = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetValidatorsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetValidatorsResponse): GetValidatorsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string s */ 1:
                    message.s = reader.string();
                    break;
                case /* string errmsg */ 2:
                    message.errmsg = reader.string();
                    break;
                case /* repeated injective_explorer_rpc.Validator data */ 3:
                    message.data.push(Validator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetValidatorsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string s = 1; */
        if (message.s !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.s);
        /* string errmsg = 2; */
        if (message.errmsg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
        /* repeated injective_explorer_rpc.Validator data = 3; */
        for (let i = 0; i < message.data.length; i++)
            Validator.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorsResponse
 */
export const GetValidatorsResponse = new GetValidatorsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Validator$Type extends MessageType<Validator> {
    constructor() {
        super("injective_explorer_rpc.Validator", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "moniker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "operator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "consensus_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "jailed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "status", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "tokens", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "delegator_shares", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "description", kind: "message", T: () => ValidatorDescription },
            { no: 10, name: "unbonding_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "unbonding_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "commission_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "commission_max_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "commission_max_change_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "commission_update_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "proposed", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "signed", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "missed", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "uptimes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUptime },
            { no: 21, name: "slashing_events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SlashingEvent },
            { no: 22, name: "uptime_percentage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 23, name: "image_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Validator>): Validator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.moniker = "";
        message.operatorAddress = "";
        message.consensusAddress = "";
        message.jailed = false;
        message.status = 0;
        message.tokens = "";
        message.delegatorShares = "";
        message.unbondingHeight = 0n;
        message.unbondingTime = "";
        message.commissionRate = "";
        message.commissionMaxRate = "";
        message.commissionMaxChangeRate = "";
        message.commissionUpdateTime = "";
        message.proposed = 0n;
        message.signed = 0n;
        message.missed = 0n;
        message.timestamp = "";
        message.uptimes = [];
        message.slashingEvents = [];
        message.uptimePercentage = 0;
        message.imageUrl = "";
        if (value !== undefined)
            reflectionMergePartial<Validator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Validator): Validator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string moniker */ 2:
                    message.moniker = reader.string();
                    break;
                case /* string operator_address */ 3:
                    message.operatorAddress = reader.string();
                    break;
                case /* string consensus_address */ 4:
                    message.consensusAddress = reader.string();
                    break;
                case /* bool jailed */ 5:
                    message.jailed = reader.bool();
                    break;
                case /* sint32 status */ 6:
                    message.status = reader.sint32();
                    break;
                case /* string tokens */ 7:
                    message.tokens = reader.string();
                    break;
                case /* string delegator_shares */ 8:
                    message.delegatorShares = reader.string();
                    break;
                case /* injective_explorer_rpc.ValidatorDescription description */ 9:
                    message.description = ValidatorDescription.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* sint64 unbonding_height */ 10:
                    message.unbondingHeight = reader.sint64().toBigInt();
                    break;
                case /* string unbonding_time */ 11:
                    message.unbondingTime = reader.string();
                    break;
                case /* string commission_rate */ 12:
                    message.commissionRate = reader.string();
                    break;
                case /* string commission_max_rate */ 13:
                    message.commissionMaxRate = reader.string();
                    break;
                case /* string commission_max_change_rate */ 14:
                    message.commissionMaxChangeRate = reader.string();
                    break;
                case /* string commission_update_time */ 15:
                    message.commissionUpdateTime = reader.string();
                    break;
                case /* uint64 proposed */ 16:
                    message.proposed = reader.uint64().toBigInt();
                    break;
                case /* uint64 signed */ 17:
                    message.signed = reader.uint64().toBigInt();
                    break;
                case /* uint64 missed */ 18:
                    message.missed = reader.uint64().toBigInt();
                    break;
                case /* string timestamp */ 19:
                    message.timestamp = reader.string();
                    break;
                case /* repeated injective_explorer_rpc.ValidatorUptime uptimes */ 20:
                    message.uptimes.push(ValidatorUptime.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_explorer_rpc.SlashingEvent slashing_events */ 21:
                    message.slashingEvents.push(SlashingEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double uptime_percentage */ 22:
                    message.uptimePercentage = reader.double();
                    break;
                case /* string image_url */ 23:
                    message.imageUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Validator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string moniker = 2; */
        if (message.moniker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.moniker);
        /* string operator_address = 3; */
        if (message.operatorAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.operatorAddress);
        /* string consensus_address = 4; */
        if (message.consensusAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.consensusAddress);
        /* bool jailed = 5; */
        if (message.jailed !== false)
            writer.tag(5, WireType.Varint).bool(message.jailed);
        /* sint32 status = 6; */
        if (message.status !== 0)
            writer.tag(6, WireType.Varint).sint32(message.status);
        /* string tokens = 7; */
        if (message.tokens !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.tokens);
        /* string delegator_shares = 8; */
        if (message.delegatorShares !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.delegatorShares);
        /* injective_explorer_rpc.ValidatorDescription description = 9; */
        if (message.description)
            ValidatorDescription.internalBinaryWrite(message.description, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* sint64 unbonding_height = 10; */
        if (message.unbondingHeight !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.unbondingHeight);
        /* string unbonding_time = 11; */
        if (message.unbondingTime !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.unbondingTime);
        /* string commission_rate = 12; */
        if (message.commissionRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.commissionRate);
        /* string commission_max_rate = 13; */
        if (message.commissionMaxRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.commissionMaxRate);
        /* string commission_max_change_rate = 14; */
        if (message.commissionMaxChangeRate !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.commissionMaxChangeRate);
        /* string commission_update_time = 15; */
        if (message.commissionUpdateTime !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.commissionUpdateTime);
        /* uint64 proposed = 16; */
        if (message.proposed !== 0n)
            writer.tag(16, WireType.Varint).uint64(message.proposed);
        /* uint64 signed = 17; */
        if (message.signed !== 0n)
            writer.tag(17, WireType.Varint).uint64(message.signed);
        /* uint64 missed = 18; */
        if (message.missed !== 0n)
            writer.tag(18, WireType.Varint).uint64(message.missed);
        /* string timestamp = 19; */
        if (message.timestamp !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.timestamp);
        /* repeated injective_explorer_rpc.ValidatorUptime uptimes = 20; */
        for (let i = 0; i < message.uptimes.length; i++)
            ValidatorUptime.internalBinaryWrite(message.uptimes[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.SlashingEvent slashing_events = 21; */
        for (let i = 0; i < message.slashingEvents.length; i++)
            SlashingEvent.internalBinaryWrite(message.slashingEvents[i], writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* double uptime_percentage = 22; */
        if (message.uptimePercentage !== 0)
            writer.tag(22, WireType.Bit64).double(message.uptimePercentage);
        /* string image_url = 23; */
        if (message.imageUrl !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.imageUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Validator
 */
export const Validator = new Validator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidatorDescription$Type extends MessageType<ValidatorDescription> {
    constructor() {
        super("injective_explorer_rpc.ValidatorDescription", [
            { no: 1, name: "moniker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "identity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "website", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "security_contact", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "details", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "image_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidatorDescription>): ValidatorDescription {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.moniker = "";
        message.identity = "";
        message.website = "";
        message.securityContact = "";
        message.details = "";
        message.imageUrl = "";
        if (value !== undefined)
            reflectionMergePartial<ValidatorDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorDescription): ValidatorDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string moniker */ 1:
                    message.moniker = reader.string();
                    break;
                case /* string identity */ 2:
                    message.identity = reader.string();
                    break;
                case /* string website */ 3:
                    message.website = reader.string();
                    break;
                case /* string security_contact */ 4:
                    message.securityContact = reader.string();
                    break;
                case /* string details */ 5:
                    message.details = reader.string();
                    break;
                case /* string image_url */ 6:
                    message.imageUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidatorDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string moniker = 1; */
        if (message.moniker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.moniker);
        /* string identity = 2; */
        if (message.identity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.identity);
        /* string website = 3; */
        if (message.website !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.website);
        /* string security_contact = 4; */
        if (message.securityContact !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.securityContact);
        /* string details = 5; */
        if (message.details !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.details);
        /* string image_url = 6; */
        if (message.imageUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.imageUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.ValidatorDescription
 */
export const ValidatorDescription = new ValidatorDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidatorUptime$Type extends MessageType<ValidatorUptime> {
    constructor() {
        super("injective_explorer_rpc.ValidatorUptime", [
            { no: 1, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidatorUptime>): ValidatorUptime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blockNumber = 0n;
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<ValidatorUptime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorUptime): ValidatorUptime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 block_number */ 1:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidatorUptime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 block_number = 1; */
        if (message.blockNumber !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.blockNumber);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.ValidatorUptime
 */
export const ValidatorUptime = new ValidatorUptime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlashingEvent$Type extends MessageType<SlashingEvent> {
    constructor() {
        super("injective_explorer_rpc.SlashingEvent", [
            { no: 1, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "block_timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "power", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "jailed", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "missed_blocks", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SlashingEvent>): SlashingEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blockNumber = 0n;
        message.blockTimestamp = "";
        message.address = "";
        message.power = 0n;
        message.reason = "";
        message.jailed = "";
        message.missedBlocks = 0n;
        if (value !== undefined)
            reflectionMergePartial<SlashingEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SlashingEvent): SlashingEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 block_number */ 1:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                case /* string block_timestamp */ 2:
                    message.blockTimestamp = reader.string();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                case /* uint64 power */ 4:
                    message.power = reader.uint64().toBigInt();
                    break;
                case /* string reason */ 5:
                    message.reason = reader.string();
                    break;
                case /* string jailed */ 6:
                    message.jailed = reader.string();
                    break;
                case /* uint64 missed_blocks */ 7:
                    message.missedBlocks = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SlashingEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 block_number = 1; */
        if (message.blockNumber !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.blockNumber);
        /* string block_timestamp = 2; */
        if (message.blockTimestamp !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.blockTimestamp);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        /* uint64 power = 4; */
        if (message.power !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.power);
        /* string reason = 5; */
        if (message.reason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reason);
        /* string jailed = 6; */
        if (message.jailed !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.jailed);
        /* uint64 missed_blocks = 7; */
        if (message.missedBlocks !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.missedBlocks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.SlashingEvent
 */
export const SlashingEvent = new SlashingEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetValidatorRequest$Type extends MessageType<GetValidatorRequest> {
    constructor() {
        super("injective_explorer_rpc.GetValidatorRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetValidatorRequest>): GetValidatorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<GetValidatorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetValidatorRequest): GetValidatorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetValidatorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorRequest
 */
export const GetValidatorRequest = new GetValidatorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetValidatorResponse$Type extends MessageType<GetValidatorResponse> {
    constructor() {
        super("injective_explorer_rpc.GetValidatorResponse", [
            { no: 1, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errmsg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", T: () => Validator }
        ]);
    }
    create(value?: PartialMessage<GetValidatorResponse>): GetValidatorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.s = "";
        message.errmsg = "";
        if (value !== undefined)
            reflectionMergePartial<GetValidatorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetValidatorResponse): GetValidatorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string s */ 1:
                    message.s = reader.string();
                    break;
                case /* string errmsg */ 2:
                    message.errmsg = reader.string();
                    break;
                case /* injective_explorer_rpc.Validator data */ 3:
                    message.data = Validator.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetValidatorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string s = 1; */
        if (message.s !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.s);
        /* string errmsg = 2; */
        if (message.errmsg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
        /* injective_explorer_rpc.Validator data = 3; */
        if (message.data)
            Validator.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorResponse
 */
export const GetValidatorResponse = new GetValidatorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetValidatorUptimeRequest$Type extends MessageType<GetValidatorUptimeRequest> {
    constructor() {
        super("injective_explorer_rpc.GetValidatorUptimeRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetValidatorUptimeRequest>): GetValidatorUptimeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<GetValidatorUptimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetValidatorUptimeRequest): GetValidatorUptimeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetValidatorUptimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorUptimeRequest
 */
export const GetValidatorUptimeRequest = new GetValidatorUptimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetValidatorUptimeResponse$Type extends MessageType<GetValidatorUptimeResponse> {
    constructor() {
        super("injective_explorer_rpc.GetValidatorUptimeResponse", [
            { no: 1, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errmsg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUptime }
        ]);
    }
    create(value?: PartialMessage<GetValidatorUptimeResponse>): GetValidatorUptimeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.s = "";
        message.errmsg = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetValidatorUptimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetValidatorUptimeResponse): GetValidatorUptimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string s */ 1:
                    message.s = reader.string();
                    break;
                case /* string errmsg */ 2:
                    message.errmsg = reader.string();
                    break;
                case /* repeated injective_explorer_rpc.ValidatorUptime data */ 3:
                    message.data.push(ValidatorUptime.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetValidatorUptimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string s = 1; */
        if (message.s !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.s);
        /* string errmsg = 2; */
        if (message.errmsg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
        /* repeated injective_explorer_rpc.ValidatorUptime data = 3; */
        for (let i = 0; i < message.data.length; i++)
            ValidatorUptime.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorUptimeResponse
 */
export const GetValidatorUptimeResponse = new GetValidatorUptimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxsRequest$Type extends MessageType<GetTxsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetTxsRequest", [
            { no: 1, name: "before", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "after", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "module", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "from_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "to_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTxsRequest>): GetTxsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.before = 0n;
        message.after = 0n;
        message.limit = 0;
        message.skip = 0n;
        message.type = "";
        message.module = "";
        message.fromNumber = 0n;
        message.toNumber = 0n;
        message.startTime = 0n;
        message.endTime = 0n;
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<GetTxsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxsRequest): GetTxsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 before */ 1:
                    message.before = reader.uint64().toBigInt();
                    break;
                case /* uint64 after */ 2:
                    message.after = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* string type */ 5:
                    message.type = reader.string();
                    break;
                case /* string module */ 6:
                    message.module = reader.string();
                    break;
                case /* sint64 from_number */ 7:
                    message.fromNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 to_number */ 8:
                    message.toNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 start_time */ 9:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 10:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* string status */ 11:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 before = 1; */
        if (message.before !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.before);
        /* uint64 after = 2; */
        if (message.after !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.after);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        /* string type = 5; */
        if (message.type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.type);
        /* string module = 6; */
        if (message.module !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.module);
        /* sint64 from_number = 7; */
        if (message.fromNumber !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.fromNumber);
        /* sint64 to_number = 8; */
        if (message.toNumber !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.toNumber);
        /* sint64 start_time = 9; */
        if (message.startTime !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 10; */
        if (message.endTime !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.endTime);
        /* string status = 11; */
        if (message.status !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxsRequest
 */
export const GetTxsRequest = new GetTxsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxsResponse$Type extends MessageType<GetTxsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetTxsResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxData }
        ]);
    }
    create(value?: PartialMessage<GetTxsResponse>): GetTxsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetTxsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxsResponse): GetTxsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.TxData data */ 2:
                    message.data.push(TxData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.TxData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            TxData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxsResponse
 */
export const GetTxsResponse = new GetTxsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxsV2Request$Type extends MessageType<GetTxsV2Request> {
    constructor() {
        super("injective_explorer_rpc.GetTxsV2Request", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetTxsV2Request>): GetTxsV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.startTime = 0n;
        message.endTime = 0n;
        message.perPage = 0;
        message.token = "";
        message.status = "";
        message.blockNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetTxsV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxsV2Request): GetTxsV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* sint64 start_time */ 2:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 3:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* sint32 per_page */ 4:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 5:
                    message.token = reader.string();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* uint64 block_number */ 7:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxsV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* sint64 start_time = 2; */
        if (message.startTime !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 3; */
        if (message.endTime !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.endTime);
        /* sint32 per_page = 4; */
        if (message.perPage !== 0)
            writer.tag(4, WireType.Varint).sint32(message.perPage);
        /* string token = 5; */
        if (message.token !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.token);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* uint64 block_number = 7; */
        if (message.blockNumber !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.blockNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxsV2Request
 */
export const GetTxsV2Request = new GetTxsV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxsV2Response$Type extends MessageType<GetTxsV2Response> {
    constructor() {
        super("injective_explorer_rpc.GetTxsV2Response", [
            { no: 1, name: "paging", kind: "message", T: () => Cursor },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxData }
        ]);
    }
    create(value?: PartialMessage<GetTxsV2Response>): GetTxsV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetTxsV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxsV2Response): GetTxsV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Cursor paging */ 1:
                    message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.TxData data */ 2:
                    message.data.push(TxData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxsV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Cursor paging = 1; */
        if (message.paging)
            Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.TxData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            TxData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxsV2Response
 */
export const GetTxsV2Response = new GetTxsV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxByTxHashRequest$Type extends MessageType<GetTxByTxHashRequest> {
    constructor() {
        super("injective_explorer_rpc.GetTxByTxHashRequest", [
            { no: 1, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_evm_hash", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetTxByTxHashRequest>): GetTxByTxHashRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = "";
        message.isEvmHash = false;
        if (value !== undefined)
            reflectionMergePartial<GetTxByTxHashRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxByTxHashRequest): GetTxByTxHashRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash */ 1:
                    message.hash = reader.string();
                    break;
                case /* bool is_evm_hash */ 2:
                    message.isEvmHash = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxByTxHashRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash = 1; */
        if (message.hash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hash);
        /* bool is_evm_hash = 2; */
        if (message.isEvmHash !== false)
            writer.tag(2, WireType.Varint).bool(message.isEvmHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxByTxHashRequest
 */
export const GetTxByTxHashRequest = new GetTxByTxHashRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxByTxHashResponse$Type extends MessageType<GetTxByTxHashResponse> {
    constructor() {
        super("injective_explorer_rpc.GetTxByTxHashResponse", [
            { no: 1, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errmsg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", T: () => TxDetailData }
        ]);
    }
    create(value?: PartialMessage<GetTxByTxHashResponse>): GetTxByTxHashResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.s = "";
        message.errmsg = "";
        if (value !== undefined)
            reflectionMergePartial<GetTxByTxHashResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxByTxHashResponse): GetTxByTxHashResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string s */ 1:
                    message.s = reader.string();
                    break;
                case /* string errmsg */ 2:
                    message.errmsg = reader.string();
                    break;
                case /* injective_explorer_rpc.TxDetailData data */ 3:
                    message.data = TxDetailData.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxByTxHashResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string s = 1; */
        if (message.s !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.s);
        /* string errmsg = 2; */
        if (message.errmsg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
        /* injective_explorer_rpc.TxDetailData data = 3; */
        if (message.data)
            TxDetailData.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxByTxHashResponse
 */
export const GetTxByTxHashResponse = new GetTxByTxHashResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPeggyDepositTxsRequest$Type extends MessageType<GetPeggyDepositTxsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetPeggyDepositTxsRequest", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetPeggyDepositTxsRequest>): GetPeggyDepositTxsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.limit = 0;
        message.skip = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetPeggyDepositTxsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPeggyDepositTxsRequest): GetPeggyDepositTxsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPeggyDepositTxsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetPeggyDepositTxsRequest
 */
export const GetPeggyDepositTxsRequest = new GetPeggyDepositTxsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPeggyDepositTxsResponse$Type extends MessageType<GetPeggyDepositTxsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetPeggyDepositTxsResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PeggyDepositTx }
        ]);
    }
    create(value?: PartialMessage<GetPeggyDepositTxsResponse>): GetPeggyDepositTxsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<GetPeggyDepositTxsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPeggyDepositTxsResponse): GetPeggyDepositTxsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_explorer_rpc.PeggyDepositTx field */ 1:
                    message.field.push(PeggyDepositTx.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPeggyDepositTxsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_explorer_rpc.PeggyDepositTx field = 1; */
        for (let i = 0; i < message.field.length; i++)
            PeggyDepositTx.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetPeggyDepositTxsResponse
 */
export const GetPeggyDepositTxsResponse = new GetPeggyDepositTxsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeggyDepositTx$Type extends MessageType<PeggyDepositTx> {
    constructor() {
        super("injective_explorer_rpc.PeggyDepositTx", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "event_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "claim_type", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 10, name: "tx_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PeggyDepositTx>): PeggyDepositTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.eventNonce = 0n;
        message.eventHeight = 0n;
        message.amount = "";
        message.denom = "";
        message.orchestratorAddress = "";
        message.state = "";
        message.claimType = 0;
        message.txHashes = [];
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PeggyDepositTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeggyDepositTx): PeggyDepositTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* uint64 event_nonce */ 3:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 event_height */ 4:
                    message.eventHeight = reader.uint64().toBigInt();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                case /* string denom */ 6:
                    message.denom = reader.string();
                    break;
                case /* string orchestrator_address */ 7:
                    message.orchestratorAddress = reader.string();
                    break;
                case /* string state */ 8:
                    message.state = reader.string();
                    break;
                case /* sint32 claim_type */ 9:
                    message.claimType = reader.sint32();
                    break;
                case /* repeated string tx_hashes */ 10:
                    message.txHashes.push(reader.string());
                    break;
                case /* string created_at */ 11:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 12:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeggyDepositTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* uint64 event_nonce = 3; */
        if (message.eventNonce !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.eventNonce);
        /* uint64 event_height = 4; */
        if (message.eventHeight !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.eventHeight);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        /* string denom = 6; */
        if (message.denom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.denom);
        /* string orchestrator_address = 7; */
        if (message.orchestratorAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.orchestratorAddress);
        /* string state = 8; */
        if (message.state !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.state);
        /* sint32 claim_type = 9; */
        if (message.claimType !== 0)
            writer.tag(9, WireType.Varint).sint32(message.claimType);
        /* repeated string tx_hashes = 10; */
        for (let i = 0; i < message.txHashes.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.txHashes[i]);
        /* string created_at = 11; */
        if (message.createdAt !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 12; */
        if (message.updatedAt !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.PeggyDepositTx
 */
export const PeggyDepositTx = new PeggyDepositTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPeggyWithdrawalTxsRequest$Type extends MessageType<GetPeggyWithdrawalTxsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetPeggyWithdrawalTxsRequest", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetPeggyWithdrawalTxsRequest>): GetPeggyWithdrawalTxsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.limit = 0;
        message.skip = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetPeggyWithdrawalTxsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPeggyWithdrawalTxsRequest): GetPeggyWithdrawalTxsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPeggyWithdrawalTxsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetPeggyWithdrawalTxsRequest
 */
export const GetPeggyWithdrawalTxsRequest = new GetPeggyWithdrawalTxsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPeggyWithdrawalTxsResponse$Type extends MessageType<GetPeggyWithdrawalTxsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetPeggyWithdrawalTxsResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PeggyWithdrawalTx }
        ]);
    }
    create(value?: PartialMessage<GetPeggyWithdrawalTxsResponse>): GetPeggyWithdrawalTxsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<GetPeggyWithdrawalTxsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPeggyWithdrawalTxsResponse): GetPeggyWithdrawalTxsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_explorer_rpc.PeggyWithdrawalTx field */ 1:
                    message.field.push(PeggyWithdrawalTx.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPeggyWithdrawalTxsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_explorer_rpc.PeggyWithdrawalTx field = 1; */
        for (let i = 0; i < message.field.length; i++)
            PeggyWithdrawalTx.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetPeggyWithdrawalTxsResponse
 */
export const GetPeggyWithdrawalTxsResponse = new GetPeggyWithdrawalTxsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeggyWithdrawalTx$Type extends MessageType<PeggyWithdrawalTx> {
    constructor() {
        super("injective_explorer_rpc.PeggyWithdrawalTx", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "bridge_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "outgoing_tx_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "batch_timeout", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "batch_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "event_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "claim_type", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 14, name: "tx_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PeggyWithdrawalTx>): PeggyWithdrawalTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.amount = "";
        message.denom = "";
        message.bridgeFee = "";
        message.outgoingTxId = 0n;
        message.batchTimeout = 0n;
        message.batchNonce = 0n;
        message.orchestratorAddress = "";
        message.eventNonce = 0n;
        message.eventHeight = 0n;
        message.state = "";
        message.claimType = 0;
        message.txHashes = [];
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PeggyWithdrawalTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeggyWithdrawalTx): PeggyWithdrawalTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                case /* string denom */ 4:
                    message.denom = reader.string();
                    break;
                case /* string bridge_fee */ 5:
                    message.bridgeFee = reader.string();
                    break;
                case /* uint64 outgoing_tx_id */ 6:
                    message.outgoingTxId = reader.uint64().toBigInt();
                    break;
                case /* uint64 batch_timeout */ 7:
                    message.batchTimeout = reader.uint64().toBigInt();
                    break;
                case /* uint64 batch_nonce */ 8:
                    message.batchNonce = reader.uint64().toBigInt();
                    break;
                case /* string orchestrator_address */ 9:
                    message.orchestratorAddress = reader.string();
                    break;
                case /* uint64 event_nonce */ 10:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 event_height */ 11:
                    message.eventHeight = reader.uint64().toBigInt();
                    break;
                case /* string state */ 12:
                    message.state = reader.string();
                    break;
                case /* sint32 claim_type */ 13:
                    message.claimType = reader.sint32();
                    break;
                case /* repeated string tx_hashes */ 14:
                    message.txHashes.push(reader.string());
                    break;
                case /* string created_at */ 15:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 16:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeggyWithdrawalTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        /* string denom = 4; */
        if (message.denom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.denom);
        /* string bridge_fee = 5; */
        if (message.bridgeFee !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.bridgeFee);
        /* uint64 outgoing_tx_id = 6; */
        if (message.outgoingTxId !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.outgoingTxId);
        /* uint64 batch_timeout = 7; */
        if (message.batchTimeout !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.batchTimeout);
        /* uint64 batch_nonce = 8; */
        if (message.batchNonce !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.batchNonce);
        /* string orchestrator_address = 9; */
        if (message.orchestratorAddress !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.orchestratorAddress);
        /* uint64 event_nonce = 10; */
        if (message.eventNonce !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.eventNonce);
        /* uint64 event_height = 11; */
        if (message.eventHeight !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.eventHeight);
        /* string state = 12; */
        if (message.state !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.state);
        /* sint32 claim_type = 13; */
        if (message.claimType !== 0)
            writer.tag(13, WireType.Varint).sint32(message.claimType);
        /* repeated string tx_hashes = 14; */
        for (let i = 0; i < message.txHashes.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.txHashes[i]);
        /* string created_at = 15; */
        if (message.createdAt !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 16; */
        if (message.updatedAt !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.PeggyWithdrawalTx
 */
export const PeggyWithdrawalTx = new PeggyWithdrawalTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIBCTransferTxsRequest$Type extends MessageType<GetIBCTransferTxsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetIBCTransferTxsRequest", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "src_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "src_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dest_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "dest_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 8, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetIBCTransferTxsRequest>): GetIBCTransferTxsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.srcChannel = "";
        message.srcPort = "";
        message.destChannel = "";
        message.destPort = "";
        message.limit = 0;
        message.skip = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetIBCTransferTxsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIBCTransferTxsRequest): GetIBCTransferTxsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* string src_channel */ 3:
                    message.srcChannel = reader.string();
                    break;
                case /* string src_port */ 4:
                    message.srcPort = reader.string();
                    break;
                case /* string dest_channel */ 5:
                    message.destChannel = reader.string();
                    break;
                case /* string dest_port */ 6:
                    message.destPort = reader.string();
                    break;
                case /* sint32 limit */ 7:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 8:
                    message.skip = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIBCTransferTxsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* string src_channel = 3; */
        if (message.srcChannel !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.srcChannel);
        /* string src_port = 4; */
        if (message.srcPort !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.srcPort);
        /* string dest_channel = 5; */
        if (message.destChannel !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.destChannel);
        /* string dest_port = 6; */
        if (message.destPort !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.destPort);
        /* sint32 limit = 7; */
        if (message.limit !== 0)
            writer.tag(7, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 8; */
        if (message.skip !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetIBCTransferTxsRequest
 */
export const GetIBCTransferTxsRequest = new GetIBCTransferTxsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIBCTransferTxsResponse$Type extends MessageType<GetIBCTransferTxsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetIBCTransferTxsResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => IBCTransferTx }
        ]);
    }
    create(value?: PartialMessage<GetIBCTransferTxsResponse>): GetIBCTransferTxsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<GetIBCTransferTxsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIBCTransferTxsResponse): GetIBCTransferTxsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_explorer_rpc.IBCTransferTx field */ 1:
                    message.field.push(IBCTransferTx.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIBCTransferTxsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_explorer_rpc.IBCTransferTx field = 1; */
        for (let i = 0; i < message.field.length; i++)
            IBCTransferTx.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetIBCTransferTxsResponse
 */
export const GetIBCTransferTxsResponse = new GetIBCTransferTxsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IBCTransferTx$Type extends MessageType<IBCTransferTx> {
    constructor() {
        super("injective_explorer_rpc.IBCTransferTx", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "source_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "destination_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "destination_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "timeout_height", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "timeout_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "packet_sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "data_hex", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 13, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "tx_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<IBCTransferTx>): IBCTransferTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.sourcePort = "";
        message.sourceChannel = "";
        message.destinationPort = "";
        message.destinationChannel = "";
        message.amount = "";
        message.denom = "";
        message.timeoutHeight = "";
        message.timeoutTimestamp = 0n;
        message.packetSequence = 0n;
        message.dataHex = new Uint8Array(0);
        message.state = "";
        message.txHashes = [];
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<IBCTransferTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IBCTransferTx): IBCTransferTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* string source_port */ 3:
                    message.sourcePort = reader.string();
                    break;
                case /* string source_channel */ 4:
                    message.sourceChannel = reader.string();
                    break;
                case /* string destination_port */ 5:
                    message.destinationPort = reader.string();
                    break;
                case /* string destination_channel */ 6:
                    message.destinationChannel = reader.string();
                    break;
                case /* string amount */ 7:
                    message.amount = reader.string();
                    break;
                case /* string denom */ 8:
                    message.denom = reader.string();
                    break;
                case /* string timeout_height */ 9:
                    message.timeoutHeight = reader.string();
                    break;
                case /* uint64 timeout_timestamp */ 10:
                    message.timeoutTimestamp = reader.uint64().toBigInt();
                    break;
                case /* uint64 packet_sequence */ 11:
                    message.packetSequence = reader.uint64().toBigInt();
                    break;
                case /* bytes data_hex */ 12:
                    message.dataHex = reader.bytes();
                    break;
                case /* string state */ 13:
                    message.state = reader.string();
                    break;
                case /* repeated string tx_hashes */ 14:
                    message.txHashes.push(reader.string());
                    break;
                case /* string created_at */ 15:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 16:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IBCTransferTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* string source_port = 3; */
        if (message.sourcePort !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sourcePort);
        /* string source_channel = 4; */
        if (message.sourceChannel !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sourceChannel);
        /* string destination_port = 5; */
        if (message.destinationPort !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.destinationPort);
        /* string destination_channel = 6; */
        if (message.destinationChannel !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.destinationChannel);
        /* string amount = 7; */
        if (message.amount !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.amount);
        /* string denom = 8; */
        if (message.denom !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.denom);
        /* string timeout_height = 9; */
        if (message.timeoutHeight !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.timeoutHeight);
        /* uint64 timeout_timestamp = 10; */
        if (message.timeoutTimestamp !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.timeoutTimestamp);
        /* uint64 packet_sequence = 11; */
        if (message.packetSequence !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.packetSequence);
        /* bytes data_hex = 12; */
        if (message.dataHex.length)
            writer.tag(12, WireType.LengthDelimited).bytes(message.dataHex);
        /* string state = 13; */
        if (message.state !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.state);
        /* repeated string tx_hashes = 14; */
        for (let i = 0; i < message.txHashes.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.txHashes[i]);
        /* string created_at = 15; */
        if (message.createdAt !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 16; */
        if (message.updatedAt !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.IBCTransferTx
 */
export const IBCTransferTx = new IBCTransferTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmCodesRequest$Type extends MessageType<GetWasmCodesRequest> {
    constructor() {
        super("injective_explorer_rpc.GetWasmCodesRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "from_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "to_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetWasmCodesRequest>): GetWasmCodesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.fromNumber = 0n;
        message.toNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetWasmCodesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmCodesRequest): GetWasmCodesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 limit */ 1:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 from_number */ 2:
                    message.fromNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 to_number */ 3:
                    message.toNumber = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmCodesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).sint32(message.limit);
        /* sint64 from_number = 2; */
        if (message.fromNumber !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.fromNumber);
        /* sint64 to_number = 3; */
        if (message.toNumber !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.toNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmCodesRequest
 */
export const GetWasmCodesRequest = new GetWasmCodesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmCodesResponse$Type extends MessageType<GetWasmCodesResponse> {
    constructor() {
        super("injective_explorer_rpc.GetWasmCodesResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WasmCode }
        ]);
    }
    create(value?: PartialMessage<GetWasmCodesResponse>): GetWasmCodesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetWasmCodesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmCodesResponse): GetWasmCodesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.WasmCode data */ 2:
                    message.data.push(WasmCode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmCodesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.WasmCode data = 2; */
        for (let i = 0; i < message.data.length; i++)
            WasmCode.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmCodesResponse
 */
export const GetWasmCodesResponse = new GetWasmCodesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WasmCode$Type extends MessageType<WasmCode> {
    constructor() {
        super("injective_explorer_rpc.WasmCode", [
            { no: 1, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "checksum", kind: "message", T: () => Checksum },
            { no: 4, name: "created_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "contract_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "permission", kind: "message", T: () => ContractPermission },
            { no: 8, name: "code_schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "code_view", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "instantiates", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "code_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "proposal_id", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WasmCode>): WasmCode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.codeId = 0n;
        message.txHash = "";
        message.createdAt = 0n;
        message.contractType = "";
        message.version = "";
        message.codeSchema = "";
        message.codeView = "";
        message.instantiates = 0n;
        message.creator = "";
        message.codeNumber = 0n;
        message.proposalId = 0n;
        if (value !== undefined)
            reflectionMergePartial<WasmCode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WasmCode): WasmCode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 code_id */ 1:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* string tx_hash */ 2:
                    message.txHash = reader.string();
                    break;
                case /* injective_explorer_rpc.Checksum checksum */ 3:
                    message.checksum = Checksum.internalBinaryRead(reader, reader.uint32(), options, message.checksum);
                    break;
                case /* uint64 created_at */ 4:
                    message.createdAt = reader.uint64().toBigInt();
                    break;
                case /* string contract_type */ 5:
                    message.contractType = reader.string();
                    break;
                case /* string version */ 6:
                    message.version = reader.string();
                    break;
                case /* injective_explorer_rpc.ContractPermission permission */ 7:
                    message.permission = ContractPermission.internalBinaryRead(reader, reader.uint32(), options, message.permission);
                    break;
                case /* string code_schema */ 8:
                    message.codeSchema = reader.string();
                    break;
                case /* string code_view */ 9:
                    message.codeView = reader.string();
                    break;
                case /* uint64 instantiates */ 10:
                    message.instantiates = reader.uint64().toBigInt();
                    break;
                case /* string creator */ 11:
                    message.creator = reader.string();
                    break;
                case /* sint64 code_number */ 12:
                    message.codeNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 proposal_id */ 13:
                    message.proposalId = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WasmCode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 code_id = 1; */
        if (message.codeId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.codeId);
        /* string tx_hash = 2; */
        if (message.txHash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.txHash);
        /* injective_explorer_rpc.Checksum checksum = 3; */
        if (message.checksum)
            Checksum.internalBinaryWrite(message.checksum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 created_at = 4; */
        if (message.createdAt !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.createdAt);
        /* string contract_type = 5; */
        if (message.contractType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.contractType);
        /* string version = 6; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        /* injective_explorer_rpc.ContractPermission permission = 7; */
        if (message.permission)
            ContractPermission.internalBinaryWrite(message.permission, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string code_schema = 8; */
        if (message.codeSchema !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codeSchema);
        /* string code_view = 9; */
        if (message.codeView !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.codeView);
        /* uint64 instantiates = 10; */
        if (message.instantiates !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.instantiates);
        /* string creator = 11; */
        if (message.creator !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.creator);
        /* sint64 code_number = 12; */
        if (message.codeNumber !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.codeNumber);
        /* sint64 proposal_id = 13; */
        if (message.proposalId !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.proposalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.WasmCode
 */
export const WasmCode = new WasmCode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Checksum$Type extends MessageType<Checksum> {
    constructor() {
        super("injective_explorer_rpc.Checksum", [
            { no: 1, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Checksum>): Checksum {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.algorithm = "";
        message.hash = "";
        if (value !== undefined)
            reflectionMergePartial<Checksum>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Checksum): Checksum {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string algorithm */ 1:
                    message.algorithm = reader.string();
                    break;
                case /* string hash */ 2:
                    message.hash = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Checksum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string algorithm = 1; */
        if (message.algorithm !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.algorithm);
        /* string hash = 2; */
        if (message.hash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Checksum
 */
export const Checksum = new Checksum$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContractPermission$Type extends MessageType<ContractPermission> {
    constructor() {
        super("injective_explorer_rpc.ContractPermission", [
            { no: 1, name: "access_type", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ContractPermission>): ContractPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessType = 0;
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<ContractPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractPermission): ContractPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 access_type */ 1:
                    message.accessType = reader.sint32();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContractPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 access_type = 1; */
        if (message.accessType !== 0)
            writer.tag(1, WireType.Varint).sint32(message.accessType);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.ContractPermission
 */
export const ContractPermission = new ContractPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmCodeByIDRequest$Type extends MessageType<GetWasmCodeByIDRequest> {
    constructor() {
        super("injective_explorer_rpc.GetWasmCodeByIDRequest", [
            { no: 1, name: "code_id", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetWasmCodeByIDRequest>): GetWasmCodeByIDRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.codeId = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetWasmCodeByIDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmCodeByIDRequest): GetWasmCodeByIDRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 code_id */ 1:
                    message.codeId = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmCodeByIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 code_id = 1; */
        if (message.codeId !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.codeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmCodeByIDRequest
 */
export const GetWasmCodeByIDRequest = new GetWasmCodeByIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmCodeByIDResponse$Type extends MessageType<GetWasmCodeByIDResponse> {
    constructor() {
        super("injective_explorer_rpc.GetWasmCodeByIDResponse", [
            { no: 1, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "checksum", kind: "message", T: () => Checksum },
            { no: 4, name: "created_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "contract_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "permission", kind: "message", T: () => ContractPermission },
            { no: 8, name: "code_schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "code_view", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "instantiates", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "code_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "proposal_id", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetWasmCodeByIDResponse>): GetWasmCodeByIDResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.codeId = 0n;
        message.txHash = "";
        message.createdAt = 0n;
        message.contractType = "";
        message.version = "";
        message.codeSchema = "";
        message.codeView = "";
        message.instantiates = 0n;
        message.creator = "";
        message.codeNumber = 0n;
        message.proposalId = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetWasmCodeByIDResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmCodeByIDResponse): GetWasmCodeByIDResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 code_id */ 1:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* string tx_hash */ 2:
                    message.txHash = reader.string();
                    break;
                case /* injective_explorer_rpc.Checksum checksum */ 3:
                    message.checksum = Checksum.internalBinaryRead(reader, reader.uint32(), options, message.checksum);
                    break;
                case /* uint64 created_at */ 4:
                    message.createdAt = reader.uint64().toBigInt();
                    break;
                case /* string contract_type */ 5:
                    message.contractType = reader.string();
                    break;
                case /* string version */ 6:
                    message.version = reader.string();
                    break;
                case /* injective_explorer_rpc.ContractPermission permission */ 7:
                    message.permission = ContractPermission.internalBinaryRead(reader, reader.uint32(), options, message.permission);
                    break;
                case /* string code_schema */ 8:
                    message.codeSchema = reader.string();
                    break;
                case /* string code_view */ 9:
                    message.codeView = reader.string();
                    break;
                case /* uint64 instantiates */ 10:
                    message.instantiates = reader.uint64().toBigInt();
                    break;
                case /* string creator */ 11:
                    message.creator = reader.string();
                    break;
                case /* sint64 code_number */ 12:
                    message.codeNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 proposal_id */ 13:
                    message.proposalId = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmCodeByIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 code_id = 1; */
        if (message.codeId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.codeId);
        /* string tx_hash = 2; */
        if (message.txHash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.txHash);
        /* injective_explorer_rpc.Checksum checksum = 3; */
        if (message.checksum)
            Checksum.internalBinaryWrite(message.checksum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 created_at = 4; */
        if (message.createdAt !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.createdAt);
        /* string contract_type = 5; */
        if (message.contractType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.contractType);
        /* string version = 6; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        /* injective_explorer_rpc.ContractPermission permission = 7; */
        if (message.permission)
            ContractPermission.internalBinaryWrite(message.permission, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string code_schema = 8; */
        if (message.codeSchema !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codeSchema);
        /* string code_view = 9; */
        if (message.codeView !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.codeView);
        /* uint64 instantiates = 10; */
        if (message.instantiates !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.instantiates);
        /* string creator = 11; */
        if (message.creator !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.creator);
        /* sint64 code_number = 12; */
        if (message.codeNumber !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.codeNumber);
        /* sint64 proposal_id = 13; */
        if (message.proposalId !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.proposalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmCodeByIDResponse
 */
export const GetWasmCodeByIDResponse = new GetWasmCodeByIDResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmContractsRequest$Type extends MessageType<GetWasmContractsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetWasmContractsRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "code_id", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "from_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "to_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "assets_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "skip", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "lookup", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWasmContractsRequest>): GetWasmContractsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.codeId = 0n;
        message.fromNumber = 0n;
        message.toNumber = 0n;
        message.assetsOnly = false;
        message.skip = 0n;
        message.label = "";
        message.token = "";
        message.lookup = "";
        if (value !== undefined)
            reflectionMergePartial<GetWasmContractsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmContractsRequest): GetWasmContractsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 limit */ 1:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 code_id */ 2:
                    message.codeId = reader.sint64().toBigInt();
                    break;
                case /* sint64 from_number */ 3:
                    message.fromNumber = reader.sint64().toBigInt();
                    break;
                case /* sint64 to_number */ 4:
                    message.toNumber = reader.sint64().toBigInt();
                    break;
                case /* bool assets_only */ 5:
                    message.assetsOnly = reader.bool();
                    break;
                case /* sint64 skip */ 6:
                    message.skip = reader.sint64().toBigInt();
                    break;
                case /* string label */ 7:
                    message.label = reader.string();
                    break;
                case /* string token */ 8:
                    message.token = reader.string();
                    break;
                case /* string lookup */ 9:
                    message.lookup = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).sint32(message.limit);
        /* sint64 code_id = 2; */
        if (message.codeId !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.codeId);
        /* sint64 from_number = 3; */
        if (message.fromNumber !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.fromNumber);
        /* sint64 to_number = 4; */
        if (message.toNumber !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.toNumber);
        /* bool assets_only = 5; */
        if (message.assetsOnly !== false)
            writer.tag(5, WireType.Varint).bool(message.assetsOnly);
        /* sint64 skip = 6; */
        if (message.skip !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.skip);
        /* string label = 7; */
        if (message.label !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.label);
        /* string token = 8; */
        if (message.token !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.token);
        /* string lookup = 9; */
        if (message.lookup !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.lookup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmContractsRequest
 */
export const GetWasmContractsRequest = new GetWasmContractsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmContractsResponse$Type extends MessageType<GetWasmContractsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetWasmContractsResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WasmContract }
        ]);
    }
    create(value?: PartialMessage<GetWasmContractsResponse>): GetWasmContractsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetWasmContractsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmContractsResponse): GetWasmContractsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.WasmContract data */ 2:
                    message.data.push(WasmContract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.WasmContract data = 2; */
        for (let i = 0; i < message.data.length; i++)
            WasmContract.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmContractsResponse
 */
export const GetWasmContractsResponse = new GetWasmContractsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WasmContract$Type extends MessageType<WasmContract> {
    constructor() {
        super("injective_explorer_rpc.WasmContract", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "executes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "instantiated_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "init_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "last_executed_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "funds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ContractFund },
            { no: 10, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "current_migrate_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "contract_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "cw20_metadata", kind: "message", T: () => Cw20Metadata },
            { no: 17, name: "proposal_id", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WasmContract>): WasmContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.address = "";
        message.txHash = "";
        message.creator = "";
        message.executes = 0n;
        message.instantiatedAt = 0n;
        message.initMessage = "";
        message.lastExecutedAt = 0n;
        message.funds = [];
        message.codeId = 0n;
        message.admin = "";
        message.currentMigrateMessage = "";
        message.contractNumber = 0n;
        message.version = "";
        message.type = "";
        message.proposalId = 0n;
        if (value !== undefined)
            reflectionMergePartial<WasmContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WasmContract): WasmContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string tx_hash */ 3:
                    message.txHash = reader.string();
                    break;
                case /* string creator */ 4:
                    message.creator = reader.string();
                    break;
                case /* uint64 executes */ 5:
                    message.executes = reader.uint64().toBigInt();
                    break;
                case /* uint64 instantiated_at */ 6:
                    message.instantiatedAt = reader.uint64().toBigInt();
                    break;
                case /* string init_message */ 7:
                    message.initMessage = reader.string();
                    break;
                case /* uint64 last_executed_at */ 8:
                    message.lastExecutedAt = reader.uint64().toBigInt();
                    break;
                case /* repeated injective_explorer_rpc.ContractFund funds */ 9:
                    message.funds.push(ContractFund.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 code_id */ 10:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* string admin */ 11:
                    message.admin = reader.string();
                    break;
                case /* string current_migrate_message */ 12:
                    message.currentMigrateMessage = reader.string();
                    break;
                case /* sint64 contract_number */ 13:
                    message.contractNumber = reader.sint64().toBigInt();
                    break;
                case /* string version */ 14:
                    message.version = reader.string();
                    break;
                case /* string type */ 15:
                    message.type = reader.string();
                    break;
                case /* injective_explorer_rpc.Cw20Metadata cw20_metadata */ 16:
                    message.cw20Metadata = Cw20Metadata.internalBinaryRead(reader, reader.uint32(), options, message.cw20Metadata);
                    break;
                case /* sint64 proposal_id */ 17:
                    message.proposalId = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WasmContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string tx_hash = 3; */
        if (message.txHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.txHash);
        /* string creator = 4; */
        if (message.creator !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.creator);
        /* uint64 executes = 5; */
        if (message.executes !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.executes);
        /* uint64 instantiated_at = 6; */
        if (message.instantiatedAt !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.instantiatedAt);
        /* string init_message = 7; */
        if (message.initMessage !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.initMessage);
        /* uint64 last_executed_at = 8; */
        if (message.lastExecutedAt !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.lastExecutedAt);
        /* repeated injective_explorer_rpc.ContractFund funds = 9; */
        for (let i = 0; i < message.funds.length; i++)
            ContractFund.internalBinaryWrite(message.funds[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint64 code_id = 10; */
        if (message.codeId !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.codeId);
        /* string admin = 11; */
        if (message.admin !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.admin);
        /* string current_migrate_message = 12; */
        if (message.currentMigrateMessage !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.currentMigrateMessage);
        /* sint64 contract_number = 13; */
        if (message.contractNumber !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.contractNumber);
        /* string version = 14; */
        if (message.version !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.version);
        /* string type = 15; */
        if (message.type !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.type);
        /* injective_explorer_rpc.Cw20Metadata cw20_metadata = 16; */
        if (message.cw20Metadata)
            Cw20Metadata.internalBinaryWrite(message.cw20Metadata, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* sint64 proposal_id = 17; */
        if (message.proposalId !== 0n)
            writer.tag(17, WireType.Varint).sint64(message.proposalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.WasmContract
 */
export const WasmContract = new WasmContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContractFund$Type extends MessageType<ContractFund> {
    constructor() {
        super("injective_explorer_rpc.ContractFund", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ContractFund>): ContractFund {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<ContractFund>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractFund): ContractFund {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContractFund, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.ContractFund
 */
export const ContractFund = new ContractFund$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cw20Metadata$Type extends MessageType<Cw20Metadata> {
    constructor() {
        super("injective_explorer_rpc.Cw20Metadata", [
            { no: 1, name: "token_info", kind: "message", T: () => Cw20TokenInfo },
            { no: 2, name: "marketing_info", kind: "message", T: () => Cw20MarketingInfo }
        ]);
    }
    create(value?: PartialMessage<Cw20Metadata>): Cw20Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cw20Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cw20Metadata): Cw20Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Cw20TokenInfo token_info */ 1:
                    message.tokenInfo = Cw20TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
                    break;
                case /* injective_explorer_rpc.Cw20MarketingInfo marketing_info */ 2:
                    message.marketingInfo = Cw20MarketingInfo.internalBinaryRead(reader, reader.uint32(), options, message.marketingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cw20Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Cw20TokenInfo token_info = 1; */
        if (message.tokenInfo)
            Cw20TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_explorer_rpc.Cw20MarketingInfo marketing_info = 2; */
        if (message.marketingInfo)
            Cw20MarketingInfo.internalBinaryWrite(message.marketingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Cw20Metadata
 */
export const Cw20Metadata = new Cw20Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cw20TokenInfo$Type extends MessageType<Cw20TokenInfo> {
    constructor() {
        super("injective_explorer_rpc.Cw20TokenInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "decimals", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "total_supply", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cw20TokenInfo>): Cw20TokenInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.symbol = "";
        message.decimals = 0n;
        message.totalSupply = "";
        if (value !== undefined)
            reflectionMergePartial<Cw20TokenInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cw20TokenInfo): Cw20TokenInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 2:
                    message.symbol = reader.string();
                    break;
                case /* sint64 decimals */ 3:
                    message.decimals = reader.sint64().toBigInt();
                    break;
                case /* string total_supply */ 4:
                    message.totalSupply = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cw20TokenInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string symbol = 2; */
        if (message.symbol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.symbol);
        /* sint64 decimals = 3; */
        if (message.decimals !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.decimals);
        /* string total_supply = 4; */
        if (message.totalSupply !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.totalSupply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Cw20TokenInfo
 */
export const Cw20TokenInfo = new Cw20TokenInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cw20MarketingInfo$Type extends MessageType<Cw20MarketingInfo> {
    constructor() {
        super("injective_explorer_rpc.Cw20MarketingInfo", [
            { no: 1, name: "project", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "logo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "marketing", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Cw20MarketingInfo>): Cw20MarketingInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.project = "";
        message.description = "";
        message.logo = "";
        message.marketing = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Cw20MarketingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cw20MarketingInfo): Cw20MarketingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string project */ 1:
                    message.project = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string logo */ 3:
                    message.logo = reader.string();
                    break;
                case /* bytes marketing */ 4:
                    message.marketing = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cw20MarketingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string project = 1; */
        if (message.project !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.project);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string logo = 3; */
        if (message.logo !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.logo);
        /* bytes marketing = 4; */
        if (message.marketing.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.marketing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Cw20MarketingInfo
 */
export const Cw20MarketingInfo = new Cw20MarketingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmContractByAddressRequest$Type extends MessageType<GetWasmContractByAddressRequest> {
    constructor() {
        super("injective_explorer_rpc.GetWasmContractByAddressRequest", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWasmContractByAddressRequest>): GetWasmContractByAddressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetWasmContractByAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmContractByAddressRequest): GetWasmContractByAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmContractByAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmContractByAddressRequest
 */
export const GetWasmContractByAddressRequest = new GetWasmContractByAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWasmContractByAddressResponse$Type extends MessageType<GetWasmContractByAddressResponse> {
    constructor() {
        super("injective_explorer_rpc.GetWasmContractByAddressResponse", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "executes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "instantiated_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "init_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "last_executed_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "funds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ContractFund },
            { no: 10, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "current_migrate_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "contract_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "cw20_metadata", kind: "message", T: () => Cw20Metadata },
            { no: 17, name: "proposal_id", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetWasmContractByAddressResponse>): GetWasmContractByAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.address = "";
        message.txHash = "";
        message.creator = "";
        message.executes = 0n;
        message.instantiatedAt = 0n;
        message.initMessage = "";
        message.lastExecutedAt = 0n;
        message.funds = [];
        message.codeId = 0n;
        message.admin = "";
        message.currentMigrateMessage = "";
        message.contractNumber = 0n;
        message.version = "";
        message.type = "";
        message.proposalId = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetWasmContractByAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWasmContractByAddressResponse): GetWasmContractByAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string tx_hash */ 3:
                    message.txHash = reader.string();
                    break;
                case /* string creator */ 4:
                    message.creator = reader.string();
                    break;
                case /* uint64 executes */ 5:
                    message.executes = reader.uint64().toBigInt();
                    break;
                case /* uint64 instantiated_at */ 6:
                    message.instantiatedAt = reader.uint64().toBigInt();
                    break;
                case /* string init_message */ 7:
                    message.initMessage = reader.string();
                    break;
                case /* uint64 last_executed_at */ 8:
                    message.lastExecutedAt = reader.uint64().toBigInt();
                    break;
                case /* repeated injective_explorer_rpc.ContractFund funds */ 9:
                    message.funds.push(ContractFund.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 code_id */ 10:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* string admin */ 11:
                    message.admin = reader.string();
                    break;
                case /* string current_migrate_message */ 12:
                    message.currentMigrateMessage = reader.string();
                    break;
                case /* sint64 contract_number */ 13:
                    message.contractNumber = reader.sint64().toBigInt();
                    break;
                case /* string version */ 14:
                    message.version = reader.string();
                    break;
                case /* string type */ 15:
                    message.type = reader.string();
                    break;
                case /* injective_explorer_rpc.Cw20Metadata cw20_metadata */ 16:
                    message.cw20Metadata = Cw20Metadata.internalBinaryRead(reader, reader.uint32(), options, message.cw20Metadata);
                    break;
                case /* sint64 proposal_id */ 17:
                    message.proposalId = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWasmContractByAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string tx_hash = 3; */
        if (message.txHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.txHash);
        /* string creator = 4; */
        if (message.creator !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.creator);
        /* uint64 executes = 5; */
        if (message.executes !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.executes);
        /* uint64 instantiated_at = 6; */
        if (message.instantiatedAt !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.instantiatedAt);
        /* string init_message = 7; */
        if (message.initMessage !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.initMessage);
        /* uint64 last_executed_at = 8; */
        if (message.lastExecutedAt !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.lastExecutedAt);
        /* repeated injective_explorer_rpc.ContractFund funds = 9; */
        for (let i = 0; i < message.funds.length; i++)
            ContractFund.internalBinaryWrite(message.funds[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint64 code_id = 10; */
        if (message.codeId !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.codeId);
        /* string admin = 11; */
        if (message.admin !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.admin);
        /* string current_migrate_message = 12; */
        if (message.currentMigrateMessage !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.currentMigrateMessage);
        /* sint64 contract_number = 13; */
        if (message.contractNumber !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.contractNumber);
        /* string version = 14; */
        if (message.version !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.version);
        /* string type = 15; */
        if (message.type !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.type);
        /* injective_explorer_rpc.Cw20Metadata cw20_metadata = 16; */
        if (message.cw20Metadata)
            Cw20Metadata.internalBinaryWrite(message.cw20Metadata, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* sint64 proposal_id = 17; */
        if (message.proposalId !== 0n)
            writer.tag(17, WireType.Varint).sint64(message.proposalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetWasmContractByAddressResponse
 */
export const GetWasmContractByAddressResponse = new GetWasmContractByAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCw20BalanceRequest$Type extends MessageType<GetCw20BalanceRequest> {
    constructor() {
        super("injective_explorer_rpc.GetCw20BalanceRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetCw20BalanceRequest>): GetCw20BalanceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<GetCw20BalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCw20BalanceRequest): GetCw20BalanceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* sint32 limit */ 2:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCw20BalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* sint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetCw20BalanceRequest
 */
export const GetCw20BalanceRequest = new GetCw20BalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCw20BalanceResponse$Type extends MessageType<GetCw20BalanceResponse> {
    constructor() {
        super("injective_explorer_rpc.GetCw20BalanceResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WasmCw20Balance }
        ]);
    }
    create(value?: PartialMessage<GetCw20BalanceResponse>): GetCw20BalanceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<GetCw20BalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCw20BalanceResponse): GetCw20BalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_explorer_rpc.WasmCw20Balance field */ 1:
                    message.field.push(WasmCw20Balance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCw20BalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_explorer_rpc.WasmCw20Balance field = 1; */
        for (let i = 0; i < message.field.length; i++)
            WasmCw20Balance.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetCw20BalanceResponse
 */
export const GetCw20BalanceResponse = new GetCw20BalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WasmCw20Balance$Type extends MessageType<WasmCw20Balance> {
    constructor() {
        super("injective_explorer_rpc.WasmCw20Balance", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "cw20_metadata", kind: "message", T: () => Cw20Metadata }
        ]);
    }
    create(value?: PartialMessage<WasmCw20Balance>): WasmCw20Balance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        message.account = "";
        message.balance = "";
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<WasmCw20Balance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WasmCw20Balance): WasmCw20Balance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* string account */ 2:
                    message.account = reader.string();
                    break;
                case /* string balance */ 3:
                    message.balance = reader.string();
                    break;
                case /* sint64 updated_at */ 4:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* injective_explorer_rpc.Cw20Metadata cw20_metadata */ 5:
                    message.cw20Metadata = Cw20Metadata.internalBinaryRead(reader, reader.uint32(), options, message.cw20Metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WasmCw20Balance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* string account = 2; */
        if (message.account !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        /* string balance = 3; */
        if (message.balance !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.balance);
        /* sint64 updated_at = 4; */
        if (message.updatedAt !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.updatedAt);
        /* injective_explorer_rpc.Cw20Metadata cw20_metadata = 5; */
        if (message.cw20Metadata)
            Cw20Metadata.internalBinaryWrite(message.cw20Metadata, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.WasmCw20Balance
 */
export const WasmCw20Balance = new WasmCw20Balance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelayersRequest$Type extends MessageType<RelayersRequest> {
    constructor() {
        super("injective_explorer_rpc.RelayersRequest", [
            { no: 1, name: "market_i_ds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RelayersRequest>): RelayersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIDs = [];
        if (value !== undefined)
            reflectionMergePartial<RelayersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelayersRequest): RelayersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_i_ds */ 1:
                    message.marketIDs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelayersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_i_ds = 1; */
        for (let i = 0; i < message.marketIDs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.RelayersRequest
 */
export const RelayersRequest = new RelayersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelayersResponse$Type extends MessageType<RelayersResponse> {
    constructor() {
        super("injective_explorer_rpc.RelayersResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RelayerMarkets }
        ]);
    }
    create(value?: PartialMessage<RelayersResponse>): RelayersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<RelayersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelayersResponse): RelayersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_explorer_rpc.RelayerMarkets field */ 1:
                    message.field.push(RelayerMarkets.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelayersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_explorer_rpc.RelayerMarkets field = 1; */
        for (let i = 0; i < message.field.length; i++)
            RelayerMarkets.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.RelayersResponse
 */
export const RelayersResponse = new RelayersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelayerMarkets$Type extends MessageType<RelayerMarkets> {
    constructor() {
        super("injective_explorer_rpc.RelayerMarkets", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relayers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Relayer }
        ]);
    }
    create(value?: PartialMessage<RelayerMarkets>): RelayerMarkets {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.relayers = [];
        if (value !== undefined)
            reflectionMergePartial<RelayerMarkets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelayerMarkets): RelayerMarkets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* repeated injective_explorer_rpc.Relayer relayers */ 2:
                    message.relayers.push(Relayer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelayerMarkets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* repeated injective_explorer_rpc.Relayer relayers = 2; */
        for (let i = 0; i < message.relayers.length; i++)
            Relayer.internalBinaryWrite(message.relayers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.RelayerMarkets
 */
export const RelayerMarkets = new RelayerMarkets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Relayer$Type extends MessageType<Relayer> {
    constructor() {
        super("injective_explorer_rpc.Relayer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cta", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Relayer>): Relayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.cta = "";
        if (value !== undefined)
            reflectionMergePartial<Relayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Relayer): Relayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string cta */ 2:
                    message.cta = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Relayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string cta = 2; */
        if (message.cta !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Relayer
 */
export const Relayer = new Relayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBankTransfersRequest$Type extends MessageType<GetBankTransfersRequest> {
    constructor() {
        super("injective_explorer_rpc.GetBankTransfersRequest", [
            { no: 1, name: "senders", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "recipients", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_community_pool_related", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "address", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 10, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetBankTransfersRequest>): GetBankTransfersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senders = [];
        message.recipients = [];
        message.isCommunityPoolRelated = false;
        message.limit = 0;
        message.skip = 0n;
        message.startTime = 0n;
        message.endTime = 0n;
        message.address = [];
        message.perPage = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetBankTransfersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBankTransfersRequest): GetBankTransfersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string senders */ 1:
                    message.senders.push(reader.string());
                    break;
                case /* repeated string recipients */ 2:
                    message.recipients.push(reader.string());
                    break;
                case /* bool is_community_pool_related */ 3:
                    message.isCommunityPoolRelated = reader.bool();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint64 start_time */ 6:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 7:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string address */ 8:
                    message.address.push(reader.string());
                    break;
                case /* sint32 per_page */ 9:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 10:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBankTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string senders = 1; */
        for (let i = 0; i < message.senders.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.senders[i]);
        /* repeated string recipients = 2; */
        for (let i = 0; i < message.recipients.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.recipients[i]);
        /* bool is_community_pool_related = 3; */
        if (message.isCommunityPoolRelated !== false)
            writer.tag(3, WireType.Varint).bool(message.isCommunityPoolRelated);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint64 start_time = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 7; */
        if (message.endTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.endTime);
        /* repeated string address = 8; */
        for (let i = 0; i < message.address.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.address[i]);
        /* sint32 per_page = 9; */
        if (message.perPage !== 0)
            writer.tag(9, WireType.Varint).sint32(message.perPage);
        /* string token = 10; */
        if (message.token !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBankTransfersRequest
 */
export const GetBankTransfersRequest = new GetBankTransfersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBankTransfersResponse$Type extends MessageType<GetBankTransfersResponse> {
    constructor() {
        super("injective_explorer_rpc.GetBankTransfersResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BankTransfer }
        ]);
    }
    create(value?: PartialMessage<GetBankTransfersResponse>): GetBankTransfersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetBankTransfersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBankTransfersResponse): GetBankTransfersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_explorer_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_explorer_rpc.BankTransfer data */ 2:
                    message.data.push(BankTransfer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBankTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_explorer_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_explorer_rpc.BankTransfer data = 2; */
        for (let i = 0; i < message.data.length; i++)
            BankTransfer.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBankTransfersResponse
 */
export const GetBankTransfersResponse = new GetBankTransfersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BankTransfer$Type extends MessageType<BankTransfer> {
    constructor() {
        super("injective_explorer_rpc.BankTransfer", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 4, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "block_timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BankTransfer>): BankTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.recipient = "";
        message.amounts = [];
        message.blockNumber = 0n;
        message.blockTimestamp = "";
        if (value !== undefined)
            reflectionMergePartial<BankTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BankTransfer): BankTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string recipient */ 2:
                    message.recipient = reader.string();
                    break;
                case /* repeated injective_explorer_rpc.Coin amounts */ 3:
                    message.amounts.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 block_number */ 4:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                case /* string block_timestamp */ 5:
                    message.blockTimestamp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BankTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string recipient = 2; */
        if (message.recipient !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.recipient);
        /* repeated injective_explorer_rpc.Coin amounts = 3; */
        for (let i = 0; i < message.amounts.length; i++)
            Coin.internalBinaryWrite(message.amounts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 block_number = 4; */
        if (message.blockNumber !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.blockNumber);
        /* string block_timestamp = 5; */
        if (message.blockTimestamp !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.blockTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.BankTransfer
 */
export const BankTransfer = new BankTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Coin$Type extends MessageType<Coin> {
    constructor() {
        super("injective_explorer_rpc.Coin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Coin>): Coin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        message.usdValue = "";
        if (value !== undefined)
            reflectionMergePartial<Coin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coin): Coin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* string usd_value */ 3:
                    message.usdValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* string usd_value = 3; */
        if (message.usdValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Coin
 */
export const Coin = new Coin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTxsRequest$Type extends MessageType<StreamTxsRequest> {
    constructor() {
        super("injective_explorer_rpc.StreamTxsRequest", []);
    }
    create(value?: PartialMessage<StreamTxsRequest>): StreamTxsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamTxsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTxsRequest): StreamTxsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTxsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.StreamTxsRequest
 */
export const StreamTxsRequest = new StreamTxsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTxsResponse$Type extends MessageType<StreamTxsResponse> {
    constructor() {
        super("injective_explorer_rpc.StreamTxsResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "block_timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "messages", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "tx_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "error_log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "claim_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTxsResponse>): StreamTxsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.blockNumber = 0n;
        message.blockTimestamp = "";
        message.hash = "";
        message.codespace = "";
        message.messages = "";
        message.txNumber = 0n;
        message.errorLog = "";
        message.code = 0;
        message.claimIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamTxsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTxsResponse): StreamTxsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint64 block_number */ 2:
                    message.blockNumber = reader.uint64().toBigInt();
                    break;
                case /* string block_timestamp */ 3:
                    message.blockTimestamp = reader.string();
                    break;
                case /* string hash */ 4:
                    message.hash = reader.string();
                    break;
                case /* string codespace */ 5:
                    message.codespace = reader.string();
                    break;
                case /* string messages */ 6:
                    message.messages = reader.string();
                    break;
                case /* uint64 tx_number */ 7:
                    message.txNumber = reader.uint64().toBigInt();
                    break;
                case /* string error_log */ 8:
                    message.errorLog = reader.string();
                    break;
                case /* uint32 code */ 9:
                    message.code = reader.uint32();
                    break;
                case /* repeated sint64 claim_ids */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.claimIds.push(reader.sint64().toBigInt());
                    else
                        message.claimIds.push(reader.sint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTxsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint64 block_number = 2; */
        if (message.blockNumber !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockNumber);
        /* string block_timestamp = 3; */
        if (message.blockTimestamp !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
        /* string hash = 4; */
        if (message.hash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hash);
        /* string codespace = 5; */
        if (message.codespace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.codespace);
        /* string messages = 6; */
        if (message.messages !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.messages);
        /* uint64 tx_number = 7; */
        if (message.txNumber !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.txNumber);
        /* string error_log = 8; */
        if (message.errorLog !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.errorLog);
        /* uint32 code = 9; */
        if (message.code !== 0)
            writer.tag(9, WireType.Varint).uint32(message.code);
        /* repeated sint64 claim_ids = 10; */
        if (message.claimIds.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.claimIds.length; i++)
                writer.sint64(message.claimIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.StreamTxsResponse
 */
export const StreamTxsResponse = new StreamTxsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamBlocksRequest$Type extends MessageType<StreamBlocksRequest> {
    constructor() {
        super("injective_explorer_rpc.StreamBlocksRequest", []);
    }
    create(value?: PartialMessage<StreamBlocksRequest>): StreamBlocksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamBlocksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamBlocksRequest): StreamBlocksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamBlocksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.StreamBlocksRequest
 */
export const StreamBlocksRequest = new StreamBlocksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamBlocksResponse$Type extends MessageType<StreamBlocksResponse> {
    constructor() {
        super("injective_explorer_rpc.StreamBlocksResponse", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "proposer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "moniker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "block_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parent_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "num_pre_commits", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "num_txs", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "txs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TxDataRPC },
            { no: 9, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "block_unix_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamBlocksResponse>): StreamBlocksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.proposer = "";
        message.moniker = "";
        message.blockHash = "";
        message.parentHash = "";
        message.numPreCommits = 0n;
        message.numTxs = 0n;
        message.txs = [];
        message.timestamp = "";
        message.blockUnixTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamBlocksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamBlocksResponse): StreamBlocksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* string proposer */ 2:
                    message.proposer = reader.string();
                    break;
                case /* string moniker */ 3:
                    message.moniker = reader.string();
                    break;
                case /* string block_hash */ 4:
                    message.blockHash = reader.string();
                    break;
                case /* string parent_hash */ 5:
                    message.parentHash = reader.string();
                    break;
                case /* sint64 num_pre_commits */ 6:
                    message.numPreCommits = reader.sint64().toBigInt();
                    break;
                case /* sint64 num_txs */ 7:
                    message.numTxs = reader.sint64().toBigInt();
                    break;
                case /* repeated injective_explorer_rpc.TxDataRPC txs */ 8:
                    message.txs.push(TxDataRPC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string timestamp */ 9:
                    message.timestamp = reader.string();
                    break;
                case /* uint64 block_unix_timestamp */ 10:
                    message.blockUnixTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamBlocksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* string proposer = 2; */
        if (message.proposer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.proposer);
        /* string moniker = 3; */
        if (message.moniker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.moniker);
        /* string block_hash = 4; */
        if (message.blockHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.blockHash);
        /* string parent_hash = 5; */
        if (message.parentHash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.parentHash);
        /* sint64 num_pre_commits = 6; */
        if (message.numPreCommits !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.numPreCommits);
        /* sint64 num_txs = 7; */
        if (message.numTxs !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.numTxs);
        /* repeated injective_explorer_rpc.TxDataRPC txs = 8; */
        for (let i = 0; i < message.txs.length; i++)
            TxDataRPC.internalBinaryWrite(message.txs[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string timestamp = 9; */
        if (message.timestamp !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.timestamp);
        /* uint64 block_unix_timestamp = 10; */
        if (message.blockUnixTimestamp !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.blockUnixTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.StreamBlocksResponse
 */
export const StreamBlocksResponse = new StreamBlocksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatsRequest$Type extends MessageType<GetStatsRequest> {
    constructor() {
        super("injective_explorer_rpc.GetStatsRequest", []);
    }
    create(value?: PartialMessage<GetStatsRequest>): GetStatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatsRequest): GetStatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetStatsRequest
 */
export const GetStatsRequest = new GetStatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatsResponse$Type extends MessageType<GetStatsResponse> {
    constructor() {
        super("injective_explorer_rpc.GetStatsResponse", [
            { no: 1, name: "addresses", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "assets", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "inj_supply", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "txs_ps24_h", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "txs_ps100_b", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "txs_total", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "txs24_h", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "txs30_d", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "block_count24_h", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatsResponse>): GetStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = 0n;
        message.assets = 0n;
        message.injSupply = 0n;
        message.txsPs24H = 0n;
        message.txsPs100B = 0n;
        message.txsTotal = 0n;
        message.txs24H = 0n;
        message.txs30D = 0n;
        message.blockCount24H = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatsResponse): GetStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 addresses */ 1:
                    message.addresses = reader.uint64().toBigInt();
                    break;
                case /* uint64 assets */ 2:
                    message.assets = reader.uint64().toBigInt();
                    break;
                case /* uint64 inj_supply */ 3:
                    message.injSupply = reader.uint64().toBigInt();
                    break;
                case /* uint64 txs_ps24_h */ 4:
                    message.txsPs24H = reader.uint64().toBigInt();
                    break;
                case /* uint64 txs_ps100_b */ 5:
                    message.txsPs100B = reader.uint64().toBigInt();
                    break;
                case /* uint64 txs_total */ 6:
                    message.txsTotal = reader.uint64().toBigInt();
                    break;
                case /* uint64 txs24_h */ 7:
                    message.txs24H = reader.uint64().toBigInt();
                    break;
                case /* uint64 txs30_d */ 8:
                    message.txs30D = reader.uint64().toBigInt();
                    break;
                case /* uint64 block_count24_h */ 9:
                    message.blockCount24H = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 addresses = 1; */
        if (message.addresses !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.addresses);
        /* uint64 assets = 2; */
        if (message.assets !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.assets);
        /* uint64 inj_supply = 3; */
        if (message.injSupply !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.injSupply);
        /* uint64 txs_ps24_h = 4; */
        if (message.txsPs24H !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.txsPs24H);
        /* uint64 txs_ps100_b = 5; */
        if (message.txsPs100B !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.txsPs100B);
        /* uint64 txs_total = 6; */
        if (message.txsTotal !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.txsTotal);
        /* uint64 txs24_h = 7; */
        if (message.txs24H !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.txs24H);
        /* uint64 txs30_d = 8; */
        if (message.txs30D !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.txs30D);
        /* uint64 block_count24_h = 9; */
        if (message.blockCount24H !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.blockCount24H);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetStatsResponse
 */
export const GetStatsResponse = new GetStatsResponse$Type();
/**
 * @generated ServiceType for protobuf service injective_explorer_rpc.InjectiveExplorerRPC
 */
export const InjectiveExplorerRPC = new ServiceType("injective_explorer_rpc.InjectiveExplorerRPC", [
    { name: "GetAccountTxs", options: {}, I: GetAccountTxsRequest, O: GetAccountTxsResponse },
    { name: "GetAccountTxsV2", options: {}, I: GetAccountTxsV2Request, O: GetAccountTxsV2Response },
    { name: "GetContractTxs", options: {}, I: GetContractTxsRequest, O: GetContractTxsResponse },
    { name: "GetContractTxsV2", options: {}, I: GetContractTxsV2Request, O: GetContractTxsV2Response },
    { name: "GetBlocks", options: {}, I: GetBlocksRequest, O: GetBlocksResponse },
    { name: "GetBlocksV2", options: {}, I: GetBlocksV2Request, O: GetBlocksV2Response },
    { name: "GetBlock", options: {}, I: GetBlockRequest, O: GetBlockResponse },
    { name: "GetValidators", options: {}, I: GetValidatorsRequest, O: GetValidatorsResponse },
    { name: "GetValidator", options: {}, I: GetValidatorRequest, O: GetValidatorResponse },
    { name: "GetValidatorUptime", options: {}, I: GetValidatorUptimeRequest, O: GetValidatorUptimeResponse },
    { name: "GetTxs", options: {}, I: GetTxsRequest, O: GetTxsResponse },
    { name: "GetTxsV2", options: {}, I: GetTxsV2Request, O: GetTxsV2Response },
    { name: "GetTxByTxHash", options: {}, I: GetTxByTxHashRequest, O: GetTxByTxHashResponse },
    { name: "GetPeggyDepositTxs", options: {}, I: GetPeggyDepositTxsRequest, O: GetPeggyDepositTxsResponse },
    { name: "GetPeggyWithdrawalTxs", options: {}, I: GetPeggyWithdrawalTxsRequest, O: GetPeggyWithdrawalTxsResponse },
    { name: "GetIBCTransferTxs", options: {}, I: GetIBCTransferTxsRequest, O: GetIBCTransferTxsResponse },
    { name: "GetWasmCodes", options: {}, I: GetWasmCodesRequest, O: GetWasmCodesResponse },
    { name: "GetWasmCodeByID", options: {}, I: GetWasmCodeByIDRequest, O: GetWasmCodeByIDResponse },
    { name: "GetWasmContracts", options: {}, I: GetWasmContractsRequest, O: GetWasmContractsResponse },
    { name: "GetWasmContractByAddress", options: {}, I: GetWasmContractByAddressRequest, O: GetWasmContractByAddressResponse },
    { name: "GetCw20Balance", options: {}, I: GetCw20BalanceRequest, O: GetCw20BalanceResponse },
    { name: "Relayers", options: {}, I: RelayersRequest, O: RelayersResponse },
    { name: "GetBankTransfers", options: {}, I: GetBankTransfersRequest, O: GetBankTransfersResponse },
    { name: "StreamTxs", serverStreaming: true, options: {}, I: StreamTxsRequest, O: StreamTxsResponse },
    { name: "StreamBlocks", serverStreaming: true, options: {}, I: StreamBlocksRequest, O: StreamBlocksResponse },
    { name: "GetStats", options: {}, I: GetStatsRequest, O: GetStatsResponse }
]);
