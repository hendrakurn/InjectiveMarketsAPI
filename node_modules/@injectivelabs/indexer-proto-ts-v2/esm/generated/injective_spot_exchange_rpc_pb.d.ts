// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_spot_exchange_rpc.proto" (package "injective_spot_exchange_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveSpotExchangeRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_spot_exchange_rpc.MarketsRequest
 */
export interface MarketsRequest {
    /**
     * Filter by market status
     *
     * @generated from protobuf field: string market_status = 1
     */
    marketStatus: string;
    /**
     * Filter by the Coin denomination of the base currency
     *
     * @generated from protobuf field: string base_denom = 2
     */
    baseDenom: string;
    /**
     * Filter by the Coin denomination of the quote currency
     *
     * @generated from protobuf field: string quote_denom = 3
     */
    quoteDenom: string;
    /**
     * @generated from protobuf field: repeated string market_statuses = 4
     */
    marketStatuses: string[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.MarketsResponse
 */
export interface MarketsResponse {
    /**
     * Spot Markets list
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotMarketInfo markets = 1
     */
    markets: SpotMarketInfo[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotMarketInfo
 */
export interface SpotMarketInfo {
    /**
     * SpotMarket ID is keccak265(baseDenom || quoteDenom)
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * The status of the market
     *
     * @generated from protobuf field: string market_status = 2
     */
    marketStatus: string;
    /**
     * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
     * asset.
     *
     * @generated from protobuf field: string ticker = 3
     */
    ticker: string;
    /**
     * Coin denom used for the base asset.
     *
     * @generated from protobuf field: string base_denom = 4
     */
    baseDenom: string;
    /**
     * Token metadata for base asset
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.TokenMeta base_token_meta = 5
     */
    baseTokenMeta?: TokenMeta;
    /**
     * Coin denom used for the quote asset.
     *
     * @generated from protobuf field: string quote_denom = 6
     */
    quoteDenom: string;
    /**
     * Token metadata for quote asset
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7
     */
    quoteTokenMeta?: TokenMeta;
    /**
     * Defines the fee percentage makers pay when trading (in quote asset)
     *
     * @generated from protobuf field: string maker_fee_rate = 8
     */
    makerFeeRate: string;
    /**
     * Defines the fee percentage takers pay when trading (in quote asset)
     *
     * @generated from protobuf field: string taker_fee_rate = 9
     */
    takerFeeRate: string;
    /**
     * Percentage of the transaction fee shared with the service provider
     *
     * @generated from protobuf field: string service_provider_fee = 10
     */
    serviceProviderFee: string;
    /**
     * Defines the minimum required tick size for the order's price
     *
     * @generated from protobuf field: string min_price_tick_size = 11
     */
    minPriceTickSize: string;
    /**
     * Defines the minimum required tick size for the order's quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 12
     */
    minQuantityTickSize: string;
    /**
     * Minimum notional value for the market
     *
     * @generated from protobuf field: string min_notional = 13
     */
    minNotional: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.TokenMeta
 */
export interface TokenMeta {
    /**
     * Token full name
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * Token contract address (native or not)
     *
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * Token symbol short name
     *
     * @generated from protobuf field: string symbol = 3
     */
    symbol: string;
    /**
     * URL to the logo image
     *
     * @generated from protobuf field: string logo = 4
     */
    logo: string;
    /**
     * Token decimals
     *
     * @generated from protobuf field: sint32 decimals = 5
     */
    decimals: number;
    /**
     * Token metadata fetched timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 6
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.MarketRequest
 */
export interface MarketRequest {
    /**
     * MarketId of the market we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.MarketResponse
 */
export interface MarketResponse {
    /**
     * Info about particular spot market
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotMarketInfo market = 1
     */
    market?: SpotMarketInfo;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamMarketsRequest
 */
export interface StreamMarketsRequest {
    /**
     * List of market IDs for updates streaming, empty means 'ALL' spot markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamMarketsResponse
 */
export interface StreamMarketsResponse {
    /**
     * Info about particular spot market
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotMarketInfo market = 1
     */
    market?: SpotMarketInfo;
    /**
     * Update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbookV2Request
 */
export interface OrderbookV2Request {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Depth of the orderbook
     *
     * @generated from protobuf field: sint32 depth = 2
     */
    depth: number;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbookV2Response
 */
export interface OrderbookV2Response {
    /**
     * Orderbook of a particular spot market
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1
     */
    orderbook?: SpotLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotLimitOrderbookV2
 */
export interface SpotLimitOrderbookV2 {
    /**
     * Array of price levels for buys
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevel buys = 1
     */
    buys: PriceLevel[];
    /**
     * Array of price levels for sells
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevel sells = 2
     */
    sells: PriceLevel[];
    /**
     * market orderbook sequence
     *
     * @generated from protobuf field: uint64 sequence = 3
     */
    sequence: bigint;
    /**
     * Last update timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
    /**
     * Block height at which the orderbook was last updated.
     *
     * @generated from protobuf field: sint64 height = 5
     */
    height: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.PriceLevel
 */
export interface PriceLevel {
    /**
     * Price number of the price level.
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * Quantity of the price level.
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * Price level last updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbooksV2Request
 */
export interface OrderbooksV2Request {
    /**
     * MarketIds of the markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
    /**
     * Depth of the orderbook
     *
     * @generated from protobuf field: sint32 depth = 2
     */
    depth: number;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbooksV2Response
 */
export interface OrderbooksV2Response {
    /**
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1
     */
    orderbooks: SingleSpotLimitOrderbookV2[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2
 */
export interface SingleSpotLimitOrderbookV2 {
    /**
     * market's ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Orderbook of the market
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2
     */
    orderbook?: SpotLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrderbookV2Request
 */
export interface StreamOrderbookV2Request {
    /**
     * List of market IDs for orderbook streaming, empty means 'ALL' spot markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrderbookV2Response
 */
export interface StreamOrderbookV2Response {
    /**
     * Orderbook of a Spot Market
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1
     */
    orderbook?: SpotLimitOrderbookV2;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
    /**
     * MarketId of the market's orderbook
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrderbookUpdateRequest
 */
export interface StreamOrderbookUpdateRequest {
    /**
     * List of market IDs for orderbook streaming, empty means 'ALL' spot markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrderbookUpdateResponse
 */
export interface StreamOrderbookUpdateResponse {
    /**
     * Orderbook level updates of a Spot Market
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1
     */
    orderbookLevelUpdates?: OrderbookLevelUpdates;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
    /**
     * MarketId of the market's orderbook
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbookLevelUpdates
 */
export interface OrderbookLevelUpdates {
    /**
     * market's ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * orderbook update sequence
     *
     * @generated from protobuf field: uint64 sequence = 2
     */
    sequence: bigint;
    /**
     * buy levels
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevelUpdate buys = 3
     */
    buys: PriceLevelUpdate[];
    /**
     * sell levels
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevelUpdate sells = 4
     */
    sells: PriceLevelUpdate[];
    /**
     * updates timestamp
     *
     * @generated from protobuf field: sint64 updated_at = 5
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.PriceLevelUpdate
 */
export interface PriceLevelUpdate {
    /**
     * Price number of the price level.
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * Quantity of the price level.
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * Price level status.
     *
     * @generated from protobuf field: bool is_active = 3
     */
    isActive: boolean;
    /**
     * Price level last updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrdersRequest
 */
export interface OrdersRequest {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Look for specific order side
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Look for specific subaccountId of an order
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 5
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 6
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 7
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 8
     */
    marketIds: string[];
    /**
     * Should include inactive orders
     *
     * @generated from protobuf field: bool include_inactive = 9
     */
    includeInactive: boolean;
    /**
     * Choose to return subaccount total orders
     *
     * @generated from protobuf field: bool subaccount_total_orders = 10
     */
    subaccountTotalOrders: boolean;
    /**
     * TradeId of the order we want to fetch
     *
     * @generated from protobuf field: string trade_id = 11
     */
    tradeId: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 12
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrdersResponse
 */
export interface OrdersResponse {
    /**
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotLimitOrder orders = 1
     */
    orders: SpotLimitOrder[];
    /**
     * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotLimitOrder
 */
export interface SpotLimitOrder {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Spot Market ID is keccak265(baseDenom + quoteDenom)
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 5
     */
    price: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 6
     */
    quantity: string;
    /**
     * The amount of the quantity remaining unfilled
     *
     * @generated from protobuf field: string unfilled_quantity = 7
     */
    unfilledQuantity: string;
    /**
     * Trigger price is the trigger price used by stop/take orders. 0 if the
     * trigger price is not set.
     *
     * @generated from protobuf field: string trigger_price = 8
     */
    triggerPrice: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 9
     */
    feeRecipient: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 10
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 11
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 12
     */
    updatedAt: bigint;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 13
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_spot_exchange_rpc.Paging
 */
export interface Paging {
    /**
     * total number of txs saved in database
     *
     * @generated from protobuf field: sint64 total = 1
     */
    total: bigint;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 from = 2
     */
    from: number;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 to = 3
     */
    to: number;
    /**
     * count entries by subaccount, serving some places on helix
     *
     * @generated from protobuf field: sint64 count_by_subaccount = 4
     */
    countBySubaccount: bigint;
    /**
     * array of tokens to navigate to the next pages
     *
     * @generated from protobuf field: repeated string next = 5
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrdersRequest
 */
export interface StreamOrdersRequest {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Look for specific order side
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Look for specific subaccountId of an order
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 5
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 6
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 7
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 8
     */
    marketIds: string[];
    /**
     * Should include inactive orders
     *
     * @generated from protobuf field: bool include_inactive = 9
     */
    includeInactive: boolean;
    /**
     * Choose to return subaccount total orders
     *
     * @generated from protobuf field: bool subaccount_total_orders = 10
     */
    subaccountTotalOrders: boolean;
    /**
     * TradeId of the order we want to fetch
     *
     * @generated from protobuf field: string trade_id = 11
     */
    tradeId: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 12
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrdersResponse
 */
export interface StreamOrdersResponse {
    /**
     * Updated market order
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrder order = 1
     */
    order?: SpotLimitOrder;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.TradesRequest
 */
export interface TradesRequest {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the item result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.TradesResponse
 */
export interface TradesResponse {
    /**
     * Trades of a Spot Market
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotTrade trades = 1
     */
    trades: SpotTrade[];
    /**
     * Paging indicates pages response is on
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotTrade
 */
export interface SpotTrade {
    /**
     * Maker order hash.
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The subaccountId that executed the trade
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * The ID of the market that this trade is in
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The execution type of the trade
     *
     * @generated from protobuf field: string trade_execution_type = 4
     */
    tradeExecutionType: string;
    /**
     * The direction the trade
     *
     * @generated from protobuf field: string trade_direction = 5
     */
    tradeDirection: string;
    /**
     * Price level at which trade has been executed
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.PriceLevel price = 6
     */
    price?: PriceLevel;
    /**
     * The fee associated with the trade (quote asset denom)
     *
     * @generated from protobuf field: string fee = 7
     */
    fee: string;
    /**
     * Timestamp of trade execution in UNIX millis
     *
     * @generated from protobuf field: sint64 executed_at = 8
     */
    executedAt: bigint;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 9
     */
    feeRecipient: string;
    /**
     * A unique string that helps differentiate between trades
     *
     * @generated from protobuf field: string trade_id = 10
     */
    tradeId: string;
    /**
     * Trade's execution side, marker/taker
     *
     * @generated from protobuf field: string execution_side = 11
     */
    executionSide: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 12
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamTradesRequest
 */
export interface StreamTradesRequest {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the item result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamTradesResponse
 */
export interface StreamTradesResponse {
    /**
     * New spot market trade
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotTrade trade = 1
     */
    trade?: SpotTrade;
    /**
     * Executed trades update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.TradesV2Request
 */
export interface TradesV2Request {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the item result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.TradesV2Response
 */
export interface TradesV2Response {
    /**
     * Trades of a Spot Market
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotTrade trades = 1
     */
    trades: SpotTrade[];
    /**
     * Paging indicates pages response is on
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamTradesV2Request
 */
export interface StreamTradesV2Request {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the item result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamTradesV2Response
 */
export interface StreamTradesV2Response {
    /**
     * New spot market trade
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotTrade trade = 1
     */
    trade?: SpotTrade;
    /**
     * Executed trades update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SubaccountOrdersListRequest
 */
export interface SubaccountOrdersListRequest {
    /**
     * subaccount ID to filter orders for specific subaccount
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Market ID to filter orders for specific market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SubaccountOrdersListResponse
 */
export interface SubaccountOrdersListResponse {
    /**
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotLimitOrder orders = 1
     */
    orders: SpotLimitOrder[];
    /**
     * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SubaccountTradesListRequest
 */
export interface SubaccountTradesListRequest {
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Filter trades by market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Filter by execution type of trades
     *
     * @generated from protobuf field: string execution_type = 3
     */
    executionType: string;
    /**
     * Filter by direction trades
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SubaccountTradesListResponse
 */
export interface SubaccountTradesListResponse {
    /**
     * List of spot market trades
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotTrade trades = 1
     */
    trades: SpotTrade[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrdersHistoryRequest
 */
export interface OrdersHistoryRequest {
    /**
     * subaccount ID to filter orders for specific subaccount
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Market ID to filter orders for specific market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * filter by order types
     *
     * @generated from protobuf field: repeated string order_types = 5
     */
    orderTypes: string[];
    /**
     * order side filter
     *
     * @generated from protobuf field: string direction = 6
     */
    direction: string;
    /**
     * Search for orders which createdAt >= startTime, time in millisecond
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * Search for orders which createdAt <= endTime, time in millisecond
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * Filter by order state
     *
     * @generated from protobuf field: string state = 9
     */
    state: string;
    /**
     * @generated from protobuf field: repeated string execution_types = 10
     */
    executionTypes: string[];
    /**
     * @generated from protobuf field: repeated string market_ids = 11
     */
    marketIds: string[];
    /**
     * TradeId of the order we want to fetch
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Return only orders for active markets
     *
     * @generated from protobuf field: bool active_markets_only = 13
     */
    activeMarketsOnly: boolean;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrdersHistoryResponse
 */
export interface OrdersHistoryResponse {
    /**
     * List of history spot orders
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotOrderHistory orders = 1
     */
    orders: SpotOrderHistory[];
    /**
     * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotOrderHistory
 */
export interface SpotOrderHistory {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * Spot Market ID is keccak265(baseDenom + quoteDenom)
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * active state of the order
     *
     * @generated from protobuf field: bool is_active = 3
     */
    isActive: boolean;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * The execution type
     *
     * @generated from protobuf field: string execution_type = 5
     */
    executionType: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_type = 6
     */
    orderType: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 7
     */
    price: string;
    /**
     * Trigger price
     *
     * @generated from protobuf field: string trigger_price = 8
     */
    triggerPrice: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 9
     */
    quantity: string;
    /**
     * Filled amount
     *
     * @generated from protobuf field: string filled_quantity = 10
     */
    filledQuantity: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 11
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 12
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 13
     */
    updatedAt: bigint;
    /**
     * Order direction (order side)
     *
     * @generated from protobuf field: string direction = 14
     */
    direction: string;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 15
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 16
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrdersHistoryRequest
 */
export interface StreamOrdersHistoryRequest {
    /**
     * subaccount ID to filter orders for specific subaccount
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Market ID to filter orders for specific market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * filter by order types
     *
     * @generated from protobuf field: repeated string order_types = 3
     */
    orderTypes: string[];
    /**
     * order side filter
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Filter by order state
     *
     * @generated from protobuf field: string state = 5
     */
    state: string;
    /**
     * @generated from protobuf field: repeated string execution_types = 6
     */
    executionTypes: string[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrdersHistoryResponse
 */
export interface StreamOrdersHistoryResponse {
    /**
     * Updated order
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.SpotOrderHistory order = 1
     */
    order?: SpotOrderHistory;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.AtomicSwapHistoryRequest
 */
export interface AtomicSwapHistoryRequest {
    /**
     * sender of the atomic swap
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * atomic swap contract address to filter
     *
     * @generated from protobuf field: string contract_address = 2
     */
    contractAddress: string;
    /**
     * skip some swaps
     *
     * @generated from protobuf field: sint32 skip = 3
     */
    skip: number;
    /**
     * limit number of swaps returned by this API
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * lowerbound of atomic swap index
     *
     * @generated from protobuf field: sint32 from_number = 5
     */
    fromNumber: number;
    /**
     * upperbound of atomic swap index
     *
     * @generated from protobuf field: sint32 to_number = 6
     */
    toNumber: number;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.AtomicSwapHistoryResponse
 */
export interface AtomicSwapHistoryResponse {
    /**
     * Paging indicates total number of records with this filter
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 1
     */
    paging?: Paging;
    /**
     * swap data
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.AtomicSwap data = 2
     */
    data: AtomicSwap[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.AtomicSwap
 */
export interface AtomicSwap {
    /**
     * executor of the swap
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * swap route
     *
     * @generated from protobuf field: string route = 2
     */
    route: string;
    /**
     * source coin
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.Coin source_coin = 3
     */
    sourceCoin?: Coin;
    /**
     * destination received coin
     *
     * @generated from protobuf field: injective_spot_exchange_rpc.Coin dest_coin = 4
     */
    destCoin?: Coin;
    /**
     * fees of each steps in route
     *
     * @generated from protobuf field: repeated injective_spot_exchange_rpc.Coin fees = 5
     */
    fees: Coin[];
    /**
     * contract address that executes to make this swap
     *
     * @generated from protobuf field: string contract_address = 6
     */
    contractAddress: string;
    /**
     * Numerical index by sender to use in pagination from_number and to_number
     *
     * @generated from protobuf field: sint32 index_by_sender = 7
     */
    indexBySender: number;
    /**
     * Numerical index by sender + acontract to use in pagination from_number and
     * to_number, that support contract filter
     *
     * @generated from protobuf field: sint32 index_by_sender_contract = 8
     */
    indexBySenderContract: number;
    /**
     * transaction hash of the swap
     *
     * @generated from protobuf field: string tx_hash = 9
     */
    txHash: string;
    /**
     * transaction timestamp of the swap
     *
     * @generated from protobuf field: sint64 executed_at = 10
     */
    executedAt: bigint;
    /**
     * Refunded amount of the swap
     *
     * @generated from protobuf field: string refund_amount = 11
     */
    refundAmount: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.Coin
 */
export interface Coin {
    /**
     * Denom of the coin
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * @generated from protobuf field: string usd_value = 3
     */
    usdValue: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class MarketsRequest$Type extends MessageType<MarketsRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.MarketsRequest", [
            { no: 1, name: "market_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "base_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "market_statuses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketsRequest>): MarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketStatus = "";
        message.baseDenom = "";
        message.quoteDenom = "";
        message.marketStatuses = [];
        if (value !== undefined)
            reflectionMergePartial<MarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketsRequest): MarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_status */ 1:
                    message.marketStatus = reader.string();
                    break;
                case /* string base_denom */ 2:
                    message.baseDenom = reader.string();
                    break;
                case /* string quote_denom */ 3:
                    message.quoteDenom = reader.string();
                    break;
                case /* repeated string market_statuses */ 4:
                    message.marketStatuses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_status = 1; */
        if (message.marketStatus !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketStatus);
        /* string base_denom = 2; */
        if (message.baseDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.baseDenom);
        /* string quote_denom = 3; */
        if (message.quoteDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
        /* repeated string market_statuses = 4; */
        for (let i = 0; i < message.marketStatuses.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.marketStatuses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.MarketsRequest
 */
export const MarketsRequest = new MarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketsResponse$Type extends MessageType<MarketsResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.MarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotMarketInfo }
        ]);
    }
    create(value?: PartialMessage<MarketsResponse>): MarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<MarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketsResponse): MarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SpotMarketInfo markets */ 1:
                    message.markets.push(SpotMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SpotMarketInfo markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            SpotMarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.MarketsResponse
 */
export const MarketsResponse = new MarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketInfo$Type extends MessageType<SpotMarketInfo> {
    constructor() {
        super("injective_spot_exchange_rpc.SpotMarketInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "base_token_meta", kind: "message", T: () => TokenMeta },
            { no: 6, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "quote_token_meta", kind: "message", T: () => TokenMeta },
            { no: 8, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "service_provider_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotMarketInfo>): SpotMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.marketStatus = "";
        message.ticker = "";
        message.baseDenom = "";
        message.quoteDenom = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.serviceProviderFee = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<SpotMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketInfo): SpotMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string market_status */ 2:
                    message.marketStatus = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string base_denom */ 4:
                    message.baseDenom = reader.string();
                    break;
                case /* injective_spot_exchange_rpc.TokenMeta base_token_meta */ 5:
                    message.baseTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.baseTokenMeta);
                    break;
                case /* string quote_denom */ 6:
                    message.quoteDenom = reader.string();
                    break;
                case /* injective_spot_exchange_rpc.TokenMeta quote_token_meta */ 7:
                    message.quoteTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.quoteTokenMeta);
                    break;
                case /* string maker_fee_rate */ 8:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 9:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string service_provider_fee */ 10:
                    message.serviceProviderFee = reader.string();
                    break;
                case /* string min_price_tick_size */ 11:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 12:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 13:
                    message.minNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string market_status = 2; */
        if (message.marketStatus !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketStatus);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string base_denom = 4; */
        if (message.baseDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.baseDenom);
        /* injective_spot_exchange_rpc.TokenMeta base_token_meta = 5; */
        if (message.baseTokenMeta)
            TokenMeta.internalBinaryWrite(message.baseTokenMeta, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string quote_denom = 6; */
        if (message.quoteDenom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
        /* injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7; */
        if (message.quoteTokenMeta)
            TokenMeta.internalBinaryWrite(message.quoteTokenMeta, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string maker_fee_rate = 8; */
        if (message.makerFeeRate !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 9; */
        if (message.takerFeeRate !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string service_provider_fee = 10; */
        if (message.serviceProviderFee !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.serviceProviderFee);
        /* string min_price_tick_size = 11; */
        if (message.minPriceTickSize !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 12; */
        if (message.minQuantityTickSize !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 13; */
        if (message.minNotional !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotMarketInfo
 */
export const SpotMarketInfo = new SpotMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenMeta$Type extends MessageType<TokenMeta> {
    constructor() {
        super("injective_spot_exchange_rpc.TokenMeta", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "logo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "decimals", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TokenMeta>): TokenMeta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.address = "";
        message.symbol = "";
        message.logo = "";
        message.decimals = 0;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<TokenMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenMeta): TokenMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string symbol */ 3:
                    message.symbol = reader.string();
                    break;
                case /* string logo */ 4:
                    message.logo = reader.string();
                    break;
                case /* sint32 decimals */ 5:
                    message.decimals = reader.sint32();
                    break;
                case /* sint64 updated_at */ 6:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string symbol = 3; */
        if (message.symbol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.symbol);
        /* string logo = 4; */
        if (message.logo !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.logo);
        /* sint32 decimals = 5; */
        if (message.decimals !== 0)
            writer.tag(5, WireType.Varint).sint32(message.decimals);
        /* sint64 updated_at = 6; */
        if (message.updatedAt !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.TokenMeta
 */
export const TokenMeta = new TokenMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketRequest$Type extends MessageType<MarketRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.MarketRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketRequest>): MarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketRequest): MarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.MarketRequest
 */
export const MarketRequest = new MarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketResponse$Type extends MessageType<MarketResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.MarketResponse", [
            { no: 1, name: "market", kind: "message", T: () => SpotMarketInfo }
        ]);
    }
    create(value?: PartialMessage<MarketResponse>): MarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketResponse): MarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotMarketInfo market */ 1:
                    message.market = SpotMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotMarketInfo market = 1; */
        if (message.market)
            SpotMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.MarketResponse
 */
export const MarketResponse = new MarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamMarketsRequest$Type extends MessageType<StreamMarketsRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamMarketsRequest", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamMarketsRequest>): StreamMarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamMarketsRequest): StreamMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamMarketsRequest
 */
export const StreamMarketsRequest = new StreamMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamMarketsResponse$Type extends MessageType<StreamMarketsResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamMarketsResponse", [
            { no: 1, name: "market", kind: "message", T: () => SpotMarketInfo },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamMarketsResponse>): StreamMarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamMarketsResponse): StreamMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotMarketInfo market */ 1:
                    message.market = SpotMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotMarketInfo market = 1; */
        if (message.market)
            SpotMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamMarketsResponse
 */
export const StreamMarketsResponse = new StreamMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookV2Request$Type extends MessageType<OrderbookV2Request> {
    constructor() {
        super("injective_spot_exchange_rpc.OrderbookV2Request", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbookV2Request>): OrderbookV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.depth = 0;
        if (value !== undefined)
            reflectionMergePartial<OrderbookV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookV2Request): OrderbookV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* sint32 depth */ 2:
                    message.depth = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* sint32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).sint32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbookV2Request
 */
export const OrderbookV2Request = new OrderbookV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookV2Response$Type extends MessageType<OrderbookV2Response> {
    constructor() {
        super("injective_spot_exchange_rpc.OrderbookV2Response", [
            { no: 1, name: "orderbook", kind: "message", T: () => SpotLimitOrderbookV2 }
        ]);
    }
    create(value?: PartialMessage<OrderbookV2Response>): OrderbookV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OrderbookV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookV2Response): OrderbookV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook */ 1:
                    message.orderbook = SpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1; */
        if (message.orderbook)
            SpotLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbookV2Response
 */
export const OrderbookV2Response = new OrderbookV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotLimitOrderbookV2$Type extends MessageType<SpotLimitOrderbookV2> {
    constructor() {
        super("injective_spot_exchange_rpc.SpotLimitOrderbookV2", [
            { no: 1, name: "buys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevel },
            { no: 2, name: "sells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevel },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SpotLimitOrderbookV2>): SpotLimitOrderbookV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buys = [];
        message.sells = [];
        message.sequence = 0n;
        message.timestamp = 0n;
        message.height = 0n;
        if (value !== undefined)
            reflectionMergePartial<SpotLimitOrderbookV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotLimitOrderbookV2): SpotLimitOrderbookV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.PriceLevel buys */ 1:
                    message.buys.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_spot_exchange_rpc.PriceLevel sells */ 2:
                    message.sells.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 height */ 5:
                    message.height = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotLimitOrderbookV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.PriceLevel buys = 1; */
        for (let i = 0; i < message.buys.length; i++)
            PriceLevel.internalBinaryWrite(message.buys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_spot_exchange_rpc.PriceLevel sells = 2; */
        for (let i = 0; i < message.sells.length; i++)
            PriceLevel.internalBinaryWrite(message.sells[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 sequence = 3; */
        if (message.sequence !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        /* sint64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotLimitOrderbookV2
 */
export const SpotLimitOrderbookV2 = new SpotLimitOrderbookV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevel$Type extends MessageType<PriceLevel> {
    constructor() {
        super("injective_spot_exchange_rpc.PriceLevel", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceLevel>): PriceLevel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevel): PriceLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.PriceLevel
 */
export const PriceLevel = new PriceLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbooksV2Request$Type extends MessageType<OrderbooksV2Request> {
    constructor() {
        super("injective_spot_exchange_rpc.OrderbooksV2Request", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbooksV2Request>): OrderbooksV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        message.depth = 0;
        if (value !== undefined)
            reflectionMergePartial<OrderbooksV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbooksV2Request): OrderbooksV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                case /* sint32 depth */ 2:
                    message.depth = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbooksV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        /* sint32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).sint32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbooksV2Request
 */
export const OrderbooksV2Request = new OrderbooksV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbooksV2Response$Type extends MessageType<OrderbooksV2Response> {
    constructor() {
        super("injective_spot_exchange_rpc.OrderbooksV2Response", [
            { no: 1, name: "orderbooks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SingleSpotLimitOrderbookV2 }
        ]);
    }
    create(value?: PartialMessage<OrderbooksV2Response>): OrderbooksV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderbooks = [];
        if (value !== undefined)
            reflectionMergePartial<OrderbooksV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbooksV2Response): OrderbooksV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks */ 1:
                    message.orderbooks.push(SingleSpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbooksV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1; */
        for (let i = 0; i < message.orderbooks.length; i++)
            SingleSpotLimitOrderbookV2.internalBinaryWrite(message.orderbooks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbooksV2Response
 */
export const OrderbooksV2Response = new OrderbooksV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SingleSpotLimitOrderbookV2$Type extends MessageType<SingleSpotLimitOrderbookV2> {
    constructor() {
        super("injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orderbook", kind: "message", T: () => SpotLimitOrderbookV2 }
        ]);
    }
    create(value?: PartialMessage<SingleSpotLimitOrderbookV2>): SingleSpotLimitOrderbookV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<SingleSpotLimitOrderbookV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SingleSpotLimitOrderbookV2): SingleSpotLimitOrderbookV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook */ 2:
                    message.orderbook = SpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SingleSpotLimitOrderbookV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2; */
        if (message.orderbook)
            SpotLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2
 */
export const SingleSpotLimitOrderbookV2 = new SingleSpotLimitOrderbookV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookV2Request$Type extends MessageType<StreamOrderbookV2Request> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrderbookV2Request", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookV2Request>): StreamOrderbookV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookV2Request): StreamOrderbookV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrderbookV2Request
 */
export const StreamOrderbookV2Request = new StreamOrderbookV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookV2Response$Type extends MessageType<StreamOrderbookV2Response> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrderbookV2Response", [
            { no: 1, name: "orderbook", kind: "message", T: () => SpotLimitOrderbookV2 },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookV2Response>): StreamOrderbookV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookV2Response): StreamOrderbookV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook */ 1:
                    message.orderbook = SpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1; */
        if (message.orderbook)
            SpotLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrderbookV2Response
 */
export const StreamOrderbookV2Response = new StreamOrderbookV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookUpdateRequest$Type extends MessageType<StreamOrderbookUpdateRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrderbookUpdateRequest", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookUpdateRequest>): StreamOrderbookUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookUpdateRequest): StreamOrderbookUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrderbookUpdateRequest
 */
export const StreamOrderbookUpdateRequest = new StreamOrderbookUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookUpdateResponse$Type extends MessageType<StreamOrderbookUpdateResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrderbookUpdateResponse", [
            { no: 1, name: "orderbook_level_updates", kind: "message", T: () => OrderbookLevelUpdates },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookUpdateResponse>): StreamOrderbookUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookUpdateResponse): StreamOrderbookUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates */ 1:
                    message.orderbookLevelUpdates = OrderbookLevelUpdates.internalBinaryRead(reader, reader.uint32(), options, message.orderbookLevelUpdates);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1; */
        if (message.orderbookLevelUpdates)
            OrderbookLevelUpdates.internalBinaryWrite(message.orderbookLevelUpdates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrderbookUpdateResponse
 */
export const StreamOrderbookUpdateResponse = new StreamOrderbookUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookLevelUpdates$Type extends MessageType<OrderbookLevelUpdates> {
    constructor() {
        super("injective_spot_exchange_rpc.OrderbookLevelUpdates", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "buys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevelUpdate },
            { no: 4, name: "sells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevelUpdate },
            { no: 5, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbookLevelUpdates>): OrderbookLevelUpdates {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.sequence = 0n;
        message.buys = [];
        message.sells = [];
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<OrderbookLevelUpdates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookLevelUpdates): OrderbookLevelUpdates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* uint64 sequence */ 2:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* repeated injective_spot_exchange_rpc.PriceLevelUpdate buys */ 3:
                    message.buys.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_spot_exchange_rpc.PriceLevelUpdate sells */ 4:
                    message.sells.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 updated_at */ 5:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookLevelUpdates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* uint64 sequence = 2; */
        if (message.sequence !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.sequence);
        /* repeated injective_spot_exchange_rpc.PriceLevelUpdate buys = 3; */
        for (let i = 0; i < message.buys.length; i++)
            PriceLevelUpdate.internalBinaryWrite(message.buys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_spot_exchange_rpc.PriceLevelUpdate sells = 4; */
        for (let i = 0; i < message.sells.length; i++)
            PriceLevelUpdate.internalBinaryWrite(message.sells[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sint64 updated_at = 5; */
        if (message.updatedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbookLevelUpdates
 */
export const OrderbookLevelUpdates = new OrderbookLevelUpdates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevelUpdate$Type extends MessageType<PriceLevelUpdate> {
    constructor() {
        super("injective_spot_exchange_rpc.PriceLevelUpdate", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceLevelUpdate>): PriceLevelUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.isActive = false;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceLevelUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevelUpdate): PriceLevelUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.PriceLevelUpdate
 */
export const PriceLevelUpdate = new PriceLevelUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersRequest$Type extends MessageType<OrdersRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.OrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "include_inactive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "subaccount_total_orders", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrdersRequest>): OrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.orderSide = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.includeInactive = false;
        message.subaccountTotalOrders = false;
        message.tradeId = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<OrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersRequest): OrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 5:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 6:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 7:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 8:
                    message.marketIds.push(reader.string());
                    break;
                case /* bool include_inactive */ 9:
                    message.includeInactive = reader.bool();
                    break;
                case /* bool subaccount_total_orders */ 10:
                    message.subaccountTotalOrders = reader.bool();
                    break;
                case /* string trade_id */ 11:
                    message.tradeId = reader.string();
                    break;
                case /* string cid */ 12:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 5; */
        if (message.limit !== 0)
            writer.tag(5, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 7; */
        if (message.endTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 8; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
        /* bool include_inactive = 9; */
        if (message.includeInactive !== false)
            writer.tag(9, WireType.Varint).bool(message.includeInactive);
        /* bool subaccount_total_orders = 10; */
        if (message.subaccountTotalOrders !== false)
            writer.tag(10, WireType.Varint).bool(message.subaccountTotalOrders);
        /* string trade_id = 11; */
        if (message.tradeId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
        /* string cid = 12; */
        if (message.cid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrdersRequest
 */
export const OrdersRequest = new OrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersResponse$Type extends MessageType<OrdersResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.OrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotLimitOrder },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<OrdersResponse>): OrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<OrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersResponse): OrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SpotLimitOrder orders */ 1:
                    message.orders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_spot_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SpotLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            SpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_spot_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrdersResponse
 */
export const OrdersResponse = new OrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotLimitOrder$Type extends MessageType<SpotLimitOrder> {
    constructor() {
        super("injective_spot_exchange_rpc.SpotLimitOrder", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "unfilled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotLimitOrder>): SpotLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.orderSide = "";
        message.marketId = "";
        message.subaccountId = "";
        message.price = "";
        message.quantity = "";
        message.unfilledQuantity = "";
        message.triggerPrice = "";
        message.feeRecipient = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SpotLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotLimitOrder): SpotLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* string price */ 5:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 6:
                    message.quantity = reader.string();
                    break;
                case /* string unfilled_quantity */ 7:
                    message.unfilledQuantity = reader.string();
                    break;
                case /* string trigger_price */ 8:
                    message.triggerPrice = reader.string();
                    break;
                case /* string fee_recipient */ 9:
                    message.feeRecipient = reader.string();
                    break;
                case /* string state */ 10:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 11:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 12:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string tx_hash */ 13:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* string price = 5; */
        if (message.price !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.price);
        /* string quantity = 6; */
        if (message.quantity !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.quantity);
        /* string unfilled_quantity = 7; */
        if (message.unfilledQuantity !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.unfilledQuantity);
        /* string trigger_price = 8; */
        if (message.triggerPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
        /* string fee_recipient = 9; */
        if (message.feeRecipient !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
        /* string state = 10; */
        if (message.state !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 11; */
        if (message.createdAt !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 12; */
        if (message.updatedAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.updatedAt);
        /* string tx_hash = 13; */
        if (message.txHash !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotLimitOrder
 */
export const SpotLimitOrder = new SpotLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Paging$Type extends MessageType<Paging> {
    constructor() {
        super("injective_spot_exchange_rpc.Paging", [
            { no: 1, name: "total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "from", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "to", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "count_by_subaccount", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Paging>): Paging {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0n;
        message.from = 0;
        message.to = 0;
        message.countBySubaccount = 0n;
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<Paging>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Paging): Paging {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 total */ 1:
                    message.total = reader.sint64().toBigInt();
                    break;
                case /* sint32 from */ 2:
                    message.from = reader.sint32();
                    break;
                case /* sint32 to */ 3:
                    message.to = reader.sint32();
                    break;
                case /* sint64 count_by_subaccount */ 4:
                    message.countBySubaccount = reader.sint64().toBigInt();
                    break;
                case /* repeated string next */ 5:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Paging, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 total = 1; */
        if (message.total !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.total);
        /* sint32 from = 2; */
        if (message.from !== 0)
            writer.tag(2, WireType.Varint).sint32(message.from);
        /* sint32 to = 3; */
        if (message.to !== 0)
            writer.tag(3, WireType.Varint).sint32(message.to);
        /* sint64 count_by_subaccount = 4; */
        if (message.countBySubaccount !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
        /* repeated string next = 5; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.Paging
 */
export const Paging = new Paging$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersRequest$Type extends MessageType<StreamOrdersRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "include_inactive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "subaccount_total_orders", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersRequest>): StreamOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.orderSide = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.includeInactive = false;
        message.subaccountTotalOrders = false;
        message.tradeId = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersRequest): StreamOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 5:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 6:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 7:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 8:
                    message.marketIds.push(reader.string());
                    break;
                case /* bool include_inactive */ 9:
                    message.includeInactive = reader.bool();
                    break;
                case /* bool subaccount_total_orders */ 10:
                    message.subaccountTotalOrders = reader.bool();
                    break;
                case /* string trade_id */ 11:
                    message.tradeId = reader.string();
                    break;
                case /* string cid */ 12:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 5; */
        if (message.limit !== 0)
            writer.tag(5, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 7; */
        if (message.endTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 8; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
        /* bool include_inactive = 9; */
        if (message.includeInactive !== false)
            writer.tag(9, WireType.Varint).bool(message.includeInactive);
        /* bool subaccount_total_orders = 10; */
        if (message.subaccountTotalOrders !== false)
            writer.tag(10, WireType.Varint).bool(message.subaccountTotalOrders);
        /* string trade_id = 11; */
        if (message.tradeId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
        /* string cid = 12; */
        if (message.cid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrdersRequest
 */
export const StreamOrdersRequest = new StreamOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersResponse$Type extends MessageType<StreamOrdersResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrdersResponse", [
            { no: 1, name: "order", kind: "message", T: () => SpotLimitOrder },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersResponse>): StreamOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersResponse): StreamOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotLimitOrder order */ 1:
                    message.order = SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotLimitOrder order = 1; */
        if (message.order)
            SpotLimitOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrdersResponse
 */
export const StreamOrdersResponse = new StreamOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesRequest$Type extends MessageType<TradesRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.TradesRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradesRequest>): TradesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<TradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesRequest): TradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.TradesRequest
 */
export const TradesRequest = new TradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesResponse$Type extends MessageType<TradesResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.TradesResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotTrade },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<TradesResponse>): TradesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<TradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesResponse): TradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SpotTrade trades */ 1:
                    message.trades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_spot_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SpotTrade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            SpotTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_spot_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.TradesResponse
 */
export const TradesResponse = new TradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotTrade$Type extends MessageType<SpotTrade> {
    constructor() {
        super("injective_spot_exchange_rpc.SpotTrade", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "trade_execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "trade_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "price", kind: "message", T: () => PriceLevel },
            { no: 7, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotTrade>): SpotTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.subaccountId = "";
        message.marketId = "";
        message.tradeExecutionType = "";
        message.tradeDirection = "";
        message.fee = "";
        message.executedAt = 0n;
        message.feeRecipient = "";
        message.tradeId = "";
        message.executionSide = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SpotTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotTrade): SpotTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string trade_execution_type */ 4:
                    message.tradeExecutionType = reader.string();
                    break;
                case /* string trade_direction */ 5:
                    message.tradeDirection = reader.string();
                    break;
                case /* injective_spot_exchange_rpc.PriceLevel price */ 6:
                    message.price = PriceLevel.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* string fee */ 7:
                    message.fee = reader.string();
                    break;
                case /* sint64 executed_at */ 8:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* string fee_recipient */ 9:
                    message.feeRecipient = reader.string();
                    break;
                case /* string trade_id */ 10:
                    message.tradeId = reader.string();
                    break;
                case /* string execution_side */ 11:
                    message.executionSide = reader.string();
                    break;
                case /* string cid */ 12:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string trade_execution_type = 4; */
        if (message.tradeExecutionType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
        /* string trade_direction = 5; */
        if (message.tradeDirection !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tradeDirection);
        /* injective_spot_exchange_rpc.PriceLevel price = 6; */
        if (message.price)
            PriceLevel.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string fee = 7; */
        if (message.fee !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.fee);
        /* sint64 executed_at = 8; */
        if (message.executedAt !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.executedAt);
        /* string fee_recipient = 9; */
        if (message.feeRecipient !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
        /* string trade_id = 10; */
        if (message.tradeId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.tradeId);
        /* string execution_side = 11; */
        if (message.executionSide !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.executionSide);
        /* string cid = 12; */
        if (message.cid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotTrade
 */
export const SpotTrade = new SpotTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesRequest$Type extends MessageType<StreamTradesRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamTradesRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesRequest>): StreamTradesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<StreamTradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesRequest): StreamTradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamTradesRequest
 */
export const StreamTradesRequest = new StreamTradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesResponse$Type extends MessageType<StreamTradesResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamTradesResponse", [
            { no: 1, name: "trade", kind: "message", T: () => SpotTrade },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesResponse>): StreamTradesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamTradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesResponse): StreamTradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotTrade trade */ 1:
                    message.trade = SpotTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotTrade trade = 1; */
        if (message.trade)
            SpotTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamTradesResponse
 */
export const StreamTradesResponse = new StreamTradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesV2Request$Type extends MessageType<TradesV2Request> {
    constructor() {
        super("injective_spot_exchange_rpc.TradesV2Request", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradesV2Request>): TradesV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<TradesV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesV2Request): TradesV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.TradesV2Request
 */
export const TradesV2Request = new TradesV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesV2Response$Type extends MessageType<TradesV2Response> {
    constructor() {
        super("injective_spot_exchange_rpc.TradesV2Response", [
            { no: 1, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotTrade },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<TradesV2Response>): TradesV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<TradesV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesV2Response): TradesV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SpotTrade trades */ 1:
                    message.trades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_spot_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SpotTrade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            SpotTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_spot_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.TradesV2Response
 */
export const TradesV2Response = new TradesV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesV2Request$Type extends MessageType<StreamTradesV2Request> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamTradesV2Request", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesV2Request>): StreamTradesV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<StreamTradesV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesV2Request): StreamTradesV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamTradesV2Request
 */
export const StreamTradesV2Request = new StreamTradesV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesV2Response$Type extends MessageType<StreamTradesV2Response> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamTradesV2Response", [
            { no: 1, name: "trade", kind: "message", T: () => SpotTrade },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesV2Response>): StreamTradesV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamTradesV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesV2Response): StreamTradesV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotTrade trade */ 1:
                    message.trade = SpotTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotTrade trade = 1; */
        if (message.trade)
            SpotTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamTradesV2Response
 */
export const StreamTradesV2Response = new StreamTradesV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrdersListRequest$Type extends MessageType<SubaccountOrdersListRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.SubaccountOrdersListRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrdersListRequest>): SubaccountOrdersListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrdersListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrdersListRequest): SubaccountOrdersListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrdersListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SubaccountOrdersListRequest
 */
export const SubaccountOrdersListRequest = new SubaccountOrdersListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrdersListResponse$Type extends MessageType<SubaccountOrdersListResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.SubaccountOrdersListResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotLimitOrder },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrdersListResponse>): SubaccountOrdersListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrdersListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrdersListResponse): SubaccountOrdersListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SpotLimitOrder orders */ 1:
                    message.orders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_spot_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrdersListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SpotLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            SpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_spot_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SubaccountOrdersListResponse
 */
export const SubaccountOrdersListResponse = new SubaccountOrdersListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountTradesListRequest$Type extends MessageType<SubaccountTradesListRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.SubaccountTradesListRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountTradesListRequest>): SubaccountTradesListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.executionType = "";
        message.direction = "";
        message.skip = 0n;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<SubaccountTradesListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountTradesListRequest): SubaccountTradesListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string execution_type */ 3:
                    message.executionType = reader.string();
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountTradesListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string execution_type = 3; */
        if (message.executionType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionType);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SubaccountTradesListRequest
 */
export const SubaccountTradesListRequest = new SubaccountTradesListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountTradesListResponse$Type extends MessageType<SubaccountTradesListResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.SubaccountTradesListResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotTrade }
        ]);
    }
    create(value?: PartialMessage<SubaccountTradesListResponse>): SubaccountTradesListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountTradesListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountTradesListResponse): SubaccountTradesListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SpotTrade trades */ 1:
                    message.trades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountTradesListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SpotTrade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            SpotTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SubaccountTradesListResponse
 */
export const SubaccountTradesListResponse = new SubaccountTradesListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersHistoryRequest$Type extends MessageType<OrdersHistoryRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.OrdersHistoryRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "order_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "active_markets_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrdersHistoryRequest>): OrdersHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        message.orderTypes = [];
        message.direction = "";
        message.startTime = 0n;
        message.endTime = 0n;
        message.state = "";
        message.executionTypes = [];
        message.marketIds = [];
        message.tradeId = "";
        message.activeMarketsOnly = false;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<OrdersHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersHistoryRequest): OrdersHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* repeated string order_types */ 5:
                    message.orderTypes.push(reader.string());
                    break;
                case /* string direction */ 6:
                    message.direction = reader.string();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* string state */ 9:
                    message.state = reader.string();
                    break;
                case /* repeated string execution_types */ 10:
                    message.executionTypes.push(reader.string());
                    break;
                case /* repeated string market_ids */ 11:
                    message.marketIds.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* bool active_markets_only */ 13:
                    message.activeMarketsOnly = reader.bool();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* repeated string order_types = 5; */
        for (let i = 0; i < message.orderTypes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.orderTypes[i]);
        /* string direction = 6; */
        if (message.direction !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.direction);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* string state = 9; */
        if (message.state !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.state);
        /* repeated string execution_types = 10; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* repeated string market_ids = 11; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.marketIds[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* bool active_markets_only = 13; */
        if (message.activeMarketsOnly !== false)
            writer.tag(13, WireType.Varint).bool(message.activeMarketsOnly);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrdersHistoryRequest
 */
export const OrdersHistoryRequest = new OrdersHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersHistoryResponse$Type extends MessageType<OrdersHistoryResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.OrdersHistoryResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrderHistory },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<OrdersHistoryResponse>): OrdersHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<OrdersHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersHistoryResponse): OrdersHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_spot_exchange_rpc.SpotOrderHistory orders */ 1:
                    message.orders.push(SpotOrderHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_spot_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_spot_exchange_rpc.SpotOrderHistory orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            SpotOrderHistory.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_spot_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrdersHistoryResponse
 */
export const OrdersHistoryResponse = new OrdersHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotOrderHistory$Type extends MessageType<SpotOrderHistory> {
    constructor() {
        super("injective_spot_exchange_rpc.SpotOrderHistory", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "filled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotOrderHistory>): SpotOrderHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.marketId = "";
        message.isActive = false;
        message.subaccountId = "";
        message.executionType = "";
        message.orderType = "";
        message.price = "";
        message.triggerPrice = "";
        message.quantity = "";
        message.filledQuantity = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.direction = "";
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SpotOrderHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotOrderHistory): SpotOrderHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* string execution_type */ 5:
                    message.executionType = reader.string();
                    break;
                case /* string order_type */ 6:
                    message.orderType = reader.string();
                    break;
                case /* string price */ 7:
                    message.price = reader.string();
                    break;
                case /* string trigger_price */ 8:
                    message.triggerPrice = reader.string();
                    break;
                case /* string quantity */ 9:
                    message.quantity = reader.string();
                    break;
                case /* string filled_quantity */ 10:
                    message.filledQuantity = reader.string();
                    break;
                case /* string state */ 11:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 12:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 13:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string direction */ 14:
                    message.direction = reader.string();
                    break;
                case /* string tx_hash */ 15:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 16:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotOrderHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* string execution_type = 5; */
        if (message.executionType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.executionType);
        /* string order_type = 6; */
        if (message.orderType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orderType);
        /* string price = 7; */
        if (message.price !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.price);
        /* string trigger_price = 8; */
        if (message.triggerPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
        /* string quantity = 9; */
        if (message.quantity !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.quantity);
        /* string filled_quantity = 10; */
        if (message.filledQuantity !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
        /* string state = 11; */
        if (message.state !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 12; */
        if (message.createdAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 13; */
        if (message.updatedAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.updatedAt);
        /* string direction = 14; */
        if (message.direction !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.direction);
        /* string tx_hash = 15; */
        if (message.txHash !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 16; */
        if (message.cid !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotOrderHistory
 */
export const SpotOrderHistory = new SpotOrderHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersHistoryRequest$Type extends MessageType<StreamOrdersHistoryRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrdersHistoryRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersHistoryRequest>): StreamOrdersHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.orderTypes = [];
        message.direction = "";
        message.state = "";
        message.executionTypes = [];
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersHistoryRequest): StreamOrdersHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* repeated string order_types */ 3:
                    message.orderTypes.push(reader.string());
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* string state */ 5:
                    message.state = reader.string();
                    break;
                case /* repeated string execution_types */ 6:
                    message.executionTypes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* repeated string order_types = 3; */
        for (let i = 0; i < message.orderTypes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.orderTypes[i]);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* string state = 5; */
        if (message.state !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.state);
        /* repeated string execution_types = 6; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.executionTypes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrdersHistoryRequest
 */
export const StreamOrdersHistoryRequest = new StreamOrdersHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersHistoryResponse$Type extends MessageType<StreamOrdersHistoryResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.StreamOrdersHistoryResponse", [
            { no: 1, name: "order", kind: "message", T: () => SpotOrderHistory },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersHistoryResponse>): StreamOrdersHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersHistoryResponse): StreamOrdersHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.SpotOrderHistory order */ 1:
                    message.order = SpotOrderHistory.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.SpotOrderHistory order = 1; */
        if (message.order)
            SpotOrderHistory.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrdersHistoryResponse
 */
export const StreamOrdersHistoryResponse = new StreamOrdersHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AtomicSwapHistoryRequest$Type extends MessageType<AtomicSwapHistoryRequest> {
    constructor() {
        super("injective_spot_exchange_rpc.AtomicSwapHistoryRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "from_number", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "to_number", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AtomicSwapHistoryRequest>): AtomicSwapHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.contractAddress = "";
        message.skip = 0;
        message.limit = 0;
        message.fromNumber = 0;
        message.toNumber = 0;
        if (value !== undefined)
            reflectionMergePartial<AtomicSwapHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AtomicSwapHistoryRequest): AtomicSwapHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string contract_address */ 2:
                    message.contractAddress = reader.string();
                    break;
                case /* sint32 skip */ 3:
                    message.skip = reader.sint32();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* sint32 from_number */ 5:
                    message.fromNumber = reader.sint32();
                    break;
                case /* sint32 to_number */ 6:
                    message.toNumber = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AtomicSwapHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string contract_address = 2; */
        if (message.contractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
        /* sint32 skip = 3; */
        if (message.skip !== 0)
            writer.tag(3, WireType.Varint).sint32(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* sint32 from_number = 5; */
        if (message.fromNumber !== 0)
            writer.tag(5, WireType.Varint).sint32(message.fromNumber);
        /* sint32 to_number = 6; */
        if (message.toNumber !== 0)
            writer.tag(6, WireType.Varint).sint32(message.toNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.AtomicSwapHistoryRequest
 */
export const AtomicSwapHistoryRequest = new AtomicSwapHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AtomicSwapHistoryResponse$Type extends MessageType<AtomicSwapHistoryResponse> {
    constructor() {
        super("injective_spot_exchange_rpc.AtomicSwapHistoryResponse", [
            { no: 1, name: "paging", kind: "message", T: () => Paging },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AtomicSwap }
        ]);
    }
    create(value?: PartialMessage<AtomicSwapHistoryResponse>): AtomicSwapHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<AtomicSwapHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AtomicSwapHistoryResponse): AtomicSwapHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_spot_exchange_rpc.Paging paging */ 1:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                case /* repeated injective_spot_exchange_rpc.AtomicSwap data */ 2:
                    message.data.push(AtomicSwap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AtomicSwapHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_spot_exchange_rpc.Paging paging = 1; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_spot_exchange_rpc.AtomicSwap data = 2; */
        for (let i = 0; i < message.data.length; i++)
            AtomicSwap.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.AtomicSwapHistoryResponse
 */
export const AtomicSwapHistoryResponse = new AtomicSwapHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AtomicSwap$Type extends MessageType<AtomicSwap> {
    constructor() {
        super("injective_spot_exchange_rpc.AtomicSwap", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "route", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_coin", kind: "message", T: () => Coin },
            { no: 4, name: "dest_coin", kind: "message", T: () => Coin },
            { no: 5, name: "fees", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 6, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "index_by_sender", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 8, name: "index_by_sender_contract", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 9, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "refund_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AtomicSwap>): AtomicSwap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.route = "";
        message.fees = [];
        message.contractAddress = "";
        message.indexBySender = 0;
        message.indexBySenderContract = 0;
        message.txHash = "";
        message.executedAt = 0n;
        message.refundAmount = "";
        if (value !== undefined)
            reflectionMergePartial<AtomicSwap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AtomicSwap): AtomicSwap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string route */ 2:
                    message.route = reader.string();
                    break;
                case /* injective_spot_exchange_rpc.Coin source_coin */ 3:
                    message.sourceCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.sourceCoin);
                    break;
                case /* injective_spot_exchange_rpc.Coin dest_coin */ 4:
                    message.destCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.destCoin);
                    break;
                case /* repeated injective_spot_exchange_rpc.Coin fees */ 5:
                    message.fees.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string contract_address */ 6:
                    message.contractAddress = reader.string();
                    break;
                case /* sint32 index_by_sender */ 7:
                    message.indexBySender = reader.sint32();
                    break;
                case /* sint32 index_by_sender_contract */ 8:
                    message.indexBySenderContract = reader.sint32();
                    break;
                case /* string tx_hash */ 9:
                    message.txHash = reader.string();
                    break;
                case /* sint64 executed_at */ 10:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* string refund_amount */ 11:
                    message.refundAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AtomicSwap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string route = 2; */
        if (message.route !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.route);
        /* injective_spot_exchange_rpc.Coin source_coin = 3; */
        if (message.sourceCoin)
            Coin.internalBinaryWrite(message.sourceCoin, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_spot_exchange_rpc.Coin dest_coin = 4; */
        if (message.destCoin)
            Coin.internalBinaryWrite(message.destCoin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_spot_exchange_rpc.Coin fees = 5; */
        for (let i = 0; i < message.fees.length; i++)
            Coin.internalBinaryWrite(message.fees[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string contract_address = 6; */
        if (message.contractAddress !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.contractAddress);
        /* sint32 index_by_sender = 7; */
        if (message.indexBySender !== 0)
            writer.tag(7, WireType.Varint).sint32(message.indexBySender);
        /* sint32 index_by_sender_contract = 8; */
        if (message.indexBySenderContract !== 0)
            writer.tag(8, WireType.Varint).sint32(message.indexBySenderContract);
        /* string tx_hash = 9; */
        if (message.txHash !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.txHash);
        /* sint64 executed_at = 10; */
        if (message.executedAt !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.executedAt);
        /* string refund_amount = 11; */
        if (message.refundAmount !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.refundAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.AtomicSwap
 */
export const AtomicSwap = new AtomicSwap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Coin$Type extends MessageType<Coin> {
    constructor() {
        super("injective_spot_exchange_rpc.Coin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Coin>): Coin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        message.usdValue = "";
        if (value !== undefined)
            reflectionMergePartial<Coin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coin): Coin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* string usd_value */ 3:
                    message.usdValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* string usd_value = 3; */
        if (message.usdValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.Coin
 */
export const Coin = new Coin$Type();
/**
 * @generated ServiceType for protobuf service injective_spot_exchange_rpc.InjectiveSpotExchangeRPC
 */
export const InjectiveSpotExchangeRPC = new ServiceType("injective_spot_exchange_rpc.InjectiveSpotExchangeRPC", [
    { name: "Markets", options: {}, I: MarketsRequest, O: MarketsResponse },
    { name: "Market", options: {}, I: MarketRequest, O: MarketResponse },
    { name: "StreamMarkets", serverStreaming: true, options: {}, I: StreamMarketsRequest, O: StreamMarketsResponse },
    { name: "OrderbookV2", options: {}, I: OrderbookV2Request, O: OrderbookV2Response },
    { name: "OrderbooksV2", options: {}, I: OrderbooksV2Request, O: OrderbooksV2Response },
    { name: "StreamOrderbookV2", serverStreaming: true, options: {}, I: StreamOrderbookV2Request, O: StreamOrderbookV2Response },
    { name: "StreamOrderbookUpdate", serverStreaming: true, options: {}, I: StreamOrderbookUpdateRequest, O: StreamOrderbookUpdateResponse },
    { name: "Orders", options: {}, I: OrdersRequest, O: OrdersResponse },
    { name: "StreamOrders", serverStreaming: true, options: {}, I: StreamOrdersRequest, O: StreamOrdersResponse },
    { name: "Trades", options: {}, I: TradesRequest, O: TradesResponse },
    { name: "StreamTrades", serverStreaming: true, options: {}, I: StreamTradesRequest, O: StreamTradesResponse },
    { name: "TradesV2", options: {}, I: TradesV2Request, O: TradesV2Response },
    { name: "StreamTradesV2", serverStreaming: true, options: {}, I: StreamTradesV2Request, O: StreamTradesV2Response },
    { name: "SubaccountOrdersList", options: {}, I: SubaccountOrdersListRequest, O: SubaccountOrdersListResponse },
    { name: "SubaccountTradesList", options: {}, I: SubaccountTradesListRequest, O: SubaccountTradesListResponse },
    { name: "OrdersHistory", options: {}, I: OrdersHistoryRequest, O: OrdersHistoryResponse },
    { name: "StreamOrdersHistory", serverStreaming: true, options: {}, I: StreamOrdersHistoryRequest, O: StreamOrdersHistoryResponse },
    { name: "AtomicSwapHistory", options: {}, I: AtomicSwapHistoryRequest, O: AtomicSwapHistoryResponse }
]);
