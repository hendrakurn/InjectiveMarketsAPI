import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class SpotMarketHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.SpotMarketHistoryRequest", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "from",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "to",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "countback",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = "";
    message.marketId = "";
    message.resolution = "";
    message.from = 0;
    message.to = 0;
    message.countback = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string symbol */
        1:
          message.symbol = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string resolution */
        3:
          message.resolution = reader.string();
          break;
        case /* sint32 from */
        4:
          message.from = reader.sint32();
          break;
        case /* sint32 to */
        5:
          message.to = reader.sint32();
          break;
        case /* sint32 countback */
        6:
          message.countback = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.symbol !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.symbol);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.resolution !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.resolution);
    if (message.from !== 0)
      writer.tag(4, WireType.Varint).sint32(message.from);
    if (message.to !== 0)
      writer.tag(5, WireType.Varint).sint32(message.to);
    if (message.countback !== 0)
      writer.tag(6, WireType.Varint).sint32(message.countback);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketHistoryRequest = new SpotMarketHistoryRequest$Type();
class SpotMarketHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.SpotMarketHistoryResponse", [
      {
        no: 1,
        name: "t",
        kind: "scalar",
        repeat: 1,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "o",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "h",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "l",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "c",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "v",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "s",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.t = [];
    message.o = [];
    message.h = [];
    message.l = [];
    message.c = [];
    message.v = [];
    message.s = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sint32 t */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.t.push(reader.sint32());
          else
            message.t.push(reader.sint32());
          break;
        case /* repeated double o */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.o.push(reader.double());
          else
            message.o.push(reader.double());
          break;
        case /* repeated double h */
        3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.h.push(reader.double());
          else
            message.h.push(reader.double());
          break;
        case /* repeated double l */
        4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.l.push(reader.double());
          else
            message.l.push(reader.double());
          break;
        case /* repeated double c */
        5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.c.push(reader.double());
          else
            message.c.push(reader.double());
          break;
        case /* repeated double v */
        6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.v.push(reader.double());
          else
            message.v.push(reader.double());
          break;
        case /* string s */
        7:
          message.s = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.t.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.t.length; i++)
        writer.sint32(message.t[i]);
      writer.join();
    }
    if (message.o.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.o.length; i++)
        writer.double(message.o[i]);
      writer.join();
    }
    if (message.h.length) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.h.length; i++)
        writer.double(message.h[i]);
      writer.join();
    }
    if (message.l.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.l.length; i++)
        writer.double(message.l[i]);
      writer.join();
    }
    if (message.c.length) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.c.length; i++)
        writer.double(message.c[i]);
      writer.join();
    }
    if (message.v.length) {
      writer.tag(6, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.v.length; i++)
        writer.double(message.v[i]);
      writer.join();
    }
    if (message.s !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.s);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketHistoryResponse = new SpotMarketHistoryResponse$Type();
class DerivativeMarketHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.DerivativeMarketHistoryRequest", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "from",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "to",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "countback",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = "";
    message.marketId = "";
    message.resolution = "";
    message.from = 0;
    message.to = 0;
    message.countback = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string symbol */
        1:
          message.symbol = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string resolution */
        3:
          message.resolution = reader.string();
          break;
        case /* sint32 from */
        4:
          message.from = reader.sint32();
          break;
        case /* sint32 to */
        5:
          message.to = reader.sint32();
          break;
        case /* sint32 countback */
        6:
          message.countback = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.symbol !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.symbol);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.resolution !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.resolution);
    if (message.from !== 0)
      writer.tag(4, WireType.Varint).sint32(message.from);
    if (message.to !== 0)
      writer.tag(5, WireType.Varint).sint32(message.to);
    if (message.countback !== 0)
      writer.tag(6, WireType.Varint).sint32(message.countback);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketHistoryRequest = new DerivativeMarketHistoryRequest$Type();
class DerivativeMarketHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.DerivativeMarketHistoryResponse", [
      {
        no: 1,
        name: "t",
        kind: "scalar",
        repeat: 1,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "o",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "h",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "l",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "c",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "v",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "s",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.t = [];
    message.o = [];
    message.h = [];
    message.l = [];
    message.c = [];
    message.v = [];
    message.s = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sint32 t */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.t.push(reader.sint32());
          else
            message.t.push(reader.sint32());
          break;
        case /* repeated double o */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.o.push(reader.double());
          else
            message.o.push(reader.double());
          break;
        case /* repeated double h */
        3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.h.push(reader.double());
          else
            message.h.push(reader.double());
          break;
        case /* repeated double l */
        4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.l.push(reader.double());
          else
            message.l.push(reader.double());
          break;
        case /* repeated double c */
        5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.c.push(reader.double());
          else
            message.c.push(reader.double());
          break;
        case /* repeated double v */
        6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.v.push(reader.double());
          else
            message.v.push(reader.double());
          break;
        case /* string s */
        7:
          message.s = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.t.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.t.length; i++)
        writer.sint32(message.t[i]);
      writer.join();
    }
    if (message.o.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.o.length; i++)
        writer.double(message.o[i]);
      writer.join();
    }
    if (message.h.length) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.h.length; i++)
        writer.double(message.h[i]);
      writer.join();
    }
    if (message.l.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.l.length; i++)
        writer.double(message.l[i]);
      writer.join();
    }
    if (message.c.length) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.c.length; i++)
        writer.double(message.c[i]);
      writer.join();
    }
    if (message.v.length) {
      writer.tag(6, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.v.length; i++)
        writer.double(message.v[i]);
      writer.join();
    }
    if (message.s !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.s);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketHistoryResponse = new DerivativeMarketHistoryResponse$Type();
class SpotMarketSummaryRequest$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.SpotMarketSummaryRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.resolution = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string resolution */
        2:
          message.resolution = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.resolution !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.resolution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketSummaryRequest = new SpotMarketSummaryRequest$Type();
class SpotMarketSummaryResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.SpotMarketSummaryResponse", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "open",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "high",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "low",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "price",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "change",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.open = 0;
    message.high = 0;
    message.low = 0;
    message.volume = 0;
    message.price = 0;
    message.change = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* double open */
        2:
          message.open = reader.double();
          break;
        case /* double high */
        3:
          message.high = reader.double();
          break;
        case /* double low */
        4:
          message.low = reader.double();
          break;
        case /* double volume */
        5:
          message.volume = reader.double();
          break;
        case /* double price */
        6:
          message.price = reader.double();
          break;
        case /* double change */
        7:
          message.change = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.open !== 0)
      writer.tag(2, WireType.Bit64).double(message.open);
    if (message.high !== 0)
      writer.tag(3, WireType.Bit64).double(message.high);
    if (message.low !== 0)
      writer.tag(4, WireType.Bit64).double(message.low);
    if (message.volume !== 0)
      writer.tag(5, WireType.Bit64).double(message.volume);
    if (message.price !== 0)
      writer.tag(6, WireType.Bit64).double(message.price);
    if (message.change !== 0)
      writer.tag(7, WireType.Bit64).double(message.change);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketSummaryResponse = new SpotMarketSummaryResponse$Type();
class AllSpotMarketSummaryRequest$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.AllSpotMarketSummaryRequest", [
      {
        no: 1,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.resolution = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string resolution */
        1:
          message.resolution = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.resolution !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.resolution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AllSpotMarketSummaryRequest = new AllSpotMarketSummaryRequest$Type();
class AllSpotMarketSummaryResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.AllSpotMarketSummaryResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => MarketSummaryResp }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_chart_rpc.MarketSummaryResp field */
        1:
          message.field.push(MarketSummaryResp.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      MarketSummaryResp.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AllSpotMarketSummaryResponse = new AllSpotMarketSummaryResponse$Type();
class MarketSummaryResp$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.MarketSummaryResp", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "open",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "high",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "low",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "price",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "change",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.open = 0;
    message.high = 0;
    message.low = 0;
    message.volume = 0;
    message.price = 0;
    message.change = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* double open */
        2:
          message.open = reader.double();
          break;
        case /* double high */
        3:
          message.high = reader.double();
          break;
        case /* double low */
        4:
          message.low = reader.double();
          break;
        case /* double volume */
        5:
          message.volume = reader.double();
          break;
        case /* double price */
        6:
          message.price = reader.double();
          break;
        case /* double change */
        7:
          message.change = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.open !== 0)
      writer.tag(2, WireType.Bit64).double(message.open);
    if (message.high !== 0)
      writer.tag(3, WireType.Bit64).double(message.high);
    if (message.low !== 0)
      writer.tag(4, WireType.Bit64).double(message.low);
    if (message.volume !== 0)
      writer.tag(5, WireType.Bit64).double(message.volume);
    if (message.price !== 0)
      writer.tag(6, WireType.Bit64).double(message.price);
    if (message.change !== 0)
      writer.tag(7, WireType.Bit64).double(message.change);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketSummaryResp = new MarketSummaryResp$Type();
class DerivativeMarketSummaryRequest$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.DerivativeMarketSummaryRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "index_price",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.indexPrice = false;
    message.resolution = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool index_price */
        2:
          message.indexPrice = reader.bool();
          break;
        case /* string resolution */
        3:
          message.resolution = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.indexPrice !== false)
      writer.tag(2, WireType.Varint).bool(message.indexPrice);
    if (message.resolution !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.resolution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketSummaryRequest = new DerivativeMarketSummaryRequest$Type();
class DerivativeMarketSummaryResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.DerivativeMarketSummaryResponse", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "open",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "high",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "low",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "price",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "change",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.open = 0;
    message.high = 0;
    message.low = 0;
    message.volume = 0;
    message.price = 0;
    message.change = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* double open */
        2:
          message.open = reader.double();
          break;
        case /* double high */
        3:
          message.high = reader.double();
          break;
        case /* double low */
        4:
          message.low = reader.double();
          break;
        case /* double volume */
        5:
          message.volume = reader.double();
          break;
        case /* double price */
        6:
          message.price = reader.double();
          break;
        case /* double change */
        7:
          message.change = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.open !== 0)
      writer.tag(2, WireType.Bit64).double(message.open);
    if (message.high !== 0)
      writer.tag(3, WireType.Bit64).double(message.high);
    if (message.low !== 0)
      writer.tag(4, WireType.Bit64).double(message.low);
    if (message.volume !== 0)
      writer.tag(5, WireType.Bit64).double(message.volume);
    if (message.price !== 0)
      writer.tag(6, WireType.Bit64).double(message.price);
    if (message.change !== 0)
      writer.tag(7, WireType.Bit64).double(message.change);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketSummaryResponse = new DerivativeMarketSummaryResponse$Type();
class AllDerivativeMarketSummaryRequest$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.AllDerivativeMarketSummaryRequest", [
      {
        no: 1,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.resolution = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string resolution */
        1:
          message.resolution = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.resolution !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.resolution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AllDerivativeMarketSummaryRequest = new AllDerivativeMarketSummaryRequest$Type();
class AllDerivativeMarketSummaryResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.AllDerivativeMarketSummaryResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => MarketSummaryResp }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_chart_rpc.MarketSummaryResp field */
        1:
          message.field.push(MarketSummaryResp.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      MarketSummaryResp.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AllDerivativeMarketSummaryResponse = new AllDerivativeMarketSummaryResponse$Type();
class MarketSnapshotRequest$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.MarketSnapshotRequest", [
      {
        no: 1,
        name: "market_i_ds",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "countback",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIDs = [];
    message.resolution = "";
    message.countback = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_i_ds */
        1:
          message.marketIDs.push(reader.string());
          break;
        case /* string resolution */
        2:
          message.resolution = reader.string();
          break;
        case /* sint32 countback */
        3:
          message.countback = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIDs.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIDs[i]);
    if (message.resolution !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.resolution);
    if (message.countback !== 0)
      writer.tag(3, WireType.Varint).sint32(message.countback);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketSnapshotRequest = new MarketSnapshotRequest$Type();
class MarketSnapshotResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.MarketSnapshotResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => MarketSnapshotHistoryResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_chart_rpc.MarketSnapshotHistoryResponse field */
        1:
          message.field.push(MarketSnapshotHistoryResponse.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      MarketSnapshotHistoryResponse.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketSnapshotResponse = new MarketSnapshotResponse$Type();
class MarketSnapshotHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_chart_rpc.MarketSnapshotHistoryResponse", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "t",
        kind: "scalar",
        repeat: 1,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "o",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "h",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "l",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "c",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 8,
        name: "v",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.resolution = "";
    message.t = [];
    message.o = [];
    message.h = [];
    message.l = [];
    message.c = [];
    message.v = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string resolution */
        2:
          message.resolution = reader.string();
          break;
        case /* repeated sint32 t */
        3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.t.push(reader.sint32());
          else
            message.t.push(reader.sint32());
          break;
        case /* repeated double o */
        4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.o.push(reader.double());
          else
            message.o.push(reader.double());
          break;
        case /* repeated double h */
        5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.h.push(reader.double());
          else
            message.h.push(reader.double());
          break;
        case /* repeated double l */
        6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.l.push(reader.double());
          else
            message.l.push(reader.double());
          break;
        case /* repeated double c */
        7:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.c.push(reader.double());
          else
            message.c.push(reader.double());
          break;
        case /* repeated double v */
        8:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.v.push(reader.double());
          else
            message.v.push(reader.double());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.resolution !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.resolution);
    if (message.t.length) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.t.length; i++)
        writer.sint32(message.t[i]);
      writer.join();
    }
    if (message.o.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.o.length; i++)
        writer.double(message.o[i]);
      writer.join();
    }
    if (message.h.length) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.h.length; i++)
        writer.double(message.h[i]);
      writer.join();
    }
    if (message.l.length) {
      writer.tag(6, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.l.length; i++)
        writer.double(message.l[i]);
      writer.join();
    }
    if (message.c.length) {
      writer.tag(7, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.c.length; i++)
        writer.double(message.c[i]);
      writer.join();
    }
    if (message.v.length) {
      writer.tag(8, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.v.length; i++)
        writer.double(message.v[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketSnapshotHistoryResponse = new MarketSnapshotHistoryResponse$Type();
const InjectiveChartRPC = new ServiceType("injective_chart_rpc.InjectiveChartRPC", [
  { name: "SpotMarketHistory", options: {}, I: SpotMarketHistoryRequest, O: SpotMarketHistoryResponse },
  { name: "DerivativeMarketHistory", options: {}, I: DerivativeMarketHistoryRequest, O: DerivativeMarketHistoryResponse },
  { name: "SpotMarketSummary", options: {}, I: SpotMarketSummaryRequest, O: SpotMarketSummaryResponse },
  { name: "AllSpotMarketSummary", options: {}, I: AllSpotMarketSummaryRequest, O: AllSpotMarketSummaryResponse },
  { name: "DerivativeMarketSummary", options: {}, I: DerivativeMarketSummaryRequest, O: DerivativeMarketSummaryResponse },
  { name: "AllDerivativeMarketSummary", options: {}, I: AllDerivativeMarketSummaryRequest, O: AllDerivativeMarketSummaryResponse },
  { name: "MarketSnapshot", options: {}, I: MarketSnapshotRequest, O: MarketSnapshotResponse }
]);
export {
  AllDerivativeMarketSummaryRequest,
  AllDerivativeMarketSummaryResponse,
  AllSpotMarketSummaryRequest,
  AllSpotMarketSummaryResponse,
  DerivativeMarketHistoryRequest,
  DerivativeMarketHistoryResponse,
  DerivativeMarketSummaryRequest,
  DerivativeMarketSummaryResponse,
  InjectiveChartRPC,
  MarketSnapshotHistoryResponse,
  MarketSnapshotRequest,
  MarketSnapshotResponse,
  MarketSummaryResp,
  SpotMarketHistoryRequest,
  SpotMarketHistoryResponse,
  SpotMarketSummaryRequest,
  SpotMarketSummaryResponse
};
