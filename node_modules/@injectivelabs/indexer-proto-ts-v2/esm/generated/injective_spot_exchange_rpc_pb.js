import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class MarketsRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.MarketsRequest", [
      {
        no: 1,
        name: "market_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "base_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "market_statuses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketStatus = "";
    message.baseDenom = "";
    message.quoteDenom = "";
    message.marketStatuses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_status */
        1:
          message.marketStatus = reader.string();
          break;
        case /* string base_denom */
        2:
          message.baseDenom = reader.string();
          break;
        case /* string quote_denom */
        3:
          message.quoteDenom = reader.string();
          break;
        case /* repeated string market_statuses */
        4:
          message.marketStatuses.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketStatus !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketStatus);
    if (message.baseDenom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.baseDenom);
    if (message.quoteDenom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
    for (let i = 0; i < message.marketStatuses.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.marketStatuses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketsRequest = new MarketsRequest$Type();
class MarketsResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.MarketsResponse", [
      { no: 1, name: "markets", kind: "message", repeat: 2, T: () => SpotMarketInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SpotMarketInfo markets */
        1:
          message.markets.push(SpotMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.markets.length; i++)
      SpotMarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketsResponse = new MarketsResponse$Type();
class SpotMarketInfo$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SpotMarketInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "base_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "base_token_meta", kind: "message", T: () => TokenMeta },
      {
        no: 6,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "quote_token_meta", kind: "message", T: () => TokenMeta },
      {
        no: 8,
        name: "maker_fee_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "taker_fee_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "service_provider_fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "min_price_tick_size",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "min_quantity_tick_size",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "min_notional",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.marketStatus = "";
    message.ticker = "";
    message.baseDenom = "";
    message.quoteDenom = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.serviceProviderFee = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string market_status */
        2:
          message.marketStatus = reader.string();
          break;
        case /* string ticker */
        3:
          message.ticker = reader.string();
          break;
        case /* string base_denom */
        4:
          message.baseDenom = reader.string();
          break;
        case /* injective_spot_exchange_rpc.TokenMeta base_token_meta */
        5:
          message.baseTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.baseTokenMeta);
          break;
        case /* string quote_denom */
        6:
          message.quoteDenom = reader.string();
          break;
        case /* injective_spot_exchange_rpc.TokenMeta quote_token_meta */
        7:
          message.quoteTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.quoteTokenMeta);
          break;
        case /* string maker_fee_rate */
        8:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        9:
          message.takerFeeRate = reader.string();
          break;
        case /* string service_provider_fee */
        10:
          message.serviceProviderFee = reader.string();
          break;
        case /* string min_price_tick_size */
        11:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        12:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        13:
          message.minNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.marketStatus !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketStatus);
    if (message.ticker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ticker);
    if (message.baseDenom !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.baseDenom);
    if (message.baseTokenMeta)
      TokenMeta.internalBinaryWrite(message.baseTokenMeta, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.quoteDenom !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.quoteTokenMeta)
      TokenMeta.internalBinaryWrite(message.quoteTokenMeta, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.makerFeeRate !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.serviceProviderFee !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.serviceProviderFee);
    if (message.minPriceTickSize !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.minNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketInfo = new SpotMarketInfo$Type();
class TokenMeta$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.TokenMeta", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "logo",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.address = "";
    message.symbol = "";
    message.logo = "";
    message.decimals = 0;
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        case /* string symbol */
        3:
          message.symbol = reader.string();
          break;
        case /* string logo */
        4:
          message.logo = reader.string();
          break;
        case /* sint32 decimals */
        5:
          message.decimals = reader.sint32();
          break;
        case /* sint64 updated_at */
        6:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    if (message.symbol !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.symbol);
    if (message.logo !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.logo);
    if (message.decimals !== 0)
      writer.tag(5, WireType.Varint).sint32(message.decimals);
    if (message.updatedAt !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TokenMeta = new TokenMeta$Type();
class MarketRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.MarketRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketRequest = new MarketRequest$Type();
class MarketResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.MarketResponse", [
      { no: 1, name: "market", kind: "message", T: () => SpotMarketInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotMarketInfo market */
        1:
          message.market = SpotMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      SpotMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketResponse = new MarketResponse$Type();
class StreamMarketsRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamMarketsRequest", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamMarketsRequest = new StreamMarketsRequest$Type();
class StreamMarketsResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamMarketsResponse", [
      { no: 1, name: "market", kind: "message", T: () => SpotMarketInfo },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotMarketInfo market */
        1:
          message.market = SpotMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      SpotMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamMarketsResponse = new StreamMarketsResponse$Type();
class OrderbookV2Request$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrderbookV2Request", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "depth",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.depth = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* sint32 depth */
        2:
          message.depth = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.depth !== 0)
      writer.tag(2, WireType.Varint).sint32(message.depth);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookV2Request = new OrderbookV2Request$Type();
class OrderbookV2Response$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrderbookV2Response", [
      { no: 1, name: "orderbook", kind: "message", T: () => SpotLimitOrderbookV2 }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook */
        1:
          message.orderbook = SpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderbook)
      SpotLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookV2Response = new OrderbookV2Response$Type();
class SpotLimitOrderbookV2$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SpotLimitOrderbookV2", [
      { no: 1, name: "buys", kind: "message", repeat: 2, T: () => PriceLevel },
      { no: 2, name: "sells", kind: "message", repeat: 2, T: () => PriceLevel },
      {
        no: 3,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.buys = [];
    message.sells = [];
    message.sequence = 0n;
    message.timestamp = 0n;
    message.height = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.PriceLevel buys */
        1:
          message.buys.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_spot_exchange_rpc.PriceLevel sells */
        2:
          message.sells.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 sequence */
        3:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* sint64 height */
        5:
          message.height = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.buys.length; i++)
      PriceLevel.internalBinaryWrite(message.buys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sells.length; i++)
      PriceLevel.internalBinaryWrite(message.sells[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.sequence !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.sequence);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.height);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotLimitOrderbookV2 = new SpotLimitOrderbookV2$Type();
class PriceLevel$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.PriceLevel", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceLevel = new PriceLevel$Type();
class OrderbooksV2Request$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrderbooksV2Request", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "depth",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    message.depth = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        case /* sint32 depth */
        2:
          message.depth = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.depth !== 0)
      writer.tag(2, WireType.Varint).sint32(message.depth);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbooksV2Request = new OrderbooksV2Request$Type();
class OrderbooksV2Response$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrderbooksV2Response", [
      { no: 1, name: "orderbooks", kind: "message", repeat: 2, T: () => SingleSpotLimitOrderbookV2 }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderbooks = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks */
        1:
          message.orderbooks.push(SingleSpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orderbooks.length; i++)
      SingleSpotLimitOrderbookV2.internalBinaryWrite(message.orderbooks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbooksV2Response = new OrderbooksV2Response$Type();
class SingleSpotLimitOrderbookV2$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "orderbook", kind: "message", T: () => SpotLimitOrderbookV2 }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook */
        2:
          message.orderbook = SpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderbook)
      SpotLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SingleSpotLimitOrderbookV2 = new SingleSpotLimitOrderbookV2$Type();
class StreamOrderbookV2Request$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrderbookV2Request", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookV2Request = new StreamOrderbookV2Request$Type();
class StreamOrderbookV2Response$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrderbookV2Response", [
      { no: 1, name: "orderbook", kind: "message", T: () => SpotLimitOrderbookV2 },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook */
        1:
          message.orderbook = SpotLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* string market_id */
        4:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderbook)
      SpotLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    if (message.marketId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookV2Response = new StreamOrderbookV2Response$Type();
class StreamOrderbookUpdateRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrderbookUpdateRequest", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookUpdateRequest = new StreamOrderbookUpdateRequest$Type();
class StreamOrderbookUpdateResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrderbookUpdateResponse", [
      { no: 1, name: "orderbook_level_updates", kind: "message", T: () => OrderbookLevelUpdates },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates */
        1:
          message.orderbookLevelUpdates = OrderbookLevelUpdates.internalBinaryRead(reader, reader.uint32(), options, message.orderbookLevelUpdates);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* string market_id */
        4:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderbookLevelUpdates)
      OrderbookLevelUpdates.internalBinaryWrite(message.orderbookLevelUpdates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    if (message.marketId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrderbookUpdateResponse = new StreamOrderbookUpdateResponse$Type();
class OrderbookLevelUpdates$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrderbookLevelUpdates", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "buys", kind: "message", repeat: 2, T: () => PriceLevelUpdate },
      { no: 4, name: "sells", kind: "message", repeat: 2, T: () => PriceLevelUpdate },
      {
        no: 5,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.sequence = 0n;
    message.buys = [];
    message.sells = [];
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* uint64 sequence */
        2:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* repeated injective_spot_exchange_rpc.PriceLevelUpdate buys */
        3:
          message.buys.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_spot_exchange_rpc.PriceLevelUpdate sells */
        4:
          message.sells.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 updated_at */
        5:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.sequence !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.sequence);
    for (let i = 0; i < message.buys.length; i++)
      PriceLevelUpdate.internalBinaryWrite(message.buys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sells.length; i++)
      PriceLevelUpdate.internalBinaryWrite(message.sells[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookLevelUpdates = new OrderbookLevelUpdates$Type();
class PriceLevelUpdate$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.PriceLevelUpdate", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.isActive = false;
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* bool is_active */
        3:
          message.isActive = reader.bool();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.isActive !== false)
      writer.tag(3, WireType.Varint).bool(message.isActive);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceLevelUpdate = new PriceLevelUpdate$Type();
class OrdersRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "include_inactive",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "subaccount_total_orders",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderSide = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.includeInactive = false;
    message.subaccountTotalOrders = false;
    message.tradeId = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        5:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        6:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        7:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        8:
          message.marketIds.push(reader.string());
          break;
        case /* bool include_inactive */
        9:
          message.includeInactive = reader.bool();
          break;
        case /* bool subaccount_total_orders */
        10:
          message.subaccountTotalOrders = reader.bool();
          break;
        case /* string trade_id */
        11:
          message.tradeId = reader.string();
          break;
        case /* string cid */
        12:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(5, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.includeInactive !== false)
      writer.tag(9, WireType.Varint).bool(message.includeInactive);
    if (message.subaccountTotalOrders !== false)
      writer.tag(10, WireType.Varint).bool(message.subaccountTotalOrders);
    if (message.tradeId !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
    if (message.cid !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersRequest = new OrdersRequest$Type();
class OrdersResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrdersResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => SpotLimitOrder },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SpotLimitOrder orders */
        1:
          message.orders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_spot_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      SpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersResponse = new OrdersResponse$Type();
class SpotLimitOrder$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SpotLimitOrder", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "unfilled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.orderSide = "";
    message.marketId = "";
    message.subaccountId = "";
    message.price = "";
    message.quantity = "";
    message.unfilledQuantity = "";
    message.triggerPrice = "";
    message.feeRecipient = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* string price */
        5:
          message.price = reader.string();
          break;
        case /* string quantity */
        6:
          message.quantity = reader.string();
          break;
        case /* string unfilled_quantity */
        7:
          message.unfilledQuantity = reader.string();
          break;
        case /* string trigger_price */
        8:
          message.triggerPrice = reader.string();
          break;
        case /* string fee_recipient */
        9:
          message.feeRecipient = reader.string();
          break;
        case /* string state */
        10:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        11:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        12:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string tx_hash */
        13:
          message.txHash = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.price !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.quantity);
    if (message.unfilledQuantity !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.unfilledQuantity);
    if (message.triggerPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.feeRecipient !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.state !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.updatedAt);
    if (message.txHash !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotLimitOrder = new SpotLimitOrder$Type();
class Paging$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.Paging", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "from",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "to",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "count_by_subaccount",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total = 0n;
    message.from = 0;
    message.to = 0;
    message.countBySubaccount = 0n;
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 total */
        1:
          message.total = reader.sint64().toBigInt();
          break;
        case /* sint32 from */
        2:
          message.from = reader.sint32();
          break;
        case /* sint32 to */
        3:
          message.to = reader.sint32();
          break;
        case /* sint64 count_by_subaccount */
        4:
          message.countBySubaccount = reader.sint64().toBigInt();
          break;
        case /* repeated string next */
        5:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.total);
    if (message.from !== 0)
      writer.tag(2, WireType.Varint).sint32(message.from);
    if (message.to !== 0)
      writer.tag(3, WireType.Varint).sint32(message.to);
    if (message.countBySubaccount !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
    for (let i = 0; i < message.next.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Paging = new Paging$Type();
class StreamOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "include_inactive",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "subaccount_total_orders",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderSide = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.includeInactive = false;
    message.subaccountTotalOrders = false;
    message.tradeId = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        5:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        6:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        7:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        8:
          message.marketIds.push(reader.string());
          break;
        case /* bool include_inactive */
        9:
          message.includeInactive = reader.bool();
          break;
        case /* bool subaccount_total_orders */
        10:
          message.subaccountTotalOrders = reader.bool();
          break;
        case /* string trade_id */
        11:
          message.tradeId = reader.string();
          break;
        case /* string cid */
        12:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(5, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.includeInactive !== false)
      writer.tag(9, WireType.Varint).bool(message.includeInactive);
    if (message.subaccountTotalOrders !== false)
      writer.tag(10, WireType.Varint).bool(message.subaccountTotalOrders);
    if (message.tradeId !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
    if (message.cid !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersRequest = new StreamOrdersRequest$Type();
class StreamOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrdersResponse", [
      { no: 1, name: "order", kind: "message", T: () => SpotLimitOrder },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotLimitOrder order */
        1:
          message.order = SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.order)
      SpotLimitOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersResponse = new StreamOrdersResponse$Type();
class TradesRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.TradesRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesRequest = new TradesRequest$Type();
class TradesResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.TradesResponse", [
      { no: 1, name: "trades", kind: "message", repeat: 2, T: () => SpotTrade },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SpotTrade trades */
        1:
          message.trades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_spot_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.trades.length; i++)
      SpotTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesResponse = new TradesResponse$Type();
class SpotTrade$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SpotTrade", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "trade_execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "trade_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "price", kind: "message", T: () => PriceLevel },
      {
        no: 7,
        name: "fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.subaccountId = "";
    message.marketId = "";
    message.tradeExecutionType = "";
    message.tradeDirection = "";
    message.fee = "";
    message.executedAt = 0n;
    message.feeRecipient = "";
    message.tradeId = "";
    message.executionSide = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string trade_execution_type */
        4:
          message.tradeExecutionType = reader.string();
          break;
        case /* string trade_direction */
        5:
          message.tradeDirection = reader.string();
          break;
        case /* injective_spot_exchange_rpc.PriceLevel price */
        6:
          message.price = PriceLevel.internalBinaryRead(reader, reader.uint32(), options, message.price);
          break;
        case /* string fee */
        7:
          message.fee = reader.string();
          break;
        case /* sint64 executed_at */
        8:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* string fee_recipient */
        9:
          message.feeRecipient = reader.string();
          break;
        case /* string trade_id */
        10:
          message.tradeId = reader.string();
          break;
        case /* string execution_side */
        11:
          message.executionSide = reader.string();
          break;
        case /* string cid */
        12:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.tradeExecutionType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
    if (message.tradeDirection !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.tradeDirection);
    if (message.price)
      PriceLevel.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.fee !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.fee);
    if (message.executedAt !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.executedAt);
    if (message.feeRecipient !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.tradeId !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.tradeId);
    if (message.executionSide !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.executionSide);
    if (message.cid !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotTrade = new SpotTrade$Type();
class StreamTradesRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamTradesRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesRequest = new StreamTradesRequest$Type();
class StreamTradesResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamTradesResponse", [
      { no: 1, name: "trade", kind: "message", T: () => SpotTrade },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotTrade trade */
        1:
          message.trade = SpotTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.trade)
      SpotTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesResponse = new StreamTradesResponse$Type();
class TradesV2Request$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.TradesV2Request", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesV2Request = new TradesV2Request$Type();
class TradesV2Response$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.TradesV2Response", [
      { no: 1, name: "trades", kind: "message", repeat: 2, T: () => SpotTrade },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SpotTrade trades */
        1:
          message.trades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_spot_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.trades.length; i++)
      SpotTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesV2Response = new TradesV2Response$Type();
class StreamTradesV2Request$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamTradesV2Request", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.executionSide = "";
    message.direction = "";
    message.subaccountId = "";
    message.skip = 0n;
    message.limit = 0;
    message.startTime = 0n;
    message.endTime = 0n;
    message.marketIds = [];
    message.subaccountIds = [];
    message.executionTypes = [];
    message.tradeId = "";
    message.accountAddress = "";
    message.cid = "";
    message.feeRecipient = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string execution_side */
        2:
          message.executionSide = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string market_ids */
        9:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string subaccount_ids */
        10:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string execution_types */
        11:
          message.executionTypes.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* string account_address */
        13:
          message.accountAddress = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        case /* string fee_recipient */
        15:
          message.feeRecipient = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.executionSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.accountAddress !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    if (message.feeRecipient !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesV2Request = new StreamTradesV2Request$Type();
class StreamTradesV2Response$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamTradesV2Response", [
      { no: 1, name: "trade", kind: "message", T: () => SpotTrade },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotTrade trade */
        1:
          message.trade = SpotTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.trade)
      SpotTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTradesV2Response = new StreamTradesV2Response$Type();
class SubaccountOrdersListRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SubaccountOrdersListRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrdersListRequest = new SubaccountOrdersListRequest$Type();
class SubaccountOrdersListResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SubaccountOrdersListResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => SpotLimitOrder },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SpotLimitOrder orders */
        1:
          message.orders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_spot_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      SpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrdersListResponse = new SubaccountOrdersListResponse$Type();
class SubaccountTradesListRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SubaccountTradesListRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.executionType = "";
    message.direction = "";
    message.skip = 0n;
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string execution_type */
        3:
          message.executionType = reader.string();
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        6:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.executionType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionType);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(6, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountTradesListRequest = new SubaccountTradesListRequest$Type();
class SubaccountTradesListResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SubaccountTradesListResponse", [
      { no: 1, name: "trades", kind: "message", repeat: 2, T: () => SpotTrade }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SpotTrade trades */
        1:
          message.trades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.trades.length; i++)
      SpotTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountTradesListResponse = new SubaccountTradesListResponse$Type();
class OrdersHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrdersHistoryRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "order_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "active_markets_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.skip = 0n;
    message.limit = 0;
    message.orderTypes = [];
    message.direction = "";
    message.startTime = 0n;
    message.endTime = 0n;
    message.state = "";
    message.executionTypes = [];
    message.marketIds = [];
    message.tradeId = "";
    message.activeMarketsOnly = false;
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* repeated string order_types */
        5:
          message.orderTypes.push(reader.string());
          break;
        case /* string direction */
        6:
          message.direction = reader.string();
          break;
        case /* sint64 start_time */
        7:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        8:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* string state */
        9:
          message.state = reader.string();
          break;
        case /* repeated string execution_types */
        10:
          message.executionTypes.push(reader.string());
          break;
        case /* repeated string market_ids */
        11:
          message.marketIds.push(reader.string());
          break;
        case /* string trade_id */
        12:
          message.tradeId = reader.string();
          break;
        case /* bool active_markets_only */
        13:
          message.activeMarketsOnly = reader.bool();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    for (let i = 0; i < message.orderTypes.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.orderTypes[i]);
    if (message.direction !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.direction);
    if (message.startTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.endTime);
    if (message.state !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.state);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.executionTypes[i]);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.tradeId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
    if (message.activeMarketsOnly !== false)
      writer.tag(13, WireType.Varint).bool(message.activeMarketsOnly);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersHistoryRequest = new OrdersHistoryRequest$Type();
class OrdersHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.OrdersHistoryResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => SpotOrderHistory },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_spot_exchange_rpc.SpotOrderHistory orders */
        1:
          message.orders.push(SpotOrderHistory.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_spot_exchange_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      SpotOrderHistory.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersHistoryResponse = new OrdersHistoryResponse$Type();
class SpotOrderHistory$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.SpotOrderHistory", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "filled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.marketId = "";
    message.isActive = false;
    message.subaccountId = "";
    message.executionType = "";
    message.orderType = "";
    message.price = "";
    message.triggerPrice = "";
    message.quantity = "";
    message.filledQuantity = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.direction = "";
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* bool is_active */
        3:
          message.isActive = reader.bool();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* string execution_type */
        5:
          message.executionType = reader.string();
          break;
        case /* string order_type */
        6:
          message.orderType = reader.string();
          break;
        case /* string price */
        7:
          message.price = reader.string();
          break;
        case /* string trigger_price */
        8:
          message.triggerPrice = reader.string();
          break;
        case /* string quantity */
        9:
          message.quantity = reader.string();
          break;
        case /* string filled_quantity */
        10:
          message.filledQuantity = reader.string();
          break;
        case /* string state */
        11:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        12:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        13:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string direction */
        14:
          message.direction = reader.string();
          break;
        case /* string tx_hash */
        15:
          message.txHash = reader.string();
          break;
        case /* string cid */
        16:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.isActive !== false)
      writer.tag(3, WireType.Varint).bool(message.isActive);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.executionType !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.executionType);
    if (message.orderType !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.orderType);
    if (message.price !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.price);
    if (message.triggerPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.quantity !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.quantity);
    if (message.filledQuantity !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
    if (message.state !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.updatedAt);
    if (message.direction !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.direction);
    if (message.txHash !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotOrderHistory = new SpotOrderHistory$Type();
class StreamOrdersHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrdersHistoryRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "order_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "execution_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.orderTypes = [];
    message.direction = "";
    message.state = "";
    message.executionTypes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* repeated string order_types */
        3:
          message.orderTypes.push(reader.string());
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* string state */
        5:
          message.state = reader.string();
          break;
        case /* repeated string execution_types */
        6:
          message.executionTypes.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.orderTypes.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.orderTypes[i]);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.state !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.state);
    for (let i = 0; i < message.executionTypes.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.executionTypes[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersHistoryRequest = new StreamOrdersHistoryRequest$Type();
class StreamOrdersHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.StreamOrdersHistoryResponse", [
      { no: 1, name: "order", kind: "message", T: () => SpotOrderHistory },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.SpotOrderHistory order */
        1:
          message.order = SpotOrderHistory.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.order)
      SpotOrderHistory.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamOrdersHistoryResponse = new StreamOrdersHistoryResponse$Type();
class AtomicSwapHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.AtomicSwapHistoryRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "from_number",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "to_number",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.contractAddress = "";
    message.skip = 0;
    message.limit = 0;
    message.fromNumber = 0;
    message.toNumber = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string contract_address */
        2:
          message.contractAddress = reader.string();
          break;
        case /* sint32 skip */
        3:
          message.skip = reader.sint32();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* sint32 from_number */
        5:
          message.fromNumber = reader.sint32();
          break;
        case /* sint32 to_number */
        6:
          message.toNumber = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.contractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
    if (message.skip !== 0)
      writer.tag(3, WireType.Varint).sint32(message.skip);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    if (message.fromNumber !== 0)
      writer.tag(5, WireType.Varint).sint32(message.fromNumber);
    if (message.toNumber !== 0)
      writer.tag(6, WireType.Varint).sint32(message.toNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AtomicSwapHistoryRequest = new AtomicSwapHistoryRequest$Type();
class AtomicSwapHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.AtomicSwapHistoryResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => AtomicSwap }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_spot_exchange_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_spot_exchange_rpc.AtomicSwap data */
        2:
          message.data.push(AtomicSwap.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      AtomicSwap.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AtomicSwapHistoryResponse = new AtomicSwapHistoryResponse$Type();
class AtomicSwap$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.AtomicSwap", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "route",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "source_coin", kind: "message", T: () => Coin },
      { no: 4, name: "dest_coin", kind: "message", T: () => Coin },
      { no: 5, name: "fees", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 6,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "index_by_sender",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 8,
        name: "index_by_sender_contract",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 9,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "refund_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.route = "";
    message.fees = [];
    message.contractAddress = "";
    message.indexBySender = 0;
    message.indexBySenderContract = 0;
    message.txHash = "";
    message.executedAt = 0n;
    message.refundAmount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string route */
        2:
          message.route = reader.string();
          break;
        case /* injective_spot_exchange_rpc.Coin source_coin */
        3:
          message.sourceCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.sourceCoin);
          break;
        case /* injective_spot_exchange_rpc.Coin dest_coin */
        4:
          message.destCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.destCoin);
          break;
        case /* repeated injective_spot_exchange_rpc.Coin fees */
        5:
          message.fees.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string contract_address */
        6:
          message.contractAddress = reader.string();
          break;
        case /* sint32 index_by_sender */
        7:
          message.indexBySender = reader.sint32();
          break;
        case /* sint32 index_by_sender_contract */
        8:
          message.indexBySenderContract = reader.sint32();
          break;
        case /* string tx_hash */
        9:
          message.txHash = reader.string();
          break;
        case /* sint64 executed_at */
        10:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* string refund_amount */
        11:
          message.refundAmount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.route !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.route);
    if (message.sourceCoin)
      Coin.internalBinaryWrite(message.sourceCoin, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.destCoin)
      Coin.internalBinaryWrite(message.destCoin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.fees.length; i++)
      Coin.internalBinaryWrite(message.fees[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.contractAddress !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.contractAddress);
    if (message.indexBySender !== 0)
      writer.tag(7, WireType.Varint).sint32(message.indexBySender);
    if (message.indexBySenderContract !== 0)
      writer.tag(8, WireType.Varint).sint32(message.indexBySenderContract);
    if (message.txHash !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.txHash);
    if (message.executedAt !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.executedAt);
    if (message.refundAmount !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.refundAmount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AtomicSwap = new AtomicSwap$Type();
class Coin$Type extends MessageType {
  constructor() {
    super("injective_spot_exchange_rpc.Coin", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "usd_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.amount = "";
    message.usdValue = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        case /* string usd_value */
        3:
          message.usdValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    if (message.usdValue !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Coin = new Coin$Type();
const InjectiveSpotExchangeRPC = new ServiceType("injective_spot_exchange_rpc.InjectiveSpotExchangeRPC", [
  { name: "Markets", options: {}, I: MarketsRequest, O: MarketsResponse },
  { name: "Market", options: {}, I: MarketRequest, O: MarketResponse },
  { name: "StreamMarkets", serverStreaming: true, options: {}, I: StreamMarketsRequest, O: StreamMarketsResponse },
  { name: "OrderbookV2", options: {}, I: OrderbookV2Request, O: OrderbookV2Response },
  { name: "OrderbooksV2", options: {}, I: OrderbooksV2Request, O: OrderbooksV2Response },
  { name: "StreamOrderbookV2", serverStreaming: true, options: {}, I: StreamOrderbookV2Request, O: StreamOrderbookV2Response },
  { name: "StreamOrderbookUpdate", serverStreaming: true, options: {}, I: StreamOrderbookUpdateRequest, O: StreamOrderbookUpdateResponse },
  { name: "Orders", options: {}, I: OrdersRequest, O: OrdersResponse },
  { name: "StreamOrders", serverStreaming: true, options: {}, I: StreamOrdersRequest, O: StreamOrdersResponse },
  { name: "Trades", options: {}, I: TradesRequest, O: TradesResponse },
  { name: "StreamTrades", serverStreaming: true, options: {}, I: StreamTradesRequest, O: StreamTradesResponse },
  { name: "TradesV2", options: {}, I: TradesV2Request, O: TradesV2Response },
  { name: "StreamTradesV2", serverStreaming: true, options: {}, I: StreamTradesV2Request, O: StreamTradesV2Response },
  { name: "SubaccountOrdersList", options: {}, I: SubaccountOrdersListRequest, O: SubaccountOrdersListResponse },
  { name: "SubaccountTradesList", options: {}, I: SubaccountTradesListRequest, O: SubaccountTradesListResponse },
  { name: "OrdersHistory", options: {}, I: OrdersHistoryRequest, O: OrdersHistoryResponse },
  { name: "StreamOrdersHistory", serverStreaming: true, options: {}, I: StreamOrdersHistoryRequest, O: StreamOrdersHistoryResponse },
  { name: "AtomicSwapHistory", options: {}, I: AtomicSwapHistoryRequest, O: AtomicSwapHistoryResponse }
]);
export {
  AtomicSwap,
  AtomicSwapHistoryRequest,
  AtomicSwapHistoryResponse,
  Coin,
  InjectiveSpotExchangeRPC,
  MarketRequest,
  MarketResponse,
  MarketsRequest,
  MarketsResponse,
  OrderbookLevelUpdates,
  OrderbookV2Request,
  OrderbookV2Response,
  OrderbooksV2Request,
  OrderbooksV2Response,
  OrdersHistoryRequest,
  OrdersHistoryResponse,
  OrdersRequest,
  OrdersResponse,
  Paging,
  PriceLevel,
  PriceLevelUpdate,
  SingleSpotLimitOrderbookV2,
  SpotLimitOrder,
  SpotLimitOrderbookV2,
  SpotMarketInfo,
  SpotOrderHistory,
  SpotTrade,
  StreamMarketsRequest,
  StreamMarketsResponse,
  StreamOrderbookUpdateRequest,
  StreamOrderbookUpdateResponse,
  StreamOrderbookV2Request,
  StreamOrderbookV2Response,
  StreamOrdersHistoryRequest,
  StreamOrdersHistoryResponse,
  StreamOrdersRequest,
  StreamOrdersResponse,
  StreamTradesRequest,
  StreamTradesResponse,
  StreamTradesV2Request,
  StreamTradesV2Response,
  SubaccountOrdersListRequest,
  SubaccountOrdersListResponse,
  SubaccountTradesListRequest,
  SubaccountTradesListResponse,
  TokenMeta,
  TradesRequest,
  TradesResponse,
  TradesV2Request,
  TradesV2Response
};
