import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class TokenHoldersRequest$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.TokenHoldersRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "cursor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.cursor = "";
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string cursor */
        2:
          message.cursor = reader.string();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.cursor !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cursor);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TokenHoldersRequest = new TokenHoldersRequest$Type();
class TokenHoldersResponse$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.TokenHoldersResponse", [
      { no: 1, name: "holders", kind: "message", repeat: 2, T: () => Holder },
      {
        no: 2,
        name: "next_cursors",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.holders = [];
    message.nextCursors = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_portfolio_rpc.Holder holders */
        1:
          message.holders.push(Holder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string next_cursors */
        2:
          message.nextCursors.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.holders.length; i++)
      Holder.internalBinaryWrite(message.holders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.nextCursors.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.nextCursors[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TokenHoldersResponse = new TokenHoldersResponse$Type();
class Holder$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.Holder", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.balance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* string balance */
        2:
          message.balance = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.balance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.balance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Holder = new Holder$Type();
class AccountPortfolioRequest$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.AccountPortfolioRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountPortfolioRequest = new AccountPortfolioRequest$Type();
class AccountPortfolioResponse$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.AccountPortfolioResponse", [
      { no: 1, name: "portfolio", kind: "message", T: () => Portfolio }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_portfolio_rpc.Portfolio portfolio */
        1:
          message.portfolio = Portfolio.internalBinaryRead(reader, reader.uint32(), options, message.portfolio);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.portfolio)
      Portfolio.internalBinaryWrite(message.portfolio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountPortfolioResponse = new AccountPortfolioResponse$Type();
class Portfolio$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.Portfolio", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "bank_balances", kind: "message", repeat: 2, T: () => Coin },
      { no: 3, name: "subaccounts", kind: "message", repeat: 2, T: () => SubaccountBalanceV2 },
      { no: 4, name: "positions_with_upnl", kind: "message", repeat: 2, T: () => PositionsWithUPNL }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.bankBalances = [];
    message.subaccounts = [];
    message.positionsWithUpnl = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* repeated injective_portfolio_rpc.Coin bank_balances */
        2:
          message.bankBalances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts */
        3:
          message.subaccounts.push(SubaccountBalanceV2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_portfolio_rpc.PositionsWithUPNL positions_with_upnl */
        4:
          message.positionsWithUpnl.push(PositionsWithUPNL.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    for (let i = 0; i < message.bankBalances.length; i++)
      Coin.internalBinaryWrite(message.bankBalances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.subaccounts.length; i++)
      SubaccountBalanceV2.internalBinaryWrite(message.subaccounts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.positionsWithUpnl.length; i++)
      PositionsWithUPNL.internalBinaryWrite(message.positionsWithUpnl[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Portfolio = new Portfolio$Type();
class Coin$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.Coin", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "usd_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.amount = "";
    message.usdValue = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        case /* string usd_value */
        3:
          message.usdValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    if (message.usdValue !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Coin = new Coin$Type();
class SubaccountBalanceV2$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.SubaccountBalanceV2", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "deposit", kind: "message", T: () => SubaccountDeposit }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        case /* injective_portfolio_rpc.SubaccountDeposit deposit */
        3:
          message.deposit = SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    if (message.deposit)
      SubaccountDeposit.internalBinaryWrite(message.deposit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalanceV2 = new SubaccountBalanceV2$Type();
class SubaccountDeposit$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.SubaccountDeposit", [
      {
        no: 1,
        name: "total_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "available_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "total_balance_usd",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "available_balance_usd",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.totalBalance = "";
    message.availableBalance = "";
    message.totalBalanceUsd = "";
    message.availableBalanceUsd = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string total_balance */
        1:
          message.totalBalance = reader.string();
          break;
        case /* string available_balance */
        2:
          message.availableBalance = reader.string();
          break;
        case /* string total_balance_usd */
        3:
          message.totalBalanceUsd = reader.string();
          break;
        case /* string available_balance_usd */
        4:
          message.availableBalanceUsd = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalBalance !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.totalBalance);
    if (message.availableBalance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
    if (message.totalBalanceUsd !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.totalBalanceUsd);
    if (message.availableBalanceUsd !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.availableBalanceUsd);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountDeposit = new SubaccountDeposit$Type();
class PositionsWithUPNL$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.PositionsWithUPNL", [
      { no: 1, name: "position", kind: "message", T: () => DerivativePosition },
      {
        no: 2,
        name: "unrealized_pnl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.unrealizedPnl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_portfolio_rpc.DerivativePosition position */
        1:
          message.position = DerivativePosition.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        case /* string unrealized_pnl */
        2:
          message.unrealizedPnl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.position)
      DerivativePosition.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.unrealizedPnl !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.unrealizedPnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionsWithUPNL = new PositionsWithUPNL$Type();
class DerivativePosition$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.DerivativePosition", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "entry_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "liquidation_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "mark_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "aggregate_reduce_only_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "funding_last",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "funding_sum",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "cumulative_funding_entry",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 17,
        name: "effective_cumulative_funding_entry",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.marketId = "";
    message.subaccountId = "";
    message.direction = "";
    message.quantity = "";
    message.entryPrice = "";
    message.margin = "";
    message.liquidationPrice = "";
    message.markPrice = "";
    message.aggregateReduceOnlyQuantity = "";
    message.updatedAt = 0n;
    message.createdAt = 0n;
    message.fundingLast = "";
    message.fundingSum = "";
    message.cumulativeFundingEntry = "";
    message.effectiveCumulativeFundingEntry = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* string quantity */
        5:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        6:
          message.entryPrice = reader.string();
          break;
        case /* string margin */
        7:
          message.margin = reader.string();
          break;
        case /* string liquidation_price */
        8:
          message.liquidationPrice = reader.string();
          break;
        case /* string mark_price */
        9:
          message.markPrice = reader.string();
          break;
        case /* string aggregate_reduce_only_quantity */
        11:
          message.aggregateReduceOnlyQuantity = reader.string();
          break;
        case /* sint64 updated_at */
        12:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        13:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* string funding_last */
        14:
          message.fundingLast = reader.string();
          break;
        case /* string funding_sum */
        15:
          message.fundingSum = reader.string();
          break;
        case /* string cumulative_funding_entry */
        16:
          message.cumulativeFundingEntry = reader.string();
          break;
        case /* string effective_cumulative_funding_entry */
        17:
          message.effectiveCumulativeFundingEntry = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.quantity !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
    if (message.margin !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.margin);
    if (message.liquidationPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
    if (message.markPrice !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
    if (message.aggregateReduceOnlyQuantity !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.aggregateReduceOnlyQuantity);
    if (message.updatedAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.updatedAt);
    if (message.createdAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.createdAt);
    if (message.fundingLast !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.fundingLast);
    if (message.fundingSum !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.fundingSum);
    if (message.cumulativeFundingEntry !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
    if (message.effectiveCumulativeFundingEntry !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.effectiveCumulativeFundingEntry);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativePosition = new DerivativePosition$Type();
class AccountPortfolioBalancesRequest$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.AccountPortfolioBalancesRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "usd",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.usd = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* bool usd */
        2:
          message.usd = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.usd !== false)
      writer.tag(2, WireType.Varint).bool(message.usd);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountPortfolioBalancesRequest = new AccountPortfolioBalancesRequest$Type();
class AccountPortfolioBalancesResponse$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.AccountPortfolioBalancesResponse", [
      { no: 1, name: "portfolio", kind: "message", T: () => PortfolioBalances }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_portfolio_rpc.PortfolioBalances portfolio */
        1:
          message.portfolio = PortfolioBalances.internalBinaryRead(reader, reader.uint32(), options, message.portfolio);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.portfolio)
      PortfolioBalances.internalBinaryWrite(message.portfolio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountPortfolioBalancesResponse = new AccountPortfolioBalancesResponse$Type();
class PortfolioBalances$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.PortfolioBalances", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "bank_balances", kind: "message", repeat: 2, T: () => Coin },
      { no: 3, name: "subaccounts", kind: "message", repeat: 2, T: () => SubaccountBalanceV2 },
      {
        no: 4,
        name: "total_usd",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.bankBalances = [];
    message.subaccounts = [];
    message.totalUsd = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* repeated injective_portfolio_rpc.Coin bank_balances */
        2:
          message.bankBalances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts */
        3:
          message.subaccounts.push(SubaccountBalanceV2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string total_usd */
        4:
          message.totalUsd = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    for (let i = 0; i < message.bankBalances.length; i++)
      Coin.internalBinaryWrite(message.bankBalances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.subaccounts.length; i++)
      SubaccountBalanceV2.internalBinaryWrite(message.subaccounts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.totalUsd !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.totalUsd);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PortfolioBalances = new PortfolioBalances$Type();
class StreamAccountPortfolioRequest$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.StreamAccountPortfolioRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.subaccountId = "";
    message.type = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string type */
        3:
          message.type = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.type !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.type);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamAccountPortfolioRequest = new StreamAccountPortfolioRequest$Type();
class StreamAccountPortfolioResponse$Type extends MessageType {
  constructor() {
    super("injective_portfolio_rpc.StreamAccountPortfolioResponse", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = "";
    message.denom = "";
    message.amount = "";
    message.subaccountId = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */
        1:
          message.type = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        case /* string amount */
        3:
          message.amount = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* sint64 timestamp */
        5:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.amount);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.timestamp !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamAccountPortfolioResponse = new StreamAccountPortfolioResponse$Type();
const InjectivePortfolioRPC = new ServiceType("injective_portfolio_rpc.InjectivePortfolioRPC", [
  { name: "TokenHolders", options: {}, I: TokenHoldersRequest, O: TokenHoldersResponse },
  { name: "AccountPortfolio", options: {}, I: AccountPortfolioRequest, O: AccountPortfolioResponse },
  { name: "AccountPortfolioBalances", options: {}, I: AccountPortfolioBalancesRequest, O: AccountPortfolioBalancesResponse },
  { name: "StreamAccountPortfolio", serverStreaming: true, options: {}, I: StreamAccountPortfolioRequest, O: StreamAccountPortfolioResponse }
]);
export {
  AccountPortfolioBalancesRequest,
  AccountPortfolioBalancesResponse,
  AccountPortfolioRequest,
  AccountPortfolioResponse,
  Coin,
  DerivativePosition,
  Holder,
  InjectivePortfolioRPC,
  Portfolio,
  PortfolioBalances,
  PositionsWithUPNL,
  StreamAccountPortfolioRequest,
  StreamAccountPortfolioResponse,
  SubaccountBalanceV2,
  SubaccountDeposit,
  TokenHoldersRequest,
  TokenHoldersResponse
};
