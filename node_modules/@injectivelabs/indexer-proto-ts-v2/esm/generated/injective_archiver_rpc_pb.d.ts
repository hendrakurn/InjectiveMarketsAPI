// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_archiver_rpc.proto" (package "injective_archiver_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveArchiverRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_archiver_rpc.BalanceRequest
 */
export interface BalanceRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * Symbol resolution. Possible resolutions are 1D,1W,1M
     *
     * @generated from protobuf field: string resolution = 2
     */
    resolution: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.BalanceResponse
 */
export interface BalanceResponse {
    /**
     * @generated from protobuf field: injective_archiver_rpc.HistoricalBalance historical_balance = 1
     */
    historicalBalance?: HistoricalBalance;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalBalance
 */
export interface HistoricalBalance {
    /**
     * Time, Unix timestamp (UTC)
     *
     * @generated from protobuf field: repeated sint32 t = 1
     */
    t: number[];
    /**
     * Balance value
     *
     * @generated from protobuf field: repeated double v = 2
     */
    v: number[];
    /**
     * Detailed Balance value
     *
     * @generated from protobuf field: repeated injective_archiver_rpc.HistoricalDetailedBalance dv = 3
     */
    dv: HistoricalDetailedBalance[];
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalDetailedBalance
 */
export interface HistoricalDetailedBalance {
    /**
     * Spot amount value
     *
     * @generated from protobuf field: double spot = 1
     */
    spot: number;
    /**
     * Perpetual amount value
     *
     * @generated from protobuf field: double perp = 2
     */
    perp: number;
    /**
     * Staking amount value
     *
     * @generated from protobuf field: double staking = 3
     */
    staking: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.AccountStatsRequest
 */
export interface AccountStatsRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * Time period filter for pnl and volume.
     *
     * @generated from protobuf field: string period = 2
     */
    period: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.AccountStatsResponse
 */
export interface AccountStatsResponse {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * Realized profit and loss (USD)
     *
     * @generated from protobuf field: double pnl = 2
     */
    pnl: number;
    /**
     * Trade volume (USD)
     *
     * @generated from protobuf field: double volume = 3
     */
    volume: number;
    /**
     * Staking amount (INJ)
     *
     * @generated from protobuf field: string stake = 4
     */
    stake: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.RpnlRequest
 */
export interface RpnlRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * Symbol resolution. Possible resolutions are 1D,1W,1M
     *
     * @generated from protobuf field: string resolution = 2
     */
    resolution: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.RpnlResponse
 */
export interface RpnlResponse {
    /**
     * @generated from protobuf field: injective_archiver_rpc.HistoricalRPNL historical_rpnl = 1
     */
    historicalRpnl?: HistoricalRPNL;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalRPNL
 */
export interface HistoricalRPNL {
    /**
     * Time, Unix timestamp (UTC)
     *
     * @generated from protobuf field: repeated sint32 t = 1
     */
    t: number[];
    /**
     * Realized Profit and Loss value
     *
     * @generated from protobuf field: repeated double v = 2
     */
    v: number[];
    /**
     * Detailed Profit and Loss value
     *
     * @generated from protobuf field: repeated injective_archiver_rpc.HistoricalDetailedPNL dv = 3
     */
    dv: HistoricalDetailedPNL[];
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalDetailedPNL
 */
export interface HistoricalDetailedPNL {
    /**
     * Realized Profit and Loss value
     *
     * @generated from protobuf field: double rpnl = 1
     */
    rpnl: number;
    /**
     * Unrealized Profit and Loss value
     *
     * @generated from protobuf field: double upnl = 2
     */
    upnl: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolumesRequest
 */
export interface VolumesRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * Symbol resolution. Possible resolutions are 1D,1W,1M
     *
     * @generated from protobuf field: string resolution = 2
     */
    resolution: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolumesResponse
 */
export interface VolumesResponse {
    /**
     * @generated from protobuf field: injective_archiver_rpc.HistoricalVolumes historical_volumes = 1
     */
    historicalVolumes?: HistoricalVolumes;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalVolumes
 */
export interface HistoricalVolumes {
    /**
     * Time, Unix timestamp (UTC)
     *
     * @generated from protobuf field: repeated sint32 t = 1
     */
    t: number[];
    /**
     * Volume value
     *
     * @generated from protobuf field: repeated double v = 2
     */
    v: number[];
}
/**
 * @generated from protobuf message injective_archiver_rpc.PnlLeaderboardRequest
 */
export interface PnlLeaderboardRequest {
    /**
     * Start date of the leaderboard period in unix time (ms)
     *
     * @generated from protobuf field: sint64 start_date = 1
     */
    startDate: bigint;
    /**
     * End date of the leaderboard period in unix time (ms)
     *
     * @generated from protobuf field: sint64 end_date = 2
     */
    endDate: bigint;
    /**
     * Number of leaderboard entries to return
     *
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
    /**
     * Account address that's querying the leaderboard
     *
     * @generated from protobuf field: string account = 4
     */
    account: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.PnlLeaderboardResponse
 */
export interface PnlLeaderboardResponse {
    /**
     * First date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string first_date = 1
     */
    firstDate: string;
    /**
     * Last date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string last_date = 2
     */
    lastDate: string;
    /**
     * Leaderboard entries
     *
     * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
     */
    leaders: LeaderboardRow[];
    /**
     * Leaderboard entry for the querying account
     *
     * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
     */
    accountRow?: LeaderboardRow;
}
/**
 * @generated from protobuf message injective_archiver_rpc.LeaderboardRow
 */
export interface LeaderboardRow {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * Realized profit and loss (USD)
     *
     * @generated from protobuf field: double pnl = 2
     */
    pnl: number;
    /**
     * Trade volume (USD)
     *
     * @generated from protobuf field: double volume = 3
     */
    volume: number;
    /**
     * Rank in leaderboard
     *
     * @generated from protobuf field: sint32 rank = 4
     */
    rank: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolLeaderboardRequest
 */
export interface VolLeaderboardRequest {
    /**
     * Start date of the leaderboard period in unix time (ms)
     *
     * @generated from protobuf field: sint64 start_date = 1
     */
    startDate: bigint;
    /**
     * End date of the leaderboard period in unix time (ms)
     *
     * @generated from protobuf field: sint64 end_date = 2
     */
    endDate: bigint;
    /**
     * Number of leaderboard entries to return
     *
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
    /**
     * Account address that's querying the leaderboard
     *
     * @generated from protobuf field: string account = 4
     */
    account: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolLeaderboardResponse
 */
export interface VolLeaderboardResponse {
    /**
     * First date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string first_date = 1
     */
    firstDate: string;
    /**
     * Last date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string last_date = 2
     */
    lastDate: string;
    /**
     * Leaderboard entries
     *
     * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
     */
    leaders: LeaderboardRow[];
    /**
     * Leaderboard entry for the querying account
     *
     * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
     */
    accountRow?: LeaderboardRow;
}
/**
 * @generated from protobuf message injective_archiver_rpc.PnlLeaderboardFixedResolutionRequest
 */
export interface PnlLeaderboardFixedResolutionRequest {
    /**
     * Leaderboard resolution. Possible resolutions are 1D,1W,1M,6M,ALL
     *
     * @generated from protobuf field: string resolution = 1
     */
    resolution: string;
    /**
     * Number of leaderboard entries to return
     *
     * @generated from protobuf field: sint32 limit = 2
     */
    limit: number;
    /**
     * Account address that's querying the leaderboard
     *
     * @generated from protobuf field: string account = 3
     */
    account: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.PnlLeaderboardFixedResolutionResponse
 */
export interface PnlLeaderboardFixedResolutionResponse {
    /**
     * First date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string first_date = 1
     */
    firstDate: string;
    /**
     * Last date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string last_date = 2
     */
    lastDate: string;
    /**
     * Leaderboard entries
     *
     * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
     */
    leaders: LeaderboardRow[];
    /**
     * Leaderboard entry for the querying account
     *
     * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
     */
    accountRow?: LeaderboardRow;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolLeaderboardFixedResolutionRequest
 */
export interface VolLeaderboardFixedResolutionRequest {
    /**
     * Leaderboard resolution. Possible resolutions are 1D,1W,1M,6M,ALL
     *
     * @generated from protobuf field: string resolution = 1
     */
    resolution: string;
    /**
     * Number of leaderboard entries to return
     *
     * @generated from protobuf field: sint32 limit = 2
     */
    limit: number;
    /**
     * Account address that's querying the leaderboard
     *
     * @generated from protobuf field: string account = 3
     */
    account: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolLeaderboardFixedResolutionResponse
 */
export interface VolLeaderboardFixedResolutionResponse {
    /**
     * First date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string first_date = 1
     */
    firstDate: string;
    /**
     * Last date of snapshots used for the leaderboard period
     *
     * @generated from protobuf field: string last_date = 2
     */
    lastDate: string;
    /**
     * Leaderboard entries
     *
     * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
     */
    leaders: LeaderboardRow[];
    /**
     * Leaderboard entry for the querying account
     *
     * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
     */
    accountRow?: LeaderboardRow;
}
/**
 * @generated from protobuf message injective_archiver_rpc.DenomHoldersRequest
 */
export interface DenomHoldersRequest {
    /**
     * Denom address
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * Token for pagination
     *
     * @generated from protobuf field: string token = 2
     */
    token: string;
    /**
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.DenomHoldersResponse
 */
export interface DenomHoldersResponse {
    /**
     * @generated from protobuf field: repeated injective_archiver_rpc.Holder holders = 1
     */
    holders: Holder[];
    /**
     * Next tokens for pagination
     *
     * @generated from protobuf field: repeated string next = 2
     */
    next: string[];
    /**
     * Total number of holders
     *
     * @generated from protobuf field: sint32 total = 3
     */
    total: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.Holder
 */
export interface Holder {
    /**
     * Account address for the holder
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * The balance of the holder
     *
     * @generated from protobuf field: string balance = 2
     */
    balance: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalTradesRequest
 */
export interface HistoricalTradesRequest {
    /**
     * The starting block height that the trades must be equal or older than
     *
     * @generated from protobuf field: uint64 from_block = 1
     */
    fromBlock: bigint;
    /**
     * The ending block height that the trades must be equal or older than
     *
     * @generated from protobuf field: uint64 end_block = 2
     */
    endBlock: bigint;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 from_time = 3
     */
    fromTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 end_time = 4
     */
    endTime: bigint;
    /**
     * The number of trades to return per page
     *
     * @generated from protobuf field: sint32 per_page = 5
     */
    perPage: number;
    /**
     * Token for pagination
     *
     * @generated from protobuf field: string token = 6
     */
    token: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 7
     */
    account: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalTradesResponse
 */
export interface HistoricalTradesResponse {
    /**
     * @generated from protobuf field: repeated injective_archiver_rpc.HistoricalTrade trades = 1
     */
    trades: HistoricalTrade[];
    /**
     * The last block height available in the service
     *
     * @generated from protobuf field: uint64 last_height = 2
     */
    lastHeight: bigint;
    /**
     * The timestamp of the last block available in the service
     *
     * @generated from protobuf field: sint64 last_time = 3
     */
    lastTime: bigint;
    /**
     * Next token for pagination
     *
     * @generated from protobuf field: repeated string next = 4
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalTrade
 */
export interface HistoricalTrade {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * The subaccountId that executed the trade
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * The ID of the market that this trade is in
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The direction the trade
     *
     * @generated from protobuf field: string trade_direction = 4
     */
    tradeDirection: string;
    /**
     * Price level at which trade has been executed
     *
     * @generated from protobuf field: injective_archiver_rpc.PriceLevel price = 5
     */
    price?: PriceLevel;
    /**
     * The fee associated with the trade (quote asset denom)
     *
     * @generated from protobuf field: string fee = 6
     */
    fee: string;
    /**
     * Timestamp of trade execution in UNIX millis
     *
     * @generated from protobuf field: sint64 executed_at = 7
     */
    executedAt: bigint;
    /**
     * Block height of trade execution
     *
     * @generated from protobuf field: uint64 executed_height = 8
     */
    executedHeight: bigint;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 9
     */
    feeRecipient: string;
    /**
     * Trade's execution side, maker/taker
     *
     * @generated from protobuf field: string execution_side = 10
     */
    executionSide: string;
    /**
     * USD value of the trade at the time of execution
     *
     * @generated from protobuf field: string usd_value = 11
     */
    usdValue: string;
    /**
     * A list of flag assigned to the trade
     *
     * @generated from protobuf field: repeated string flags = 12
     */
    flags: string[];
    /**
     * Type of market
     *
     * @generated from protobuf field: string market_type = 13
     */
    marketType: string;
    /**
     * Unique trade ID
     *
     * @generated from protobuf field: string trade_id = 14
     */
    tradeId: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.PriceLevel
 */
export interface PriceLevel {
    /**
     * Price number of the price level.
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * Quantity of the price level.
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * Price level last updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_archiver_rpc.StreamSpotAverageEntriesRequest
 */
export interface StreamSpotAverageEntriesRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.StreamSpotAverageEntriesResponse
 */
export interface StreamSpotAverageEntriesResponse {
    /**
     * List of spot average entries
     *
     * @generated from protobuf field: injective_archiver_rpc.SpotAverageEntry average_entry = 1
     */
    averageEntry?: SpotAverageEntry;
    /**
     * Operation timestamp in UNIX.
     *
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_archiver_rpc.SpotAverageEntry
 */
export interface SpotAverageEntry {
    /**
     * The ID of the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * The average entry price for the spot market
     *
     * @generated from protobuf field: string average_entry_price = 2
     */
    averageEntryPrice: string;
    /**
     * The total quantity held in the spot market
     *
     * @generated from protobuf field: string quantity = 3
     */
    quantity: string;
    /**
     * The USD value of the total quantity held in the spot market
     *
     * @generated from protobuf field: string usd_value = 4
     */
    usdValue: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class BalanceRequest$Type extends MessageType<BalanceRequest> {
    constructor() {
        super("injective_archiver_rpc.BalanceRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BalanceRequest>): BalanceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.resolution = "";
        if (value !== undefined)
            reflectionMergePartial<BalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceRequest): BalanceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string resolution */ 2:
                    message.resolution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string resolution = 2; */
        if (message.resolution !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resolution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.BalanceRequest
 */
export const BalanceRequest = new BalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceResponse$Type extends MessageType<BalanceResponse> {
    constructor() {
        super("injective_archiver_rpc.BalanceResponse", [
            { no: 1, name: "historical_balance", kind: "message", T: () => HistoricalBalance }
        ]);
    }
    create(value?: PartialMessage<BalanceResponse>): BalanceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceResponse): BalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_archiver_rpc.HistoricalBalance historical_balance */ 1:
                    message.historicalBalance = HistoricalBalance.internalBinaryRead(reader, reader.uint32(), options, message.historicalBalance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_archiver_rpc.HistoricalBalance historical_balance = 1; */
        if (message.historicalBalance)
            HistoricalBalance.internalBinaryWrite(message.historicalBalance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.BalanceResponse
 */
export const BalanceResponse = new BalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalBalance$Type extends MessageType<HistoricalBalance> {
    constructor() {
        super("injective_archiver_rpc.HistoricalBalance", [
            { no: 1, name: "t", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "v", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "dv", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HistoricalDetailedBalance }
        ]);
    }
    create(value?: PartialMessage<HistoricalBalance>): HistoricalBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = [];
        message.v = [];
        message.dv = [];
        if (value !== undefined)
            reflectionMergePartial<HistoricalBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalBalance): HistoricalBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sint32 t */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.t.push(reader.sint32());
                    else
                        message.t.push(reader.sint32());
                    break;
                case /* repeated double v */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.v.push(reader.double());
                    else
                        message.v.push(reader.double());
                    break;
                case /* repeated injective_archiver_rpc.HistoricalDetailedBalance dv */ 3:
                    message.dv.push(HistoricalDetailedBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sint32 t = 1; */
        if (message.t.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.t.length; i++)
                writer.sint32(message.t[i]);
            writer.join();
        }
        /* repeated double v = 2; */
        if (message.v.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.v.length; i++)
                writer.double(message.v[i]);
            writer.join();
        }
        /* repeated injective_archiver_rpc.HistoricalDetailedBalance dv = 3; */
        for (let i = 0; i < message.dv.length; i++)
            HistoricalDetailedBalance.internalBinaryWrite(message.dv[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalBalance
 */
export const HistoricalBalance = new HistoricalBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalDetailedBalance$Type extends MessageType<HistoricalDetailedBalance> {
    constructor() {
        super("injective_archiver_rpc.HistoricalDetailedBalance", [
            { no: 1, name: "spot", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "perp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "staking", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalDetailedBalance>): HistoricalDetailedBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spot = 0;
        message.perp = 0;
        message.staking = 0;
        if (value !== undefined)
            reflectionMergePartial<HistoricalDetailedBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalDetailedBalance): HistoricalDetailedBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double spot */ 1:
                    message.spot = reader.double();
                    break;
                case /* double perp */ 2:
                    message.perp = reader.double();
                    break;
                case /* double staking */ 3:
                    message.staking = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalDetailedBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double spot = 1; */
        if (message.spot !== 0)
            writer.tag(1, WireType.Bit64).double(message.spot);
        /* double perp = 2; */
        if (message.perp !== 0)
            writer.tag(2, WireType.Bit64).double(message.perp);
        /* double staking = 3; */
        if (message.staking !== 0)
            writer.tag(3, WireType.Bit64).double(message.staking);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalDetailedBalance
 */
export const HistoricalDetailedBalance = new HistoricalDetailedBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountStatsRequest$Type extends MessageType<AccountStatsRequest> {
    constructor() {
        super("injective_archiver_rpc.AccountStatsRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "period", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountStatsRequest>): AccountStatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.period = "";
        if (value !== undefined)
            reflectionMergePartial<AccountStatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountStatsRequest): AccountStatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string period */ 2:
                    message.period = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountStatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string period = 2; */
        if (message.period !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.period);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.AccountStatsRequest
 */
export const AccountStatsRequest = new AccountStatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountStatsResponse$Type extends MessageType<AccountStatsResponse> {
    constructor() {
        super("injective_archiver_rpc.AccountStatsResponse", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pnl", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "stake", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountStatsResponse>): AccountStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.pnl = 0;
        message.volume = 0;
        message.stake = "";
        if (value !== undefined)
            reflectionMergePartial<AccountStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountStatsResponse): AccountStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* double pnl */ 2:
                    message.pnl = reader.double();
                    break;
                case /* double volume */ 3:
                    message.volume = reader.double();
                    break;
                case /* string stake */ 4:
                    message.stake = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* double pnl = 2; */
        if (message.pnl !== 0)
            writer.tag(2, WireType.Bit64).double(message.pnl);
        /* double volume = 3; */
        if (message.volume !== 0)
            writer.tag(3, WireType.Bit64).double(message.volume);
        /* string stake = 4; */
        if (message.stake !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.stake);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.AccountStatsResponse
 */
export const AccountStatsResponse = new AccountStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpnlRequest$Type extends MessageType<RpnlRequest> {
    constructor() {
        super("injective_archiver_rpc.RpnlRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpnlRequest>): RpnlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.resolution = "";
        if (value !== undefined)
            reflectionMergePartial<RpnlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpnlRequest): RpnlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string resolution */ 2:
                    message.resolution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpnlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string resolution = 2; */
        if (message.resolution !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resolution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.RpnlRequest
 */
export const RpnlRequest = new RpnlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpnlResponse$Type extends MessageType<RpnlResponse> {
    constructor() {
        super("injective_archiver_rpc.RpnlResponse", [
            { no: 1, name: "historical_rpnl", kind: "message", T: () => HistoricalRPNL }
        ]);
    }
    create(value?: PartialMessage<RpnlResponse>): RpnlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RpnlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpnlResponse): RpnlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_archiver_rpc.HistoricalRPNL historical_rpnl */ 1:
                    message.historicalRpnl = HistoricalRPNL.internalBinaryRead(reader, reader.uint32(), options, message.historicalRpnl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpnlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_archiver_rpc.HistoricalRPNL historical_rpnl = 1; */
        if (message.historicalRpnl)
            HistoricalRPNL.internalBinaryWrite(message.historicalRpnl, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.RpnlResponse
 */
export const RpnlResponse = new RpnlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalRPNL$Type extends MessageType<HistoricalRPNL> {
    constructor() {
        super("injective_archiver_rpc.HistoricalRPNL", [
            { no: 1, name: "t", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "v", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "dv", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HistoricalDetailedPNL }
        ]);
    }
    create(value?: PartialMessage<HistoricalRPNL>): HistoricalRPNL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = [];
        message.v = [];
        message.dv = [];
        if (value !== undefined)
            reflectionMergePartial<HistoricalRPNL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalRPNL): HistoricalRPNL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sint32 t */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.t.push(reader.sint32());
                    else
                        message.t.push(reader.sint32());
                    break;
                case /* repeated double v */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.v.push(reader.double());
                    else
                        message.v.push(reader.double());
                    break;
                case /* repeated injective_archiver_rpc.HistoricalDetailedPNL dv */ 3:
                    message.dv.push(HistoricalDetailedPNL.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalRPNL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sint32 t = 1; */
        if (message.t.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.t.length; i++)
                writer.sint32(message.t[i]);
            writer.join();
        }
        /* repeated double v = 2; */
        if (message.v.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.v.length; i++)
                writer.double(message.v[i]);
            writer.join();
        }
        /* repeated injective_archiver_rpc.HistoricalDetailedPNL dv = 3; */
        for (let i = 0; i < message.dv.length; i++)
            HistoricalDetailedPNL.internalBinaryWrite(message.dv[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalRPNL
 */
export const HistoricalRPNL = new HistoricalRPNL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalDetailedPNL$Type extends MessageType<HistoricalDetailedPNL> {
    constructor() {
        super("injective_archiver_rpc.HistoricalDetailedPNL", [
            { no: 1, name: "rpnl", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "upnl", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalDetailedPNL>): HistoricalDetailedPNL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rpnl = 0;
        message.upnl = 0;
        if (value !== undefined)
            reflectionMergePartial<HistoricalDetailedPNL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalDetailedPNL): HistoricalDetailedPNL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rpnl */ 1:
                    message.rpnl = reader.double();
                    break;
                case /* double upnl */ 2:
                    message.upnl = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalDetailedPNL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rpnl = 1; */
        if (message.rpnl !== 0)
            writer.tag(1, WireType.Bit64).double(message.rpnl);
        /* double upnl = 2; */
        if (message.upnl !== 0)
            writer.tag(2, WireType.Bit64).double(message.upnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalDetailedPNL
 */
export const HistoricalDetailedPNL = new HistoricalDetailedPNL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolumesRequest$Type extends MessageType<VolumesRequest> {
    constructor() {
        super("injective_archiver_rpc.VolumesRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VolumesRequest>): VolumesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.resolution = "";
        if (value !== undefined)
            reflectionMergePartial<VolumesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolumesRequest): VolumesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string resolution */ 2:
                    message.resolution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolumesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string resolution = 2; */
        if (message.resolution !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resolution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolumesRequest
 */
export const VolumesRequest = new VolumesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolumesResponse$Type extends MessageType<VolumesResponse> {
    constructor() {
        super("injective_archiver_rpc.VolumesResponse", [
            { no: 1, name: "historical_volumes", kind: "message", T: () => HistoricalVolumes }
        ]);
    }
    create(value?: PartialMessage<VolumesResponse>): VolumesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VolumesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolumesResponse): VolumesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_archiver_rpc.HistoricalVolumes historical_volumes */ 1:
                    message.historicalVolumes = HistoricalVolumes.internalBinaryRead(reader, reader.uint32(), options, message.historicalVolumes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolumesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_archiver_rpc.HistoricalVolumes historical_volumes = 1; */
        if (message.historicalVolumes)
            HistoricalVolumes.internalBinaryWrite(message.historicalVolumes, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolumesResponse
 */
export const VolumesResponse = new VolumesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalVolumes$Type extends MessageType<HistoricalVolumes> {
    constructor() {
        super("injective_archiver_rpc.HistoricalVolumes", [
            { no: 1, name: "t", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "v", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalVolumes>): HistoricalVolumes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = [];
        message.v = [];
        if (value !== undefined)
            reflectionMergePartial<HistoricalVolumes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalVolumes): HistoricalVolumes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sint32 t */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.t.push(reader.sint32());
                    else
                        message.t.push(reader.sint32());
                    break;
                case /* repeated double v */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.v.push(reader.double());
                    else
                        message.v.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalVolumes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sint32 t = 1; */
        if (message.t.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.t.length; i++)
                writer.sint32(message.t[i]);
            writer.join();
        }
        /* repeated double v = 2; */
        if (message.v.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.v.length; i++)
                writer.double(message.v[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalVolumes
 */
export const HistoricalVolumes = new HistoricalVolumes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PnlLeaderboardRequest$Type extends MessageType<PnlLeaderboardRequest> {
    constructor() {
        super("injective_archiver_rpc.PnlLeaderboardRequest", [
            { no: 1, name: "start_date", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PnlLeaderboardRequest>): PnlLeaderboardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = 0n;
        message.endDate = 0n;
        message.limit = 0;
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<PnlLeaderboardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PnlLeaderboardRequest): PnlLeaderboardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 start_date */ 1:
                    message.startDate = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_date */ 2:
                    message.endDate = reader.sint64().toBigInt();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* string account */ 4:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PnlLeaderboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 start_date = 1; */
        if (message.startDate !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.startDate);
        /* sint64 end_date = 2; */
        if (message.endDate !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.endDate);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* string account = 4; */
        if (message.account !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.PnlLeaderboardRequest
 */
export const PnlLeaderboardRequest = new PnlLeaderboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PnlLeaderboardResponse$Type extends MessageType<PnlLeaderboardResponse> {
    constructor() {
        super("injective_archiver_rpc.PnlLeaderboardResponse", [
            { no: 1, name: "first_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leaders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardRow },
            { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
        ]);
    }
    create(value?: PartialMessage<PnlLeaderboardResponse>): PnlLeaderboardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.firstDate = "";
        message.lastDate = "";
        message.leaders = [];
        if (value !== undefined)
            reflectionMergePartial<PnlLeaderboardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PnlLeaderboardResponse): PnlLeaderboardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string first_date */ 1:
                    message.firstDate = reader.string();
                    break;
                case /* string last_date */ 2:
                    message.lastDate = reader.string();
                    break;
                case /* repeated injective_archiver_rpc.LeaderboardRow leaders */ 3:
                    message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_archiver_rpc.LeaderboardRow account_row */ 4:
                    message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PnlLeaderboardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string first_date = 1; */
        if (message.firstDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
        /* string last_date = 2; */
        if (message.lastDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
        /* repeated injective_archiver_rpc.LeaderboardRow leaders = 3; */
        for (let i = 0; i < message.leaders.length; i++)
            LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_archiver_rpc.LeaderboardRow account_row = 4; */
        if (message.accountRow)
            LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.PnlLeaderboardResponse
 */
export const PnlLeaderboardResponse = new PnlLeaderboardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardRow$Type extends MessageType<LeaderboardRow> {
    constructor() {
        super("injective_archiver_rpc.LeaderboardRow", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pnl", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "rank", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardRow>): LeaderboardRow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.pnl = 0;
        message.volume = 0;
        message.rank = 0;
        if (value !== undefined)
            reflectionMergePartial<LeaderboardRow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardRow): LeaderboardRow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* double pnl */ 2:
                    message.pnl = reader.double();
                    break;
                case /* double volume */ 3:
                    message.volume = reader.double();
                    break;
                case /* sint32 rank */ 4:
                    message.rank = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardRow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* double pnl = 2; */
        if (message.pnl !== 0)
            writer.tag(2, WireType.Bit64).double(message.pnl);
        /* double volume = 3; */
        if (message.volume !== 0)
            writer.tag(3, WireType.Bit64).double(message.volume);
        /* sint32 rank = 4; */
        if (message.rank !== 0)
            writer.tag(4, WireType.Varint).sint32(message.rank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.LeaderboardRow
 */
export const LeaderboardRow = new LeaderboardRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolLeaderboardRequest$Type extends MessageType<VolLeaderboardRequest> {
    constructor() {
        super("injective_archiver_rpc.VolLeaderboardRequest", [
            { no: 1, name: "start_date", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VolLeaderboardRequest>): VolLeaderboardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = 0n;
        message.endDate = 0n;
        message.limit = 0;
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<VolLeaderboardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolLeaderboardRequest): VolLeaderboardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 start_date */ 1:
                    message.startDate = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_date */ 2:
                    message.endDate = reader.sint64().toBigInt();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* string account */ 4:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolLeaderboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 start_date = 1; */
        if (message.startDate !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.startDate);
        /* sint64 end_date = 2; */
        if (message.endDate !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.endDate);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* string account = 4; */
        if (message.account !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolLeaderboardRequest
 */
export const VolLeaderboardRequest = new VolLeaderboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolLeaderboardResponse$Type extends MessageType<VolLeaderboardResponse> {
    constructor() {
        super("injective_archiver_rpc.VolLeaderboardResponse", [
            { no: 1, name: "first_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leaders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardRow },
            { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
        ]);
    }
    create(value?: PartialMessage<VolLeaderboardResponse>): VolLeaderboardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.firstDate = "";
        message.lastDate = "";
        message.leaders = [];
        if (value !== undefined)
            reflectionMergePartial<VolLeaderboardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolLeaderboardResponse): VolLeaderboardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string first_date */ 1:
                    message.firstDate = reader.string();
                    break;
                case /* string last_date */ 2:
                    message.lastDate = reader.string();
                    break;
                case /* repeated injective_archiver_rpc.LeaderboardRow leaders */ 3:
                    message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_archiver_rpc.LeaderboardRow account_row */ 4:
                    message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolLeaderboardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string first_date = 1; */
        if (message.firstDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
        /* string last_date = 2; */
        if (message.lastDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
        /* repeated injective_archiver_rpc.LeaderboardRow leaders = 3; */
        for (let i = 0; i < message.leaders.length; i++)
            LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_archiver_rpc.LeaderboardRow account_row = 4; */
        if (message.accountRow)
            LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolLeaderboardResponse
 */
export const VolLeaderboardResponse = new VolLeaderboardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PnlLeaderboardFixedResolutionRequest$Type extends MessageType<PnlLeaderboardFixedResolutionRequest> {
    constructor() {
        super("injective_archiver_rpc.PnlLeaderboardFixedResolutionRequest", [
            { no: 1, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PnlLeaderboardFixedResolutionRequest>): PnlLeaderboardFixedResolutionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resolution = "";
        message.limit = 0;
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<PnlLeaderboardFixedResolutionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PnlLeaderboardFixedResolutionRequest): PnlLeaderboardFixedResolutionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resolution */ 1:
                    message.resolution = reader.string();
                    break;
                case /* sint32 limit */ 2:
                    message.limit = reader.sint32();
                    break;
                case /* string account */ 3:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PnlLeaderboardFixedResolutionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resolution = 1; */
        if (message.resolution !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resolution);
        /* sint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).sint32(message.limit);
        /* string account = 3; */
        if (message.account !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.PnlLeaderboardFixedResolutionRequest
 */
export const PnlLeaderboardFixedResolutionRequest = new PnlLeaderboardFixedResolutionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PnlLeaderboardFixedResolutionResponse$Type extends MessageType<PnlLeaderboardFixedResolutionResponse> {
    constructor() {
        super("injective_archiver_rpc.PnlLeaderboardFixedResolutionResponse", [
            { no: 1, name: "first_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leaders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardRow },
            { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
        ]);
    }
    create(value?: PartialMessage<PnlLeaderboardFixedResolutionResponse>): PnlLeaderboardFixedResolutionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.firstDate = "";
        message.lastDate = "";
        message.leaders = [];
        if (value !== undefined)
            reflectionMergePartial<PnlLeaderboardFixedResolutionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PnlLeaderboardFixedResolutionResponse): PnlLeaderboardFixedResolutionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string first_date */ 1:
                    message.firstDate = reader.string();
                    break;
                case /* string last_date */ 2:
                    message.lastDate = reader.string();
                    break;
                case /* repeated injective_archiver_rpc.LeaderboardRow leaders */ 3:
                    message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_archiver_rpc.LeaderboardRow account_row */ 4:
                    message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PnlLeaderboardFixedResolutionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string first_date = 1; */
        if (message.firstDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
        /* string last_date = 2; */
        if (message.lastDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
        /* repeated injective_archiver_rpc.LeaderboardRow leaders = 3; */
        for (let i = 0; i < message.leaders.length; i++)
            LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_archiver_rpc.LeaderboardRow account_row = 4; */
        if (message.accountRow)
            LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.PnlLeaderboardFixedResolutionResponse
 */
export const PnlLeaderboardFixedResolutionResponse = new PnlLeaderboardFixedResolutionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolLeaderboardFixedResolutionRequest$Type extends MessageType<VolLeaderboardFixedResolutionRequest> {
    constructor() {
        super("injective_archiver_rpc.VolLeaderboardFixedResolutionRequest", [
            { no: 1, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VolLeaderboardFixedResolutionRequest>): VolLeaderboardFixedResolutionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resolution = "";
        message.limit = 0;
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<VolLeaderboardFixedResolutionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolLeaderboardFixedResolutionRequest): VolLeaderboardFixedResolutionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resolution */ 1:
                    message.resolution = reader.string();
                    break;
                case /* sint32 limit */ 2:
                    message.limit = reader.sint32();
                    break;
                case /* string account */ 3:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolLeaderboardFixedResolutionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resolution = 1; */
        if (message.resolution !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resolution);
        /* sint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).sint32(message.limit);
        /* string account = 3; */
        if (message.account !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolLeaderboardFixedResolutionRequest
 */
export const VolLeaderboardFixedResolutionRequest = new VolLeaderboardFixedResolutionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolLeaderboardFixedResolutionResponse$Type extends MessageType<VolLeaderboardFixedResolutionResponse> {
    constructor() {
        super("injective_archiver_rpc.VolLeaderboardFixedResolutionResponse", [
            { no: 1, name: "first_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leaders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardRow },
            { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
        ]);
    }
    create(value?: PartialMessage<VolLeaderboardFixedResolutionResponse>): VolLeaderboardFixedResolutionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.firstDate = "";
        message.lastDate = "";
        message.leaders = [];
        if (value !== undefined)
            reflectionMergePartial<VolLeaderboardFixedResolutionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolLeaderboardFixedResolutionResponse): VolLeaderboardFixedResolutionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string first_date */ 1:
                    message.firstDate = reader.string();
                    break;
                case /* string last_date */ 2:
                    message.lastDate = reader.string();
                    break;
                case /* repeated injective_archiver_rpc.LeaderboardRow leaders */ 3:
                    message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_archiver_rpc.LeaderboardRow account_row */ 4:
                    message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolLeaderboardFixedResolutionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string first_date = 1; */
        if (message.firstDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
        /* string last_date = 2; */
        if (message.lastDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
        /* repeated injective_archiver_rpc.LeaderboardRow leaders = 3; */
        for (let i = 0; i < message.leaders.length; i++)
            LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_archiver_rpc.LeaderboardRow account_row = 4; */
        if (message.accountRow)
            LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolLeaderboardFixedResolutionResponse
 */
export const VolLeaderboardFixedResolutionResponse = new VolLeaderboardFixedResolutionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomHoldersRequest$Type extends MessageType<DenomHoldersRequest> {
    constructor() {
        super("injective_archiver_rpc.DenomHoldersRequest", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DenomHoldersRequest>): DenomHoldersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.token = "";
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<DenomHoldersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomHoldersRequest): DenomHoldersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomHoldersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.DenomHoldersRequest
 */
export const DenomHoldersRequest = new DenomHoldersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomHoldersResponse$Type extends MessageType<DenomHoldersResponse> {
    constructor() {
        super("injective_archiver_rpc.DenomHoldersResponse", [
            { no: 1, name: "holders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Holder },
            { no: 2, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DenomHoldersResponse>): DenomHoldersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.holders = [];
        message.next = [];
        message.total = 0;
        if (value !== undefined)
            reflectionMergePartial<DenomHoldersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomHoldersResponse): DenomHoldersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_archiver_rpc.Holder holders */ 1:
                    message.holders.push(Holder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string next */ 2:
                    message.next.push(reader.string());
                    break;
                case /* sint32 total */ 3:
                    message.total = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomHoldersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_archiver_rpc.Holder holders = 1; */
        for (let i = 0; i < message.holders.length; i++)
            Holder.internalBinaryWrite(message.holders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string next = 2; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
        /* sint32 total = 3; */
        if (message.total !== 0)
            writer.tag(3, WireType.Varint).sint32(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.DenomHoldersResponse
 */
export const DenomHoldersResponse = new DenomHoldersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Holder$Type extends MessageType<Holder> {
    constructor() {
        super("injective_archiver_rpc.Holder", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Holder>): Holder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.balance = "";
        if (value !== undefined)
            reflectionMergePartial<Holder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Holder): Holder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* string balance */ 2:
                    message.balance = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Holder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* string balance = 2; */
        if (message.balance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.balance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.Holder
 */
export const Holder = new Holder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalTradesRequest$Type extends MessageType<HistoricalTradesRequest> {
    constructor() {
        super("injective_archiver_rpc.HistoricalTradesRequest", [
            { no: 1, name: "from_block", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end_block", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "from_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalTradesRequest>): HistoricalTradesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromBlock = 0n;
        message.endBlock = 0n;
        message.fromTime = 0n;
        message.endTime = 0n;
        message.perPage = 0;
        message.token = "";
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<HistoricalTradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalTradesRequest): HistoricalTradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 from_block */ 1:
                    message.fromBlock = reader.uint64().toBigInt();
                    break;
                case /* uint64 end_block */ 2:
                    message.endBlock = reader.uint64().toBigInt();
                    break;
                case /* sint64 from_time */ 3:
                    message.fromTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 4:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* sint32 per_page */ 5:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 6:
                    message.token = reader.string();
                    break;
                case /* string account */ 7:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalTradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 from_block = 1; */
        if (message.fromBlock !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.fromBlock);
        /* uint64 end_block = 2; */
        if (message.endBlock !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.endBlock);
        /* sint64 from_time = 3; */
        if (message.fromTime !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.fromTime);
        /* sint64 end_time = 4; */
        if (message.endTime !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.endTime);
        /* sint32 per_page = 5; */
        if (message.perPage !== 0)
            writer.tag(5, WireType.Varint).sint32(message.perPage);
        /* string token = 6; */
        if (message.token !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.token);
        /* string account = 7; */
        if (message.account !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalTradesRequest
 */
export const HistoricalTradesRequest = new HistoricalTradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalTradesResponse$Type extends MessageType<HistoricalTradesResponse> {
    constructor() {
        super("injective_archiver_rpc.HistoricalTradesResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HistoricalTrade },
            { no: 2, name: "last_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalTradesResponse>): HistoricalTradesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trades = [];
        message.lastHeight = 0n;
        message.lastTime = 0n;
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<HistoricalTradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalTradesResponse): HistoricalTradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_archiver_rpc.HistoricalTrade trades */ 1:
                    message.trades.push(HistoricalTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 last_height */ 2:
                    message.lastHeight = reader.uint64().toBigInt();
                    break;
                case /* sint64 last_time */ 3:
                    message.lastTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string next */ 4:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalTradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_archiver_rpc.HistoricalTrade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            HistoricalTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 last_height = 2; */
        if (message.lastHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.lastHeight);
        /* sint64 last_time = 3; */
        if (message.lastTime !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.lastTime);
        /* repeated string next = 4; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalTradesResponse
 */
export const HistoricalTradesResponse = new HistoricalTradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalTrade$Type extends MessageType<HistoricalTrade> {
    constructor() {
        super("injective_archiver_rpc.HistoricalTrade", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "trade_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "price", kind: "message", T: () => PriceLevel },
            { no: 6, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "executed_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "market_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalTrade>): HistoricalTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.subaccountId = "";
        message.marketId = "";
        message.tradeDirection = "";
        message.fee = "";
        message.executedAt = 0n;
        message.executedHeight = 0n;
        message.feeRecipient = "";
        message.executionSide = "";
        message.usdValue = "";
        message.flags = [];
        message.marketType = "";
        message.tradeId = "";
        if (value !== undefined)
            reflectionMergePartial<HistoricalTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalTrade): HistoricalTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string trade_direction */ 4:
                    message.tradeDirection = reader.string();
                    break;
                case /* injective_archiver_rpc.PriceLevel price */ 5:
                    message.price = PriceLevel.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* string fee */ 6:
                    message.fee = reader.string();
                    break;
                case /* sint64 executed_at */ 7:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* uint64 executed_height */ 8:
                    message.executedHeight = reader.uint64().toBigInt();
                    break;
                case /* string fee_recipient */ 9:
                    message.feeRecipient = reader.string();
                    break;
                case /* string execution_side */ 10:
                    message.executionSide = reader.string();
                    break;
                case /* string usd_value */ 11:
                    message.usdValue = reader.string();
                    break;
                case /* repeated string flags */ 12:
                    message.flags.push(reader.string());
                    break;
                case /* string market_type */ 13:
                    message.marketType = reader.string();
                    break;
                case /* string trade_id */ 14:
                    message.tradeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string trade_direction = 4; */
        if (message.tradeDirection !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tradeDirection);
        /* injective_archiver_rpc.PriceLevel price = 5; */
        if (message.price)
            PriceLevel.internalBinaryWrite(message.price, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string fee = 6; */
        if (message.fee !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fee);
        /* sint64 executed_at = 7; */
        if (message.executedAt !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.executedAt);
        /* uint64 executed_height = 8; */
        if (message.executedHeight !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.executedHeight);
        /* string fee_recipient = 9; */
        if (message.feeRecipient !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
        /* string execution_side = 10; */
        if (message.executionSide !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.executionSide);
        /* string usd_value = 11; */
        if (message.usdValue !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.usdValue);
        /* repeated string flags = 12; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.flags[i]);
        /* string market_type = 13; */
        if (message.marketType !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.marketType);
        /* string trade_id = 14; */
        if (message.tradeId !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.tradeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalTrade
 */
export const HistoricalTrade = new HistoricalTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevel$Type extends MessageType<PriceLevel> {
    constructor() {
        super("injective_archiver_rpc.PriceLevel", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceLevel>): PriceLevel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevel): PriceLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.PriceLevel
 */
export const PriceLevel = new PriceLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamSpotAverageEntriesRequest$Type extends MessageType<StreamSpotAverageEntriesRequest> {
    constructor() {
        super("injective_archiver_rpc.StreamSpotAverageEntriesRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamSpotAverageEntriesRequest>): StreamSpotAverageEntriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<StreamSpotAverageEntriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamSpotAverageEntriesRequest): StreamSpotAverageEntriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamSpotAverageEntriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.StreamSpotAverageEntriesRequest
 */
export const StreamSpotAverageEntriesRequest = new StreamSpotAverageEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamSpotAverageEntriesResponse$Type extends MessageType<StreamSpotAverageEntriesResponse> {
    constructor() {
        super("injective_archiver_rpc.StreamSpotAverageEntriesResponse", [
            { no: 1, name: "average_entry", kind: "message", T: () => SpotAverageEntry },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamSpotAverageEntriesResponse>): StreamSpotAverageEntriesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamSpotAverageEntriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamSpotAverageEntriesResponse): StreamSpotAverageEntriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_archiver_rpc.SpotAverageEntry average_entry */ 1:
                    message.averageEntry = SpotAverageEntry.internalBinaryRead(reader, reader.uint32(), options, message.averageEntry);
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamSpotAverageEntriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_archiver_rpc.SpotAverageEntry average_entry = 1; */
        if (message.averageEntry)
            SpotAverageEntry.internalBinaryWrite(message.averageEntry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.StreamSpotAverageEntriesResponse
 */
export const StreamSpotAverageEntriesResponse = new StreamSpotAverageEntriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotAverageEntry$Type extends MessageType<SpotAverageEntry> {
    constructor() {
        super("injective_archiver_rpc.SpotAverageEntry", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "average_entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotAverageEntry>): SpotAverageEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.averageEntryPrice = "";
        message.quantity = "";
        message.usdValue = "";
        if (value !== undefined)
            reflectionMergePartial<SpotAverageEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotAverageEntry): SpotAverageEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string average_entry_price */ 2:
                    message.averageEntryPrice = reader.string();
                    break;
                case /* string quantity */ 3:
                    message.quantity = reader.string();
                    break;
                case /* string usd_value */ 4:
                    message.usdValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotAverageEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string average_entry_price = 2; */
        if (message.averageEntryPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.averageEntryPrice);
        /* string quantity = 3; */
        if (message.quantity !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quantity);
        /* string usd_value = 4; */
        if (message.usdValue !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.usdValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.SpotAverageEntry
 */
export const SpotAverageEntry = new SpotAverageEntry$Type();
/**
 * @generated ServiceType for protobuf service injective_archiver_rpc.InjectiveArchiverRPC
 */
export const InjectiveArchiverRPC = new ServiceType("injective_archiver_rpc.InjectiveArchiverRPC", [
    { name: "Balance", options: {}, I: BalanceRequest, O: BalanceResponse },
    { name: "AccountStats", options: {}, I: AccountStatsRequest, O: AccountStatsResponse },
    { name: "Rpnl", options: {}, I: RpnlRequest, O: RpnlResponse },
    { name: "Volumes", options: {}, I: VolumesRequest, O: VolumesResponse },
    { name: "PnlLeaderboard", options: {}, I: PnlLeaderboardRequest, O: PnlLeaderboardResponse },
    { name: "VolLeaderboard", options: {}, I: VolLeaderboardRequest, O: VolLeaderboardResponse },
    { name: "PnlLeaderboardFixedResolution", options: {}, I: PnlLeaderboardFixedResolutionRequest, O: PnlLeaderboardFixedResolutionResponse },
    { name: "VolLeaderboardFixedResolution", options: {}, I: VolLeaderboardFixedResolutionRequest, O: VolLeaderboardFixedResolutionResponse },
    { name: "DenomHolders", options: {}, I: DenomHoldersRequest, O: DenomHoldersResponse },
    { name: "HistoricalTrades", options: {}, I: HistoricalTradesRequest, O: HistoricalTradesResponse },
    { name: "StreamSpotAverageEntries", serverStreaming: true, options: {}, I: StreamSpotAverageEntriesRequest, O: StreamSpotAverageEntriesResponse }
]);
