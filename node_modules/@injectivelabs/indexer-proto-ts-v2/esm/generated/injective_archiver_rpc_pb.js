import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class BalanceRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.BalanceRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.resolution = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string resolution */
        2:
          message.resolution = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.resolution !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.resolution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BalanceRequest = new BalanceRequest$Type();
class BalanceResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.BalanceResponse", [
      { no: 1, name: "historical_balance", kind: "message", T: () => HistoricalBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_archiver_rpc.HistoricalBalance historical_balance */
        1:
          message.historicalBalance = HistoricalBalance.internalBinaryRead(reader, reader.uint32(), options, message.historicalBalance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.historicalBalance)
      HistoricalBalance.internalBinaryWrite(message.historicalBalance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BalanceResponse = new BalanceResponse$Type();
class HistoricalBalance$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalBalance", [
      {
        no: 1,
        name: "t",
        kind: "scalar",
        repeat: 1,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "v",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 3, name: "dv", kind: "message", repeat: 2, T: () => HistoricalDetailedBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.t = [];
    message.v = [];
    message.dv = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sint32 t */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.t.push(reader.sint32());
          else
            message.t.push(reader.sint32());
          break;
        case /* repeated double v */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.v.push(reader.double());
          else
            message.v.push(reader.double());
          break;
        case /* repeated injective_archiver_rpc.HistoricalDetailedBalance dv */
        3:
          message.dv.push(HistoricalDetailedBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.t.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.t.length; i++)
        writer.sint32(message.t[i]);
      writer.join();
    }
    if (message.v.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.v.length; i++)
        writer.double(message.v[i]);
      writer.join();
    }
    for (let i = 0; i < message.dv.length; i++)
      HistoricalDetailedBalance.internalBinaryWrite(message.dv[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalBalance = new HistoricalBalance$Type();
class HistoricalDetailedBalance$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalDetailedBalance", [
      {
        no: 1,
        name: "spot",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "perp",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "staking",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.spot = 0;
    message.perp = 0;
    message.staking = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double spot */
        1:
          message.spot = reader.double();
          break;
        case /* double perp */
        2:
          message.perp = reader.double();
          break;
        case /* double staking */
        3:
          message.staking = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.spot !== 0)
      writer.tag(1, WireType.Bit64).double(message.spot);
    if (message.perp !== 0)
      writer.tag(2, WireType.Bit64).double(message.perp);
    if (message.staking !== 0)
      writer.tag(3, WireType.Bit64).double(message.staking);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalDetailedBalance = new HistoricalDetailedBalance$Type();
class AccountStatsRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.AccountStatsRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "period",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.period = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string period */
        2:
          message.period = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.period !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.period);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountStatsRequest = new AccountStatsRequest$Type();
class AccountStatsResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.AccountStatsResponse", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pnl",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "stake",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.pnl = 0;
    message.volume = 0;
    message.stake = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* double pnl */
        2:
          message.pnl = reader.double();
          break;
        case /* double volume */
        3:
          message.volume = reader.double();
          break;
        case /* string stake */
        4:
          message.stake = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.pnl !== 0)
      writer.tag(2, WireType.Bit64).double(message.pnl);
    if (message.volume !== 0)
      writer.tag(3, WireType.Bit64).double(message.volume);
    if (message.stake !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.stake);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountStatsResponse = new AccountStatsResponse$Type();
class RpnlRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.RpnlRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.resolution = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string resolution */
        2:
          message.resolution = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.resolution !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.resolution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RpnlRequest = new RpnlRequest$Type();
class RpnlResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.RpnlResponse", [
      { no: 1, name: "historical_rpnl", kind: "message", T: () => HistoricalRPNL }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_archiver_rpc.HistoricalRPNL historical_rpnl */
        1:
          message.historicalRpnl = HistoricalRPNL.internalBinaryRead(reader, reader.uint32(), options, message.historicalRpnl);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.historicalRpnl)
      HistoricalRPNL.internalBinaryWrite(message.historicalRpnl, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RpnlResponse = new RpnlResponse$Type();
class HistoricalRPNL$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalRPNL", [
      {
        no: 1,
        name: "t",
        kind: "scalar",
        repeat: 1,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "v",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 3, name: "dv", kind: "message", repeat: 2, T: () => HistoricalDetailedPNL }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.t = [];
    message.v = [];
    message.dv = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sint32 t */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.t.push(reader.sint32());
          else
            message.t.push(reader.sint32());
          break;
        case /* repeated double v */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.v.push(reader.double());
          else
            message.v.push(reader.double());
          break;
        case /* repeated injective_archiver_rpc.HistoricalDetailedPNL dv */
        3:
          message.dv.push(HistoricalDetailedPNL.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.t.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.t.length; i++)
        writer.sint32(message.t[i]);
      writer.join();
    }
    if (message.v.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.v.length; i++)
        writer.double(message.v[i]);
      writer.join();
    }
    for (let i = 0; i < message.dv.length; i++)
      HistoricalDetailedPNL.internalBinaryWrite(message.dv[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalRPNL = new HistoricalRPNL$Type();
class HistoricalDetailedPNL$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalDetailedPNL", [
      {
        no: 1,
        name: "rpnl",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "upnl",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rpnl = 0;
    message.upnl = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double rpnl */
        1:
          message.rpnl = reader.double();
          break;
        case /* double upnl */
        2:
          message.upnl = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rpnl !== 0)
      writer.tag(1, WireType.Bit64).double(message.rpnl);
    if (message.upnl !== 0)
      writer.tag(2, WireType.Bit64).double(message.upnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalDetailedPNL = new HistoricalDetailedPNL$Type();
class VolumesRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.VolumesRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.resolution = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string resolution */
        2:
          message.resolution = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.resolution !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.resolution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolumesRequest = new VolumesRequest$Type();
class VolumesResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.VolumesResponse", [
      { no: 1, name: "historical_volumes", kind: "message", T: () => HistoricalVolumes }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_archiver_rpc.HistoricalVolumes historical_volumes */
        1:
          message.historicalVolumes = HistoricalVolumes.internalBinaryRead(reader, reader.uint32(), options, message.historicalVolumes);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.historicalVolumes)
      HistoricalVolumes.internalBinaryWrite(message.historicalVolumes, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolumesResponse = new VolumesResponse$Type();
class HistoricalVolumes$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalVolumes", [
      {
        no: 1,
        name: "t",
        kind: "scalar",
        repeat: 1,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "v",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.t = [];
    message.v = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sint32 t */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.t.push(reader.sint32());
          else
            message.t.push(reader.sint32());
          break;
        case /* repeated double v */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.v.push(reader.double());
          else
            message.v.push(reader.double());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.t.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.t.length; i++)
        writer.sint32(message.t[i]);
      writer.join();
    }
    if (message.v.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.v.length; i++)
        writer.double(message.v[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalVolumes = new HistoricalVolumes$Type();
class PnlLeaderboardRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.PnlLeaderboardRequest", [
      {
        no: 1,
        name: "start_date",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "end_date",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.startDate = 0n;
    message.endDate = 0n;
    message.limit = 0;
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 start_date */
        1:
          message.startDate = reader.sint64().toBigInt();
          break;
        case /* sint64 end_date */
        2:
          message.endDate = reader.sint64().toBigInt();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* string account */
        4:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.startDate !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.startDate);
    if (message.endDate !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.endDate);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.account !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PnlLeaderboardRequest = new PnlLeaderboardRequest$Type();
class PnlLeaderboardResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.PnlLeaderboardResponse", [
      {
        no: 1,
        name: "first_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "last_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "leaders", kind: "message", repeat: 2, T: () => LeaderboardRow },
      { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.firstDate = "";
    message.lastDate = "";
    message.leaders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string first_date */
        1:
          message.firstDate = reader.string();
          break;
        case /* string last_date */
        2:
          message.lastDate = reader.string();
          break;
        case /* repeated injective_archiver_rpc.LeaderboardRow leaders */
        3:
          message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_archiver_rpc.LeaderboardRow account_row */
        4:
          message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.firstDate !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
    if (message.lastDate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
    for (let i = 0; i < message.leaders.length; i++)
      LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.accountRow)
      LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PnlLeaderboardResponse = new PnlLeaderboardResponse$Type();
class LeaderboardRow$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.LeaderboardRow", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pnl",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "rank",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.pnl = 0;
    message.volume = 0;
    message.rank = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* double pnl */
        2:
          message.pnl = reader.double();
          break;
        case /* double volume */
        3:
          message.volume = reader.double();
          break;
        case /* sint32 rank */
        4:
          message.rank = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.pnl !== 0)
      writer.tag(2, WireType.Bit64).double(message.pnl);
    if (message.volume !== 0)
      writer.tag(3, WireType.Bit64).double(message.volume);
    if (message.rank !== 0)
      writer.tag(4, WireType.Varint).sint32(message.rank);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardRow = new LeaderboardRow$Type();
class VolLeaderboardRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.VolLeaderboardRequest", [
      {
        no: 1,
        name: "start_date",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "end_date",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.startDate = 0n;
    message.endDate = 0n;
    message.limit = 0;
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 start_date */
        1:
          message.startDate = reader.sint64().toBigInt();
          break;
        case /* sint64 end_date */
        2:
          message.endDate = reader.sint64().toBigInt();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* string account */
        4:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.startDate !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.startDate);
    if (message.endDate !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.endDate);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.account !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolLeaderboardRequest = new VolLeaderboardRequest$Type();
class VolLeaderboardResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.VolLeaderboardResponse", [
      {
        no: 1,
        name: "first_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "last_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "leaders", kind: "message", repeat: 2, T: () => LeaderboardRow },
      { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.firstDate = "";
    message.lastDate = "";
    message.leaders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string first_date */
        1:
          message.firstDate = reader.string();
          break;
        case /* string last_date */
        2:
          message.lastDate = reader.string();
          break;
        case /* repeated injective_archiver_rpc.LeaderboardRow leaders */
        3:
          message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_archiver_rpc.LeaderboardRow account_row */
        4:
          message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.firstDate !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
    if (message.lastDate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
    for (let i = 0; i < message.leaders.length; i++)
      LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.accountRow)
      LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolLeaderboardResponse = new VolLeaderboardResponse$Type();
class PnlLeaderboardFixedResolutionRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.PnlLeaderboardFixedResolutionRequest", [
      {
        no: 1,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.resolution = "";
    message.limit = 0;
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string resolution */
        1:
          message.resolution = reader.string();
          break;
        case /* sint32 limit */
        2:
          message.limit = reader.sint32();
          break;
        case /* string account */
        3:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.resolution !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.resolution);
    if (message.limit !== 0)
      writer.tag(2, WireType.Varint).sint32(message.limit);
    if (message.account !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PnlLeaderboardFixedResolutionRequest = new PnlLeaderboardFixedResolutionRequest$Type();
class PnlLeaderboardFixedResolutionResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.PnlLeaderboardFixedResolutionResponse", [
      {
        no: 1,
        name: "first_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "last_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "leaders", kind: "message", repeat: 2, T: () => LeaderboardRow },
      { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.firstDate = "";
    message.lastDate = "";
    message.leaders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string first_date */
        1:
          message.firstDate = reader.string();
          break;
        case /* string last_date */
        2:
          message.lastDate = reader.string();
          break;
        case /* repeated injective_archiver_rpc.LeaderboardRow leaders */
        3:
          message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_archiver_rpc.LeaderboardRow account_row */
        4:
          message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.firstDate !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
    if (message.lastDate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
    for (let i = 0; i < message.leaders.length; i++)
      LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.accountRow)
      LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PnlLeaderboardFixedResolutionResponse = new PnlLeaderboardFixedResolutionResponse$Type();
class VolLeaderboardFixedResolutionRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.VolLeaderboardFixedResolutionRequest", [
      {
        no: 1,
        name: "resolution",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.resolution = "";
    message.limit = 0;
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string resolution */
        1:
          message.resolution = reader.string();
          break;
        case /* sint32 limit */
        2:
          message.limit = reader.sint32();
          break;
        case /* string account */
        3:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.resolution !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.resolution);
    if (message.limit !== 0)
      writer.tag(2, WireType.Varint).sint32(message.limit);
    if (message.account !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolLeaderboardFixedResolutionRequest = new VolLeaderboardFixedResolutionRequest$Type();
class VolLeaderboardFixedResolutionResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.VolLeaderboardFixedResolutionResponse", [
      {
        no: 1,
        name: "first_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "last_date",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "leaders", kind: "message", repeat: 2, T: () => LeaderboardRow },
      { no: 4, name: "account_row", kind: "message", T: () => LeaderboardRow }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.firstDate = "";
    message.lastDate = "";
    message.leaders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string first_date */
        1:
          message.firstDate = reader.string();
          break;
        case /* string last_date */
        2:
          message.lastDate = reader.string();
          break;
        case /* repeated injective_archiver_rpc.LeaderboardRow leaders */
        3:
          message.leaders.push(LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_archiver_rpc.LeaderboardRow account_row */
        4:
          message.accountRow = LeaderboardRow.internalBinaryRead(reader, reader.uint32(), options, message.accountRow);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.firstDate !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.firstDate);
    if (message.lastDate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.lastDate);
    for (let i = 0; i < message.leaders.length; i++)
      LeaderboardRow.internalBinaryWrite(message.leaders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.accountRow)
      LeaderboardRow.internalBinaryWrite(message.accountRow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolLeaderboardFixedResolutionResponse = new VolLeaderboardFixedResolutionResponse$Type();
class DenomHoldersRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.DenomHoldersRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.token = "";
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string token */
        2:
          message.token = reader.string();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.token !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.token);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomHoldersRequest = new DenomHoldersRequest$Type();
class DenomHoldersResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.DenomHoldersResponse", [
      { no: 1, name: "holders", kind: "message", repeat: 2, T: () => Holder },
      {
        no: 2,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "total",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.holders = [];
    message.next = [];
    message.total = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_archiver_rpc.Holder holders */
        1:
          message.holders.push(Holder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string next */
        2:
          message.next.push(reader.string());
          break;
        case /* sint32 total */
        3:
          message.total = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.holders.length; i++)
      Holder.internalBinaryWrite(message.holders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.next.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
    if (message.total !== 0)
      writer.tag(3, WireType.Varint).sint32(message.total);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomHoldersResponse = new DenomHoldersResponse$Type();
class Holder$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.Holder", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.balance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* string balance */
        2:
          message.balance = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.balance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.balance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Holder = new Holder$Type();
class HistoricalTradesRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalTradesRequest", [
      {
        no: 1,
        name: "from_block",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "end_block",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "from_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fromBlock = 0n;
    message.endBlock = 0n;
    message.fromTime = 0n;
    message.endTime = 0n;
    message.perPage = 0;
    message.token = "";
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 from_block */
        1:
          message.fromBlock = reader.uint64().toBigInt();
          break;
        case /* uint64 end_block */
        2:
          message.endBlock = reader.uint64().toBigInt();
          break;
        case /* sint64 from_time */
        3:
          message.fromTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        4:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* sint32 per_page */
        5:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        6:
          message.token = reader.string();
          break;
        case /* string account */
        7:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fromBlock !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.fromBlock);
    if (message.endBlock !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.endBlock);
    if (message.fromTime !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.fromTime);
    if (message.endTime !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.endTime);
    if (message.perPage !== 0)
      writer.tag(5, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.token);
    if (message.account !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalTradesRequest = new HistoricalTradesRequest$Type();
class HistoricalTradesResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalTradesResponse", [
      { no: 1, name: "trades", kind: "message", repeat: 2, T: () => HistoricalTrade },
      {
        no: 2,
        name: "last_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "last_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trades = [];
    message.lastHeight = 0n;
    message.lastTime = 0n;
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_archiver_rpc.HistoricalTrade trades */
        1:
          message.trades.push(HistoricalTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 last_height */
        2:
          message.lastHeight = reader.uint64().toBigInt();
          break;
        case /* sint64 last_time */
        3:
          message.lastTime = reader.sint64().toBigInt();
          break;
        case /* repeated string next */
        4:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.trades.length; i++)
      HistoricalTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.lastHeight !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.lastHeight);
    if (message.lastTime !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.lastTime);
    for (let i = 0; i < message.next.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalTradesResponse = new HistoricalTradesResponse$Type();
class HistoricalTrade$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.HistoricalTrade", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "trade_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "price", kind: "message", T: () => PriceLevel },
      {
        no: 6,
        name: "fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "executed_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "usd_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "flags",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "market_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.subaccountId = "";
    message.marketId = "";
    message.tradeDirection = "";
    message.fee = "";
    message.executedAt = 0n;
    message.executedHeight = 0n;
    message.feeRecipient = "";
    message.executionSide = "";
    message.usdValue = "";
    message.flags = [];
    message.marketType = "";
    message.tradeId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string trade_direction */
        4:
          message.tradeDirection = reader.string();
          break;
        case /* injective_archiver_rpc.PriceLevel price */
        5:
          message.price = PriceLevel.internalBinaryRead(reader, reader.uint32(), options, message.price);
          break;
        case /* string fee */
        6:
          message.fee = reader.string();
          break;
        case /* sint64 executed_at */
        7:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* uint64 executed_height */
        8:
          message.executedHeight = reader.uint64().toBigInt();
          break;
        case /* string fee_recipient */
        9:
          message.feeRecipient = reader.string();
          break;
        case /* string execution_side */
        10:
          message.executionSide = reader.string();
          break;
        case /* string usd_value */
        11:
          message.usdValue = reader.string();
          break;
        case /* repeated string flags */
        12:
          message.flags.push(reader.string());
          break;
        case /* string market_type */
        13:
          message.marketType = reader.string();
          break;
        case /* string trade_id */
        14:
          message.tradeId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.tradeDirection !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.tradeDirection);
    if (message.price)
      PriceLevel.internalBinaryWrite(message.price, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.fee !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.fee);
    if (message.executedAt !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.executedAt);
    if (message.executedHeight !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.executedHeight);
    if (message.feeRecipient !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.executionSide !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.executionSide);
    if (message.usdValue !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.usdValue);
    for (let i = 0; i < message.flags.length; i++)
      writer.tag(12, WireType.LengthDelimited).string(message.flags[i]);
    if (message.marketType !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.marketType);
    if (message.tradeId !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.tradeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalTrade = new HistoricalTrade$Type();
class PriceLevel$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.PriceLevel", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceLevel = new PriceLevel$Type();
class StreamSpotAverageEntriesRequest$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.StreamSpotAverageEntriesRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamSpotAverageEntriesRequest = new StreamSpotAverageEntriesRequest$Type();
class StreamSpotAverageEntriesResponse$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.StreamSpotAverageEntriesResponse", [
      { no: 1, name: "average_entry", kind: "message", T: () => SpotAverageEntry },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_archiver_rpc.SpotAverageEntry average_entry */
        1:
          message.averageEntry = SpotAverageEntry.internalBinaryRead(reader, reader.uint32(), options, message.averageEntry);
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.averageEntry)
      SpotAverageEntry.internalBinaryWrite(message.averageEntry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamSpotAverageEntriesResponse = new StreamSpotAverageEntriesResponse$Type();
class SpotAverageEntry$Type extends MessageType {
  constructor() {
    super("injective_archiver_rpc.SpotAverageEntry", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "average_entry_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "usd_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.averageEntryPrice = "";
    message.quantity = "";
    message.usdValue = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string average_entry_price */
        2:
          message.averageEntryPrice = reader.string();
          break;
        case /* string quantity */
        3:
          message.quantity = reader.string();
          break;
        case /* string usd_value */
        4:
          message.usdValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.averageEntryPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.averageEntryPrice);
    if (message.quantity !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quantity);
    if (message.usdValue !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.usdValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotAverageEntry = new SpotAverageEntry$Type();
const InjectiveArchiverRPC = new ServiceType("injective_archiver_rpc.InjectiveArchiverRPC", [
  { name: "Balance", options: {}, I: BalanceRequest, O: BalanceResponse },
  { name: "AccountStats", options: {}, I: AccountStatsRequest, O: AccountStatsResponse },
  { name: "Rpnl", options: {}, I: RpnlRequest, O: RpnlResponse },
  { name: "Volumes", options: {}, I: VolumesRequest, O: VolumesResponse },
  { name: "PnlLeaderboard", options: {}, I: PnlLeaderboardRequest, O: PnlLeaderboardResponse },
  { name: "VolLeaderboard", options: {}, I: VolLeaderboardRequest, O: VolLeaderboardResponse },
  { name: "PnlLeaderboardFixedResolution", options: {}, I: PnlLeaderboardFixedResolutionRequest, O: PnlLeaderboardFixedResolutionResponse },
  { name: "VolLeaderboardFixedResolution", options: {}, I: VolLeaderboardFixedResolutionRequest, O: VolLeaderboardFixedResolutionResponse },
  { name: "DenomHolders", options: {}, I: DenomHoldersRequest, O: DenomHoldersResponse },
  { name: "HistoricalTrades", options: {}, I: HistoricalTradesRequest, O: HistoricalTradesResponse },
  { name: "StreamSpotAverageEntries", serverStreaming: true, options: {}, I: StreamSpotAverageEntriesRequest, O: StreamSpotAverageEntriesResponse }
]);
export {
  AccountStatsRequest,
  AccountStatsResponse,
  BalanceRequest,
  BalanceResponse,
  DenomHoldersRequest,
  DenomHoldersResponse,
  HistoricalBalance,
  HistoricalDetailedBalance,
  HistoricalDetailedPNL,
  HistoricalRPNL,
  HistoricalTrade,
  HistoricalTradesRequest,
  HistoricalTradesResponse,
  HistoricalVolumes,
  Holder,
  InjectiveArchiverRPC,
  LeaderboardRow,
  PnlLeaderboardFixedResolutionRequest,
  PnlLeaderboardFixedResolutionResponse,
  PnlLeaderboardRequest,
  PnlLeaderboardResponse,
  PriceLevel,
  RpnlRequest,
  RpnlResponse,
  SpotAverageEntry,
  StreamSpotAverageEntriesRequest,
  StreamSpotAverageEntriesResponse,
  VolLeaderboardFixedResolutionRequest,
  VolLeaderboardFixedResolutionResponse,
  VolLeaderboardRequest,
  VolLeaderboardResponse,
  VolumesRequest,
  VolumesResponse
};
