// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_auction_rpc.proto" (package "injective_auction_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveAuctionRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_auction_rpc.AuctionEndpointRequest
 */
export interface AuctionEndpointRequest {
    /**
     * The auction round number. -1 for latest.
     *
     * @generated from protobuf field: sint64 round = 1
     */
    round: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionEndpointResponse
 */
export interface AuctionEndpointResponse {
    /**
     * The auction
     *
     * @generated from protobuf field: injective_auction_rpc.Auction auction = 1
     */
    auction?: Auction;
    /**
     * Bids of the auction
     *
     * @generated from protobuf field: repeated injective_auction_rpc.Bid bids = 2
     */
    bids: Bid[];
}
/**
 * @generated from protobuf message injective_auction_rpc.Auction
 */
export interface Auction {
    /**
     * Account address of the auction winner
     *
     * @generated from protobuf field: string winner = 1
     */
    winner: string;
    /**
     * Coins in the basket
     *
     * @generated from protobuf field: repeated injective_auction_rpc.Coin basket = 2
     */
    basket: Coin[];
    /**
     * @generated from protobuf field: string winning_bid_amount = 3
     */
    winningBidAmount: string;
    /**
     * @generated from protobuf field: uint64 round = 4
     */
    round: bigint;
    /**
     * Auction end timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 end_timestamp = 5
     */
    endTimestamp: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 6
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: injective_auction_rpc.AuctionContract contract = 7
     */
    contract?: AuctionContract;
}
/**
 * @generated from protobuf message injective_auction_rpc.Coin
 */
export interface Coin {
    /**
     * Denom of the coin
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * @generated from protobuf field: string usd_value = 3
     */
    usdValue: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionContract
 */
export interface AuctionContract {
    /**
     * @generated from protobuf field: uint64 id = 1
     */
    id: bigint;
    /**
     * Bid target of the auction
     *
     * @generated from protobuf field: string bid_target = 2
     */
    bidTarget: string;
    /**
     * Total slots of the auction
     *
     * @generated from protobuf field: uint64 current_slots = 3
     */
    currentSlots: bigint;
    /**
     * Total slots of the auction
     *
     * @generated from protobuf field: uint64 total_slots = 4
     */
    totalSlots: bigint;
    /**
     * Max user allocation of the auction
     *
     * @generated from protobuf field: string max_user_allocation = 5
     */
    maxUserAllocation: string;
    /**
     * Total committed amount of the auction
     *
     * @generated from protobuf field: string total_committed = 6
     */
    totalCommitted: string;
    /**
     * Whitelist addresses for the auction
     *
     * @generated from protobuf field: repeated string whitelist_addresses = 7
     */
    whitelistAddresses: string[];
    /**
     * Auction start timestamp in UNIX millis.
     *
     * @generated from protobuf field: uint64 start_timestamp = 8
     */
    startTimestamp: bigint;
    /**
     * Auction end timestamp in UNIX millis.
     *
     * @generated from protobuf field: uint64 end_timestamp = 9
     */
    endTimestamp: bigint;
    /**
     * Max round allocation of the auction
     *
     * @generated from protobuf field: string max_round_allocation = 10
     */
    maxRoundAllocation: string;
    /**
     * Whether any bid has been placed in the auction.
     *
     * @generated from protobuf field: bool is_bid_placed = 11
     */
    isBidPlaced: boolean;
}
/**
 * @generated from protobuf message injective_auction_rpc.Bid
 */
export interface Bid {
    /**
     * Account address of the bidder
     *
     * @generated from protobuf field: string bidder = 1
     */
    bidder: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * Bid timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsRequest
 */
export interface AuctionsRequest {
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsResponse
 */
export interface AuctionsResponse {
    /**
     * The historical auctions
     *
     * @generated from protobuf field: repeated injective_auction_rpc.Auction auctions = 1
     */
    auctions: Auction[];
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsHistoryV2Request
 */
export interface AuctionsHistoryV2Request {
    /**
     * @generated from protobuf field: sint32 per_page = 1
     */
    perPage: number;
    /**
     * Pagination token
     *
     * @generated from protobuf field: string token = 2
     */
    token: string;
    /**
     * The ending timestamp in UNIX milliseconds to filter the auctions
     *
     * @generated from protobuf field: sint64 end_time = 3
     */
    endTime: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsHistoryV2Response
 */
export interface AuctionsHistoryV2Response {
    /**
     * The historical auctions
     *
     * @generated from protobuf field: repeated injective_auction_rpc.AuctionV2Result auctions = 1
     */
    auctions: AuctionV2Result[];
    /**
     * Next tokens for pagination
     *
     * @generated from protobuf field: repeated string next = 2
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionV2Result
 */
export interface AuctionV2Result {
    /**
     * Account address of the auction winner
     *
     * @generated from protobuf field: string winner = 1
     */
    winner: string;
    /**
     * Coins in the basket
     *
     * @generated from protobuf field: repeated injective_auction_rpc.CoinPrices basket = 2
     */
    basket: CoinPrices[];
    /**
     * @generated from protobuf field: string winning_bid_amount = 3
     */
    winningBidAmount: string;
    /**
     * @generated from protobuf field: uint64 round = 4
     */
    round: bigint;
    /**
     * Auction end timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 end_timestamp = 5
     */
    endTimestamp: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 6
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: injective_auction_rpc.AuctionContract contract = 7
     */
    contract?: AuctionContract;
    /**
     * @generated from protobuf field: string winning_bid_amount_usd = 8
     */
    winningBidAmountUsd: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.CoinPrices
 */
export interface CoinPrices {
    /**
     * Denom of the coin
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * Map of historical prices.
     *
     * @generated from protobuf field: map<string, string> prices = 3
     */
    prices: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionV2Request
 */
export interface AuctionV2Request {
    /**
     * The auction round number.
     *
     * @generated from protobuf field: sint64 round = 1
     */
    round: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionV2Response
 */
export interface AuctionV2Response {
    /**
     * Account address of the auction winner
     *
     * @generated from protobuf field: string winner = 1
     */
    winner: string;
    /**
     * Coins in the basket
     *
     * @generated from protobuf field: repeated injective_auction_rpc.CoinPrices basket = 2
     */
    basket: CoinPrices[];
    /**
     * @generated from protobuf field: string winning_bid_amount = 3
     */
    winningBidAmount: string;
    /**
     * @generated from protobuf field: uint64 round = 4
     */
    round: bigint;
    /**
     * Auction end timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 end_timestamp = 5
     */
    endTimestamp: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 6
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: injective_auction_rpc.AuctionContract contract = 7
     */
    contract?: AuctionContract;
    /**
     * @generated from protobuf field: string winning_bid_amount_usd = 8
     */
    winningBidAmountUsd: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.AccountAuctionsV2Request
 */
export interface AccountAuctionsV2Request {
    /**
     * Address of account
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: sint32 per_page = 2
     */
    perPage: number;
    /**
     * Pagination token
     *
     * @generated from protobuf field: string token = 3
     */
    token: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.AccountAuctionsV2Response
 */
export interface AccountAuctionsV2Response {
    /**
     * The historical auctions
     *
     * @generated from protobuf field: repeated injective_auction_rpc.AccountAuctionV2 auctions = 1
     */
    auctions: AccountAuctionV2[];
    /**
     * Next tokens for pagination
     *
     * @generated from protobuf field: repeated string next = 2
     */
    next: string[];
    /**
     * Total number of auctions
     *
     * @generated from protobuf field: sint64 total = 3
     */
    total: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AccountAuctionV2
 */
export interface AccountAuctionV2 {
    /**
     * @generated from protobuf field: uint64 id = 1
     */
    id: bigint;
    /**
     * @generated from protobuf field: uint64 round = 2
     */
    round: bigint;
    /**
     * @generated from protobuf field: string amount_deposited = 3
     */
    amountDeposited: string;
    /**
     * Whether the auction rewards can be claimed.
     *
     * @generated from protobuf field: bool is_claimable = 4
     */
    isClaimable: boolean;
    /**
     * @generated from protobuf field: repeated injective_auction_rpc.CoinPrices claimed_assets = 5
     */
    claimedAssets: CoinPrices[];
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionAccountStatusRequest
 */
export interface AuctionAccountStatusRequest {
    /**
     * The auction round number
     *
     * @generated from protobuf field: sint64 round = 1
     */
    round: bigint;
    /**
     * Address of account
     *
     * @generated from protobuf field: string address = 2
     */
    address: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionAccountStatusResponse
 */
export interface AuctionAccountStatusResponse {
    /**
     * The allowlist status of the account
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.StreamBidsRequest
 */
export interface StreamBidsRequest {
}
/**
 * @generated from protobuf message injective_auction_rpc.StreamBidsResponse
 */
export interface StreamBidsResponse {
    /**
     * Account address of the bidder
     *
     * @generated from protobuf field: string bidder = 1
     */
    bidder: string;
    /**
     * @generated from protobuf field: string bid_amount = 2
     */
    bidAmount: string;
    /**
     * @generated from protobuf field: uint64 round = 3
     */
    round: bigint;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.InjBurntEndpointRequest
 */
export interface InjBurntEndpointRequest {
}
/**
 * @generated from protobuf message injective_auction_rpc.InjBurntEndpointResponse
 */
export interface InjBurntEndpointResponse {
    /**
     * @generated from protobuf field: string total_inj_burnt = 1
     */
    totalInjBurnt: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsStatsRequest
 */
export interface AuctionsStatsRequest {
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsStatsResponse
 */
export interface AuctionsStatsResponse {
    /**
     * Total cumulative amount of INJ burnt in auctions
     *
     * @generated from protobuf field: string total_burnt = 1
     */
    totalBurnt: string;
    /**
     * Total cumulative historical basket value in USD of all auctions
     *
     * @generated from protobuf field: string total_usd_value = 2
     */
    totalUsdValue: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class AuctionEndpointRequest$Type extends MessageType<AuctionEndpointRequest> {
    constructor() {
        super("injective_auction_rpc.AuctionEndpointRequest", [
            { no: 1, name: "round", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionEndpointRequest>): AuctionEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0n;
        if (value !== undefined)
            reflectionMergePartial<AuctionEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionEndpointRequest): AuctionEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 round */ 1:
                    message.round = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 round = 1; */
        if (message.round !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.round);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionEndpointRequest
 */
export const AuctionEndpointRequest = new AuctionEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionEndpointResponse$Type extends MessageType<AuctionEndpointResponse> {
    constructor() {
        super("injective_auction_rpc.AuctionEndpointResponse", [
            { no: 1, name: "auction", kind: "message", T: () => Auction },
            { no: 2, name: "bids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Bid }
        ]);
    }
    create(value?: PartialMessage<AuctionEndpointResponse>): AuctionEndpointResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bids = [];
        if (value !== undefined)
            reflectionMergePartial<AuctionEndpointResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionEndpointResponse): AuctionEndpointResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_auction_rpc.Auction auction */ 1:
                    message.auction = Auction.internalBinaryRead(reader, reader.uint32(), options, message.auction);
                    break;
                case /* repeated injective_auction_rpc.Bid bids */ 2:
                    message.bids.push(Bid.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionEndpointResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_auction_rpc.Auction auction = 1; */
        if (message.auction)
            Auction.internalBinaryWrite(message.auction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_auction_rpc.Bid bids = 2; */
        for (let i = 0; i < message.bids.length; i++)
            Bid.internalBinaryWrite(message.bids[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionEndpointResponse
 */
export const AuctionEndpointResponse = new AuctionEndpointResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Auction$Type extends MessageType<Auction> {
    constructor() {
        super("injective_auction_rpc.Auction", [
            { no: 1, name: "winner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "basket", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 3, name: "winning_bid_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "round", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "end_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "contract", kind: "message", T: () => AuctionContract }
        ]);
    }
    create(value?: PartialMessage<Auction>): Auction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.winner = "";
        message.basket = [];
        message.winningBidAmount = "";
        message.round = 0n;
        message.endTimestamp = 0n;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<Auction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Auction): Auction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string winner */ 1:
                    message.winner = reader.string();
                    break;
                case /* repeated injective_auction_rpc.Coin basket */ 2:
                    message.basket.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string winning_bid_amount */ 3:
                    message.winningBidAmount = reader.string();
                    break;
                case /* uint64 round */ 4:
                    message.round = reader.uint64().toBigInt();
                    break;
                case /* sint64 end_timestamp */ 5:
                    message.endTimestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 6:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* injective_auction_rpc.AuctionContract contract */ 7:
                    message.contract = AuctionContract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Auction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string winner = 1; */
        if (message.winner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.winner);
        /* repeated injective_auction_rpc.Coin basket = 2; */
        for (let i = 0; i < message.basket.length; i++)
            Coin.internalBinaryWrite(message.basket[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string winning_bid_amount = 3; */
        if (message.winningBidAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.winningBidAmount);
        /* uint64 round = 4; */
        if (message.round !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.round);
        /* sint64 end_timestamp = 5; */
        if (message.endTimestamp !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.endTimestamp);
        /* sint64 updated_at = 6; */
        if (message.updatedAt !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.updatedAt);
        /* injective_auction_rpc.AuctionContract contract = 7; */
        if (message.contract)
            AuctionContract.internalBinaryWrite(message.contract, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.Auction
 */
export const Auction = new Auction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Coin$Type extends MessageType<Coin> {
    constructor() {
        super("injective_auction_rpc.Coin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Coin>): Coin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        message.usdValue = "";
        if (value !== undefined)
            reflectionMergePartial<Coin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coin): Coin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* string usd_value */ 3:
                    message.usdValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* string usd_value = 3; */
        if (message.usdValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.Coin
 */
export const Coin = new Coin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionContract$Type extends MessageType<AuctionContract> {
    constructor() {
        super("injective_auction_rpc.AuctionContract", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bid_target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_slots", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "total_slots", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "max_user_allocation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "total_committed", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "whitelist_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "start_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "end_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "max_round_allocation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "is_bid_placed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionContract>): AuctionContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.bidTarget = "";
        message.currentSlots = 0n;
        message.totalSlots = 0n;
        message.maxUserAllocation = "";
        message.totalCommitted = "";
        message.whitelistAddresses = [];
        message.startTimestamp = 0n;
        message.endTimestamp = 0n;
        message.maxRoundAllocation = "";
        message.isBidPlaced = false;
        if (value !== undefined)
            reflectionMergePartial<AuctionContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionContract): AuctionContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string bid_target */ 2:
                    message.bidTarget = reader.string();
                    break;
                case /* uint64 current_slots */ 3:
                    message.currentSlots = reader.uint64().toBigInt();
                    break;
                case /* uint64 total_slots */ 4:
                    message.totalSlots = reader.uint64().toBigInt();
                    break;
                case /* string max_user_allocation */ 5:
                    message.maxUserAllocation = reader.string();
                    break;
                case /* string total_committed */ 6:
                    message.totalCommitted = reader.string();
                    break;
                case /* repeated string whitelist_addresses */ 7:
                    message.whitelistAddresses.push(reader.string());
                    break;
                case /* uint64 start_timestamp */ 8:
                    message.startTimestamp = reader.uint64().toBigInt();
                    break;
                case /* uint64 end_timestamp */ 9:
                    message.endTimestamp = reader.uint64().toBigInt();
                    break;
                case /* string max_round_allocation */ 10:
                    message.maxRoundAllocation = reader.string();
                    break;
                case /* bool is_bid_placed */ 11:
                    message.isBidPlaced = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string bid_target = 2; */
        if (message.bidTarget !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bidTarget);
        /* uint64 current_slots = 3; */
        if (message.currentSlots !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.currentSlots);
        /* uint64 total_slots = 4; */
        if (message.totalSlots !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.totalSlots);
        /* string max_user_allocation = 5; */
        if (message.maxUserAllocation !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.maxUserAllocation);
        /* string total_committed = 6; */
        if (message.totalCommitted !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.totalCommitted);
        /* repeated string whitelist_addresses = 7; */
        for (let i = 0; i < message.whitelistAddresses.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.whitelistAddresses[i]);
        /* uint64 start_timestamp = 8; */
        if (message.startTimestamp !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.startTimestamp);
        /* uint64 end_timestamp = 9; */
        if (message.endTimestamp !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.endTimestamp);
        /* string max_round_allocation = 10; */
        if (message.maxRoundAllocation !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.maxRoundAllocation);
        /* bool is_bid_placed = 11; */
        if (message.isBidPlaced !== false)
            writer.tag(11, WireType.Varint).bool(message.isBidPlaced);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionContract
 */
export const AuctionContract = new AuctionContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bid$Type extends MessageType<Bid> {
    constructor() {
        super("injective_auction_rpc.Bid", [
            { no: 1, name: "bidder", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Bid>): Bid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bidder = "";
        message.amount = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Bid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bid): Bid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bidder */ 1:
                    message.bidder = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bidder = 1; */
        if (message.bidder !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bidder);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.Bid
 */
export const Bid = new Bid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionsRequest$Type extends MessageType<AuctionsRequest> {
    constructor() {
        super("injective_auction_rpc.AuctionsRequest", []);
    }
    create(value?: PartialMessage<AuctionsRequest>): AuctionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuctionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionsRequest): AuctionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsRequest
 */
export const AuctionsRequest = new AuctionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionsResponse$Type extends MessageType<AuctionsResponse> {
    constructor() {
        super("injective_auction_rpc.AuctionsResponse", [
            { no: 1, name: "auctions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Auction }
        ]);
    }
    create(value?: PartialMessage<AuctionsResponse>): AuctionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.auctions = [];
        if (value !== undefined)
            reflectionMergePartial<AuctionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionsResponse): AuctionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_auction_rpc.Auction auctions */ 1:
                    message.auctions.push(Auction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_auction_rpc.Auction auctions = 1; */
        for (let i = 0; i < message.auctions.length; i++)
            Auction.internalBinaryWrite(message.auctions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsResponse
 */
export const AuctionsResponse = new AuctionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionsHistoryV2Request$Type extends MessageType<AuctionsHistoryV2Request> {
    constructor() {
        super("injective_auction_rpc.AuctionsHistoryV2Request", [
            { no: 1, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionsHistoryV2Request>): AuctionsHistoryV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.perPage = 0;
        message.token = "";
        message.endTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<AuctionsHistoryV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionsHistoryV2Request): AuctionsHistoryV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 per_page */ 1:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                case /* sint64 end_time */ 3:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionsHistoryV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 per_page = 1; */
        if (message.perPage !== 0)
            writer.tag(1, WireType.Varint).sint32(message.perPage);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        /* sint64 end_time = 3; */
        if (message.endTime !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsHistoryV2Request
 */
export const AuctionsHistoryV2Request = new AuctionsHistoryV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionsHistoryV2Response$Type extends MessageType<AuctionsHistoryV2Response> {
    constructor() {
        super("injective_auction_rpc.AuctionsHistoryV2Response", [
            { no: 1, name: "auctions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AuctionV2Result },
            { no: 2, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionsHistoryV2Response>): AuctionsHistoryV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.auctions = [];
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<AuctionsHistoryV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionsHistoryV2Response): AuctionsHistoryV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_auction_rpc.AuctionV2Result auctions */ 1:
                    message.auctions.push(AuctionV2Result.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string next */ 2:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionsHistoryV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_auction_rpc.AuctionV2Result auctions = 1; */
        for (let i = 0; i < message.auctions.length; i++)
            AuctionV2Result.internalBinaryWrite(message.auctions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string next = 2; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsHistoryV2Response
 */
export const AuctionsHistoryV2Response = new AuctionsHistoryV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionV2Result$Type extends MessageType<AuctionV2Result> {
    constructor() {
        super("injective_auction_rpc.AuctionV2Result", [
            { no: 1, name: "winner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "basket", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CoinPrices },
            { no: 3, name: "winning_bid_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "round", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "end_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "contract", kind: "message", T: () => AuctionContract },
            { no: 8, name: "winning_bid_amount_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionV2Result>): AuctionV2Result {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.winner = "";
        message.basket = [];
        message.winningBidAmount = "";
        message.round = 0n;
        message.endTimestamp = 0n;
        message.updatedAt = 0n;
        message.winningBidAmountUsd = "";
        if (value !== undefined)
            reflectionMergePartial<AuctionV2Result>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionV2Result): AuctionV2Result {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string winner */ 1:
                    message.winner = reader.string();
                    break;
                case /* repeated injective_auction_rpc.CoinPrices basket */ 2:
                    message.basket.push(CoinPrices.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string winning_bid_amount */ 3:
                    message.winningBidAmount = reader.string();
                    break;
                case /* uint64 round */ 4:
                    message.round = reader.uint64().toBigInt();
                    break;
                case /* sint64 end_timestamp */ 5:
                    message.endTimestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 6:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* injective_auction_rpc.AuctionContract contract */ 7:
                    message.contract = AuctionContract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* string winning_bid_amount_usd */ 8:
                    message.winningBidAmountUsd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionV2Result, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string winner = 1; */
        if (message.winner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.winner);
        /* repeated injective_auction_rpc.CoinPrices basket = 2; */
        for (let i = 0; i < message.basket.length; i++)
            CoinPrices.internalBinaryWrite(message.basket[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string winning_bid_amount = 3; */
        if (message.winningBidAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.winningBidAmount);
        /* uint64 round = 4; */
        if (message.round !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.round);
        /* sint64 end_timestamp = 5; */
        if (message.endTimestamp !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.endTimestamp);
        /* sint64 updated_at = 6; */
        if (message.updatedAt !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.updatedAt);
        /* injective_auction_rpc.AuctionContract contract = 7; */
        if (message.contract)
            AuctionContract.internalBinaryWrite(message.contract, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string winning_bid_amount_usd = 8; */
        if (message.winningBidAmountUsd !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.winningBidAmountUsd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionV2Result
 */
export const AuctionV2Result = new AuctionV2Result$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoinPrices$Type extends MessageType<CoinPrices> {
    constructor() {
        super("injective_auction_rpc.CoinPrices", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "prices", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<CoinPrices>): CoinPrices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        message.prices = {};
        if (value !== undefined)
            reflectionMergePartial<CoinPrices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoinPrices): CoinPrices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* map<string, string> prices */ 3:
                    this.binaryReadMap3(message.prices, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: CoinPrices["prices"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CoinPrices["prices"] | undefined, val: CoinPrices["prices"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for injective_auction_rpc.CoinPrices.prices");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: CoinPrices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* map<string, string> prices = 3; */
        for (let k of globalThis.Object.keys(message.prices))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.prices[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.CoinPrices
 */
export const CoinPrices = new CoinPrices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionV2Request$Type extends MessageType<AuctionV2Request> {
    constructor() {
        super("injective_auction_rpc.AuctionV2Request", [
            { no: 1, name: "round", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionV2Request>): AuctionV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0n;
        if (value !== undefined)
            reflectionMergePartial<AuctionV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionV2Request): AuctionV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 round */ 1:
                    message.round = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 round = 1; */
        if (message.round !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.round);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionV2Request
 */
export const AuctionV2Request = new AuctionV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionV2Response$Type extends MessageType<AuctionV2Response> {
    constructor() {
        super("injective_auction_rpc.AuctionV2Response", [
            { no: 1, name: "winner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "basket", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CoinPrices },
            { no: 3, name: "winning_bid_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "round", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "end_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "contract", kind: "message", T: () => AuctionContract },
            { no: 8, name: "winning_bid_amount_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionV2Response>): AuctionV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.winner = "";
        message.basket = [];
        message.winningBidAmount = "";
        message.round = 0n;
        message.endTimestamp = 0n;
        message.updatedAt = 0n;
        message.winningBidAmountUsd = "";
        if (value !== undefined)
            reflectionMergePartial<AuctionV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionV2Response): AuctionV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string winner */ 1:
                    message.winner = reader.string();
                    break;
                case /* repeated injective_auction_rpc.CoinPrices basket */ 2:
                    message.basket.push(CoinPrices.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string winning_bid_amount */ 3:
                    message.winningBidAmount = reader.string();
                    break;
                case /* uint64 round */ 4:
                    message.round = reader.uint64().toBigInt();
                    break;
                case /* sint64 end_timestamp */ 5:
                    message.endTimestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 6:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* injective_auction_rpc.AuctionContract contract */ 7:
                    message.contract = AuctionContract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* string winning_bid_amount_usd */ 8:
                    message.winningBidAmountUsd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string winner = 1; */
        if (message.winner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.winner);
        /* repeated injective_auction_rpc.CoinPrices basket = 2; */
        for (let i = 0; i < message.basket.length; i++)
            CoinPrices.internalBinaryWrite(message.basket[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string winning_bid_amount = 3; */
        if (message.winningBidAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.winningBidAmount);
        /* uint64 round = 4; */
        if (message.round !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.round);
        /* sint64 end_timestamp = 5; */
        if (message.endTimestamp !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.endTimestamp);
        /* sint64 updated_at = 6; */
        if (message.updatedAt !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.updatedAt);
        /* injective_auction_rpc.AuctionContract contract = 7; */
        if (message.contract)
            AuctionContract.internalBinaryWrite(message.contract, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string winning_bid_amount_usd = 8; */
        if (message.winningBidAmountUsd !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.winningBidAmountUsd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionV2Response
 */
export const AuctionV2Response = new AuctionV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountAuctionsV2Request$Type extends MessageType<AccountAuctionsV2Request> {
    constructor() {
        super("injective_auction_rpc.AccountAuctionsV2Request", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountAuctionsV2Request>): AccountAuctionsV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.perPage = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<AccountAuctionsV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountAuctionsV2Request): AccountAuctionsV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* sint32 per_page */ 2:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountAuctionsV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* sint32 per_page = 2; */
        if (message.perPage !== 0)
            writer.tag(2, WireType.Varint).sint32(message.perPage);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AccountAuctionsV2Request
 */
export const AccountAuctionsV2Request = new AccountAuctionsV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountAuctionsV2Response$Type extends MessageType<AccountAuctionsV2Response> {
    constructor() {
        super("injective_auction_rpc.AccountAuctionsV2Response", [
            { no: 1, name: "auctions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AccountAuctionV2 },
            { no: 2, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AccountAuctionsV2Response>): AccountAuctionsV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.auctions = [];
        message.next = [];
        message.total = 0n;
        if (value !== undefined)
            reflectionMergePartial<AccountAuctionsV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountAuctionsV2Response): AccountAuctionsV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_auction_rpc.AccountAuctionV2 auctions */ 1:
                    message.auctions.push(AccountAuctionV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string next */ 2:
                    message.next.push(reader.string());
                    break;
                case /* sint64 total */ 3:
                    message.total = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountAuctionsV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_auction_rpc.AccountAuctionV2 auctions = 1; */
        for (let i = 0; i < message.auctions.length; i++)
            AccountAuctionV2.internalBinaryWrite(message.auctions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string next = 2; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
        /* sint64 total = 3; */
        if (message.total !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AccountAuctionsV2Response
 */
export const AccountAuctionsV2Response = new AccountAuctionsV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountAuctionV2$Type extends MessageType<AccountAuctionV2> {
    constructor() {
        super("injective_auction_rpc.AccountAuctionV2", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "round", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "amount_deposited", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_claimable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "claimed_assets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CoinPrices }
        ]);
    }
    create(value?: PartialMessage<AccountAuctionV2>): AccountAuctionV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.round = 0n;
        message.amountDeposited = "";
        message.isClaimable = false;
        message.claimedAssets = [];
        if (value !== undefined)
            reflectionMergePartial<AccountAuctionV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountAuctionV2): AccountAuctionV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 round */ 2:
                    message.round = reader.uint64().toBigInt();
                    break;
                case /* string amount_deposited */ 3:
                    message.amountDeposited = reader.string();
                    break;
                case /* bool is_claimable */ 4:
                    message.isClaimable = reader.bool();
                    break;
                case /* repeated injective_auction_rpc.CoinPrices claimed_assets */ 5:
                    message.claimedAssets.push(CoinPrices.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountAuctionV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 round = 2; */
        if (message.round !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.round);
        /* string amount_deposited = 3; */
        if (message.amountDeposited !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amountDeposited);
        /* bool is_claimable = 4; */
        if (message.isClaimable !== false)
            writer.tag(4, WireType.Varint).bool(message.isClaimable);
        /* repeated injective_auction_rpc.CoinPrices claimed_assets = 5; */
        for (let i = 0; i < message.claimedAssets.length; i++)
            CoinPrices.internalBinaryWrite(message.claimedAssets[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AccountAuctionV2
 */
export const AccountAuctionV2 = new AccountAuctionV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionAccountStatusRequest$Type extends MessageType<AuctionAccountStatusRequest> {
    constructor() {
        super("injective_auction_rpc.AuctionAccountStatusRequest", [
            { no: 1, name: "round", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionAccountStatusRequest>): AuctionAccountStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0n;
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<AuctionAccountStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionAccountStatusRequest): AuctionAccountStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 round */ 1:
                    message.round = reader.sint64().toBigInt();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionAccountStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 round = 1; */
        if (message.round !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.round);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionAccountStatusRequest
 */
export const AuctionAccountStatusRequest = new AuctionAccountStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionAccountStatusResponse$Type extends MessageType<AuctionAccountStatusResponse> {
    constructor() {
        super("injective_auction_rpc.AuctionAccountStatusResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionAccountStatusResponse>): AuctionAccountStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<AuctionAccountStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionAccountStatusResponse): AuctionAccountStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionAccountStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionAccountStatusResponse
 */
export const AuctionAccountStatusResponse = new AuctionAccountStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamBidsRequest$Type extends MessageType<StreamBidsRequest> {
    constructor() {
        super("injective_auction_rpc.StreamBidsRequest", []);
    }
    create(value?: PartialMessage<StreamBidsRequest>): StreamBidsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamBidsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamBidsRequest): StreamBidsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamBidsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.StreamBidsRequest
 */
export const StreamBidsRequest = new StreamBidsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamBidsResponse$Type extends MessageType<StreamBidsResponse> {
    constructor() {
        super("injective_auction_rpc.StreamBidsResponse", [
            { no: 1, name: "bidder", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bid_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "round", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamBidsResponse>): StreamBidsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bidder = "";
        message.bidAmount = "";
        message.round = 0n;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamBidsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamBidsResponse): StreamBidsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bidder */ 1:
                    message.bidder = reader.string();
                    break;
                case /* string bid_amount */ 2:
                    message.bidAmount = reader.string();
                    break;
                case /* uint64 round */ 3:
                    message.round = reader.uint64().toBigInt();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamBidsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bidder = 1; */
        if (message.bidder !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bidder);
        /* string bid_amount = 2; */
        if (message.bidAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bidAmount);
        /* uint64 round = 3; */
        if (message.round !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.round);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.StreamBidsResponse
 */
export const StreamBidsResponse = new StreamBidsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InjBurntEndpointRequest$Type extends MessageType<InjBurntEndpointRequest> {
    constructor() {
        super("injective_auction_rpc.InjBurntEndpointRequest", []);
    }
    create(value?: PartialMessage<InjBurntEndpointRequest>): InjBurntEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<InjBurntEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InjBurntEndpointRequest): InjBurntEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InjBurntEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.InjBurntEndpointRequest
 */
export const InjBurntEndpointRequest = new InjBurntEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InjBurntEndpointResponse$Type extends MessageType<InjBurntEndpointResponse> {
    constructor() {
        super("injective_auction_rpc.InjBurntEndpointResponse", [
            { no: 1, name: "total_inj_burnt", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InjBurntEndpointResponse>): InjBurntEndpointResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalInjBurnt = "";
        if (value !== undefined)
            reflectionMergePartial<InjBurntEndpointResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InjBurntEndpointResponse): InjBurntEndpointResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string total_inj_burnt */ 1:
                    message.totalInjBurnt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InjBurntEndpointResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string total_inj_burnt = 1; */
        if (message.totalInjBurnt !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.totalInjBurnt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.InjBurntEndpointResponse
 */
export const InjBurntEndpointResponse = new InjBurntEndpointResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionsStatsRequest$Type extends MessageType<AuctionsStatsRequest> {
    constructor() {
        super("injective_auction_rpc.AuctionsStatsRequest", []);
    }
    create(value?: PartialMessage<AuctionsStatsRequest>): AuctionsStatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuctionsStatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionsStatsRequest): AuctionsStatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionsStatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsStatsRequest
 */
export const AuctionsStatsRequest = new AuctionsStatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuctionsStatsResponse$Type extends MessageType<AuctionsStatsResponse> {
    constructor() {
        super("injective_auction_rpc.AuctionsStatsResponse", [
            { no: 1, name: "total_burnt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuctionsStatsResponse>): AuctionsStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalBurnt = "";
        message.totalUsdValue = "";
        if (value !== undefined)
            reflectionMergePartial<AuctionsStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuctionsStatsResponse): AuctionsStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string total_burnt */ 1:
                    message.totalBurnt = reader.string();
                    break;
                case /* string total_usd_value */ 2:
                    message.totalUsdValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuctionsStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string total_burnt = 1; */
        if (message.totalBurnt !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.totalBurnt);
        /* string total_usd_value = 2; */
        if (message.totalUsdValue !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.totalUsdValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsStatsResponse
 */
export const AuctionsStatsResponse = new AuctionsStatsResponse$Type();
/**
 * @generated ServiceType for protobuf service injective_auction_rpc.InjectiveAuctionRPC
 */
export const InjectiveAuctionRPC = new ServiceType("injective_auction_rpc.InjectiveAuctionRPC", [
    { name: "AuctionEndpoint", options: {}, I: AuctionEndpointRequest, O: AuctionEndpointResponse },
    { name: "Auctions", options: {}, I: AuctionsRequest, O: AuctionsResponse },
    { name: "AuctionsHistoryV2", options: {}, I: AuctionsHistoryV2Request, O: AuctionsHistoryV2Response },
    { name: "AuctionV2", options: {}, I: AuctionV2Request, O: AuctionV2Response },
    { name: "AccountAuctionsV2", options: {}, I: AccountAuctionsV2Request, O: AccountAuctionsV2Response },
    { name: "AuctionAccountStatus", options: {}, I: AuctionAccountStatusRequest, O: AuctionAccountStatusResponse },
    { name: "StreamBids", serverStreaming: true, options: {}, I: StreamBidsRequest, O: StreamBidsResponse },
    { name: "InjBurntEndpoint", options: {}, I: InjBurntEndpointRequest, O: InjBurntEndpointResponse },
    { name: "AuctionsStats", options: {}, I: AuctionsStatsRequest, O: AuctionsStatsResponse }
]);
