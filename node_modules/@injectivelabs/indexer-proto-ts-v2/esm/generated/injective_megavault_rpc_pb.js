import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class GetVaultRequest$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.GetVaultRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetVaultRequest = new GetVaultRequest$Type();
class GetVaultResponse$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.GetVaultResponse", [
      { no: 1, name: "vault", kind: "message", T: () => Vault }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_megavault_rpc.Vault vault */
        1:
          message.vault = Vault.internalBinaryRead(reader, reader.uint32(), options, message.vault);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vault)
      Vault.internalBinaryWrite(message.vault, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetVaultResponse = new GetVaultResponse$Type();
class Vault$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Vault", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "contract_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "contract_version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "lp_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "operators", kind: "message", repeat: 2, T: () => Operator },
      { no: 8, name: "incentives", kind: "message", T: () => Incentives },
      { no: 9, name: "target_apr", kind: "message", T: () => TargetApr },
      { no: 10, name: "stats", kind: "message", T: () => VaultStats },
      {
        no: 11,
        name: "created_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "updated_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    message.contractName = "";
    message.contractVersion = "";
    message.admin = "";
    message.lpDenom = "";
    message.quoteDenom = "";
    message.operators = [];
    message.createdHeight = 0n;
    message.createdAt = 0n;
    message.updatedHeight = 0n;
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* string contract_name */
        2:
          message.contractName = reader.string();
          break;
        case /* string contract_version */
        3:
          message.contractVersion = reader.string();
          break;
        case /* string admin */
        4:
          message.admin = reader.string();
          break;
        case /* string lp_denom */
        5:
          message.lpDenom = reader.string();
          break;
        case /* string quote_denom */
        6:
          message.quoteDenom = reader.string();
          break;
        case /* repeated injective_megavault_rpc.Operator operators */
        7:
          message.operators.push(Operator.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_megavault_rpc.Incentives incentives */
        8:
          message.incentives = Incentives.internalBinaryRead(reader, reader.uint32(), options, message.incentives);
          break;
        case /* injective_megavault_rpc.TargetApr target_apr */
        9:
          message.targetApr = TargetApr.internalBinaryRead(reader, reader.uint32(), options, message.targetApr);
          break;
        case /* injective_megavault_rpc.VaultStats stats */
        10:
          message.stats = VaultStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
          break;
        case /* sint64 created_height */
        11:
          message.createdHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        12:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_height */
        13:
          message.updatedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        14:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.contractName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.contractName);
    if (message.contractVersion !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.contractVersion);
    if (message.admin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.admin);
    if (message.lpDenom !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.lpDenom);
    if (message.quoteDenom !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
    for (let i = 0; i < message.operators.length; i++)
      Operator.internalBinaryWrite(message.operators[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.incentives)
      Incentives.internalBinaryWrite(message.incentives, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.targetApr)
      TargetApr.internalBinaryWrite(message.targetApr, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.stats)
      VaultStats.internalBinaryWrite(message.stats, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    if (message.createdHeight !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.createdHeight);
    if (message.createdAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.createdAt);
    if (message.updatedHeight !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.updatedHeight);
    if (message.updatedAt !== 0n)
      writer.tag(14, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Vault = new Vault$Type();
class Operator$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Operator", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "total_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "total_liquid_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "updated_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "percentage",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.totalAmount = "";
    message.totalLiquidAmount = "";
    message.updatedHeight = 0n;
    message.updatedAt = 0n;
    message.percentage = "";
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string total_amount */
        2:
          message.totalAmount = reader.string();
          break;
        case /* string total_liquid_amount */
        3:
          message.totalLiquidAmount = reader.string();
          break;
        case /* sint64 updated_height */
        4:
          message.updatedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        5:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string percentage */
        6:
          message.percentage = reader.string();
          break;
        case /* string subaccount_id */
        7:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.totalAmount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.totalAmount);
    if (message.totalLiquidAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.totalLiquidAmount);
    if (message.updatedHeight !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.updatedHeight);
    if (message.updatedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.updatedAt);
    if (message.percentage !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.percentage);
    if (message.subaccountId !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Operator = new Operator$Type();
class Incentives$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Incentives", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "updated_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.amount = "";
    message.updatedHeight = 0n;
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        case /* sint64 updated_height */
        3:
          message.updatedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        4:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    if (message.updatedHeight !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.updatedHeight);
    if (message.updatedAt !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Incentives = new Incentives$Type();
class TargetApr$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.TargetApr", [
      {
        no: 1,
        name: "apr",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "upper_threshold",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "lower_threshold",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "updated_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.apr = "";
    message.upperThreshold = "";
    message.lowerThreshold = "";
    message.updatedHeight = 0n;
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string apr */
        1:
          message.apr = reader.string();
          break;
        case /* string upper_threshold */
        2:
          message.upperThreshold = reader.string();
          break;
        case /* string lower_threshold */
        3:
          message.lowerThreshold = reader.string();
          break;
        case /* sint64 updated_height */
        4:
          message.updatedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        5:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.apr !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.apr);
    if (message.upperThreshold !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.upperThreshold);
    if (message.lowerThreshold !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.lowerThreshold);
    if (message.updatedHeight !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.updatedHeight);
    if (message.updatedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TargetApr = new TargetApr$Type();
class VaultStats$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.VaultStats", [
      {
        no: 1,
        name: "total_subscribed_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "total_redeemed_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "current_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "current_amount_without_incentives",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "current_lp_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "current_lp_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "pnl", kind: "message", T: () => PnlStats },
      { no: 8, name: "volatility", kind: "message", T: () => VolatilityStats },
      { no: 9, name: "apr", kind: "message", T: () => AprStats },
      { no: 10, name: "max_drawdown", kind: "message", T: () => MaxDrawdown }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.totalSubscribedAmount = "";
    message.totalRedeemedAmount = "";
    message.currentAmount = "";
    message.currentAmountWithoutIncentives = "";
    message.currentLpAmount = "";
    message.currentLpPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string total_subscribed_amount */
        1:
          message.totalSubscribedAmount = reader.string();
          break;
        case /* string total_redeemed_amount */
        2:
          message.totalRedeemedAmount = reader.string();
          break;
        case /* string current_amount */
        3:
          message.currentAmount = reader.string();
          break;
        case /* string current_amount_without_incentives */
        4:
          message.currentAmountWithoutIncentives = reader.string();
          break;
        case /* string current_lp_amount */
        5:
          message.currentLpAmount = reader.string();
          break;
        case /* string current_lp_price */
        6:
          message.currentLpPrice = reader.string();
          break;
        case /* injective_megavault_rpc.PnlStats pnl */
        7:
          message.pnl = PnlStats.internalBinaryRead(reader, reader.uint32(), options, message.pnl);
          break;
        case /* injective_megavault_rpc.VolatilityStats volatility */
        8:
          message.volatility = VolatilityStats.internalBinaryRead(reader, reader.uint32(), options, message.volatility);
          break;
        case /* injective_megavault_rpc.AprStats apr */
        9:
          message.apr = AprStats.internalBinaryRead(reader, reader.uint32(), options, message.apr);
          break;
        case /* injective_megavault_rpc.MaxDrawdown max_drawdown */
        10:
          message.maxDrawdown = MaxDrawdown.internalBinaryRead(reader, reader.uint32(), options, message.maxDrawdown);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalSubscribedAmount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.totalSubscribedAmount);
    if (message.totalRedeemedAmount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.totalRedeemedAmount);
    if (message.currentAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.currentAmount);
    if (message.currentAmountWithoutIncentives !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.currentAmountWithoutIncentives);
    if (message.currentLpAmount !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.currentLpAmount);
    if (message.currentLpPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.currentLpPrice);
    if (message.pnl)
      PnlStats.internalBinaryWrite(message.pnl, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.volatility)
      VolatilityStats.internalBinaryWrite(message.volatility, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.apr)
      AprStats.internalBinaryWrite(message.apr, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.maxDrawdown)
      MaxDrawdown.internalBinaryWrite(message.maxDrawdown, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VaultStats = new VaultStats$Type();
class PnlStats$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.PnlStats", [
      { no: 1, name: "unrealized", kind: "message", T: () => UnrealizedPnl },
      { no: 2, name: "all_time", kind: "message", T: () => Pnl }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_megavault_rpc.UnrealizedPnl unrealized */
        1:
          message.unrealized = UnrealizedPnl.internalBinaryRead(reader, reader.uint32(), options, message.unrealized);
          break;
        case /* injective_megavault_rpc.Pnl all_time */
        2:
          message.allTime = Pnl.internalBinaryRead(reader, reader.uint32(), options, message.allTime);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.unrealized)
      UnrealizedPnl.internalBinaryWrite(message.unrealized, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.allTime)
      Pnl.internalBinaryWrite(message.allTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PnlStats = new PnlStats$Type();
class UnrealizedPnl$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.UnrealizedPnl", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "percentage",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    message.percentage = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        case /* string percentage */
        2:
          message.percentage = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    if (message.percentage !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.percentage);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const UnrealizedPnl = new UnrealizedPnl$Type();
class Pnl$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Pnl", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "percentage",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "total_amount_subscribed",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "total_amount_redeemed",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "current_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    message.percentage = "";
    message.totalAmountSubscribed = "";
    message.totalAmountRedeemed = "";
    message.currentAmount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        case /* string percentage */
        2:
          message.percentage = reader.string();
          break;
        case /* string total_amount_subscribed */
        3:
          message.totalAmountSubscribed = reader.string();
          break;
        case /* string total_amount_redeemed */
        4:
          message.totalAmountRedeemed = reader.string();
          break;
        case /* string current_amount */
        5:
          message.currentAmount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    if (message.percentage !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.percentage);
    if (message.totalAmountSubscribed !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.totalAmountSubscribed);
    if (message.totalAmountRedeemed !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.totalAmountRedeemed);
    if (message.currentAmount !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.currentAmount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Pnl = new Pnl$Type();
class VolatilityStats$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.VolatilityStats", [
      { no: 1, name: "thirty_days", kind: "message", T: () => Volatility }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_megavault_rpc.Volatility thirty_days */
        1:
          message.thirtyDays = Volatility.internalBinaryRead(reader, reader.uint32(), options, message.thirtyDays);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.thirtyDays)
      Volatility.internalBinaryWrite(message.thirtyDays, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolatilityStats = new VolatilityStats$Type();
class Volatility$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Volatility", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Volatility = new Volatility$Type();
class AprStats$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.AprStats", [
      { no: 1, name: "thirty_days", kind: "message", T: () => Apr }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_megavault_rpc.Apr thirty_days */
        1:
          message.thirtyDays = Apr.internalBinaryRead(reader, reader.uint32(), options, message.thirtyDays);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.thirtyDays)
      Apr.internalBinaryWrite(message.thirtyDays, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AprStats = new AprStats$Type();
class Apr$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Apr", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "original_lp_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "current_lp_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    message.originalLpPrice = "";
    message.currentLpPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        case /* string original_lp_price */
        2:
          message.originalLpPrice = reader.string();
          break;
        case /* string current_lp_price */
        3:
          message.currentLpPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    if (message.originalLpPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.originalLpPrice);
    if (message.currentLpPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.currentLpPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Apr = new Apr$Type();
class MaxDrawdown$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.MaxDrawdown", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "latest_pn_l_peak",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    message.latestPnLPeak = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        case /* string latest_pn_l_peak */
        2:
          message.latestPnLPeak = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    if (message.latestPnLPeak !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.latestPnLPeak);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MaxDrawdown = new MaxDrawdown$Type();
class GetUserRequest$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.GetUserRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    message.userAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* string user_address */
        2:
          message.userAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.userAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.userAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetUserRequest = new GetUserRequest$Type();
class GetUserResponse$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.GetUserResponse", [
      { no: 1, name: "user", kind: "message", T: () => User }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_megavault_rpc.User user */
        1:
          message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.user)
      User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetUserResponse = new GetUserResponse$Type();
class User$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.User", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "stats", kind: "message", T: () => UserStats },
      {
        no: 4,
        name: "created_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "updated_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.contractAddress = "";
    message.createdHeight = 0n;
    message.createdAt = 0n;
    message.updatedHeight = 0n;
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string contract_address */
        2:
          message.contractAddress = reader.string();
          break;
        case /* injective_megavault_rpc.UserStats stats */
        3:
          message.stats = UserStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
          break;
        case /* sint64 created_height */
        4:
          message.createdHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        5:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_height */
        6:
          message.updatedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        7:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.contractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
    if (message.stats)
      UserStats.internalBinaryWrite(message.stats, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.createdHeight !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.createdHeight);
    if (message.createdAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.createdAt);
    if (message.updatedHeight !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.updatedHeight);
    if (message.updatedAt !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const User = new User$Type();
class UserStats$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.UserStats", [
      {
        no: 1,
        name: "current_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "current_lp_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "pnl", kind: "message", T: () => PnlStats },
      {
        no: 4,
        name: "deposited_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.currentAmount = "";
    message.currentLpAmount = "";
    message.depositedValue = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string current_amount */
        1:
          message.currentAmount = reader.string();
          break;
        case /* string current_lp_amount */
        2:
          message.currentLpAmount = reader.string();
          break;
        case /* injective_megavault_rpc.PnlStats pnl */
        3:
          message.pnl = PnlStats.internalBinaryRead(reader, reader.uint32(), options, message.pnl);
          break;
        case /* string deposited_value */
        4:
          message.depositedValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.currentAmount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.currentAmount);
    if (message.currentLpAmount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.currentLpAmount);
    if (message.pnl)
      PnlStats.internalBinaryWrite(message.pnl, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.depositedValue !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.depositedValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const UserStats = new UserStats$Type();
class ListSubscriptionsRequest$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.ListSubscriptionsRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    message.userAddress = "";
    message.status = "";
    message.perPage = 0;
    message.token = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* string user_address */
        2:
          message.userAddress = reader.string();
          break;
        case /* string status */
        3:
          message.status = reader.string();
          break;
        case /* sint32 per_page */
        4:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        5:
          message.token = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.userAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.userAddress);
    if (message.status !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.status);
    if (message.perPage !== 0)
      writer.tag(4, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.token);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListSubscriptionsRequest = new ListSubscriptionsRequest$Type();
class ListSubscriptionsResponse$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.ListSubscriptionsResponse", [
      { no: 1, name: "subscriptions", kind: "message", repeat: 2, T: () => Subscription },
      {
        no: 2,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscriptions = [];
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_megavault_rpc.Subscription subscriptions */
        1:
          message.subscriptions.push(Subscription.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string next */
        2:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subscriptions.length; i++)
      Subscription.internalBinaryWrite(message.subscriptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.next.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListSubscriptionsResponse = new ListSubscriptionsResponse$Type();
class Subscription$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Subscription", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "index",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "lp_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "created_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "executed_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 11, name: "log", kind: "message", repeat: 2, T: () => OperationStatusLogEntry }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    message.user = "";
    message.index = 0n;
    message.lpAmount = "";
    message.amount = "";
    message.status = "";
    message.createdHeight = 0n;
    message.createdAt = 0n;
    message.executedHeight = 0n;
    message.executedAt = 0n;
    message.log = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* string user */
        2:
          message.user = reader.string();
          break;
        case /* sint64 index */
        3:
          message.index = reader.sint64().toBigInt();
          break;
        case /* string lp_amount */
        4:
          message.lpAmount = reader.string();
          break;
        case /* string amount */
        5:
          message.amount = reader.string();
          break;
        case /* string status */
        6:
          message.status = reader.string();
          break;
        case /* sint64 created_height */
        7:
          message.createdHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        8:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 executed_height */
        9:
          message.executedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 executed_at */
        10:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* repeated injective_megavault_rpc.OperationStatusLogEntry log */
        11:
          message.log.push(OperationStatusLogEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.user !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.user);
    if (message.index !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.index);
    if (message.lpAmount !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.lpAmount);
    if (message.amount !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.amount);
    if (message.status !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.status);
    if (message.createdHeight !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.createdHeight);
    if (message.createdAt !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.createdAt);
    if (message.executedHeight !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.executedHeight);
    if (message.executedAt !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.executedAt);
    for (let i = 0; i < message.log.length; i++)
      OperationStatusLogEntry.internalBinaryWrite(message.log[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Subscription = new Subscription$Type();
class OperationStatusLogEntry$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.OperationStatusLogEntry", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "block_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "block_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    message.txHash = "";
    message.blockHeight = 0n;
    message.blockTime = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        case /* string tx_hash */
        2:
          message.txHash = reader.string();
          break;
        case /* sint64 block_height */
        3:
          message.blockHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 block_time */
        4:
          message.blockTime = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    if (message.txHash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.txHash);
    if (message.blockHeight !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.blockHeight);
    if (message.blockTime !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.blockTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OperationStatusLogEntry = new OperationStatusLogEntry$Type();
class ListRedemptionsRequest$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.ListRedemptionsRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    message.userAddress = "";
    message.status = "";
    message.perPage = 0;
    message.token = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* string user_address */
        2:
          message.userAddress = reader.string();
          break;
        case /* string status */
        3:
          message.status = reader.string();
          break;
        case /* sint32 per_page */
        4:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        5:
          message.token = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.userAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.userAddress);
    if (message.status !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.status);
    if (message.perPage !== 0)
      writer.tag(4, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.token);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListRedemptionsRequest = new ListRedemptionsRequest$Type();
class ListRedemptionsResponse$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.ListRedemptionsResponse", [
      { no: 1, name: "redemptions", kind: "message", repeat: 2, T: () => Redemption },
      {
        no: 2,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.redemptions = [];
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_megavault_rpc.Redemption redemptions */
        1:
          message.redemptions.push(Redemption.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string next */
        2:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.redemptions.length; i++)
      Redemption.internalBinaryWrite(message.redemptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.next.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListRedemptionsResponse = new ListRedemptionsResponse$Type();
class Redemption$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.Redemption", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "index",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "lp_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "due_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "created_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "executed_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 12, name: "log", kind: "message", repeat: 2, T: () => OperationStatusLogEntry }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    message.user = "";
    message.index = 0n;
    message.lpAmount = "";
    message.amount = "";
    message.status = "";
    message.dueAt = 0n;
    message.createdHeight = 0n;
    message.createdAt = 0n;
    message.executedHeight = 0n;
    message.executedAt = 0n;
    message.log = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* string user */
        2:
          message.user = reader.string();
          break;
        case /* sint64 index */
        3:
          message.index = reader.sint64().toBigInt();
          break;
        case /* string lp_amount */
        4:
          message.lpAmount = reader.string();
          break;
        case /* string amount */
        5:
          message.amount = reader.string();
          break;
        case /* string status */
        6:
          message.status = reader.string();
          break;
        case /* sint64 due_at */
        7:
          message.dueAt = reader.sint64().toBigInt();
          break;
        case /* sint64 created_height */
        8:
          message.createdHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        9:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 executed_height */
        10:
          message.executedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 executed_at */
        11:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* repeated injective_megavault_rpc.OperationStatusLogEntry log */
        12:
          message.log.push(OperationStatusLogEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.user !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.user);
    if (message.index !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.index);
    if (message.lpAmount !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.lpAmount);
    if (message.amount !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.amount);
    if (message.status !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.status);
    if (message.dueAt !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.dueAt);
    if (message.createdHeight !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.createdHeight);
    if (message.createdAt !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.createdAt);
    if (message.executedHeight !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.executedHeight);
    if (message.executedAt !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.executedAt);
    for (let i = 0; i < message.log.length; i++)
      OperationStatusLogEntry.internalBinaryWrite(message.log[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Redemption = new Redemption$Type();
class GetOperatorRedemptionBucketsRequest$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.GetOperatorRedemptionBucketsRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "operator_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    message.operatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* string operator_address */
        2:
          message.operatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.operatorAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetOperatorRedemptionBucketsRequest = new GetOperatorRedemptionBucketsRequest$Type();
class GetOperatorRedemptionBucketsResponse$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.GetOperatorRedemptionBucketsResponse", [
      { no: 1, name: "buckets", kind: "message", repeat: 2, T: () => RedemptionBucket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.buckets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_megavault_rpc.RedemptionBucket buckets */
        1:
          message.buckets.push(RedemptionBucket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.buckets.length; i++)
      RedemptionBucket.internalBinaryWrite(message.buckets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetOperatorRedemptionBucketsResponse = new GetOperatorRedemptionBucketsResponse$Type();
class RedemptionBucket$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.RedemptionBucket", [
      {
        no: 1,
        name: "bucket",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "lp_amount_to_redeem",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "needed_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "missing_liquidity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucket = "";
    message.lpAmountToRedeem = "";
    message.neededAmount = "";
    message.missingLiquidity = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string bucket */
        1:
          message.bucket = reader.string();
          break;
        case /* string lp_amount_to_redeem */
        2:
          message.lpAmountToRedeem = reader.string();
          break;
        case /* string needed_amount */
        3:
          message.neededAmount = reader.string();
          break;
        case /* string missing_liquidity */
        4:
          message.missingLiquidity = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bucket !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.bucket);
    if (message.lpAmountToRedeem !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.lpAmountToRedeem);
    if (message.neededAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.neededAmount);
    if (message.missingLiquidity !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.missingLiquidity);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RedemptionBucket = new RedemptionBucket$Type();
class TvlHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.TvlHistoryRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "since",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "max_data_points",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    message.since = 0n;
    message.maxDataPoints = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* sint64 since */
        2:
          message.since = reader.sint64().toBigInt();
          break;
        case /* sint32 max_data_points */
        3:
          message.maxDataPoints = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.since !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.since);
    if (message.maxDataPoints !== 0)
      writer.tag(3, WireType.Varint).sint32(message.maxDataPoints);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TvlHistoryRequest = new TvlHistoryRequest$Type();
class TvlHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.TvlHistoryResponse", [
      { no: 1, name: "history", kind: "message", repeat: 2, T: () => HistoricalTVL }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.history = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_megavault_rpc.HistoricalTVL history */
        1:
          message.history.push(HistoricalTVL.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.history.length; i++)
      HistoricalTVL.internalBinaryWrite(message.history[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TvlHistoryResponse = new TvlHistoryResponse$Type();
class HistoricalTVL$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.HistoricalTVL", [
      {
        no: 1,
        name: "t",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "v",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.t = 0n;
    message.v = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 t */
        1:
          message.t = reader.sint64().toBigInt();
          break;
        case /* string v */
        2:
          message.v = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.t !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.t);
    if (message.v !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.v);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalTVL = new HistoricalTVL$Type();
class PnlHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.PnlHistoryRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "since",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "max_data_points",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    message.since = 0n;
    message.maxDataPoints = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* sint64 since */
        2:
          message.since = reader.sint64().toBigInt();
          break;
        case /* sint32 max_data_points */
        3:
          message.maxDataPoints = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.since !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.since);
    if (message.maxDataPoints !== 0)
      writer.tag(3, WireType.Varint).sint32(message.maxDataPoints);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PnlHistoryRequest = new PnlHistoryRequest$Type();
class PnlHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.PnlHistoryResponse", [
      { no: 1, name: "history", kind: "message", repeat: 2, T: () => HistoricalPnL }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.history = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_megavault_rpc.HistoricalPnL history */
        1:
          message.history.push(HistoricalPnL.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.history.length; i++)
      HistoricalPnL.internalBinaryWrite(message.history[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PnlHistoryResponse = new PnlHistoryResponse$Type();
class HistoricalPnL$Type extends MessageType {
  constructor() {
    super("injective_megavault_rpc.HistoricalPnL", [
      {
        no: 1,
        name: "t",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "v",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.t = 0n;
    message.v = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 t */
        1:
          message.t = reader.sint64().toBigInt();
          break;
        case /* string v */
        2:
          message.v = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.t !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.t);
    if (message.v !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.v);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalPnL = new HistoricalPnL$Type();
const InjectiveMegavaultRPC = new ServiceType("injective_megavault_rpc.InjectiveMegavaultRPC", [
  { name: "GetVault", options: {}, I: GetVaultRequest, O: GetVaultResponse },
  { name: "GetUser", options: {}, I: GetUserRequest, O: GetUserResponse },
  { name: "ListSubscriptions", options: {}, I: ListSubscriptionsRequest, O: ListSubscriptionsResponse },
  { name: "ListRedemptions", options: {}, I: ListRedemptionsRequest, O: ListRedemptionsResponse },
  { name: "GetOperatorRedemptionBuckets", options: {}, I: GetOperatorRedemptionBucketsRequest, O: GetOperatorRedemptionBucketsResponse },
  { name: "TvlHistory", options: {}, I: TvlHistoryRequest, O: TvlHistoryResponse },
  { name: "PnlHistory", options: {}, I: PnlHistoryRequest, O: PnlHistoryResponse }
]);
export {
  Apr,
  AprStats,
  GetOperatorRedemptionBucketsRequest,
  GetOperatorRedemptionBucketsResponse,
  GetUserRequest,
  GetUserResponse,
  GetVaultRequest,
  GetVaultResponse,
  HistoricalPnL,
  HistoricalTVL,
  Incentives,
  InjectiveMegavaultRPC,
  ListRedemptionsRequest,
  ListRedemptionsResponse,
  ListSubscriptionsRequest,
  ListSubscriptionsResponse,
  MaxDrawdown,
  OperationStatusLogEntry,
  Operator,
  Pnl,
  PnlHistoryRequest,
  PnlHistoryResponse,
  PnlStats,
  Redemption,
  RedemptionBucket,
  Subscription,
  TargetApr,
  TvlHistoryRequest,
  TvlHistoryResponse,
  UnrealizedPnl,
  User,
  UserStats,
  Vault,
  VaultStats,
  Volatility,
  VolatilityStats
};
