// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_accounts_rpc.proto" (package "injective_accounts_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveAccountsRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_accounts_rpc.PortfolioRequest
 */
export interface PortfolioRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.PortfolioResponse
 */
export interface PortfolioResponse {
    /**
     * The portfolio of this account
     *
     * @generated from protobuf field: injective_accounts_rpc.AccountPortfolio portfolio = 1
     */
    portfolio?: AccountPortfolio;
}
/**
 * @generated from protobuf message injective_accounts_rpc.AccountPortfolio
 */
export interface AccountPortfolio {
    /**
     * The account's portfolio value in USD.
     *
     * @generated from protobuf field: string portfolio_value = 1
     */
    portfolioValue: string;
    /**
     * The account's available balance value in USD.
     *
     * @generated from protobuf field: string available_balance = 2
     */
    availableBalance: string;
    /**
     * The account's locked balance value in USD.
     *
     * @generated from protobuf field: string locked_balance = 3
     */
    lockedBalance: string;
    /**
     * The account's total unrealized PnL value in USD.
     *
     * @generated from protobuf field: string unrealized_pnl = 4
     */
    unrealizedPnl: string;
    /**
     * List of all subaccounts' portfolio
     *
     * @generated from protobuf field: repeated injective_accounts_rpc.SubaccountPortfolio subaccounts = 5
     */
    subaccounts: SubaccountPortfolio[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountPortfolio
 */
export interface SubaccountPortfolio {
    /**
     * The ID of this subaccount
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * The subaccount's available balance value in USD.
     *
     * @generated from protobuf field: string available_balance = 2
     */
    availableBalance: string;
    /**
     * The subaccount's locked balance value in USD.
     *
     * @generated from protobuf field: string locked_balance = 3
     */
    lockedBalance: string;
    /**
     * The subaccount's total unrealized PnL value in USD.
     *
     * @generated from protobuf field: string unrealized_pnl = 4
     */
    unrealizedPnl: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.OrderStatesRequest
 */
export interface OrderStatesRequest {
    /**
     * @generated from protobuf field: repeated string spot_order_hashes = 1
     */
    spotOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string derivative_order_hashes = 2
     */
    derivativeOrderHashes: string[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.OrderStatesResponse
 */
export interface OrderStatesResponse {
    /**
     * List of the spot order state records
     *
     * @generated from protobuf field: repeated injective_accounts_rpc.OrderStateRecord spot_order_states = 1
     */
    spotOrderStates: OrderStateRecord[];
    /**
     * List of the derivative order state records
     *
     * @generated from protobuf field: repeated injective_accounts_rpc.OrderStateRecord derivative_order_states = 2
     */
    derivativeOrderStates: OrderStateRecord[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.OrderStateRecord
 */
export interface OrderStateRecord {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * The Market ID of the order
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The type of the order
     *
     * @generated from protobuf field: string order_type = 4
     */
    orderType: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_side = 5
     */
    orderSide: string;
    /**
     * The state (status) of the order
     *
     * @generated from protobuf field: string state = 6
     */
    state: string;
    /**
     * The filled quantity of the order
     *
     * @generated from protobuf field: string quantity_filled = 7
     */
    quantityFilled: string;
    /**
     * The filled quantity of the order
     *
     * @generated from protobuf field: string quantity_remaining = 8
     */
    quantityRemaining: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 9
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 10
     */
    updatedAt: bigint;
    /**
     * Order prices
     *
     * @generated from protobuf field: string price = 11
     */
    price: string;
    /**
     * Margin for derivative order
     *
     * @generated from protobuf field: string margin = 12
     */
    margin: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountsListRequest
 */
export interface SubaccountsListRequest {
    /**
     * Account address, the subaccounts owner
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountsListResponse
 */
export interface SubaccountsListResponse {
    /**
     * @generated from protobuf field: repeated string subaccounts = 1
     */
    subaccounts: string[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalancesListRequest
 */
export interface SubaccountBalancesListRequest {
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Filter balances by denoms. If not set, the balances of all the denoms for
     * the subaccount are provided.
     *
     * @generated from protobuf field: repeated string denoms = 2
     */
    denoms: string[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalancesListResponse
 */
export interface SubaccountBalancesListResponse {
    /**
     * List of subaccount balances
     *
     * @generated from protobuf field: repeated injective_accounts_rpc.SubaccountBalance balances = 1
     */
    balances: SubaccountBalance[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalance
 */
export interface SubaccountBalance {
    /**
     * Related subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Account address, owner of this subaccount
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
    /**
     * Coin denom on the chain.
     *
     * @generated from protobuf field: string denom = 3
     */
    denom: string;
    /**
     * @generated from protobuf field: injective_accounts_rpc.SubaccountDeposit deposit = 4
     */
    deposit?: SubaccountDeposit;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountDeposit
 */
export interface SubaccountDeposit {
    /**
     * @generated from protobuf field: string total_balance = 1
     */
    totalBalance: string;
    /**
     * @generated from protobuf field: string available_balance = 2
     */
    availableBalance: string;
    /**
     * @generated from protobuf field: string total_balance_usd = 3
     */
    totalBalanceUsd: string;
    /**
     * @generated from protobuf field: string available_balance_usd = 4
     */
    availableBalanceUsd: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalanceEndpointRequest
 */
export interface SubaccountBalanceEndpointRequest {
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Specify denom to get balance
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalanceEndpointResponse
 */
export interface SubaccountBalanceEndpointResponse {
    /**
     * Subaccount balance
     *
     * @generated from protobuf field: injective_accounts_rpc.SubaccountBalance balance = 1
     */
    balance?: SubaccountBalance;
}
/**
 * @generated from protobuf message injective_accounts_rpc.StreamSubaccountBalanceRequest
 */
export interface StreamSubaccountBalanceRequest {
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Filter balances by denoms. If not set, the balances of all the denoms for
     * the subaccount are provided.
     *
     * @generated from protobuf field: repeated string denoms = 2
     */
    denoms: string[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.StreamSubaccountBalanceResponse
 */
export interface StreamSubaccountBalanceResponse {
    /**
     * Subaccount balance
     *
     * @generated from protobuf field: injective_accounts_rpc.SubaccountBalance balance = 1
     */
    balance?: SubaccountBalance;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountHistoryRequest
 */
export interface SubaccountHistoryRequest {
    /**
     * SubaccountId of the trader we want to get the history from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Filter history by denom
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * Filter history by transfer type
     *
     * @generated from protobuf field: repeated string transfer_types = 3
     */
    transferTypes: string[];
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 5
     */
    limit: number;
    /**
     * Upper bound of account transfer history's executedAt
     *
     * @generated from protobuf field: sint64 end_time = 6
     */
    endTime: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountHistoryResponse
 */
export interface SubaccountHistoryResponse {
    /**
     * List of subaccount transfers
     *
     * @generated from protobuf field: repeated injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1
     */
    transfers: SubaccountBalanceTransfer[];
    /**
     * @generated from protobuf field: injective_accounts_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalanceTransfer
 */
export interface SubaccountBalanceTransfer {
    /**
     * Type of the subaccount balance transfer
     *
     * @generated from protobuf field: string transfer_type = 1
     */
    transferType: string;
    /**
     * Subaccount ID of the sending side
     *
     * @generated from protobuf field: string src_subaccount_id = 2
     */
    srcSubaccountId: string;
    /**
     * Account address of the sending side
     *
     * @generated from protobuf field: string src_account_address = 3
     */
    srcAccountAddress: string;
    /**
     * Subaccount ID of the receiving side
     *
     * @generated from protobuf field: string dst_subaccount_id = 4
     */
    dstSubaccountId: string;
    /**
     * Account address of the receiving side
     *
     * @generated from protobuf field: string dst_account_address = 5
     */
    dstAccountAddress: string;
    /**
     * Coin amount of the transfer
     *
     * @generated from protobuf field: injective_accounts_rpc.CosmosCoin amount = 6
     */
    amount?: CosmosCoin;
    /**
     * Timestamp of the transfer in UNIX millis
     *
     * @generated from protobuf field: sint64 executed_at = 7
     */
    executedAt: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.CosmosCoin
 */
export interface CosmosCoin {
    /**
     * Coin denominator
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * Coin amount (big int)
     *
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_accounts_rpc.Paging
 */
export interface Paging {
    /**
     * total number of txs saved in database
     *
     * @generated from protobuf field: sint64 total = 1
     */
    total: bigint;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 from = 2
     */
    from: number;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 to = 3
     */
    to: number;
    /**
     * count entries by subaccount, serving some places on helix
     *
     * @generated from protobuf field: sint64 count_by_subaccount = 4
     */
    countBySubaccount: bigint;
    /**
     * array of tokens to navigate to the next pages
     *
     * @generated from protobuf field: repeated string next = 5
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountOrderSummaryRequest
 */
export interface SubaccountOrderSummaryRequest {
    /**
     * SubaccountId of the trader we want to get the summary from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * MarketId is limiting order summary to specific market only
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Filter by direction of the orders
     *
     * @generated from protobuf field: string order_direction = 3
     */
    orderDirection: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountOrderSummaryResponse
 */
export interface SubaccountOrderSummaryResponse {
    /**
     * Total count of subaccount's spot orders in given market and direction
     *
     * @generated from protobuf field: sint64 spot_orders_total = 1
     */
    spotOrdersTotal: bigint;
    /**
     * Total count of subaccount's derivative orders in given market and direction
     *
     * @generated from protobuf field: sint64 derivative_orders_total = 2
     */
    derivativeOrdersTotal: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.RewardsRequest
 */
export interface RewardsRequest {
    /**
     * The distribution epoch sequence number. -1 for latest.
     *
     * @generated from protobuf field: sint64 epoch = 1
     */
    epoch: bigint;
    /**
     * Account address for the rewards distribution
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.RewardsResponse
 */
export interface RewardsResponse {
    /**
     * The trading rewards distributed
     *
     * @generated from protobuf field: repeated injective_accounts_rpc.Reward rewards = 1
     */
    rewards: Reward[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.Reward
 */
export interface Reward {
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Reward coins distributed
     *
     * @generated from protobuf field: repeated injective_accounts_rpc.Coin rewards = 2
     */
    rewards: Coin[];
    /**
     * Rewards distribution timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 distributed_at = 3
     */
    distributedAt: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.Coin
 */
export interface Coin {
    /**
     * Denom of the coin
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * @generated from protobuf field: string usd_value = 3
     */
    usdValue: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.StreamAccountDataRequest
 */
export interface StreamAccountDataRequest {
    /**
     * account address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.StreamAccountDataResponse
 */
export interface StreamAccountDataResponse {
    /**
     * @generated from protobuf field: injective_accounts_rpc.SubaccountBalanceResult subaccount_balance = 1
     */
    subaccountBalance?: SubaccountBalanceResult;
    /**
     * @generated from protobuf field: injective_accounts_rpc.PositionsResult position = 2
     */
    position?: PositionsResult;
    /**
     * @generated from protobuf field: injective_accounts_rpc.TradeResult trade = 3
     */
    trade?: TradeResult;
    /**
     * @generated from protobuf field: injective_accounts_rpc.OrderResult order = 4
     */
    order?: OrderResult;
    /**
     * @generated from protobuf field: injective_accounts_rpc.OrderHistoryResult order_history = 5
     */
    orderHistory?: OrderHistoryResult;
    /**
     * @generated from protobuf field: injective_accounts_rpc.FundingPaymentResult funding_payment = 6
     */
    fundingPayment?: FundingPaymentResult;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalanceResult
 */
export interface SubaccountBalanceResult {
    /**
     * Subaccount balance
     *
     * @generated from protobuf field: injective_accounts_rpc.SubaccountBalance balance = 1
     */
    balance?: SubaccountBalance;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.PositionsResult
 */
export interface PositionsResult {
    /**
     * Updated derivative Position
     *
     * @generated from protobuf field: injective_accounts_rpc.Position position = 1
     */
    position?: Position;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.Position
 */
export interface Position {
    /**
     * Ticker of the derivative market
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * The subaccountId that the position belongs to
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Direction of the position
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Quantity of the position
     *
     * @generated from protobuf field: string quantity = 5
     */
    quantity: string;
    /**
     * Price of the position
     *
     * @generated from protobuf field: string entry_price = 6
     */
    entryPrice: string;
    /**
     * Margin of the position
     *
     * @generated from protobuf field: string margin = 7
     */
    margin: string;
    /**
     * LiquidationPrice of the position
     *
     * @generated from protobuf field: string liquidation_price = 8
     */
    liquidationPrice: string;
    /**
     * MarkPrice of the position
     *
     * @generated from protobuf field: string mark_price = 9
     */
    markPrice: string;
    /**
     * Position updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 10
     */
    updatedAt: bigint;
    /**
     * Position created timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 11
     */
    createdAt: bigint;
    /**
     * Last funding fees since position opened
     *
     * @generated from protobuf field: string funding_last = 12
     */
    fundingLast: string;
    /**
     * Net funding fees since position opened
     *
     * @generated from protobuf field: string funding_sum = 13
     */
    fundingSum: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.TradeResult
 */
export interface TradeResult {
    /**
     * @generated from protobuf oneof: trade
     */
    trade: {
        oneofKind: "spotTrade";
        /**
         * New spot market trade
         *
         * @generated from protobuf field: injective_accounts_rpc.SpotTrade spot_trade = 1
         */
        spotTrade: SpotTrade;
    } | {
        oneofKind: "derivativeTrade";
        /**
         * New derivative market trade
         *
         * @generated from protobuf field: injective_accounts_rpc.DerivativeTrade derivative_trade = 2
         */
        derivativeTrade: DerivativeTrade;
    } | {
        oneofKind: undefined;
    };
    /**
     * Executed trades update type
     *
     * @generated from protobuf field: string operation_type = 3
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SpotTrade
 */
export interface SpotTrade {
    /**
     * Maker order hash.
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The subaccountId that executed the trade
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * The ID of the market that this trade is in
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The execution type of the trade
     *
     * @generated from protobuf field: string trade_execution_type = 4
     */
    tradeExecutionType: string;
    /**
     * The direction the trade
     *
     * @generated from protobuf field: string trade_direction = 5
     */
    tradeDirection: string;
    /**
     * Price level at which trade has been executed
     *
     * @generated from protobuf field: injective_accounts_rpc.PriceLevel price = 6
     */
    price?: PriceLevel;
    /**
     * The fee associated with the trade (quote asset denom)
     *
     * @generated from protobuf field: string fee = 7
     */
    fee: string;
    /**
     * Timestamp of trade execution in UNIX millis
     *
     * @generated from protobuf field: sint64 executed_at = 8
     */
    executedAt: bigint;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 9
     */
    feeRecipient: string;
    /**
     * A unique string that helps differentiate between trades
     *
     * @generated from protobuf field: string trade_id = 10
     */
    tradeId: string;
    /**
     * Trade's execution side, marker/taker
     *
     * @generated from protobuf field: string execution_side = 11
     */
    executionSide: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 12
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.PriceLevel
 */
export interface PriceLevel {
    /**
     * Price number of the price level.
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * Quantity of the price level.
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * Price level last updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.DerivativeTrade
 */
export interface DerivativeTrade {
    /**
     * Order hash.
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The subaccountId that executed the trade
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * The ID of the market that this trade is in
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The execution type of the trade
     *
     * @generated from protobuf field: string trade_execution_type = 4
     */
    tradeExecutionType: string;
    /**
     * True if the trade is a liquidation
     *
     * @generated from protobuf field: bool is_liquidation = 5
     */
    isLiquidation: boolean;
    /**
     * Position Delta from the trade
     *
     * @generated from protobuf field: injective_accounts_rpc.PositionDelta position_delta = 6
     */
    positionDelta?: PositionDelta;
    /**
     * The payout associated with the trade
     *
     * @generated from protobuf field: string payout = 7
     */
    payout: string;
    /**
     * The fee associated with the trade
     *
     * @generated from protobuf field: string fee = 8
     */
    fee: string;
    /**
     * Timestamp of trade execution in UNIX millis
     *
     * @generated from protobuf field: sint64 executed_at = 9
     */
    executedAt: bigint;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 10
     */
    feeRecipient: string;
    /**
     * A unique string that helps differentiate between trades
     *
     * @generated from protobuf field: string trade_id = 11
     */
    tradeId: string;
    /**
     * Trade's execution side, marker/taker
     *
     * @generated from protobuf field: string execution_side = 12
     */
    executionSide: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 13
     */
    cid: string;
    /**
     * Profit and loss of the trade
     *
     * @generated from protobuf field: string pnl = 14
     */
    pnl: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.PositionDelta
 */
export interface PositionDelta {
    /**
     * The direction the trade
     *
     * @generated from protobuf field: string trade_direction = 1
     */
    tradeDirection: string;
    /**
     * Execution Price of the trade.
     *
     * @generated from protobuf field: string execution_price = 2
     */
    executionPrice: string;
    /**
     * Execution Quantity of the trade.
     *
     * @generated from protobuf field: string execution_quantity = 3
     */
    executionQuantity: string;
    /**
     * Execution Margin of the trade.
     *
     * @generated from protobuf field: string execution_margin = 4
     */
    executionMargin: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.OrderResult
 */
export interface OrderResult {
    /**
     * @generated from protobuf oneof: order
     */
    order: {
        oneofKind: "spotOrder";
        /**
         * Updated spot market order
         *
         * @generated from protobuf field: injective_accounts_rpc.SpotLimitOrder spot_order = 1
         */
        spotOrder: SpotLimitOrder;
    } | {
        oneofKind: "derivativeOrder";
        /**
         * Updated derivative market order
         *
         * @generated from protobuf field: injective_accounts_rpc.DerivativeLimitOrder derivative_order = 2
         */
        derivativeOrder: DerivativeLimitOrder;
    } | {
        oneofKind: undefined;
    };
    /**
     * Executed orders update type
     *
     * @generated from protobuf field: string operation_type = 3
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SpotLimitOrder
 */
export interface SpotLimitOrder {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Spot Market ID is keccak265(baseDenom + quoteDenom)
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 5
     */
    price: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 6
     */
    quantity: string;
    /**
     * The amount of the quantity remaining unfilled
     *
     * @generated from protobuf field: string unfilled_quantity = 7
     */
    unfilledQuantity: string;
    /**
     * Trigger price is the trigger price used by stop/take orders. 0 if the
     * trigger price is not set.
     *
     * @generated from protobuf field: string trigger_price = 8
     */
    triggerPrice: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 9
     */
    feeRecipient: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 10
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 11
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 12
     */
    updatedAt: bigint;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 13
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.DerivativeLimitOrder
 */
export interface DerivativeLimitOrder {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * True if the order is a reduce-only order
     *
     * @generated from protobuf field: bool is_reduce_only = 5
     */
    isReduceOnly: boolean;
    /**
     * Margin of the order
     *
     * @generated from protobuf field: string margin = 6
     */
    margin: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 7
     */
    price: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 8
     */
    quantity: string;
    /**
     * The amount of the quantity remaining unfilled
     *
     * @generated from protobuf field: string unfilled_quantity = 9
     */
    unfilledQuantity: string;
    /**
     * Trigger price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 10
     */
    triggerPrice: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 11
     */
    feeRecipient: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 12
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 13
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 14
     */
    updatedAt: bigint;
    /**
     * Order number of subaccount
     *
     * @generated from protobuf field: sint64 order_number = 15
     */
    orderNumber: bigint;
    /**
     * Order type
     *
     * @generated from protobuf field: string order_type = 16
     */
    orderType: string;
    /**
     * Order type
     *
     * @generated from protobuf field: bool is_conditional = 17
     */
    isConditional: boolean;
    /**
     * Trigger timestamp, only exists for conditional orders
     *
     * @generated from protobuf field: uint64 trigger_at = 18
     */
    triggerAt: bigint;
    /**
     * OrderHash of order that is triggered by this conditional order
     *
     * @generated from protobuf field: string placed_order_hash = 19
     */
    placedOrderHash: string;
    /**
     * Execution type of conditional order
     *
     * @generated from protobuf field: string execution_type = 20
     */
    executionType: string;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 21
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 22
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.OrderHistoryResult
 */
export interface OrderHistoryResult {
    /**
     * @generated from protobuf oneof: order_history
     */
    orderHistory: {
        oneofKind: "spotOrderHistory";
        /**
         * Spot order history
         *
         * @generated from protobuf field: injective_accounts_rpc.SpotOrderHistory spot_order_history = 1
         */
        spotOrderHistory: SpotOrderHistory;
    } | {
        oneofKind: "derivativeOrderHistory";
        /**
         * Derivative order history
         *
         * @generated from protobuf field: injective_accounts_rpc.DerivativeOrderHistory derivative_order_history = 2
         */
        derivativeOrderHistory: DerivativeOrderHistory;
    } | {
        oneofKind: undefined;
    };
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 3
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SpotOrderHistory
 */
export interface SpotOrderHistory {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * Spot Market ID is keccak265(baseDenom + quoteDenom)
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * active state of the order
     *
     * @generated from protobuf field: bool is_active = 3
     */
    isActive: boolean;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * The execution type
     *
     * @generated from protobuf field: string execution_type = 5
     */
    executionType: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_type = 6
     */
    orderType: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 7
     */
    price: string;
    /**
     * Trigger price
     *
     * @generated from protobuf field: string trigger_price = 8
     */
    triggerPrice: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 9
     */
    quantity: string;
    /**
     * Filled amount
     *
     * @generated from protobuf field: string filled_quantity = 10
     */
    filledQuantity: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 11
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 12
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 13
     */
    updatedAt: bigint;
    /**
     * Order direction (order side)
     *
     * @generated from protobuf field: string direction = 14
     */
    direction: string;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 15
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 16
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.DerivativeOrderHistory
 */
export interface DerivativeOrderHistory {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * Spot Market ID is keccak265(baseDenom + quoteDenom)
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * active state of the order
     *
     * @generated from protobuf field: bool is_active = 3
     */
    isActive: boolean;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * The execution type
     *
     * @generated from protobuf field: string execution_type = 5
     */
    executionType: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_type = 6
     */
    orderType: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 7
     */
    price: string;
    /**
     * Trigger price
     *
     * @generated from protobuf field: string trigger_price = 8
     */
    triggerPrice: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 9
     */
    quantity: string;
    /**
     * Filled amount
     *
     * @generated from protobuf field: string filled_quantity = 10
     */
    filledQuantity: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 11
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 12
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 13
     */
    updatedAt: bigint;
    /**
     * True if an order is reduce only
     *
     * @generated from protobuf field: bool is_reduce_only = 14
     */
    isReduceOnly: boolean;
    /**
     * Order direction (order side)
     *
     * @generated from protobuf field: string direction = 15
     */
    direction: string;
    /**
     * True if this is conditional order, otherwise false
     *
     * @generated from protobuf field: bool is_conditional = 16
     */
    isConditional: boolean;
    /**
     * Trigger timestamp in unix milli
     *
     * @generated from protobuf field: uint64 trigger_at = 17
     */
    triggerAt: bigint;
    /**
     * Order hash placed when this triggers
     *
     * @generated from protobuf field: string placed_order_hash = 18
     */
    placedOrderHash: string;
    /**
     * Order's margin
     *
     * @generated from protobuf field: string margin = 19
     */
    margin: string;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 20
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 21
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.FundingPaymentResult
 */
export interface FundingPaymentResult {
    /**
     * Funding payments of the account
     *
     * @generated from protobuf field: injective_accounts_rpc.FundingPayment funding_payments = 1
     */
    fundingPayments?: FundingPayment;
    /**
     * Funding payments type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.FundingPayment
 */
export interface FundingPayment {
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * The subaccountId that the position belongs to
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * Amount of the funding payment
     *
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
    /**
     * Timestamp of funding payment in UNIX millis
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioRequest$Type extends MessageType<PortfolioRequest> {
    constructor() {
        super("injective_accounts_rpc.PortfolioRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PortfolioRequest>): PortfolioRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<PortfolioRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioRequest): PortfolioRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.PortfolioRequest
 */
export const PortfolioRequest = new PortfolioRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioResponse$Type extends MessageType<PortfolioResponse> {
    constructor() {
        super("injective_accounts_rpc.PortfolioResponse", [
            { no: 1, name: "portfolio", kind: "message", T: () => AccountPortfolio }
        ]);
    }
    create(value?: PartialMessage<PortfolioResponse>): PortfolioResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PortfolioResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioResponse): PortfolioResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.AccountPortfolio portfolio */ 1:
                    message.portfolio = AccountPortfolio.internalBinaryRead(reader, reader.uint32(), options, message.portfolio);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.AccountPortfolio portfolio = 1; */
        if (message.portfolio)
            AccountPortfolio.internalBinaryWrite(message.portfolio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.PortfolioResponse
 */
export const PortfolioResponse = new PortfolioResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountPortfolio$Type extends MessageType<AccountPortfolio> {
    constructor() {
        super("injective_accounts_rpc.AccountPortfolio", [
            { no: 1, name: "portfolio_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "available_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "locked_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unrealized_pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "subaccounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountPortfolio }
        ]);
    }
    create(value?: PartialMessage<AccountPortfolio>): AccountPortfolio {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.portfolioValue = "";
        message.availableBalance = "";
        message.lockedBalance = "";
        message.unrealizedPnl = "";
        message.subaccounts = [];
        if (value !== undefined)
            reflectionMergePartial<AccountPortfolio>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountPortfolio): AccountPortfolio {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string portfolio_value */ 1:
                    message.portfolioValue = reader.string();
                    break;
                case /* string available_balance */ 2:
                    message.availableBalance = reader.string();
                    break;
                case /* string locked_balance */ 3:
                    message.lockedBalance = reader.string();
                    break;
                case /* string unrealized_pnl */ 4:
                    message.unrealizedPnl = reader.string();
                    break;
                case /* repeated injective_accounts_rpc.SubaccountPortfolio subaccounts */ 5:
                    message.subaccounts.push(SubaccountPortfolio.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountPortfolio, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string portfolio_value = 1; */
        if (message.portfolioValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portfolioValue);
        /* string available_balance = 2; */
        if (message.availableBalance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
        /* string locked_balance = 3; */
        if (message.lockedBalance !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lockedBalance);
        /* string unrealized_pnl = 4; */
        if (message.unrealizedPnl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.unrealizedPnl);
        /* repeated injective_accounts_rpc.SubaccountPortfolio subaccounts = 5; */
        for (let i = 0; i < message.subaccounts.length; i++)
            SubaccountPortfolio.internalBinaryWrite(message.subaccounts[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.AccountPortfolio
 */
export const AccountPortfolio = new AccountPortfolio$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountPortfolio$Type extends MessageType<SubaccountPortfolio> {
    constructor() {
        super("injective_accounts_rpc.SubaccountPortfolio", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "available_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "locked_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unrealized_pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountPortfolio>): SubaccountPortfolio {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.availableBalance = "";
        message.lockedBalance = "";
        message.unrealizedPnl = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountPortfolio>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountPortfolio): SubaccountPortfolio {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string available_balance */ 2:
                    message.availableBalance = reader.string();
                    break;
                case /* string locked_balance */ 3:
                    message.lockedBalance = reader.string();
                    break;
                case /* string unrealized_pnl */ 4:
                    message.unrealizedPnl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountPortfolio, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string available_balance = 2; */
        if (message.availableBalance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
        /* string locked_balance = 3; */
        if (message.lockedBalance !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lockedBalance);
        /* string unrealized_pnl = 4; */
        if (message.unrealizedPnl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.unrealizedPnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountPortfolio
 */
export const SubaccountPortfolio = new SubaccountPortfolio$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderStatesRequest$Type extends MessageType<OrderStatesRequest> {
    constructor() {
        super("injective_accounts_rpc.OrderStatesRequest", [
            { no: 1, name: "spot_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "derivative_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderStatesRequest>): OrderStatesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spotOrderHashes = [];
        message.derivativeOrderHashes = [];
        if (value !== undefined)
            reflectionMergePartial<OrderStatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderStatesRequest): OrderStatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string spot_order_hashes */ 1:
                    message.spotOrderHashes.push(reader.string());
                    break;
                case /* repeated string derivative_order_hashes */ 2:
                    message.derivativeOrderHashes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderStatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string spot_order_hashes = 1; */
        for (let i = 0; i < message.spotOrderHashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.spotOrderHashes[i]);
        /* repeated string derivative_order_hashes = 2; */
        for (let i = 0; i < message.derivativeOrderHashes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.derivativeOrderHashes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.OrderStatesRequest
 */
export const OrderStatesRequest = new OrderStatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderStatesResponse$Type extends MessageType<OrderStatesResponse> {
    constructor() {
        super("injective_accounts_rpc.OrderStatesResponse", [
            { no: 1, name: "spot_order_states", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderStateRecord },
            { no: 2, name: "derivative_order_states", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderStateRecord }
        ]);
    }
    create(value?: PartialMessage<OrderStatesResponse>): OrderStatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spotOrderStates = [];
        message.derivativeOrderStates = [];
        if (value !== undefined)
            reflectionMergePartial<OrderStatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderStatesResponse): OrderStatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_accounts_rpc.OrderStateRecord spot_order_states */ 1:
                    message.spotOrderStates.push(OrderStateRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_accounts_rpc.OrderStateRecord derivative_order_states */ 2:
                    message.derivativeOrderStates.push(OrderStateRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderStatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_accounts_rpc.OrderStateRecord spot_order_states = 1; */
        for (let i = 0; i < message.spotOrderStates.length; i++)
            OrderStateRecord.internalBinaryWrite(message.spotOrderStates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_accounts_rpc.OrderStateRecord derivative_order_states = 2; */
        for (let i = 0; i < message.derivativeOrderStates.length; i++)
            OrderStateRecord.internalBinaryWrite(message.derivativeOrderStates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.OrderStatesResponse
 */
export const OrderStatesResponse = new OrderStatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderStateRecord$Type extends MessageType<OrderStateRecord> {
    constructor() {
        super("injective_accounts_rpc.OrderStateRecord", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "quantity_filled", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "quantity_remaining", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderStateRecord>): OrderStateRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.subaccountId = "";
        message.marketId = "";
        message.orderType = "";
        message.orderSide = "";
        message.state = "";
        message.quantityFilled = "";
        message.quantityRemaining = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.price = "";
        message.margin = "";
        if (value !== undefined)
            reflectionMergePartial<OrderStateRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderStateRecord): OrderStateRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string order_type */ 4:
                    message.orderType = reader.string();
                    break;
                case /* string order_side */ 5:
                    message.orderSide = reader.string();
                    break;
                case /* string state */ 6:
                    message.state = reader.string();
                    break;
                case /* string quantity_filled */ 7:
                    message.quantityFilled = reader.string();
                    break;
                case /* string quantity_remaining */ 8:
                    message.quantityRemaining = reader.string();
                    break;
                case /* sint64 created_at */ 9:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 10:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string price */ 11:
                    message.price = reader.string();
                    break;
                case /* string margin */ 12:
                    message.margin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderStateRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string order_type = 4; */
        if (message.orderType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orderType);
        /* string order_side = 5; */
        if (message.orderSide !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.orderSide);
        /* string state = 6; */
        if (message.state !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.state);
        /* string quantity_filled = 7; */
        if (message.quantityFilled !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.quantityFilled);
        /* string quantity_remaining = 8; */
        if (message.quantityRemaining !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.quantityRemaining);
        /* sint64 created_at = 9; */
        if (message.createdAt !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 10; */
        if (message.updatedAt !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.updatedAt);
        /* string price = 11; */
        if (message.price !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.price);
        /* string margin = 12; */
        if (message.margin !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.margin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.OrderStateRecord
 */
export const OrderStateRecord = new OrderStateRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountsListRequest$Type extends MessageType<SubaccountsListRequest> {
    constructor() {
        super("injective_accounts_rpc.SubaccountsListRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountsListRequest>): SubaccountsListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountsListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountsListRequest): SubaccountsListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountsListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountsListRequest
 */
export const SubaccountsListRequest = new SubaccountsListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountsListResponse$Type extends MessageType<SubaccountsListResponse> {
    constructor() {
        super("injective_accounts_rpc.SubaccountsListResponse", [
            { no: 1, name: "subaccounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountsListResponse>): SubaccountsListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccounts = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountsListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountsListResponse): SubaccountsListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string subaccounts */ 1:
                    message.subaccounts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountsListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string subaccounts = 1; */
        for (let i = 0; i < message.subaccounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subaccounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountsListResponse
 */
export const SubaccountsListResponse = new SubaccountsListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalancesListRequest$Type extends MessageType<SubaccountBalancesListRequest> {
    constructor() {
        super("injective_accounts_rpc.SubaccountBalancesListRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denoms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalancesListRequest>): SubaccountBalancesListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denoms = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalancesListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalancesListRequest): SubaccountBalancesListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated string denoms */ 2:
                    message.denoms.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalancesListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated string denoms = 2; */
        for (let i = 0; i < message.denoms.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.denoms[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalancesListRequest
 */
export const SubaccountBalancesListRequest = new SubaccountBalancesListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalancesListResponse$Type extends MessageType<SubaccountBalancesListResponse> {
    constructor() {
        super("injective_accounts_rpc.SubaccountBalancesListResponse", [
            { no: 1, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountBalance }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalancesListResponse>): SubaccountBalancesListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalancesListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalancesListResponse): SubaccountBalancesListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_accounts_rpc.SubaccountBalance balances */ 1:
                    message.balances.push(SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalancesListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_accounts_rpc.SubaccountBalance balances = 1; */
        for (let i = 0; i < message.balances.length; i++)
            SubaccountBalance.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalancesListResponse
 */
export const SubaccountBalancesListResponse = new SubaccountBalancesListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalance$Type extends MessageType<SubaccountBalance> {
    constructor() {
        super("injective_accounts_rpc.SubaccountBalance", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "deposit", kind: "message", T: () => SubaccountDeposit }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalance>): SubaccountBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.accountAddress = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalance): SubaccountBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                case /* string denom */ 3:
                    message.denom = reader.string();
                    break;
                case /* injective_accounts_rpc.SubaccountDeposit deposit */ 4:
                    message.deposit = SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        /* string denom = 3; */
        if (message.denom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.denom);
        /* injective_accounts_rpc.SubaccountDeposit deposit = 4; */
        if (message.deposit)
            SubaccountDeposit.internalBinaryWrite(message.deposit, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalance
 */
export const SubaccountBalance = new SubaccountBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountDeposit$Type extends MessageType<SubaccountDeposit> {
    constructor() {
        super("injective_accounts_rpc.SubaccountDeposit", [
            { no: 1, name: "total_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "available_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total_balance_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "available_balance_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountDeposit>): SubaccountDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalBalance = "";
        message.availableBalance = "";
        message.totalBalanceUsd = "";
        message.availableBalanceUsd = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountDeposit): SubaccountDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string total_balance */ 1:
                    message.totalBalance = reader.string();
                    break;
                case /* string available_balance */ 2:
                    message.availableBalance = reader.string();
                    break;
                case /* string total_balance_usd */ 3:
                    message.totalBalanceUsd = reader.string();
                    break;
                case /* string available_balance_usd */ 4:
                    message.availableBalanceUsd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string total_balance = 1; */
        if (message.totalBalance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.totalBalance);
        /* string available_balance = 2; */
        if (message.availableBalance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
        /* string total_balance_usd = 3; */
        if (message.totalBalanceUsd !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.totalBalanceUsd);
        /* string available_balance_usd = 4; */
        if (message.availableBalanceUsd !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.availableBalanceUsd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountDeposit
 */
export const SubaccountDeposit = new SubaccountDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalanceEndpointRequest$Type extends MessageType<SubaccountBalanceEndpointRequest> {
    constructor() {
        super("injective_accounts_rpc.SubaccountBalanceEndpointRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalanceEndpointRequest>): SubaccountBalanceEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalanceEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalanceEndpointRequest): SubaccountBalanceEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalanceEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalanceEndpointRequest
 */
export const SubaccountBalanceEndpointRequest = new SubaccountBalanceEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalanceEndpointResponse$Type extends MessageType<SubaccountBalanceEndpointResponse> {
    constructor() {
        super("injective_accounts_rpc.SubaccountBalanceEndpointResponse", [
            { no: 1, name: "balance", kind: "message", T: () => SubaccountBalance }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalanceEndpointResponse>): SubaccountBalanceEndpointResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalanceEndpointResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalanceEndpointResponse): SubaccountBalanceEndpointResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.SubaccountBalance balance */ 1:
                    message.balance = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalanceEndpointResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.SubaccountBalance balance = 1; */
        if (message.balance)
            SubaccountBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalanceEndpointResponse
 */
export const SubaccountBalanceEndpointResponse = new SubaccountBalanceEndpointResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamSubaccountBalanceRequest$Type extends MessageType<StreamSubaccountBalanceRequest> {
    constructor() {
        super("injective_accounts_rpc.StreamSubaccountBalanceRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denoms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamSubaccountBalanceRequest>): StreamSubaccountBalanceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denoms = [];
        if (value !== undefined)
            reflectionMergePartial<StreamSubaccountBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamSubaccountBalanceRequest): StreamSubaccountBalanceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated string denoms */ 2:
                    message.denoms.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamSubaccountBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated string denoms = 2; */
        for (let i = 0; i < message.denoms.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.denoms[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.StreamSubaccountBalanceRequest
 */
export const StreamSubaccountBalanceRequest = new StreamSubaccountBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamSubaccountBalanceResponse$Type extends MessageType<StreamSubaccountBalanceResponse> {
    constructor() {
        super("injective_accounts_rpc.StreamSubaccountBalanceResponse", [
            { no: 1, name: "balance", kind: "message", T: () => SubaccountBalance },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamSubaccountBalanceResponse>): StreamSubaccountBalanceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamSubaccountBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamSubaccountBalanceResponse): StreamSubaccountBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.SubaccountBalance balance */ 1:
                    message.balance = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamSubaccountBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.SubaccountBalance balance = 1; */
        if (message.balance)
            SubaccountBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.StreamSubaccountBalanceResponse
 */
export const StreamSubaccountBalanceResponse = new StreamSubaccountBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountHistoryRequest$Type extends MessageType<SubaccountHistoryRequest> {
    constructor() {
        super("injective_accounts_rpc.SubaccountHistoryRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "transfer_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountHistoryRequest>): SubaccountHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denom = "";
        message.transferTypes = [];
        message.skip = 0n;
        message.limit = 0;
        message.endTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubaccountHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountHistoryRequest): SubaccountHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* repeated string transfer_types */ 3:
                    message.transferTypes.push(reader.string());
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 5:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 end_time */ 6:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* repeated string transfer_types = 3; */
        for (let i = 0; i < message.transferTypes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.transferTypes[i]);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 5; */
        if (message.limit !== 0)
            writer.tag(5, WireType.Varint).sint32(message.limit);
        /* sint64 end_time = 6; */
        if (message.endTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountHistoryRequest
 */
export const SubaccountHistoryRequest = new SubaccountHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountHistoryResponse$Type extends MessageType<SubaccountHistoryResponse> {
    constructor() {
        super("injective_accounts_rpc.SubaccountHistoryResponse", [
            { no: 1, name: "transfers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountBalanceTransfer },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<SubaccountHistoryResponse>): SubaccountHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transfers = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountHistoryResponse): SubaccountHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_accounts_rpc.SubaccountBalanceTransfer transfers */ 1:
                    message.transfers.push(SubaccountBalanceTransfer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_accounts_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1; */
        for (let i = 0; i < message.transfers.length; i++)
            SubaccountBalanceTransfer.internalBinaryWrite(message.transfers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountHistoryResponse
 */
export const SubaccountHistoryResponse = new SubaccountHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalanceTransfer$Type extends MessageType<SubaccountBalanceTransfer> {
    constructor() {
        super("injective_accounts_rpc.SubaccountBalanceTransfer", [
            { no: 1, name: "transfer_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "src_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "src_account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dst_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dst_account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "amount", kind: "message", T: () => CosmosCoin },
            { no: 7, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalanceTransfer>): SubaccountBalanceTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transferType = "";
        message.srcSubaccountId = "";
        message.srcAccountAddress = "";
        message.dstSubaccountId = "";
        message.dstAccountAddress = "";
        message.executedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalanceTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalanceTransfer): SubaccountBalanceTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string transfer_type */ 1:
                    message.transferType = reader.string();
                    break;
                case /* string src_subaccount_id */ 2:
                    message.srcSubaccountId = reader.string();
                    break;
                case /* string src_account_address */ 3:
                    message.srcAccountAddress = reader.string();
                    break;
                case /* string dst_subaccount_id */ 4:
                    message.dstSubaccountId = reader.string();
                    break;
                case /* string dst_account_address */ 5:
                    message.dstAccountAddress = reader.string();
                    break;
                case /* injective_accounts_rpc.CosmosCoin amount */ 6:
                    message.amount = CosmosCoin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                case /* sint64 executed_at */ 7:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalanceTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string transfer_type = 1; */
        if (message.transferType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.transferType);
        /* string src_subaccount_id = 2; */
        if (message.srcSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.srcSubaccountId);
        /* string src_account_address = 3; */
        if (message.srcAccountAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.srcAccountAddress);
        /* string dst_subaccount_id = 4; */
        if (message.dstSubaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dstSubaccountId);
        /* string dst_account_address = 5; */
        if (message.dstAccountAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dstAccountAddress);
        /* injective_accounts_rpc.CosmosCoin amount = 6; */
        if (message.amount)
            CosmosCoin.internalBinaryWrite(message.amount, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* sint64 executed_at = 7; */
        if (message.executedAt !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.executedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalanceTransfer
 */
export const SubaccountBalanceTransfer = new SubaccountBalanceTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CosmosCoin$Type extends MessageType<CosmosCoin> {
    constructor() {
        super("injective_accounts_rpc.CosmosCoin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CosmosCoin>): CosmosCoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<CosmosCoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CosmosCoin): CosmosCoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CosmosCoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.CosmosCoin
 */
export const CosmosCoin = new CosmosCoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Paging$Type extends MessageType<Paging> {
    constructor() {
        super("injective_accounts_rpc.Paging", [
            { no: 1, name: "total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "from", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "to", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "count_by_subaccount", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Paging>): Paging {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0n;
        message.from = 0;
        message.to = 0;
        message.countBySubaccount = 0n;
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<Paging>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Paging): Paging {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 total */ 1:
                    message.total = reader.sint64().toBigInt();
                    break;
                case /* sint32 from */ 2:
                    message.from = reader.sint32();
                    break;
                case /* sint32 to */ 3:
                    message.to = reader.sint32();
                    break;
                case /* sint64 count_by_subaccount */ 4:
                    message.countBySubaccount = reader.sint64().toBigInt();
                    break;
                case /* repeated string next */ 5:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Paging, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 total = 1; */
        if (message.total !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.total);
        /* sint32 from = 2; */
        if (message.from !== 0)
            writer.tag(2, WireType.Varint).sint32(message.from);
        /* sint32 to = 3; */
        if (message.to !== 0)
            writer.tag(3, WireType.Varint).sint32(message.to);
        /* sint64 count_by_subaccount = 4; */
        if (message.countBySubaccount !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
        /* repeated string next = 5; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.Paging
 */
export const Paging = new Paging$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrderSummaryRequest$Type extends MessageType<SubaccountOrderSummaryRequest> {
    constructor() {
        super("injective_accounts_rpc.SubaccountOrderSummaryRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrderSummaryRequest>): SubaccountOrderSummaryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.orderDirection = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrderSummaryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrderSummaryRequest): SubaccountOrderSummaryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string order_direction */ 3:
                    message.orderDirection = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrderSummaryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string order_direction = 3; */
        if (message.orderDirection !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.orderDirection);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountOrderSummaryRequest
 */
export const SubaccountOrderSummaryRequest = new SubaccountOrderSummaryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrderSummaryResponse$Type extends MessageType<SubaccountOrderSummaryResponse> {
    constructor() {
        super("injective_accounts_rpc.SubaccountOrderSummaryResponse", [
            { no: 1, name: "spot_orders_total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "derivative_orders_total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrderSummaryResponse>): SubaccountOrderSummaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spotOrdersTotal = 0n;
        message.derivativeOrdersTotal = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrderSummaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrderSummaryResponse): SubaccountOrderSummaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 spot_orders_total */ 1:
                    message.spotOrdersTotal = reader.sint64().toBigInt();
                    break;
                case /* sint64 derivative_orders_total */ 2:
                    message.derivativeOrdersTotal = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrderSummaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 spot_orders_total = 1; */
        if (message.spotOrdersTotal !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.spotOrdersTotal);
        /* sint64 derivative_orders_total = 2; */
        if (message.derivativeOrdersTotal !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.derivativeOrdersTotal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountOrderSummaryResponse
 */
export const SubaccountOrderSummaryResponse = new SubaccountOrderSummaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardsRequest$Type extends MessageType<RewardsRequest> {
    constructor() {
        super("injective_accounts_rpc.RewardsRequest", [
            { no: 1, name: "epoch", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RewardsRequest>): RewardsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epoch = 0n;
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<RewardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardsRequest): RewardsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 epoch */ 1:
                    message.epoch = reader.sint64().toBigInt();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 epoch = 1; */
        if (message.epoch !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.epoch);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.RewardsRequest
 */
export const RewardsRequest = new RewardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardsResponse$Type extends MessageType<RewardsResponse> {
    constructor() {
        super("injective_accounts_rpc.RewardsResponse", [
            { no: 1, name: "rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Reward }
        ]);
    }
    create(value?: PartialMessage<RewardsResponse>): RewardsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rewards = [];
        if (value !== undefined)
            reflectionMergePartial<RewardsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardsResponse): RewardsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_accounts_rpc.Reward rewards */ 1:
                    message.rewards.push(Reward.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_accounts_rpc.Reward rewards = 1; */
        for (let i = 0; i < message.rewards.length; i++)
            Reward.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.RewardsResponse
 */
export const RewardsResponse = new RewardsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reward$Type extends MessageType<Reward> {
    constructor() {
        super("injective_accounts_rpc.Reward", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 3, name: "distributed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Reward>): Reward {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.rewards = [];
        message.distributedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<Reward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reward): Reward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* repeated injective_accounts_rpc.Coin rewards */ 2:
                    message.rewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 distributed_at */ 3:
                    message.distributedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* repeated injective_accounts_rpc.Coin rewards = 2; */
        for (let i = 0; i < message.rewards.length; i++)
            Coin.internalBinaryWrite(message.rewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sint64 distributed_at = 3; */
        if (message.distributedAt !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.distributedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.Reward
 */
export const Reward = new Reward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Coin$Type extends MessageType<Coin> {
    constructor() {
        super("injective_accounts_rpc.Coin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Coin>): Coin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        message.usdValue = "";
        if (value !== undefined)
            reflectionMergePartial<Coin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coin): Coin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* string usd_value */ 3:
                    message.usdValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* string usd_value = 3; */
        if (message.usdValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.Coin
 */
export const Coin = new Coin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamAccountDataRequest$Type extends MessageType<StreamAccountDataRequest> {
    constructor() {
        super("injective_accounts_rpc.StreamAccountDataRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamAccountDataRequest>): StreamAccountDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<StreamAccountDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamAccountDataRequest): StreamAccountDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamAccountDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.StreamAccountDataRequest
 */
export const StreamAccountDataRequest = new StreamAccountDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamAccountDataResponse$Type extends MessageType<StreamAccountDataResponse> {
    constructor() {
        super("injective_accounts_rpc.StreamAccountDataResponse", [
            { no: 1, name: "subaccount_balance", kind: "message", T: () => SubaccountBalanceResult },
            { no: 2, name: "position", kind: "message", T: () => PositionsResult },
            { no: 3, name: "trade", kind: "message", T: () => TradeResult },
            { no: 4, name: "order", kind: "message", T: () => OrderResult },
            { no: 5, name: "order_history", kind: "message", T: () => OrderHistoryResult },
            { no: 6, name: "funding_payment", kind: "message", T: () => FundingPaymentResult }
        ]);
    }
    create(value?: PartialMessage<StreamAccountDataResponse>): StreamAccountDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamAccountDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamAccountDataResponse): StreamAccountDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.SubaccountBalanceResult subaccount_balance */ 1:
                    message.subaccountBalance = SubaccountBalanceResult.internalBinaryRead(reader, reader.uint32(), options, message.subaccountBalance);
                    break;
                case /* injective_accounts_rpc.PositionsResult position */ 2:
                    message.position = PositionsResult.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* injective_accounts_rpc.TradeResult trade */ 3:
                    message.trade = TradeResult.internalBinaryRead(reader, reader.uint32(), options, message.trade);
                    break;
                case /* injective_accounts_rpc.OrderResult order */ 4:
                    message.order = OrderResult.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* injective_accounts_rpc.OrderHistoryResult order_history */ 5:
                    message.orderHistory = OrderHistoryResult.internalBinaryRead(reader, reader.uint32(), options, message.orderHistory);
                    break;
                case /* injective_accounts_rpc.FundingPaymentResult funding_payment */ 6:
                    message.fundingPayment = FundingPaymentResult.internalBinaryRead(reader, reader.uint32(), options, message.fundingPayment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamAccountDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.SubaccountBalanceResult subaccount_balance = 1; */
        if (message.subaccountBalance)
            SubaccountBalanceResult.internalBinaryWrite(message.subaccountBalance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.PositionsResult position = 2; */
        if (message.position)
            PositionsResult.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.TradeResult trade = 3; */
        if (message.trade)
            TradeResult.internalBinaryWrite(message.trade, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.OrderResult order = 4; */
        if (message.order)
            OrderResult.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.OrderHistoryResult order_history = 5; */
        if (message.orderHistory)
            OrderHistoryResult.internalBinaryWrite(message.orderHistory, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.FundingPaymentResult funding_payment = 6; */
        if (message.fundingPayment)
            FundingPaymentResult.internalBinaryWrite(message.fundingPayment, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.StreamAccountDataResponse
 */
export const StreamAccountDataResponse = new StreamAccountDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalanceResult$Type extends MessageType<SubaccountBalanceResult> {
    constructor() {
        super("injective_accounts_rpc.SubaccountBalanceResult", [
            { no: 1, name: "balance", kind: "message", T: () => SubaccountBalance },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalanceResult>): SubaccountBalanceResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalanceResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalanceResult): SubaccountBalanceResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.SubaccountBalance balance */ 1:
                    message.balance = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalanceResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.SubaccountBalance balance = 1; */
        if (message.balance)
            SubaccountBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalanceResult
 */
export const SubaccountBalanceResult = new SubaccountBalanceResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsResult$Type extends MessageType<PositionsResult> {
    constructor() {
        super("injective_accounts_rpc.PositionsResult", [
            { no: 1, name: "position", kind: "message", T: () => Position },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsResult>): PositionsResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PositionsResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsResult): PositionsResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.PositionsResult
 */
export const PositionsResult = new PositionsResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("injective_accounts_rpc.Position", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "liquidation_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "mark_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "funding_last", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "funding_sum", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.marketId = "";
        message.subaccountId = "";
        message.direction = "";
        message.quantity = "";
        message.entryPrice = "";
        message.margin = "";
        message.liquidationPrice = "";
        message.markPrice = "";
        message.updatedAt = 0n;
        message.createdAt = 0n;
        message.fundingLast = "";
        message.fundingSum = "";
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* string quantity */ 5:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 6:
                    message.entryPrice = reader.string();
                    break;
                case /* string margin */ 7:
                    message.margin = reader.string();
                    break;
                case /* string liquidation_price */ 8:
                    message.liquidationPrice = reader.string();
                    break;
                case /* string mark_price */ 9:
                    message.markPrice = reader.string();
                    break;
                case /* sint64 updated_at */ 10:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 11:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* string funding_last */ 12:
                    message.fundingLast = reader.string();
                    break;
                case /* string funding_sum */ 13:
                    message.fundingSum = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* string quantity = 5; */
        if (message.quantity !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 6; */
        if (message.entryPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
        /* string margin = 7; */
        if (message.margin !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.margin);
        /* string liquidation_price = 8; */
        if (message.liquidationPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
        /* string mark_price = 9; */
        if (message.markPrice !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
        /* sint64 updated_at = 10; */
        if (message.updatedAt !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.updatedAt);
        /* sint64 created_at = 11; */
        if (message.createdAt !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.createdAt);
        /* string funding_last = 12; */
        if (message.fundingLast !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.fundingLast);
        /* string funding_sum = 13; */
        if (message.fundingSum !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.fundingSum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeResult$Type extends MessageType<TradeResult> {
    constructor() {
        super("injective_accounts_rpc.TradeResult", [
            { no: 1, name: "spot_trade", kind: "message", oneof: "trade", T: () => SpotTrade },
            { no: 2, name: "derivative_trade", kind: "message", oneof: "trade", T: () => DerivativeTrade },
            { no: 3, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TradeResult>): TradeResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trade = { oneofKind: undefined };
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<TradeResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeResult): TradeResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.SpotTrade spot_trade */ 1:
                    message.trade = {
                        oneofKind: "spotTrade",
                        spotTrade: SpotTrade.internalBinaryRead(reader, reader.uint32(), options, (message.trade as any).spotTrade)
                    };
                    break;
                case /* injective_accounts_rpc.DerivativeTrade derivative_trade */ 2:
                    message.trade = {
                        oneofKind: "derivativeTrade",
                        derivativeTrade: DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options, (message.trade as any).derivativeTrade)
                    };
                    break;
                case /* string operation_type */ 3:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.SpotTrade spot_trade = 1; */
        if (message.trade.oneofKind === "spotTrade")
            SpotTrade.internalBinaryWrite(message.trade.spotTrade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.DerivativeTrade derivative_trade = 2; */
        if (message.trade.oneofKind === "derivativeTrade")
            DerivativeTrade.internalBinaryWrite(message.trade.derivativeTrade, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 3; */
        if (message.operationType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.TradeResult
 */
export const TradeResult = new TradeResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotTrade$Type extends MessageType<SpotTrade> {
    constructor() {
        super("injective_accounts_rpc.SpotTrade", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "trade_execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "trade_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "price", kind: "message", T: () => PriceLevel },
            { no: 7, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotTrade>): SpotTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.subaccountId = "";
        message.marketId = "";
        message.tradeExecutionType = "";
        message.tradeDirection = "";
        message.fee = "";
        message.executedAt = 0n;
        message.feeRecipient = "";
        message.tradeId = "";
        message.executionSide = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SpotTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotTrade): SpotTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string trade_execution_type */ 4:
                    message.tradeExecutionType = reader.string();
                    break;
                case /* string trade_direction */ 5:
                    message.tradeDirection = reader.string();
                    break;
                case /* injective_accounts_rpc.PriceLevel price */ 6:
                    message.price = PriceLevel.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* string fee */ 7:
                    message.fee = reader.string();
                    break;
                case /* sint64 executed_at */ 8:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* string fee_recipient */ 9:
                    message.feeRecipient = reader.string();
                    break;
                case /* string trade_id */ 10:
                    message.tradeId = reader.string();
                    break;
                case /* string execution_side */ 11:
                    message.executionSide = reader.string();
                    break;
                case /* string cid */ 12:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string trade_execution_type = 4; */
        if (message.tradeExecutionType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
        /* string trade_direction = 5; */
        if (message.tradeDirection !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tradeDirection);
        /* injective_accounts_rpc.PriceLevel price = 6; */
        if (message.price)
            PriceLevel.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string fee = 7; */
        if (message.fee !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.fee);
        /* sint64 executed_at = 8; */
        if (message.executedAt !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.executedAt);
        /* string fee_recipient = 9; */
        if (message.feeRecipient !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
        /* string trade_id = 10; */
        if (message.tradeId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.tradeId);
        /* string execution_side = 11; */
        if (message.executionSide !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.executionSide);
        /* string cid = 12; */
        if (message.cid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SpotTrade
 */
export const SpotTrade = new SpotTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevel$Type extends MessageType<PriceLevel> {
    constructor() {
        super("injective_accounts_rpc.PriceLevel", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceLevel>): PriceLevel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevel): PriceLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.PriceLevel
 */
export const PriceLevel = new PriceLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeTrade$Type extends MessageType<DerivativeTrade> {
    constructor() {
        super("injective_accounts_rpc.DerivativeTrade", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "trade_execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_liquidation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "position_delta", kind: "message", T: () => PositionDelta },
            { no: 7, name: "payout", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeTrade>): DerivativeTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.subaccountId = "";
        message.marketId = "";
        message.tradeExecutionType = "";
        message.isLiquidation = false;
        message.payout = "";
        message.fee = "";
        message.executedAt = 0n;
        message.feeRecipient = "";
        message.tradeId = "";
        message.executionSide = "";
        message.cid = "";
        message.pnl = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeTrade): DerivativeTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string trade_execution_type */ 4:
                    message.tradeExecutionType = reader.string();
                    break;
                case /* bool is_liquidation */ 5:
                    message.isLiquidation = reader.bool();
                    break;
                case /* injective_accounts_rpc.PositionDelta position_delta */ 6:
                    message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
                    break;
                case /* string payout */ 7:
                    message.payout = reader.string();
                    break;
                case /* string fee */ 8:
                    message.fee = reader.string();
                    break;
                case /* sint64 executed_at */ 9:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* string fee_recipient */ 10:
                    message.feeRecipient = reader.string();
                    break;
                case /* string trade_id */ 11:
                    message.tradeId = reader.string();
                    break;
                case /* string execution_side */ 12:
                    message.executionSide = reader.string();
                    break;
                case /* string cid */ 13:
                    message.cid = reader.string();
                    break;
                case /* string pnl */ 14:
                    message.pnl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string trade_execution_type = 4; */
        if (message.tradeExecutionType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
        /* bool is_liquidation = 5; */
        if (message.isLiquidation !== false)
            writer.tag(5, WireType.Varint).bool(message.isLiquidation);
        /* injective_accounts_rpc.PositionDelta position_delta = 6; */
        if (message.positionDelta)
            PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string payout = 7; */
        if (message.payout !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.payout);
        /* string fee = 8; */
        if (message.fee !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.fee);
        /* sint64 executed_at = 9; */
        if (message.executedAt !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.executedAt);
        /* string fee_recipient = 10; */
        if (message.feeRecipient !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.feeRecipient);
        /* string trade_id = 11; */
        if (message.tradeId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
        /* string execution_side = 12; */
        if (message.executionSide !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.executionSide);
        /* string cid = 13; */
        if (message.cid !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.cid);
        /* string pnl = 14; */
        if (message.pnl !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.pnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.DerivativeTrade
 */
export const DerivativeTrade = new DerivativeTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionDelta$Type extends MessageType<PositionDelta> {
    constructor() {
        super("injective_accounts_rpc.PositionDelta", [
            { no: 1, name: "trade_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "execution_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "execution_margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionDelta>): PositionDelta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeDirection = "";
        message.executionPrice = "";
        message.executionQuantity = "";
        message.executionMargin = "";
        if (value !== undefined)
            reflectionMergePartial<PositionDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionDelta): PositionDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_direction */ 1:
                    message.tradeDirection = reader.string();
                    break;
                case /* string execution_price */ 2:
                    message.executionPrice = reader.string();
                    break;
                case /* string execution_quantity */ 3:
                    message.executionQuantity = reader.string();
                    break;
                case /* string execution_margin */ 4:
                    message.executionMargin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_direction = 1; */
        if (message.tradeDirection !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeDirection);
        /* string execution_price = 2; */
        if (message.executionPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionPrice);
        /* string execution_quantity = 3; */
        if (message.executionQuantity !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionQuantity);
        /* string execution_margin = 4; */
        if (message.executionMargin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.executionMargin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.PositionDelta
 */
export const PositionDelta = new PositionDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderResult$Type extends MessageType<OrderResult> {
    constructor() {
        super("injective_accounts_rpc.OrderResult", [
            { no: 1, name: "spot_order", kind: "message", oneof: "order", T: () => SpotLimitOrder },
            { no: 2, name: "derivative_order", kind: "message", oneof: "order", T: () => DerivativeLimitOrder },
            { no: 3, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OrderResult>): OrderResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.order = { oneofKind: undefined };
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<OrderResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderResult): OrderResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.SpotLimitOrder spot_order */ 1:
                    message.order = {
                        oneofKind: "spotOrder",
                        spotOrder: SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, (message.order as any).spotOrder)
                    };
                    break;
                case /* injective_accounts_rpc.DerivativeLimitOrder derivative_order */ 2:
                    message.order = {
                        oneofKind: "derivativeOrder",
                        derivativeOrder: DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, (message.order as any).derivativeOrder)
                    };
                    break;
                case /* string operation_type */ 3:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.SpotLimitOrder spot_order = 1; */
        if (message.order.oneofKind === "spotOrder")
            SpotLimitOrder.internalBinaryWrite(message.order.spotOrder, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.DerivativeLimitOrder derivative_order = 2; */
        if (message.order.oneofKind === "derivativeOrder")
            DerivativeLimitOrder.internalBinaryWrite(message.order.derivativeOrder, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 3; */
        if (message.operationType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.OrderResult
 */
export const OrderResult = new OrderResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotLimitOrder$Type extends MessageType<SpotLimitOrder> {
    constructor() {
        super("injective_accounts_rpc.SpotLimitOrder", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "unfilled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotLimitOrder>): SpotLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.orderSide = "";
        message.marketId = "";
        message.subaccountId = "";
        message.price = "";
        message.quantity = "";
        message.unfilledQuantity = "";
        message.triggerPrice = "";
        message.feeRecipient = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SpotLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotLimitOrder): SpotLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* string price */ 5:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 6:
                    message.quantity = reader.string();
                    break;
                case /* string unfilled_quantity */ 7:
                    message.unfilledQuantity = reader.string();
                    break;
                case /* string trigger_price */ 8:
                    message.triggerPrice = reader.string();
                    break;
                case /* string fee_recipient */ 9:
                    message.feeRecipient = reader.string();
                    break;
                case /* string state */ 10:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 11:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 12:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string tx_hash */ 13:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* string price = 5; */
        if (message.price !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.price);
        /* string quantity = 6; */
        if (message.quantity !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.quantity);
        /* string unfilled_quantity = 7; */
        if (message.unfilledQuantity !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.unfilledQuantity);
        /* string trigger_price = 8; */
        if (message.triggerPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
        /* string fee_recipient = 9; */
        if (message.feeRecipient !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
        /* string state = 10; */
        if (message.state !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 11; */
        if (message.createdAt !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 12; */
        if (message.updatedAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.updatedAt);
        /* string tx_hash = 13; */
        if (message.txHash !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SpotLimitOrder
 */
export const SpotLimitOrder = new SpotLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeLimitOrder$Type extends MessageType<DerivativeLimitOrder> {
    constructor() {
        super("injective_accounts_rpc.DerivativeLimitOrder", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_reduce_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "unfilled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "order_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "is_conditional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "trigger_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "placed_order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeLimitOrder>): DerivativeLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.orderSide = "";
        message.marketId = "";
        message.subaccountId = "";
        message.isReduceOnly = false;
        message.margin = "";
        message.price = "";
        message.quantity = "";
        message.unfilledQuantity = "";
        message.triggerPrice = "";
        message.feeRecipient = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.orderNumber = 0n;
        message.orderType = "";
        message.isConditional = false;
        message.triggerAt = 0n;
        message.placedOrderHash = "";
        message.executionType = "";
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeLimitOrder): DerivativeLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* bool is_reduce_only */ 5:
                    message.isReduceOnly = reader.bool();
                    break;
                case /* string margin */ 6:
                    message.margin = reader.string();
                    break;
                case /* string price */ 7:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 8:
                    message.quantity = reader.string();
                    break;
                case /* string unfilled_quantity */ 9:
                    message.unfilledQuantity = reader.string();
                    break;
                case /* string trigger_price */ 10:
                    message.triggerPrice = reader.string();
                    break;
                case /* string fee_recipient */ 11:
                    message.feeRecipient = reader.string();
                    break;
                case /* string state */ 12:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 13:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 14:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 order_number */ 15:
                    message.orderNumber = reader.sint64().toBigInt();
                    break;
                case /* string order_type */ 16:
                    message.orderType = reader.string();
                    break;
                case /* bool is_conditional */ 17:
                    message.isConditional = reader.bool();
                    break;
                case /* uint64 trigger_at */ 18:
                    message.triggerAt = reader.uint64().toBigInt();
                    break;
                case /* string placed_order_hash */ 19:
                    message.placedOrderHash = reader.string();
                    break;
                case /* string execution_type */ 20:
                    message.executionType = reader.string();
                    break;
                case /* string tx_hash */ 21:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 22:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* bool is_reduce_only = 5; */
        if (message.isReduceOnly !== false)
            writer.tag(5, WireType.Varint).bool(message.isReduceOnly);
        /* string margin = 6; */
        if (message.margin !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.margin);
        /* string price = 7; */
        if (message.price !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.price);
        /* string quantity = 8; */
        if (message.quantity !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.quantity);
        /* string unfilled_quantity = 9; */
        if (message.unfilledQuantity !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.unfilledQuantity);
        /* string trigger_price = 10; */
        if (message.triggerPrice !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.triggerPrice);
        /* string fee_recipient = 11; */
        if (message.feeRecipient !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.feeRecipient);
        /* string state = 12; */
        if (message.state !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 13; */
        if (message.createdAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 14; */
        if (message.updatedAt !== 0n)
            writer.tag(14, WireType.Varint).sint64(message.updatedAt);
        /* sint64 order_number = 15; */
        if (message.orderNumber !== 0n)
            writer.tag(15, WireType.Varint).sint64(message.orderNumber);
        /* string order_type = 16; */
        if (message.orderType !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.orderType);
        /* bool is_conditional = 17; */
        if (message.isConditional !== false)
            writer.tag(17, WireType.Varint).bool(message.isConditional);
        /* uint64 trigger_at = 18; */
        if (message.triggerAt !== 0n)
            writer.tag(18, WireType.Varint).uint64(message.triggerAt);
        /* string placed_order_hash = 19; */
        if (message.placedOrderHash !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.placedOrderHash);
        /* string execution_type = 20; */
        if (message.executionType !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.executionType);
        /* string tx_hash = 21; */
        if (message.txHash !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 22; */
        if (message.cid !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.DerivativeLimitOrder
 */
export const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderHistoryResult$Type extends MessageType<OrderHistoryResult> {
    constructor() {
        super("injective_accounts_rpc.OrderHistoryResult", [
            { no: 1, name: "spot_order_history", kind: "message", oneof: "orderHistory", T: () => SpotOrderHistory },
            { no: 2, name: "derivative_order_history", kind: "message", oneof: "orderHistory", T: () => DerivativeOrderHistory },
            { no: 3, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OrderHistoryResult>): OrderHistoryResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHistory = { oneofKind: undefined };
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<OrderHistoryResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderHistoryResult): OrderHistoryResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.SpotOrderHistory spot_order_history */ 1:
                    message.orderHistory = {
                        oneofKind: "spotOrderHistory",
                        spotOrderHistory: SpotOrderHistory.internalBinaryRead(reader, reader.uint32(), options, (message.orderHistory as any).spotOrderHistory)
                    };
                    break;
                case /* injective_accounts_rpc.DerivativeOrderHistory derivative_order_history */ 2:
                    message.orderHistory = {
                        oneofKind: "derivativeOrderHistory",
                        derivativeOrderHistory: DerivativeOrderHistory.internalBinaryRead(reader, reader.uint32(), options, (message.orderHistory as any).derivativeOrderHistory)
                    };
                    break;
                case /* string operation_type */ 3:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderHistoryResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.SpotOrderHistory spot_order_history = 1; */
        if (message.orderHistory.oneofKind === "spotOrderHistory")
            SpotOrderHistory.internalBinaryWrite(message.orderHistory.spotOrderHistory, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_accounts_rpc.DerivativeOrderHistory derivative_order_history = 2; */
        if (message.orderHistory.oneofKind === "derivativeOrderHistory")
            DerivativeOrderHistory.internalBinaryWrite(message.orderHistory.derivativeOrderHistory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 3; */
        if (message.operationType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.OrderHistoryResult
 */
export const OrderHistoryResult = new OrderHistoryResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotOrderHistory$Type extends MessageType<SpotOrderHistory> {
    constructor() {
        super("injective_accounts_rpc.SpotOrderHistory", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "filled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotOrderHistory>): SpotOrderHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.marketId = "";
        message.isActive = false;
        message.subaccountId = "";
        message.executionType = "";
        message.orderType = "";
        message.price = "";
        message.triggerPrice = "";
        message.quantity = "";
        message.filledQuantity = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.direction = "";
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SpotOrderHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotOrderHistory): SpotOrderHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* string execution_type */ 5:
                    message.executionType = reader.string();
                    break;
                case /* string order_type */ 6:
                    message.orderType = reader.string();
                    break;
                case /* string price */ 7:
                    message.price = reader.string();
                    break;
                case /* string trigger_price */ 8:
                    message.triggerPrice = reader.string();
                    break;
                case /* string quantity */ 9:
                    message.quantity = reader.string();
                    break;
                case /* string filled_quantity */ 10:
                    message.filledQuantity = reader.string();
                    break;
                case /* string state */ 11:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 12:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 13:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string direction */ 14:
                    message.direction = reader.string();
                    break;
                case /* string tx_hash */ 15:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 16:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotOrderHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* string execution_type = 5; */
        if (message.executionType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.executionType);
        /* string order_type = 6; */
        if (message.orderType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orderType);
        /* string price = 7; */
        if (message.price !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.price);
        /* string trigger_price = 8; */
        if (message.triggerPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
        /* string quantity = 9; */
        if (message.quantity !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.quantity);
        /* string filled_quantity = 10; */
        if (message.filledQuantity !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
        /* string state = 11; */
        if (message.state !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 12; */
        if (message.createdAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 13; */
        if (message.updatedAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.updatedAt);
        /* string direction = 14; */
        if (message.direction !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.direction);
        /* string tx_hash = 15; */
        if (message.txHash !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 16; */
        if (message.cid !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SpotOrderHistory
 */
export const SpotOrderHistory = new SpotOrderHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeOrderHistory$Type extends MessageType<DerivativeOrderHistory> {
    constructor() {
        super("injective_accounts_rpc.DerivativeOrderHistory", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "filled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "is_reduce_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "is_conditional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "trigger_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "placed_order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeOrderHistory>): DerivativeOrderHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.marketId = "";
        message.isActive = false;
        message.subaccountId = "";
        message.executionType = "";
        message.orderType = "";
        message.price = "";
        message.triggerPrice = "";
        message.quantity = "";
        message.filledQuantity = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.isReduceOnly = false;
        message.direction = "";
        message.isConditional = false;
        message.triggerAt = 0n;
        message.placedOrderHash = "";
        message.margin = "";
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeOrderHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeOrderHistory): DerivativeOrderHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* string execution_type */ 5:
                    message.executionType = reader.string();
                    break;
                case /* string order_type */ 6:
                    message.orderType = reader.string();
                    break;
                case /* string price */ 7:
                    message.price = reader.string();
                    break;
                case /* string trigger_price */ 8:
                    message.triggerPrice = reader.string();
                    break;
                case /* string quantity */ 9:
                    message.quantity = reader.string();
                    break;
                case /* string filled_quantity */ 10:
                    message.filledQuantity = reader.string();
                    break;
                case /* string state */ 11:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 12:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 13:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* bool is_reduce_only */ 14:
                    message.isReduceOnly = reader.bool();
                    break;
                case /* string direction */ 15:
                    message.direction = reader.string();
                    break;
                case /* bool is_conditional */ 16:
                    message.isConditional = reader.bool();
                    break;
                case /* uint64 trigger_at */ 17:
                    message.triggerAt = reader.uint64().toBigInt();
                    break;
                case /* string placed_order_hash */ 18:
                    message.placedOrderHash = reader.string();
                    break;
                case /* string margin */ 19:
                    message.margin = reader.string();
                    break;
                case /* string tx_hash */ 20:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 21:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeOrderHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* string execution_type = 5; */
        if (message.executionType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.executionType);
        /* string order_type = 6; */
        if (message.orderType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orderType);
        /* string price = 7; */
        if (message.price !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.price);
        /* string trigger_price = 8; */
        if (message.triggerPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
        /* string quantity = 9; */
        if (message.quantity !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.quantity);
        /* string filled_quantity = 10; */
        if (message.filledQuantity !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
        /* string state = 11; */
        if (message.state !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 12; */
        if (message.createdAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 13; */
        if (message.updatedAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.updatedAt);
        /* bool is_reduce_only = 14; */
        if (message.isReduceOnly !== false)
            writer.tag(14, WireType.Varint).bool(message.isReduceOnly);
        /* string direction = 15; */
        if (message.direction !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.direction);
        /* bool is_conditional = 16; */
        if (message.isConditional !== false)
            writer.tag(16, WireType.Varint).bool(message.isConditional);
        /* uint64 trigger_at = 17; */
        if (message.triggerAt !== 0n)
            writer.tag(17, WireType.Varint).uint64(message.triggerAt);
        /* string placed_order_hash = 18; */
        if (message.placedOrderHash !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.placedOrderHash);
        /* string margin = 19; */
        if (message.margin !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.margin);
        /* string tx_hash = 20; */
        if (message.txHash !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 21; */
        if (message.cid !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.DerivativeOrderHistory
 */
export const DerivativeOrderHistory = new DerivativeOrderHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingPaymentResult$Type extends MessageType<FundingPaymentResult> {
    constructor() {
        super("injective_accounts_rpc.FundingPaymentResult", [
            { no: 1, name: "funding_payments", kind: "message", T: () => FundingPayment },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FundingPaymentResult>): FundingPaymentResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<FundingPaymentResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPaymentResult): FundingPaymentResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_accounts_rpc.FundingPayment funding_payments */ 1:
                    message.fundingPayments = FundingPayment.internalBinaryRead(reader, reader.uint32(), options, message.fundingPayments);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingPaymentResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_accounts_rpc.FundingPayment funding_payments = 1; */
        if (message.fundingPayments)
            FundingPayment.internalBinaryWrite(message.fundingPayments, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.FundingPaymentResult
 */
export const FundingPaymentResult = new FundingPaymentResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingPayment$Type extends MessageType<FundingPayment> {
    constructor() {
        super("injective_accounts_rpc.FundingPayment", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FundingPayment>): FundingPayment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.amount = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<FundingPayment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPayment): FundingPayment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingPayment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.FundingPayment
 */
export const FundingPayment = new FundingPayment$Type();
/**
 * @generated ServiceType for protobuf service injective_accounts_rpc.InjectiveAccountsRPC
 */
export const InjectiveAccountsRPC = new ServiceType("injective_accounts_rpc.InjectiveAccountsRPC", [
    { name: "Portfolio", options: {}, I: PortfolioRequest, O: PortfolioResponse },
    { name: "OrderStates", options: {}, I: OrderStatesRequest, O: OrderStatesResponse },
    { name: "SubaccountsList", options: {}, I: SubaccountsListRequest, O: SubaccountsListResponse },
    { name: "SubaccountBalancesList", options: {}, I: SubaccountBalancesListRequest, O: SubaccountBalancesListResponse },
    { name: "SubaccountBalanceEndpoint", options: {}, I: SubaccountBalanceEndpointRequest, O: SubaccountBalanceEndpointResponse },
    { name: "StreamSubaccountBalance", serverStreaming: true, options: {}, I: StreamSubaccountBalanceRequest, O: StreamSubaccountBalanceResponse },
    { name: "SubaccountHistory", options: {}, I: SubaccountHistoryRequest, O: SubaccountHistoryResponse },
    { name: "SubaccountOrderSummary", options: {}, I: SubaccountOrderSummaryRequest, O: SubaccountOrderSummaryResponse },
    { name: "Rewards", options: {}, I: RewardsRequest, O: RewardsResponse },
    { name: "StreamAccountData", serverStreaming: true, options: {}, I: StreamAccountDataRequest, O: StreamAccountDataResponse }
]);
