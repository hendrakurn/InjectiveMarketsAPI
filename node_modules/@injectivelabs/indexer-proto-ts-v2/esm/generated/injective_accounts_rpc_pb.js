import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class PortfolioRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.PortfolioRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PortfolioRequest = new PortfolioRequest$Type();
class PortfolioResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.PortfolioResponse", [
      { no: 1, name: "portfolio", kind: "message", T: () => AccountPortfolio }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.AccountPortfolio portfolio */
        1:
          message.portfolio = AccountPortfolio.internalBinaryRead(reader, reader.uint32(), options, message.portfolio);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.portfolio)
      AccountPortfolio.internalBinaryWrite(message.portfolio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PortfolioResponse = new PortfolioResponse$Type();
class AccountPortfolio$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.AccountPortfolio", [
      {
        no: 1,
        name: "portfolio_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "available_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "locked_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "unrealized_pnl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "subaccounts", kind: "message", repeat: 2, T: () => SubaccountPortfolio }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.portfolioValue = "";
    message.availableBalance = "";
    message.lockedBalance = "";
    message.unrealizedPnl = "";
    message.subaccounts = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string portfolio_value */
        1:
          message.portfolioValue = reader.string();
          break;
        case /* string available_balance */
        2:
          message.availableBalance = reader.string();
          break;
        case /* string locked_balance */
        3:
          message.lockedBalance = reader.string();
          break;
        case /* string unrealized_pnl */
        4:
          message.unrealizedPnl = reader.string();
          break;
        case /* repeated injective_accounts_rpc.SubaccountPortfolio subaccounts */
        5:
          message.subaccounts.push(SubaccountPortfolio.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.portfolioValue !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.portfolioValue);
    if (message.availableBalance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
    if (message.lockedBalance !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.lockedBalance);
    if (message.unrealizedPnl !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.unrealizedPnl);
    for (let i = 0; i < message.subaccounts.length; i++)
      SubaccountPortfolio.internalBinaryWrite(message.subaccounts[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountPortfolio = new AccountPortfolio$Type();
class SubaccountPortfolio$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountPortfolio", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "available_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "locked_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "unrealized_pnl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.availableBalance = "";
    message.lockedBalance = "";
    message.unrealizedPnl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string available_balance */
        2:
          message.availableBalance = reader.string();
          break;
        case /* string locked_balance */
        3:
          message.lockedBalance = reader.string();
          break;
        case /* string unrealized_pnl */
        4:
          message.unrealizedPnl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.availableBalance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
    if (message.lockedBalance !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.lockedBalance);
    if (message.unrealizedPnl !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.unrealizedPnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountPortfolio = new SubaccountPortfolio$Type();
class OrderStatesRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.OrderStatesRequest", [
      {
        no: 1,
        name: "spot_order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "derivative_order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.spotOrderHashes = [];
    message.derivativeOrderHashes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string spot_order_hashes */
        1:
          message.spotOrderHashes.push(reader.string());
          break;
        case /* repeated string derivative_order_hashes */
        2:
          message.derivativeOrderHashes.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.spotOrderHashes.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.spotOrderHashes[i]);
    for (let i = 0; i < message.derivativeOrderHashes.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.derivativeOrderHashes[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderStatesRequest = new OrderStatesRequest$Type();
class OrderStatesResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.OrderStatesResponse", [
      { no: 1, name: "spot_order_states", kind: "message", repeat: 2, T: () => OrderStateRecord },
      { no: 2, name: "derivative_order_states", kind: "message", repeat: 2, T: () => OrderStateRecord }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.spotOrderStates = [];
    message.derivativeOrderStates = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_accounts_rpc.OrderStateRecord spot_order_states */
        1:
          message.spotOrderStates.push(OrderStateRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_accounts_rpc.OrderStateRecord derivative_order_states */
        2:
          message.derivativeOrderStates.push(OrderStateRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.spotOrderStates.length; i++)
      OrderStateRecord.internalBinaryWrite(message.spotOrderStates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeOrderStates.length; i++)
      OrderStateRecord.internalBinaryWrite(message.derivativeOrderStates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderStatesResponse = new OrderStatesResponse$Type();
class OrderStateRecord$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.OrderStateRecord", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "quantity_filled",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "quantity_remaining",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.subaccountId = "";
    message.marketId = "";
    message.orderType = "";
    message.orderSide = "";
    message.state = "";
    message.quantityFilled = "";
    message.quantityRemaining = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.price = "";
    message.margin = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string order_type */
        4:
          message.orderType = reader.string();
          break;
        case /* string order_side */
        5:
          message.orderSide = reader.string();
          break;
        case /* string state */
        6:
          message.state = reader.string();
          break;
        case /* string quantity_filled */
        7:
          message.quantityFilled = reader.string();
          break;
        case /* string quantity_remaining */
        8:
          message.quantityRemaining = reader.string();
          break;
        case /* sint64 created_at */
        9:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        10:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string price */
        11:
          message.price = reader.string();
          break;
        case /* string margin */
        12:
          message.margin = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.orderType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.orderType);
    if (message.orderSide !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.orderSide);
    if (message.state !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.state);
    if (message.quantityFilled !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.quantityFilled);
    if (message.quantityRemaining !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.quantityRemaining);
    if (message.createdAt !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.updatedAt);
    if (message.price !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.price);
    if (message.margin !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.margin);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderStateRecord = new OrderStateRecord$Type();
class SubaccountsListRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountsListRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountsListRequest = new SubaccountsListRequest$Type();
class SubaccountsListResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountsListResponse", [
      {
        no: 1,
        name: "subaccounts",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccounts = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string subaccounts */
        1:
          message.subaccounts.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subaccounts.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.subaccounts[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountsListResponse = new SubaccountsListResponse$Type();
class SubaccountBalancesListRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountBalancesListRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denoms = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* repeated string denoms */
        2:
          message.denoms.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.denoms.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.denoms[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalancesListRequest = new SubaccountBalancesListRequest$Type();
class SubaccountBalancesListResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountBalancesListResponse", [
      { no: 1, name: "balances", kind: "message", repeat: 2, T: () => SubaccountBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_accounts_rpc.SubaccountBalance balances */
        1:
          message.balances.push(SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balances.length; i++)
      SubaccountBalance.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalancesListResponse = new SubaccountBalancesListResponse$Type();
class SubaccountBalance$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountBalance", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "deposit", kind: "message", T: () => SubaccountDeposit }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.accountAddress = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        case /* string denom */
        3:
          message.denom = reader.string();
          break;
        case /* injective_accounts_rpc.SubaccountDeposit deposit */
        4:
          message.deposit = SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.accountAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    if (message.denom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.denom);
    if (message.deposit)
      SubaccountDeposit.internalBinaryWrite(message.deposit, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalance = new SubaccountBalance$Type();
class SubaccountDeposit$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountDeposit", [
      {
        no: 1,
        name: "total_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "available_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "total_balance_usd",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "available_balance_usd",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.totalBalance = "";
    message.availableBalance = "";
    message.totalBalanceUsd = "";
    message.availableBalanceUsd = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string total_balance */
        1:
          message.totalBalance = reader.string();
          break;
        case /* string available_balance */
        2:
          message.availableBalance = reader.string();
          break;
        case /* string total_balance_usd */
        3:
          message.totalBalanceUsd = reader.string();
          break;
        case /* string available_balance_usd */
        4:
          message.availableBalanceUsd = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalBalance !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.totalBalance);
    if (message.availableBalance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
    if (message.totalBalanceUsd !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.totalBalanceUsd);
    if (message.availableBalanceUsd !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.availableBalanceUsd);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountDeposit = new SubaccountDeposit$Type();
class SubaccountBalanceEndpointRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountBalanceEndpointRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalanceEndpointRequest = new SubaccountBalanceEndpointRequest$Type();
class SubaccountBalanceEndpointResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountBalanceEndpointResponse", [
      { no: 1, name: "balance", kind: "message", T: () => SubaccountBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.SubaccountBalance balance */
        1:
          message.balance = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance)
      SubaccountBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalanceEndpointResponse = new SubaccountBalanceEndpointResponse$Type();
class StreamSubaccountBalanceRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.StreamSubaccountBalanceRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denoms = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* repeated string denoms */
        2:
          message.denoms.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.denoms.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.denoms[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamSubaccountBalanceRequest = new StreamSubaccountBalanceRequest$Type();
class StreamSubaccountBalanceResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.StreamSubaccountBalanceResponse", [
      { no: 1, name: "balance", kind: "message", T: () => SubaccountBalance },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.SubaccountBalance balance */
        1:
          message.balance = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance)
      SubaccountBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamSubaccountBalanceResponse = new StreamSubaccountBalanceResponse$Type();
class SubaccountHistoryRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountHistoryRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "transfer_types",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denom = "";
    message.transferTypes = [];
    message.skip = 0n;
    message.limit = 0;
    message.endTime = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        case /* repeated string transfer_types */
        3:
          message.transferTypes.push(reader.string());
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        5:
          message.limit = reader.sint32();
          break;
        case /* sint64 end_time */
        6:
          message.endTime = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    for (let i = 0; i < message.transferTypes.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.transferTypes[i]);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    if (message.limit !== 0)
      writer.tag(5, WireType.Varint).sint32(message.limit);
    if (message.endTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.endTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountHistoryRequest = new SubaccountHistoryRequest$Type();
class SubaccountHistoryResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountHistoryResponse", [
      { no: 1, name: "transfers", kind: "message", repeat: 2, T: () => SubaccountBalanceTransfer },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transfers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_accounts_rpc.SubaccountBalanceTransfer transfers */
        1:
          message.transfers.push(SubaccountBalanceTransfer.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_accounts_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transfers.length; i++)
      SubaccountBalanceTransfer.internalBinaryWrite(message.transfers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountHistoryResponse = new SubaccountHistoryResponse$Type();
class SubaccountBalanceTransfer$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountBalanceTransfer", [
      {
        no: 1,
        name: "transfer_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "src_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "src_account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "dst_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "dst_account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "amount", kind: "message", T: () => CosmosCoin },
      {
        no: 7,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transferType = "";
    message.srcSubaccountId = "";
    message.srcAccountAddress = "";
    message.dstSubaccountId = "";
    message.dstAccountAddress = "";
    message.executedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string transfer_type */
        1:
          message.transferType = reader.string();
          break;
        case /* string src_subaccount_id */
        2:
          message.srcSubaccountId = reader.string();
          break;
        case /* string src_account_address */
        3:
          message.srcAccountAddress = reader.string();
          break;
        case /* string dst_subaccount_id */
        4:
          message.dstSubaccountId = reader.string();
          break;
        case /* string dst_account_address */
        5:
          message.dstAccountAddress = reader.string();
          break;
        case /* injective_accounts_rpc.CosmosCoin amount */
        6:
          message.amount = CosmosCoin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        case /* sint64 executed_at */
        7:
          message.executedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transferType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.transferType);
    if (message.srcSubaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.srcSubaccountId);
    if (message.srcAccountAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.srcAccountAddress);
    if (message.dstSubaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.dstSubaccountId);
    if (message.dstAccountAddress !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.dstAccountAddress);
    if (message.amount)
      CosmosCoin.internalBinaryWrite(message.amount, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.executedAt !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.executedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalanceTransfer = new SubaccountBalanceTransfer$Type();
class CosmosCoin$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.CosmosCoin", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CosmosCoin = new CosmosCoin$Type();
class Paging$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.Paging", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "from",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "to",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "count_by_subaccount",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total = 0n;
    message.from = 0;
    message.to = 0;
    message.countBySubaccount = 0n;
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 total */
        1:
          message.total = reader.sint64().toBigInt();
          break;
        case /* sint32 from */
        2:
          message.from = reader.sint32();
          break;
        case /* sint32 to */
        3:
          message.to = reader.sint32();
          break;
        case /* sint64 count_by_subaccount */
        4:
          message.countBySubaccount = reader.sint64().toBigInt();
          break;
        case /* repeated string next */
        5:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.total);
    if (message.from !== 0)
      writer.tag(2, WireType.Varint).sint32(message.from);
    if (message.to !== 0)
      writer.tag(3, WireType.Varint).sint32(message.to);
    if (message.countBySubaccount !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
    for (let i = 0; i < message.next.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Paging = new Paging$Type();
class SubaccountOrderSummaryRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountOrderSummaryRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "order_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    message.orderDirection = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string order_direction */
        3:
          message.orderDirection = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.orderDirection !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.orderDirection);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrderSummaryRequest = new SubaccountOrderSummaryRequest$Type();
class SubaccountOrderSummaryResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountOrderSummaryResponse", [
      {
        no: 1,
        name: "spot_orders_total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "derivative_orders_total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.spotOrdersTotal = 0n;
    message.derivativeOrdersTotal = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 spot_orders_total */
        1:
          message.spotOrdersTotal = reader.sint64().toBigInt();
          break;
        case /* sint64 derivative_orders_total */
        2:
          message.derivativeOrdersTotal = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.spotOrdersTotal !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.spotOrdersTotal);
    if (message.derivativeOrdersTotal !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.derivativeOrdersTotal);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrderSummaryResponse = new SubaccountOrderSummaryResponse$Type();
class RewardsRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.RewardsRequest", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.epoch = 0n;
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 epoch */
        1:
          message.epoch = reader.sint64().toBigInt();
          break;
        case /* string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.epoch);
    if (message.accountAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RewardsRequest = new RewardsRequest$Type();
class RewardsResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.RewardsResponse", [
      { no: 1, name: "rewards", kind: "message", repeat: 2, T: () => Reward }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_accounts_rpc.Reward rewards */
        1:
          message.rewards.push(Reward.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.rewards.length; i++)
      Reward.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RewardsResponse = new RewardsResponse$Type();
class Reward$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.Reward", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "rewards", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 3,
        name: "distributed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.rewards = [];
    message.distributedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* repeated injective_accounts_rpc.Coin rewards */
        2:
          message.rewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 distributed_at */
        3:
          message.distributedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    for (let i = 0; i < message.rewards.length; i++)
      Coin.internalBinaryWrite(message.rewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.distributedAt !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.distributedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Reward = new Reward$Type();
class Coin$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.Coin", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "usd_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.amount = "";
    message.usdValue = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        case /* string usd_value */
        3:
          message.usdValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    if (message.usdValue !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Coin = new Coin$Type();
class StreamAccountDataRequest$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.StreamAccountDataRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamAccountDataRequest = new StreamAccountDataRequest$Type();
class StreamAccountDataResponse$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.StreamAccountDataResponse", [
      { no: 1, name: "subaccount_balance", kind: "message", T: () => SubaccountBalanceResult },
      { no: 2, name: "position", kind: "message", T: () => PositionsResult },
      { no: 3, name: "trade", kind: "message", T: () => TradeResult },
      { no: 4, name: "order", kind: "message", T: () => OrderResult },
      { no: 5, name: "order_history", kind: "message", T: () => OrderHistoryResult },
      { no: 6, name: "funding_payment", kind: "message", T: () => FundingPaymentResult }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.SubaccountBalanceResult subaccount_balance */
        1:
          message.subaccountBalance = SubaccountBalanceResult.internalBinaryRead(reader, reader.uint32(), options, message.subaccountBalance);
          break;
        case /* injective_accounts_rpc.PositionsResult position */
        2:
          message.position = PositionsResult.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        case /* injective_accounts_rpc.TradeResult trade */
        3:
          message.trade = TradeResult.internalBinaryRead(reader, reader.uint32(), options, message.trade);
          break;
        case /* injective_accounts_rpc.OrderResult order */
        4:
          message.order = OrderResult.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* injective_accounts_rpc.OrderHistoryResult order_history */
        5:
          message.orderHistory = OrderHistoryResult.internalBinaryRead(reader, reader.uint32(), options, message.orderHistory);
          break;
        case /* injective_accounts_rpc.FundingPaymentResult funding_payment */
        6:
          message.fundingPayment = FundingPaymentResult.internalBinaryRead(reader, reader.uint32(), options, message.fundingPayment);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountBalance)
      SubaccountBalanceResult.internalBinaryWrite(message.subaccountBalance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.position)
      PositionsResult.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.trade)
      TradeResult.internalBinaryWrite(message.trade, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.order)
      OrderResult.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.orderHistory)
      OrderHistoryResult.internalBinaryWrite(message.orderHistory, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.fundingPayment)
      FundingPaymentResult.internalBinaryWrite(message.fundingPayment, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamAccountDataResponse = new StreamAccountDataResponse$Type();
class SubaccountBalanceResult$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SubaccountBalanceResult", [
      { no: 1, name: "balance", kind: "message", T: () => SubaccountBalance },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.SubaccountBalance balance */
        1:
          message.balance = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance)
      SubaccountBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalanceResult = new SubaccountBalanceResult$Type();
class PositionsResult$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.PositionsResult", [
      { no: 1, name: "position", kind: "message", T: () => Position },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.Position position */
        1:
          message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.position)
      Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionsResult = new PositionsResult$Type();
class Position$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.Position", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "entry_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "liquidation_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "mark_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "funding_last",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "funding_sum",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.marketId = "";
    message.subaccountId = "";
    message.direction = "";
    message.quantity = "";
    message.entryPrice = "";
    message.margin = "";
    message.liquidationPrice = "";
    message.markPrice = "";
    message.updatedAt = 0n;
    message.createdAt = 0n;
    message.fundingLast = "";
    message.fundingSum = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* string quantity */
        5:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        6:
          message.entryPrice = reader.string();
          break;
        case /* string margin */
        7:
          message.margin = reader.string();
          break;
        case /* string liquidation_price */
        8:
          message.liquidationPrice = reader.string();
          break;
        case /* string mark_price */
        9:
          message.markPrice = reader.string();
          break;
        case /* sint64 updated_at */
        10:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        11:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* string funding_last */
        12:
          message.fundingLast = reader.string();
          break;
        case /* string funding_sum */
        13:
          message.fundingSum = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.quantity !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
    if (message.margin !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.margin);
    if (message.liquidationPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
    if (message.markPrice !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
    if (message.updatedAt !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.updatedAt);
    if (message.createdAt !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.createdAt);
    if (message.fundingLast !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.fundingLast);
    if (message.fundingSum !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.fundingSum);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Position = new Position$Type();
class TradeResult$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.TradeResult", [
      { no: 1, name: "spot_trade", kind: "message", oneof: "trade", T: () => SpotTrade },
      { no: 2, name: "derivative_trade", kind: "message", oneof: "trade", T: () => DerivativeTrade },
      {
        no: 3,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trade = { oneofKind: void 0 };
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.SpotTrade spot_trade */
        1:
          message.trade = {
            oneofKind: "spotTrade",
            spotTrade: SpotTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade.spotTrade)
          };
          break;
        case /* injective_accounts_rpc.DerivativeTrade derivative_trade */
        2:
          message.trade = {
            oneofKind: "derivativeTrade",
            derivativeTrade: DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade.derivativeTrade)
          };
          break;
        case /* string operation_type */
        3:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.trade.oneofKind === "spotTrade")
      SpotTrade.internalBinaryWrite(message.trade.spotTrade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.trade.oneofKind === "derivativeTrade")
      DerivativeTrade.internalBinaryWrite(message.trade.derivativeTrade, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeResult = new TradeResult$Type();
class SpotTrade$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SpotTrade", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "trade_execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "trade_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "price", kind: "message", T: () => PriceLevel },
      {
        no: 7,
        name: "fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.subaccountId = "";
    message.marketId = "";
    message.tradeExecutionType = "";
    message.tradeDirection = "";
    message.fee = "";
    message.executedAt = 0n;
    message.feeRecipient = "";
    message.tradeId = "";
    message.executionSide = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string trade_execution_type */
        4:
          message.tradeExecutionType = reader.string();
          break;
        case /* string trade_direction */
        5:
          message.tradeDirection = reader.string();
          break;
        case /* injective_accounts_rpc.PriceLevel price */
        6:
          message.price = PriceLevel.internalBinaryRead(reader, reader.uint32(), options, message.price);
          break;
        case /* string fee */
        7:
          message.fee = reader.string();
          break;
        case /* sint64 executed_at */
        8:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* string fee_recipient */
        9:
          message.feeRecipient = reader.string();
          break;
        case /* string trade_id */
        10:
          message.tradeId = reader.string();
          break;
        case /* string execution_side */
        11:
          message.executionSide = reader.string();
          break;
        case /* string cid */
        12:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.tradeExecutionType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
    if (message.tradeDirection !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.tradeDirection);
    if (message.price)
      PriceLevel.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.fee !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.fee);
    if (message.executedAt !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.executedAt);
    if (message.feeRecipient !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.tradeId !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.tradeId);
    if (message.executionSide !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.executionSide);
    if (message.cid !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotTrade = new SpotTrade$Type();
class PriceLevel$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.PriceLevel", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* sint64 timestamp */
        3:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceLevel = new PriceLevel$Type();
class DerivativeTrade$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.DerivativeTrade", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "trade_execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_liquidation",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 6, name: "position_delta", kind: "message", T: () => PositionDelta },
      {
        no: 7,
        name: "payout",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "pnl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.subaccountId = "";
    message.marketId = "";
    message.tradeExecutionType = "";
    message.isLiquidation = false;
    message.payout = "";
    message.fee = "";
    message.executedAt = 0n;
    message.feeRecipient = "";
    message.tradeId = "";
    message.executionSide = "";
    message.cid = "";
    message.pnl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string trade_execution_type */
        4:
          message.tradeExecutionType = reader.string();
          break;
        case /* bool is_liquidation */
        5:
          message.isLiquidation = reader.bool();
          break;
        case /* injective_accounts_rpc.PositionDelta position_delta */
        6:
          message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
          break;
        case /* string payout */
        7:
          message.payout = reader.string();
          break;
        case /* string fee */
        8:
          message.fee = reader.string();
          break;
        case /* sint64 executed_at */
        9:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* string fee_recipient */
        10:
          message.feeRecipient = reader.string();
          break;
        case /* string trade_id */
        11:
          message.tradeId = reader.string();
          break;
        case /* string execution_side */
        12:
          message.executionSide = reader.string();
          break;
        case /* string cid */
        13:
          message.cid = reader.string();
          break;
        case /* string pnl */
        14:
          message.pnl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.tradeExecutionType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
    if (message.isLiquidation !== false)
      writer.tag(5, WireType.Varint).bool(message.isLiquidation);
    if (message.positionDelta)
      PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.payout !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.payout);
    if (message.fee !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.fee);
    if (message.executedAt !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.executedAt);
    if (message.feeRecipient !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.tradeId !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
    if (message.executionSide !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.executionSide);
    if (message.cid !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.cid);
    if (message.pnl !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.pnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeTrade = new DerivativeTrade$Type();
class PositionDelta$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.PositionDelta", [
      {
        no: 1,
        name: "trade_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "execution_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "execution_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "execution_margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tradeDirection = "";
    message.executionPrice = "";
    message.executionQuantity = "";
    message.executionMargin = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string trade_direction */
        1:
          message.tradeDirection = reader.string();
          break;
        case /* string execution_price */
        2:
          message.executionPrice = reader.string();
          break;
        case /* string execution_quantity */
        3:
          message.executionQuantity = reader.string();
          break;
        case /* string execution_margin */
        4:
          message.executionMargin = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tradeDirection !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tradeDirection);
    if (message.executionPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionPrice);
    if (message.executionQuantity !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionQuantity);
    if (message.executionMargin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.executionMargin);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionDelta = new PositionDelta$Type();
class OrderResult$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.OrderResult", [
      { no: 1, name: "spot_order", kind: "message", oneof: "order", T: () => SpotLimitOrder },
      { no: 2, name: "derivative_order", kind: "message", oneof: "order", T: () => DerivativeLimitOrder },
      {
        no: 3,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.order = { oneofKind: void 0 };
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.SpotLimitOrder spot_order */
        1:
          message.order = {
            oneofKind: "spotOrder",
            spotOrder: SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order.spotOrder)
          };
          break;
        case /* injective_accounts_rpc.DerivativeLimitOrder derivative_order */
        2:
          message.order = {
            oneofKind: "derivativeOrder",
            derivativeOrder: DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order.derivativeOrder)
          };
          break;
        case /* string operation_type */
        3:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.order.oneofKind === "spotOrder")
      SpotLimitOrder.internalBinaryWrite(message.order.spotOrder, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.order.oneofKind === "derivativeOrder")
      DerivativeLimitOrder.internalBinaryWrite(message.order.derivativeOrder, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderResult = new OrderResult$Type();
class SpotLimitOrder$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SpotLimitOrder", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "unfilled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.orderSide = "";
    message.marketId = "";
    message.subaccountId = "";
    message.price = "";
    message.quantity = "";
    message.unfilledQuantity = "";
    message.triggerPrice = "";
    message.feeRecipient = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* string price */
        5:
          message.price = reader.string();
          break;
        case /* string quantity */
        6:
          message.quantity = reader.string();
          break;
        case /* string unfilled_quantity */
        7:
          message.unfilledQuantity = reader.string();
          break;
        case /* string trigger_price */
        8:
          message.triggerPrice = reader.string();
          break;
        case /* string fee_recipient */
        9:
          message.feeRecipient = reader.string();
          break;
        case /* string state */
        10:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        11:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        12:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string tx_hash */
        13:
          message.txHash = reader.string();
          break;
        case /* string cid */
        14:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.price !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.quantity);
    if (message.unfilledQuantity !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.unfilledQuantity);
    if (message.triggerPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.feeRecipient !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.state !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.updatedAt);
    if (message.txHash !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotLimitOrder = new SpotLimitOrder$Type();
class DerivativeLimitOrder$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.DerivativeLimitOrder", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "order_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_reduce_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "unfilled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 15,
        name: "order_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 16,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 17,
        name: "is_conditional",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 18,
        name: "trigger_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 19,
        name: "placed_order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 20,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 22,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.orderSide = "";
    message.marketId = "";
    message.subaccountId = "";
    message.isReduceOnly = false;
    message.margin = "";
    message.price = "";
    message.quantity = "";
    message.unfilledQuantity = "";
    message.triggerPrice = "";
    message.feeRecipient = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.orderNumber = 0n;
    message.orderType = "";
    message.isConditional = false;
    message.triggerAt = 0n;
    message.placedOrderHash = "";
    message.executionType = "";
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string order_side */
        2:
          message.orderSide = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* bool is_reduce_only */
        5:
          message.isReduceOnly = reader.bool();
          break;
        case /* string margin */
        6:
          message.margin = reader.string();
          break;
        case /* string price */
        7:
          message.price = reader.string();
          break;
        case /* string quantity */
        8:
          message.quantity = reader.string();
          break;
        case /* string unfilled_quantity */
        9:
          message.unfilledQuantity = reader.string();
          break;
        case /* string trigger_price */
        10:
          message.triggerPrice = reader.string();
          break;
        case /* string fee_recipient */
        11:
          message.feeRecipient = reader.string();
          break;
        case /* string state */
        12:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        13:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        14:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* sint64 order_number */
        15:
          message.orderNumber = reader.sint64().toBigInt();
          break;
        case /* string order_type */
        16:
          message.orderType = reader.string();
          break;
        case /* bool is_conditional */
        17:
          message.isConditional = reader.bool();
          break;
        case /* uint64 trigger_at */
        18:
          message.triggerAt = reader.uint64().toBigInt();
          break;
        case /* string placed_order_hash */
        19:
          message.placedOrderHash = reader.string();
          break;
        case /* string execution_type */
        20:
          message.executionType = reader.string();
          break;
        case /* string tx_hash */
        21:
          message.txHash = reader.string();
          break;
        case /* string cid */
        22:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.orderSide !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.isReduceOnly !== false)
      writer.tag(5, WireType.Varint).bool(message.isReduceOnly);
    if (message.margin !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.margin);
    if (message.price !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.quantity);
    if (message.unfilledQuantity !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.unfilledQuantity);
    if (message.triggerPrice !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.feeRecipient !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.state !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(14, WireType.Varint).sint64(message.updatedAt);
    if (message.orderNumber !== 0n)
      writer.tag(15, WireType.Varint).sint64(message.orderNumber);
    if (message.orderType !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.orderType);
    if (message.isConditional !== false)
      writer.tag(17, WireType.Varint).bool(message.isConditional);
    if (message.triggerAt !== 0n)
      writer.tag(18, WireType.Varint).uint64(message.triggerAt);
    if (message.placedOrderHash !== "")
      writer.tag(19, WireType.LengthDelimited).string(message.placedOrderHash);
    if (message.executionType !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.executionType);
    if (message.txHash !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
class OrderHistoryResult$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.OrderHistoryResult", [
      { no: 1, name: "spot_order_history", kind: "message", oneof: "orderHistory", T: () => SpotOrderHistory },
      { no: 2, name: "derivative_order_history", kind: "message", oneof: "orderHistory", T: () => DerivativeOrderHistory },
      {
        no: 3,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHistory = { oneofKind: void 0 };
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.SpotOrderHistory spot_order_history */
        1:
          message.orderHistory = {
            oneofKind: "spotOrderHistory",
            spotOrderHistory: SpotOrderHistory.internalBinaryRead(reader, reader.uint32(), options, message.orderHistory.spotOrderHistory)
          };
          break;
        case /* injective_accounts_rpc.DerivativeOrderHistory derivative_order_history */
        2:
          message.orderHistory = {
            oneofKind: "derivativeOrderHistory",
            derivativeOrderHistory: DerivativeOrderHistory.internalBinaryRead(reader, reader.uint32(), options, message.orderHistory.derivativeOrderHistory)
          };
          break;
        case /* string operation_type */
        3:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHistory.oneofKind === "spotOrderHistory")
      SpotOrderHistory.internalBinaryWrite(message.orderHistory.spotOrderHistory, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderHistory.oneofKind === "derivativeOrderHistory")
      DerivativeOrderHistory.internalBinaryWrite(message.orderHistory.derivativeOrderHistory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderHistoryResult = new OrderHistoryResult$Type();
class SpotOrderHistory$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.SpotOrderHistory", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "filled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.marketId = "";
    message.isActive = false;
    message.subaccountId = "";
    message.executionType = "";
    message.orderType = "";
    message.price = "";
    message.triggerPrice = "";
    message.quantity = "";
    message.filledQuantity = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.direction = "";
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* bool is_active */
        3:
          message.isActive = reader.bool();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* string execution_type */
        5:
          message.executionType = reader.string();
          break;
        case /* string order_type */
        6:
          message.orderType = reader.string();
          break;
        case /* string price */
        7:
          message.price = reader.string();
          break;
        case /* string trigger_price */
        8:
          message.triggerPrice = reader.string();
          break;
        case /* string quantity */
        9:
          message.quantity = reader.string();
          break;
        case /* string filled_quantity */
        10:
          message.filledQuantity = reader.string();
          break;
        case /* string state */
        11:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        12:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        13:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string direction */
        14:
          message.direction = reader.string();
          break;
        case /* string tx_hash */
        15:
          message.txHash = reader.string();
          break;
        case /* string cid */
        16:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.isActive !== false)
      writer.tag(3, WireType.Varint).bool(message.isActive);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.executionType !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.executionType);
    if (message.orderType !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.orderType);
    if (message.price !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.price);
    if (message.triggerPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.quantity !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.quantity);
    if (message.filledQuantity !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
    if (message.state !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.updatedAt);
    if (message.direction !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.direction);
    if (message.txHash !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotOrderHistory = new SpotOrderHistory$Type();
class DerivativeOrderHistory$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.DerivativeOrderHistory", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "execution_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "order_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "trigger_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "filled_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "is_reduce_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 15,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "is_conditional",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 17,
        name: "trigger_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 18,
        name: "placed_order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 19,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 20,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.marketId = "";
    message.isActive = false;
    message.subaccountId = "";
    message.executionType = "";
    message.orderType = "";
    message.price = "";
    message.triggerPrice = "";
    message.quantity = "";
    message.filledQuantity = "";
    message.state = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.isReduceOnly = false;
    message.direction = "";
    message.isConditional = false;
    message.triggerAt = 0n;
    message.placedOrderHash = "";
    message.margin = "";
    message.txHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* bool is_active */
        3:
          message.isActive = reader.bool();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* string execution_type */
        5:
          message.executionType = reader.string();
          break;
        case /* string order_type */
        6:
          message.orderType = reader.string();
          break;
        case /* string price */
        7:
          message.price = reader.string();
          break;
        case /* string trigger_price */
        8:
          message.triggerPrice = reader.string();
          break;
        case /* string quantity */
        9:
          message.quantity = reader.string();
          break;
        case /* string filled_quantity */
        10:
          message.filledQuantity = reader.string();
          break;
        case /* string state */
        11:
          message.state = reader.string();
          break;
        case /* sint64 created_at */
        12:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        13:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* bool is_reduce_only */
        14:
          message.isReduceOnly = reader.bool();
          break;
        case /* string direction */
        15:
          message.direction = reader.string();
          break;
        case /* bool is_conditional */
        16:
          message.isConditional = reader.bool();
          break;
        case /* uint64 trigger_at */
        17:
          message.triggerAt = reader.uint64().toBigInt();
          break;
        case /* string placed_order_hash */
        18:
          message.placedOrderHash = reader.string();
          break;
        case /* string margin */
        19:
          message.margin = reader.string();
          break;
        case /* string tx_hash */
        20:
          message.txHash = reader.string();
          break;
        case /* string cid */
        21:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.isActive !== false)
      writer.tag(3, WireType.Varint).bool(message.isActive);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.executionType !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.executionType);
    if (message.orderType !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.orderType);
    if (message.price !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.price);
    if (message.triggerPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.quantity !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.quantity);
    if (message.filledQuantity !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
    if (message.state !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.state);
    if (message.createdAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.updatedAt);
    if (message.isReduceOnly !== false)
      writer.tag(14, WireType.Varint).bool(message.isReduceOnly);
    if (message.direction !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.direction);
    if (message.isConditional !== false)
      writer.tag(16, WireType.Varint).bool(message.isConditional);
    if (message.triggerAt !== 0n)
      writer.tag(17, WireType.Varint).uint64(message.triggerAt);
    if (message.placedOrderHash !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.placedOrderHash);
    if (message.margin !== "")
      writer.tag(19, WireType.LengthDelimited).string(message.margin);
    if (message.txHash !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.txHash);
    if (message.cid !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeOrderHistory = new DerivativeOrderHistory$Type();
class FundingPaymentResult$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.FundingPaymentResult", [
      { no: 1, name: "funding_payments", kind: "message", T: () => FundingPayment },
      {
        no: 2,
        name: "operation_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operationType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_accounts_rpc.FundingPayment funding_payments */
        1:
          message.fundingPayments = FundingPayment.internalBinaryRead(reader, reader.uint32(), options, message.fundingPayments);
          break;
        case /* string operation_type */
        2:
          message.operationType = reader.string();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fundingPayments)
      FundingPayment.internalBinaryWrite(message.fundingPayments, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.operationType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.operationType);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingPaymentResult = new FundingPaymentResult$Type();
class FundingPayment$Type extends MessageType {
  constructor() {
    super("injective_accounts_rpc.FundingPayment", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.amount = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string amount */
        3:
          message.amount = reader.string();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.amount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.amount);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FundingPayment = new FundingPayment$Type();
const InjectiveAccountsRPC = new ServiceType("injective_accounts_rpc.InjectiveAccountsRPC", [
  { name: "Portfolio", options: {}, I: PortfolioRequest, O: PortfolioResponse },
  { name: "OrderStates", options: {}, I: OrderStatesRequest, O: OrderStatesResponse },
  { name: "SubaccountsList", options: {}, I: SubaccountsListRequest, O: SubaccountsListResponse },
  { name: "SubaccountBalancesList", options: {}, I: SubaccountBalancesListRequest, O: SubaccountBalancesListResponse },
  { name: "SubaccountBalanceEndpoint", options: {}, I: SubaccountBalanceEndpointRequest, O: SubaccountBalanceEndpointResponse },
  { name: "StreamSubaccountBalance", serverStreaming: true, options: {}, I: StreamSubaccountBalanceRequest, O: StreamSubaccountBalanceResponse },
  { name: "SubaccountHistory", options: {}, I: SubaccountHistoryRequest, O: SubaccountHistoryResponse },
  { name: "SubaccountOrderSummary", options: {}, I: SubaccountOrderSummaryRequest, O: SubaccountOrderSummaryResponse },
  { name: "Rewards", options: {}, I: RewardsRequest, O: RewardsResponse },
  { name: "StreamAccountData", serverStreaming: true, options: {}, I: StreamAccountDataRequest, O: StreamAccountDataResponse }
]);
export {
  AccountPortfolio,
  Coin,
  CosmosCoin,
  DerivativeLimitOrder,
  DerivativeOrderHistory,
  DerivativeTrade,
  FundingPayment,
  FundingPaymentResult,
  InjectiveAccountsRPC,
  OrderHistoryResult,
  OrderResult,
  OrderStateRecord,
  OrderStatesRequest,
  OrderStatesResponse,
  Paging,
  PortfolioRequest,
  PortfolioResponse,
  Position,
  PositionDelta,
  PositionsResult,
  PriceLevel,
  Reward,
  RewardsRequest,
  RewardsResponse,
  SpotLimitOrder,
  SpotOrderHistory,
  SpotTrade,
  StreamAccountDataRequest,
  StreamAccountDataResponse,
  StreamSubaccountBalanceRequest,
  StreamSubaccountBalanceResponse,
  SubaccountBalance,
  SubaccountBalanceEndpointRequest,
  SubaccountBalanceEndpointResponse,
  SubaccountBalanceResult,
  SubaccountBalanceTransfer,
  SubaccountBalancesListRequest,
  SubaccountBalancesListResponse,
  SubaccountDeposit,
  SubaccountHistoryRequest,
  SubaccountHistoryResponse,
  SubaccountOrderSummaryRequest,
  SubaccountOrderSummaryResponse,
  SubaccountPortfolio,
  SubaccountsListRequest,
  SubaccountsListResponse,
  TradeResult
};
