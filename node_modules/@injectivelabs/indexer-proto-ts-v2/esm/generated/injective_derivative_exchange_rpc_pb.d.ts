// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_derivative_exchange_rpc.proto" (package "injective_derivative_exchange_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveDerivativeExchangeRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.MarketsRequest
 */
export interface MarketsRequest {
    /**
     * Filter by market status
     *
     * @generated from protobuf field: string market_status = 1
     */
    marketStatus: string;
    /**
     * Filter by the Coin denomination of the quote currency
     *
     * @generated from protobuf field: string quote_denom = 2
     */
    quoteDenom: string;
    /**
     * @generated from protobuf field: repeated string market_statuses = 3
     */
    marketStatuses: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.MarketsResponse
 */
export interface MarketsResponse {
    /**
     * Derivative Markets list
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeMarketInfo markets = 1
     */
    markets: DerivativeMarketInfo[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeMarketInfo
 */
export interface DerivativeMarketInfo {
    /**
     * DerivativeMarket ID is crypto.Keccak256Hash([]byte((oracleType.String() +
     * ticker + quoteDenom + oracleBase + oracleQuote))) for perpetual markets and
     * crypto.Keccak256Hash([]byte((oracleType.String() + ticker + quoteDenom +
     * oracleBase + oracleQuote + strconv.Itoa(int(expiry))))) for expiry futures
     * markets
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * The status of the market
     *
     * @generated from protobuf field: string market_status = 2
     */
    marketStatus: string;
    /**
     * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
     * asset.
     *
     * @generated from protobuf field: string ticker = 3
     */
    ticker: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 4
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 5
     */
    oracleQuote: string;
    /**
     * Oracle Type
     *
     * @generated from protobuf field: string oracle_type = 6
     */
    oracleType: string;
    /**
     * OracleScaleFactor
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 7
     */
    oracleScaleFactor: number;
    /**
     * Defines the initial margin ratio of a derivative market
     *
     * @generated from protobuf field: string initial_margin_ratio = 8
     */
    initialMarginRatio: string;
    /**
     * Defines the maintenance margin ratio of a derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 9
     */
    maintenanceMarginRatio: string;
    /**
     * Coin denom used for the quote asset.
     *
     * @generated from protobuf field: string quote_denom = 10
     */
    quoteDenom: string;
    /**
     * Token metadata for quote asset
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11
     */
    quoteTokenMeta?: TokenMeta;
    /**
     * Defines the fee percentage makers pay when trading (in quote asset)
     *
     * @generated from protobuf field: string maker_fee_rate = 12
     */
    makerFeeRate: string;
    /**
     * Defines the fee percentage takers pay when trading (in quote asset)
     *
     * @generated from protobuf field: string taker_fee_rate = 13
     */
    takerFeeRate: string;
    /**
     * Percentage of the transaction fee shared with the service provider
     *
     * @generated from protobuf field: string service_provider_fee = 14
     */
    serviceProviderFee: string;
    /**
     * True if the market is a perpetual swap market
     *
     * @generated from protobuf field: bool is_perpetual = 15
     */
    isPerpetual: boolean;
    /**
     * Defines the minimum required tick size for the order's price
     *
     * @generated from protobuf field: string min_price_tick_size = 16
     */
    minPriceTickSize: string;
    /**
     * Defines the minimum required tick size for the order's quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 17
     */
    minQuantityTickSize: string;
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info = 18
     */
    perpetualMarketInfo?: PerpetualMarketInfo;
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding = 19
     */
    perpetualMarketFunding?: PerpetualMarketFunding;
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info = 20
     */
    expiryFuturesMarketInfo?: ExpiryFuturesMarketInfo;
    /**
     * Minimum notional value for the order
     *
     * @generated from protobuf field: string min_notional = 21
     */
    minNotional: string;
    /**
     * Defines the reduce margin ratio of a derivative market
     *
     * @generated from protobuf field: string reduce_margin_ratio = 22
     */
    reduceMarginRatio: string;
    /**
     * The open notional cap of the market, if any
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.OpenNotionalCap open_notional_cap = 23
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.TokenMeta
 */
export interface TokenMeta {
    /**
     * Token full name
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * Token contract address (native or not)
     *
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * Token symbol short name
     *
     * @generated from protobuf field: string symbol = 3
     */
    symbol: string;
    /**
     * URL to the logo image
     *
     * @generated from protobuf field: string logo = 4
     */
    logo: string;
    /**
     * Token decimals
     *
     * @generated from protobuf field: sint32 decimals = 5
     */
    decimals: number;
    /**
     * Token metadata fetched timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 6
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PerpetualMarketInfo
 */
export interface PerpetualMarketInfo {
    /**
     * Defines the default maximum absolute value of the hourly funding rate of the
     * perpetual market.
     *
     * @generated from protobuf field: string hourly_funding_rate_cap = 1
     */
    hourlyFundingRateCap: string;
    /**
     * Defines the hourly interest rate of the perpetual market.
     *
     * @generated from protobuf field: string hourly_interest_rate = 2
     */
    hourlyInterestRate: string;
    /**
     * Defines the next funding timestamp in seconds of a perpetual market in UNIX
     * seconds.
     *
     * @generated from protobuf field: sint64 next_funding_timestamp = 3
     */
    nextFundingTimestamp: bigint;
    /**
     * Defines the funding interval in seconds of a perpetual market in seconds.
     *
     * @generated from protobuf field: sint64 funding_interval = 4
     */
    fundingInterval: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PerpetualMarketFunding
 */
export interface PerpetualMarketFunding {
    /**
     * Defines the cumulative funding of a perpetual market.
     *
     * @generated from protobuf field: string cumulative_funding = 1
     */
    cumulativeFunding: string;
    /**
     * Defines defines the cumulative price for the current hour up to the last
     * timestamp.
     *
     * @generated from protobuf field: string cumulative_price = 2
     */
    cumulativePrice: string;
    /**
     * Defines the last funding timestamp in seconds of a perpetual market in UNIX
     * seconds.
     *
     * @generated from protobuf field: sint64 last_timestamp = 3
     */
    lastTimestamp: bigint;
    /**
     * Defines the last funding rate of a perpetual market.
     *
     * @generated from protobuf field: string last_funding_rate = 4
     */
    lastFundingRate: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo
 */
export interface ExpiryFuturesMarketInfo {
    /**
     * Defines the expiration time for a time expiry futures market in UNIX seconds.
     *
     * @generated from protobuf field: sint64 expiration_timestamp = 1
     */
    expirationTimestamp: bigint;
    /**
     * Defines the settlement price for a time expiry futures market.
     *
     * @generated from protobuf field: string settlement_price = 2
     */
    settlementPrice: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OpenNotionalCap
 */
export interface OpenNotionalCap {
    /**
     * The open notional cap of the market
     *
     * @generated from protobuf field: string cap = 1
     */
    cap: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.MarketRequest
 */
export interface MarketRequest {
    /**
     * MarketId of the market we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.MarketResponse
 */
export interface MarketResponse {
    /**
     * Info about particular derivative market
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1
     */
    market?: DerivativeMarketInfo;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamMarketRequest
 */
export interface StreamMarketRequest {
    /**
     * List of market IDs for updates streaming, empty means 'ALL' derivative
     * markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamMarketResponse
 */
export interface StreamMarketResponse {
    /**
     * Info about particular derivative market
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1
     */
    market?: DerivativeMarketInfo;
    /**
     * Update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest
 */
export interface BinaryOptionsMarketsRequest {
    /**
     * Filter by market status
     *
     * @generated from protobuf field: string market_status = 1
     */
    marketStatus: string;
    /**
     * Filter by the Coin denomination of the quote currency
     *
     * @generated from protobuf field: string quote_denom = 2
     */
    quoteDenom: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse
 */
export interface BinaryOptionsMarketsResponse {
    /**
     * Binary Options Markets list
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets = 1
     */
    markets: BinaryOptionsMarketInfo[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketInfo
 */
export interface BinaryOptionsMarketInfo {
    /**
     * Binary Options Market ID is crypto.Keccak256Hash([]byte((oracleType.String()
     * + ticker + quoteDenom + oracleSymbol + oracleProvider)))
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * The status of the market
     *
     * @generated from protobuf field: string market_status = 2
     */
    marketStatus: string;
    /**
     * A name of the binary options market.
     *
     * @generated from protobuf field: string ticker = 3
     */
    ticker: string;
    /**
     * Oracle symbol
     *
     * @generated from protobuf field: string oracle_symbol = 4
     */
    oracleSymbol: string;
    /**
     * Oracle provider
     *
     * @generated from protobuf field: string oracle_provider = 5
     */
    oracleProvider: string;
    /**
     * Oracle Type
     *
     * @generated from protobuf field: string oracle_type = 6
     */
    oracleType: string;
    /**
     * OracleScaleFactor
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 7
     */
    oracleScaleFactor: number;
    /**
     * Defines the expiration time for the market in UNIX seconds.
     *
     * @generated from protobuf field: sint64 expiration_timestamp = 8
     */
    expirationTimestamp: bigint;
    /**
     * Defines the settlement time for the market in UNIX seconds.
     *
     * @generated from protobuf field: sint64 settlement_timestamp = 9
     */
    settlementTimestamp: bigint;
    /**
     * Coin denom used for the quote asset.
     *
     * @generated from protobuf field: string quote_denom = 10
     */
    quoteDenom: string;
    /**
     * Token metadata for quote asset
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11
     */
    quoteTokenMeta?: TokenMeta;
    /**
     * Defines the fee percentage makers pay when trading (in quote asset)
     *
     * @generated from protobuf field: string maker_fee_rate = 12
     */
    makerFeeRate: string;
    /**
     * Defines the fee percentage takers pay when trading (in quote asset)
     *
     * @generated from protobuf field: string taker_fee_rate = 13
     */
    takerFeeRate: string;
    /**
     * Percentage of the transaction fee shared with the service provider
     *
     * @generated from protobuf field: string service_provider_fee = 14
     */
    serviceProviderFee: string;
    /**
     * Defines the minimum required tick size for the order's price
     *
     * @generated from protobuf field: string min_price_tick_size = 15
     */
    minPriceTickSize: string;
    /**
     * Defines the minimum required tick size for the order's quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 16
     */
    minQuantityTickSize: string;
    /**
     * Defines the settlement price of the market
     *
     * @generated from protobuf field: string settlement_price = 17
     */
    settlementPrice: string;
    /**
     * Defines the minimum notional value for the market
     *
     * @generated from protobuf field: string min_notional = 18
     */
    minNotional: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_derivative_exchange_rpc.Paging
 */
export interface Paging {
    /**
     * total number of txs saved in database
     *
     * @generated from protobuf field: sint64 total = 1
     */
    total: bigint;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 from = 2
     */
    from: number;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 to = 3
     */
    to: number;
    /**
     * count entries by subaccount, serving some places on helix
     *
     * @generated from protobuf field: sint64 count_by_subaccount = 4
     */
    countBySubaccount: bigint;
    /**
     * array of tokens to navigate to the next pages
     *
     * @generated from protobuf field: repeated string next = 5
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketRequest
 */
export interface BinaryOptionsMarketRequest {
    /**
     * MarketId of the market we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketResponse
 */
export interface BinaryOptionsMarketResponse {
    /**
     * Info about particular derivative market
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market = 1
     */
    market?: BinaryOptionsMarketInfo;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbookV2Request
 */
export interface OrderbookV2Request {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Depth of the orderbook
     *
     * @generated from protobuf field: sint32 depth = 2
     */
    depth: number;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbookV2Response
 */
export interface OrderbookV2Response {
    /**
     * Orderbook of a particular derivative market
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1
     */
    orderbook?: DerivativeLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2
 */
export interface DerivativeLimitOrderbookV2 {
    /**
     * Array of price levels for buys
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevel buys = 1
     */
    buys: PriceLevel[];
    /**
     * Array of price levels for sells
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevel sells = 2
     */
    sells: PriceLevel[];
    /**
     * market orderbook sequence
     *
     * @generated from protobuf field: uint64 sequence = 3
     */
    sequence: bigint;
    /**
     * Last update timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
    /**
     * Block height at which the orderbook was last updated.
     *
     * @generated from protobuf field: sint64 height = 5
     */
    height: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PriceLevel
 */
export interface PriceLevel {
    /**
     * Price number of the price level.
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * Quantity of the price level.
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * Price level last updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbooksV2Request
 */
export interface OrderbooksV2Request {
    /**
     * MarketIds of the markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
    /**
     * Depth of the orderbook
     *
     * @generated from protobuf field: sint32 depth = 2
     */
    depth: number;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbooksV2Response
 */
export interface OrderbooksV2Response {
    /**
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks = 1
     */
    orderbooks: SingleDerivativeLimitOrderbookV2[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2
 */
export interface SingleDerivativeLimitOrderbookV2 {
    /**
     * market's ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Orderbook of the market
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 2
     */
    orderbook?: DerivativeLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrderbookV2Request
 */
export interface StreamOrderbookV2Request {
    /**
     * List of market IDs for orderbook streaming, empty means 'ALL' derivative
     * markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrderbookV2Response
 */
export interface StreamOrderbookV2Response {
    /**
     * Orderbook of a Derivative Market
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1
     */
    orderbook?: DerivativeLimitOrderbookV2;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
    /**
     * MarketId of the market's orderbook
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest
 */
export interface StreamOrderbookUpdateRequest {
    /**
     * List of market IDs for orderbook streaming, empty means 'ALL' derivative
     * markets
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse
 */
export interface StreamOrderbookUpdateResponse {
    /**
     * Orderbook level updates of a Derivative Market
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1
     */
    orderbookLevelUpdates?: OrderbookLevelUpdates;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
    /**
     * MarketId of the market's orderbook
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbookLevelUpdates
 */
export interface OrderbookLevelUpdates {
    /**
     * market's ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * orderbook update sequence
     *
     * @generated from protobuf field: uint64 sequence = 2
     */
    sequence: bigint;
    /**
     * buy levels
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevelUpdate buys = 3
     */
    buys: PriceLevelUpdate[];
    /**
     * sell levels
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevelUpdate sells = 4
     */
    sells: PriceLevelUpdate[];
    /**
     * updates timestamp
     *
     * @generated from protobuf field: sint64 updated_at = 5
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PriceLevelUpdate
 */
export interface PriceLevelUpdate {
    /**
     * Price number of the price level.
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * Quantity of the price level.
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * Price level status.
     *
     * @generated from protobuf field: bool is_active = 3
     */
    isActive: boolean;
    /**
     * Price level last updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrdersRequest
 */
export interface OrdersRequest {
    /**
     * MarketId of market we want to fetch orders from. Using this field for one
     * single marketId
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Look for specific order side
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Look for specific subaccountId of an order
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 5
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 6
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 7
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get order from, use this field
     * for fetching orders from multiple markets
     *
     * @generated from protobuf field: repeated string market_ids = 8
     */
    marketIds: string[];
    /**
     * Only search for conditional/non-conditional orders
     *
     * @generated from protobuf field: string is_conditional = 9
     */
    isConditional: string;
    /**
     * Search for specific order type
     *
     * @generated from protobuf field: string order_type = 10
     */
    orderType: string;
    /**
     * Should include inactive orders
     *
     * @generated from protobuf field: bool include_inactive = 11
     */
    includeInactive: boolean;
    /**
     * Choose to return subaccount total orders
     *
     * @generated from protobuf field: bool subaccount_total_orders = 12
     */
    subaccountTotalOrders: boolean;
    /**
     * TradeId of the order we want to fetch
     *
     * @generated from protobuf field: string trade_id = 13
     */
    tradeId: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrdersResponse
 */
export interface OrdersResponse {
    /**
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1
     */
    orders: DerivativeLimitOrder[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrder
 */
export interface DerivativeLimitOrder {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * True if the order is a reduce-only order
     *
     * @generated from protobuf field: bool is_reduce_only = 5
     */
    isReduceOnly: boolean;
    /**
     * Margin of the order
     *
     * @generated from protobuf field: string margin = 6
     */
    margin: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 7
     */
    price: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 8
     */
    quantity: string;
    /**
     * The amount of the quantity remaining unfilled
     *
     * @generated from protobuf field: string unfilled_quantity = 9
     */
    unfilledQuantity: string;
    /**
     * Trigger price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 10
     */
    triggerPrice: string;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 11
     */
    feeRecipient: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 12
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 13
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 14
     */
    updatedAt: bigint;
    /**
     * Order number of subaccount
     *
     * @generated from protobuf field: sint64 order_number = 15
     */
    orderNumber: bigint;
    /**
     * Order type
     *
     * @generated from protobuf field: string order_type = 16
     */
    orderType: string;
    /**
     * Order type
     *
     * @generated from protobuf field: bool is_conditional = 17
     */
    isConditional: boolean;
    /**
     * Trigger timestamp, only exists for conditional orders
     *
     * @generated from protobuf field: uint64 trigger_at = 18
     */
    triggerAt: bigint;
    /**
     * OrderHash of order that is triggered by this conditional order
     *
     * @generated from protobuf field: string placed_order_hash = 19
     */
    placedOrderHash: string;
    /**
     * Execution type of conditional order
     *
     * @generated from protobuf field: string execution_type = 20
     */
    executionType: string;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 21
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 22
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionsRequest
 */
export interface PositionsRequest {
    /**
     * SubaccountId of the trader we want to get the positions from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * MarketId of the position we want to fetch. Use this field for fetching from
     * single market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 5
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 6
     */
    endTime: bigint;
    /**
     * MarketIds of the markets we want to filter. Use this field for fetching from
     * multiple markets
     *
     * @generated from protobuf field: repeated string market_ids = 7
     */
    marketIds: string[];
    /**
     * filter by direction of the position
     *
     * @generated from protobuf field: string direction = 8
     */
    direction: string;
    /**
     * set to True to return subaccount total positions
     *
     * @generated from protobuf field: bool subaccount_total_positions = 9
     */
    subaccountTotalPositions: boolean;
    /**
     * filter by account address
     *
     * @generated from protobuf field: string account_address = 10
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionsResponse
 */
export interface PositionsResponse {
    /**
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativePosition positions = 1
     */
    positions: DerivativePosition[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativePosition
 */
export interface DerivativePosition {
    /**
     * Ticker of the derivative market
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * The subaccountId that the position belongs to
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Direction of the position
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Quantity of the position
     *
     * @generated from protobuf field: string quantity = 5
     */
    quantity: string;
    /**
     * Price of the position
     *
     * @generated from protobuf field: string entry_price = 6
     */
    entryPrice: string;
    /**
     * Margin of the position
     *
     * @generated from protobuf field: string margin = 7
     */
    margin: string;
    /**
     * LiquidationPrice of the position
     *
     * @generated from protobuf field: string liquidation_price = 8
     */
    liquidationPrice: string;
    /**
     * MarkPrice of the position
     *
     * @generated from protobuf field: string mark_price = 9
     */
    markPrice: string;
    /**
     * Aggregate Quantity of the Reduce Only orders associated with the position
     *
     * @generated from protobuf field: string aggregate_reduce_only_quantity = 11
     */
    aggregateReduceOnlyQuantity: string;
    /**
     * Position updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 12
     */
    updatedAt: bigint;
    /**
     * Position created timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 13
     */
    createdAt: bigint;
    /**
     * Last funding fees since position opened
     *
     * @generated from protobuf field: string funding_last = 14
     */
    fundingLast: string;
    /**
     * Net funding fees since position opened
     *
     * @generated from protobuf field: string funding_sum = 15
     */
    fundingSum: string;
    /**
     * Cumulative funding entry of the position
     *
     * @generated from protobuf field: string cumulative_funding_entry = 16
     */
    cumulativeFundingEntry: string;
    /**
     * Effective cumulative funding entry of the position
     *
     * @generated from protobuf field: string effective_cumulative_funding_entry = 17
     */
    effectiveCumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionsV2Request
 */
export interface PositionsV2Request {
    /**
     * SubaccountId of the trader we want to get the positions from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * MarketId of the position we want to fetch. Use this field for fetching from
     * single market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 5
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 6
     */
    endTime: bigint;
    /**
     * MarketIds of the markets we want to filter. Use this field for fetching from
     * multiple markets
     *
     * @generated from protobuf field: repeated string market_ids = 7
     */
    marketIds: string[];
    /**
     * filter by direction of the position
     *
     * @generated from protobuf field: string direction = 8
     */
    direction: string;
    /**
     * set to True to return subaccount total positions
     *
     * @generated from protobuf field: bool subaccount_total_positions = 9
     */
    subaccountTotalPositions: boolean;
    /**
     * filter by account address
     *
     * @generated from protobuf field: string account_address = 10
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionsV2Response
 */
export interface PositionsV2Response {
    /**
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativePositionV2 positions = 1
     */
    positions: DerivativePositionV2[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativePositionV2
 */
export interface DerivativePositionV2 {
    /**
     * Ticker of the derivative market
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * The subaccountId that the position belongs to
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Direction of the position
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Quantity of the position
     *
     * @generated from protobuf field: string quantity = 5
     */
    quantity: string;
    /**
     * Price of the position
     *
     * @generated from protobuf field: string entry_price = 6
     */
    entryPrice: string;
    /**
     * Margin of the position
     *
     * @generated from protobuf field: string margin = 7
     */
    margin: string;
    /**
     * LiquidationPrice of the position
     *
     * @generated from protobuf field: string liquidation_price = 8
     */
    liquidationPrice: string;
    /**
     * MarkPrice of the position
     *
     * @generated from protobuf field: string mark_price = 9
     */
    markPrice: string;
    /**
     * Position updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 11
     */
    updatedAt: bigint;
    /**
     * Market quote denom
     *
     * @generated from protobuf field: string denom = 12
     */
    denom: string;
    /**
     * Last funding fees since position opened
     *
     * @generated from protobuf field: string funding_last = 13
     */
    fundingLast: string;
    /**
     * Net funding fees since position opened
     *
     * @generated from protobuf field: string funding_sum = 14
     */
    fundingSum: string;
    /**
     * Cumulative funding entry of the position
     *
     * @generated from protobuf field: string cumulative_funding_entry = 15
     */
    cumulativeFundingEntry: string;
    /**
     * Effective cumulative funding entry of the position
     *
     * @generated from protobuf field: string effective_cumulative_funding_entry = 16
     */
    effectiveCumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.LiquidablePositionsRequest
 */
export interface LiquidablePositionsRequest {
    /**
     * Market ID to filter orders for specific market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 2
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.LiquidablePositionsResponse
 */
export interface LiquidablePositionsResponse {
    /**
     * List of derivative positions
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativePosition positions = 1
     */
    positions: DerivativePosition[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingPaymentsRequest
 */
export interface FundingPaymentsRequest {
    /**
     * SubaccountId of the trader we want to get the positions from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * MarketIds of the funding payment we want to fetch. Using this for only one
     * market id. This field is prioritized
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * Upper bound of funding payment updatedAt
     *
     * @generated from protobuf field: sint64 end_time = 5
     */
    endTime: bigint;
    /**
     * Filter by market ids. Using this field for fetching funding payments from
     * multiple market ids
     *
     * @generated from protobuf field: repeated string market_ids = 6
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingPaymentsResponse
 */
export interface FundingPaymentsResponse {
    /**
     * List of funding payments
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.FundingPayment payments = 1
     */
    payments: FundingPayment[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingPayment
 */
export interface FundingPayment {
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * The subaccountId that the position belongs to
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * Amount of the funding payment
     *
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
    /**
     * Timestamp of funding payment in UNIX millis
     *
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingRatesRequest
 */
export interface FundingRatesRequest {
    /**
     * MarketId of the position we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 2
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
    /**
     * Upper bound of funding timestamp
     *
     * @generated from protobuf field: sint64 end_time = 4
     */
    endTime: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingRatesResponse
 */
export interface FundingRatesResponse {
    /**
     * List of funding rates
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.FundingRate funding_rates = 1
     */
    fundingRates: FundingRate[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingRate
 */
export interface FundingRate {
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Value of the funding rate
     *
     * @generated from protobuf field: string rate = 2
     */
    rate: string;
    /**
     * Timestamp of funding rate in UNIX millis
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamPositionsRequest
 */
export interface StreamPositionsRequest {
    /**
     * SubaccountId of the trader we want to get the positions from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Backward compat single market ID of position we want to stream
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * List of market IDs of the positions we want to stream
     *
     * @generated from protobuf field: repeated string market_ids = 3
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get positions
     *
     * @generated from protobuf field: repeated string subaccount_ids = 4
     */
    subaccountIds: string[];
    /**
     * filter by account address
     *
     * @generated from protobuf field: string account_address = 5
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamPositionsResponse
 */
export interface StreamPositionsResponse {
    /**
     * Updated derivative Position
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativePosition position = 1
     */
    position?: DerivativePosition;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamPositionsV2Request
 */
export interface StreamPositionsV2Request {
    /**
     * SubaccountId of the trader we want to get the positions from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Backward compat single market ID of position we want to stream
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * List of market IDs of the positions we want to stream
     *
     * @generated from protobuf field: repeated string market_ids = 3
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get positions
     *
     * @generated from protobuf field: repeated string subaccount_ids = 4
     */
    subaccountIds: string[];
    /**
     * filter by account address
     *
     * @generated from protobuf field: string account_address = 5
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamPositionsV2Response
 */
export interface StreamPositionsV2Response {
    /**
     * Updated derivative Position
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativePositionV2 position = 1
     */
    position?: DerivativePositionV2;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrdersRequest
 */
export interface StreamOrdersRequest {
    /**
     * MarketId of market we want to fetch orders from. Using this field for one
     * single marketId
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Look for specific order side
     *
     * @generated from protobuf field: string order_side = 2
     */
    orderSide: string;
    /**
     * Look for specific subaccountId of an order
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 4
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 5
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 6
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 7
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get order from, use this field
     * for fetching orders from multiple markets
     *
     * @generated from protobuf field: repeated string market_ids = 8
     */
    marketIds: string[];
    /**
     * Only search for conditional/non-conditional orders
     *
     * @generated from protobuf field: string is_conditional = 9
     */
    isConditional: string;
    /**
     * Search for specific order type
     *
     * @generated from protobuf field: string order_type = 10
     */
    orderType: string;
    /**
     * Should include inactive orders
     *
     * @generated from protobuf field: bool include_inactive = 11
     */
    includeInactive: boolean;
    /**
     * Choose to return subaccount total orders
     *
     * @generated from protobuf field: bool subaccount_total_orders = 12
     */
    subaccountTotalOrders: boolean;
    /**
     * TradeId of the order we want to fetch
     *
     * @generated from protobuf field: string trade_id = 13
     */
    tradeId: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrdersResponse
 */
export interface StreamOrdersResponse {
    /**
     * Updated market order
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrder order = 1
     */
    order?: DerivativeLimitOrder;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.TradesRequest
 */
export interface TradesRequest {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades. Use this field for fetching
     * trades from multiple subaccounts
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Filter by fee recipient
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.TradesResponse
 */
export interface TradesResponse {
    /**
     * Trades of a Derivative Market
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1
     */
    trades: DerivativeTrade[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeTrade
 */
export interface DerivativeTrade {
    /**
     * Order hash.
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * The subaccountId that executed the trade
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * The ID of the market that this trade is in
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * The execution type of the trade
     *
     * @generated from protobuf field: string trade_execution_type = 4
     */
    tradeExecutionType: string;
    /**
     * True if the trade is a liquidation
     *
     * @generated from protobuf field: bool is_liquidation = 5
     */
    isLiquidation: boolean;
    /**
     * Position Delta from the trade
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.PositionDelta position_delta = 6
     */
    positionDelta?: PositionDelta;
    /**
     * The payout associated with the trade
     *
     * @generated from protobuf field: string payout = 7
     */
    payout: string;
    /**
     * The fee associated with the trade
     *
     * @generated from protobuf field: string fee = 8
     */
    fee: string;
    /**
     * Timestamp of trade execution in UNIX millis
     *
     * @generated from protobuf field: sint64 executed_at = 9
     */
    executedAt: bigint;
    /**
     * Fee recipient address
     *
     * @generated from protobuf field: string fee_recipient = 10
     */
    feeRecipient: string;
    /**
     * A unique string that helps differentiate between trades
     *
     * @generated from protobuf field: string trade_id = 11
     */
    tradeId: string;
    /**
     * Trade's execution side, marker/taker
     *
     * @generated from protobuf field: string execution_side = 12
     */
    executionSide: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 13
     */
    cid: string;
    /**
     * Profit and loss of the trade
     *
     * @generated from protobuf field: string pnl = 14
     */
    pnl: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionDelta
 */
export interface PositionDelta {
    /**
     * The direction the trade
     *
     * @generated from protobuf field: string trade_direction = 1
     */
    tradeDirection: string;
    /**
     * Execution Price of the trade.
     *
     * @generated from protobuf field: string execution_price = 2
     */
    executionPrice: string;
    /**
     * Execution Quantity of the trade.
     *
     * @generated from protobuf field: string execution_quantity = 3
     */
    executionQuantity: string;
    /**
     * Execution Margin of the trade.
     *
     * @generated from protobuf field: string execution_margin = 4
     */
    executionMargin: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.TradesV2Request
 */
export interface TradesV2Request {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades. Use this field for fetching
     * trades from multiple subaccounts
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Filter by fee recipient
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.TradesV2Response
 */
export interface TradesV2Response {
    /**
     * Trades of a Derivative Market
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1
     */
    trades: DerivativeTrade[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamTradesRequest
 */
export interface StreamTradesRequest {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades. Use this field for fetching
     * trades from multiple subaccounts
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Filter by fee recipient
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamTradesResponse
 */
export interface StreamTradesResponse {
    /**
     * New derivative market trade
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeTrade trade = 1
     */
    trade?: DerivativeTrade;
    /**
     * Executed trades update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamTradesV2Request
 */
export interface StreamTradesV2Request {
    /**
     * MarketId of the market's orderbook we want to fetch
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Filter by execution side of the trade
     *
     * @generated from protobuf field: string execution_side = 2
     */
    executionSide: string;
    /**
     * Filter by direction the trade
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned.
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
    /**
     * The starting timestamp in UNIX milliseconds that the trades must be equal or
     * older than
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds that the trades must be equal or
     * younger than
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * MarketIds of the markets of which we want to get trades
     *
     * @generated from protobuf field: repeated string market_ids = 9
     */
    marketIds: string[];
    /**
     * Subaccount ids of traders we want to get trades. Use this field for fetching
     * trades from multiple subaccounts
     *
     * @generated from protobuf field: repeated string subaccount_ids = 10
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string execution_types = 11
     */
    executionTypes: string[];
    /**
     * Filter by the tradeId of the trade
     *
     * @generated from protobuf field: string trade_id = 12
     */
    tradeId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 13
     */
    accountAddress: string;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 14
     */
    cid: string;
    /**
     * Filter by fee recipient
     *
     * @generated from protobuf field: string fee_recipient = 15
     */
    feeRecipient: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamTradesV2Response
 */
export interface StreamTradesV2Response {
    /**
     * New derivative market trade
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeTrade trade = 1
     */
    trade?: DerivativeTrade;
    /**
     * Executed trades update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.SubaccountOrdersListRequest
 */
export interface SubaccountOrdersListRequest {
    /**
     * subaccount ID to filter orders for specific subaccount
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Market ID to filter orders for specific market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.SubaccountOrdersListResponse
 */
export interface SubaccountOrdersListResponse {
    /**
     * List of derivative orders
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1
     */
    orders: DerivativeLimitOrder[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.SubaccountTradesListRequest
 */
export interface SubaccountTradesListRequest {
    /**
     * SubaccountId of the trader we want to get the trades from
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Filter trades by market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Filter by execution type of trades
     *
     * @generated from protobuf field: string execution_type = 3
     */
    executionType: string;
    /**
     * Filter by direction trades
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 5
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 6
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.SubaccountTradesListResponse
 */
export interface SubaccountTradesListResponse {
    /**
     * List of derivative market trades
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1
     */
    trades: DerivativeTrade[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrdersHistoryRequest
 */
export interface OrdersHistoryRequest {
    /**
     * subaccount ID to filter orders for specific subaccount
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Market ID to filter orders for specific market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Skip will skip the first n item from the result
     *
     * @generated from protobuf field: uint64 skip = 3
     */
    skip: bigint;
    /**
     * Limit is used to specify the maximum number of items to be returned
     *
     * @generated from protobuf field: sint32 limit = 4
     */
    limit: number;
    /**
     * filter by order types
     *
     * @generated from protobuf field: repeated string order_types = 5
     */
    orderTypes: string[];
    /**
     * order side filter
     *
     * @generated from protobuf field: string direction = 6
     */
    direction: string;
    /**
     * Search for orders which createdAt >= startTime, time in millisecond
     *
     * @generated from protobuf field: sint64 start_time = 7
     */
    startTime: bigint;
    /**
     * Search for orders which createdAt <= endTime, time in millisecond
     *
     * @generated from protobuf field: sint64 end_time = 8
     */
    endTime: bigint;
    /**
     * Only search for conditional/non-conditional orders
     *
     * @generated from protobuf field: string is_conditional = 9
     */
    isConditional: string;
    /**
     * filter by order type
     *
     * @generated from protobuf field: string order_type = 10
     */
    orderType: string;
    /**
     * Filter by order state
     *
     * @generated from protobuf field: string state = 11
     */
    state: string;
    /**
     * @generated from protobuf field: repeated string execution_types = 12
     */
    executionTypes: string[];
    /**
     * @generated from protobuf field: repeated string market_ids = 13
     */
    marketIds: string[];
    /**
     * TradeId of the order we want to fetch
     *
     * @generated from protobuf field: string trade_id = 14
     */
    tradeId: string;
    /**
     * Return only orders for active markets
     *
     * @generated from protobuf field: bool active_markets_only = 15
     */
    activeMarketsOnly: boolean;
    /**
     * Client order ID
     *
     * @generated from protobuf field: string cid = 16
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrdersHistoryResponse
 */
export interface OrdersHistoryResponse {
    /**
     * List of historical derivative orders
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeOrderHistory orders = 1
     */
    orders: DerivativeOrderHistory[];
    /**
     * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeOrderHistory
 */
export interface DerivativeOrderHistory {
    /**
     * Hash of the order
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * Spot Market ID is keccak265(baseDenom + quoteDenom)
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * active state of the order
     *
     * @generated from protobuf field: bool is_active = 3
     */
    isActive: boolean;
    /**
     * The subaccountId that this order belongs to
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * The execution type
     *
     * @generated from protobuf field: string execution_type = 5
     */
    executionType: string;
    /**
     * The side of the order
     *
     * @generated from protobuf field: string order_type = 6
     */
    orderType: string;
    /**
     * Price of the order
     *
     * @generated from protobuf field: string price = 7
     */
    price: string;
    /**
     * Trigger price
     *
     * @generated from protobuf field: string trigger_price = 8
     */
    triggerPrice: string;
    /**
     * Quantity of the order
     *
     * @generated from protobuf field: string quantity = 9
     */
    quantity: string;
    /**
     * Filled amount
     *
     * @generated from protobuf field: string filled_quantity = 10
     */
    filledQuantity: string;
    /**
     * Order state
     *
     * @generated from protobuf field: string state = 11
     */
    state: string;
    /**
     * Order committed timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 12
     */
    createdAt: bigint;
    /**
     * Order updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 13
     */
    updatedAt: bigint;
    /**
     * True if an order is reduce only
     *
     * @generated from protobuf field: bool is_reduce_only = 14
     */
    isReduceOnly: boolean;
    /**
     * Order direction (order side)
     *
     * @generated from protobuf field: string direction = 15
     */
    direction: string;
    /**
     * True if this is conditional order, otherwise false
     *
     * @generated from protobuf field: bool is_conditional = 16
     */
    isConditional: boolean;
    /**
     * Trigger timestamp in unix milli
     *
     * @generated from protobuf field: uint64 trigger_at = 17
     */
    triggerAt: bigint;
    /**
     * Order hash placed when this triggers
     *
     * @generated from protobuf field: string placed_order_hash = 18
     */
    placedOrderHash: string;
    /**
     * Order's margin
     *
     * @generated from protobuf field: string margin = 19
     */
    margin: string;
    /**
     * Transaction Hash where order is created. Not all orders have this field
     *
     * @generated from protobuf field: string tx_hash = 20
     */
    txHash: string;
    /**
     * Custom client order ID
     *
     * @generated from protobuf field: string cid = 21
     */
    cid: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrdersHistoryRequest
 */
export interface StreamOrdersHistoryRequest {
    /**
     * subaccount ID to filter orders for specific subaccount
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Market ID to filter orders for specific market
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * filter by order types
     *
     * @generated from protobuf field: repeated string order_types = 3
     */
    orderTypes: string[];
    /**
     * order side filter
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Filter by order state
     *
     * @generated from protobuf field: string state = 5
     */
    state: string;
    /**
     * @generated from protobuf field: repeated string execution_types = 6
     */
    executionTypes: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrdersHistoryResponse
 */
export interface StreamOrdersHistoryResponse {
    /**
     * Updated order
     *
     * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeOrderHistory order = 1
     */
    order?: DerivativeOrderHistory;
    /**
     * Order update type
     *
     * @generated from protobuf field: string operation_type = 2
     */
    operationType: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OpenInterestRequest
 */
export interface OpenInterestRequest {
    /**
     * Specify multiple marketIDs to search.
     *
     * @generated from protobuf field: repeated string market_i_ds = 1
     */
    marketIDs: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OpenInterestResponse
 */
export interface OpenInterestResponse {
    /**
     * Open interest of the markets
     *
     * @generated from protobuf field: repeated injective_derivative_exchange_rpc.MarketOpenInterest open_interests = 1
     */
    openInterests: MarketOpenInterest[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.MarketOpenInterest
 */
export interface MarketOpenInterest {
    /**
     * MarketId of the market we want to fetch open interest from
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Open interest of the market
     *
     * @generated from protobuf field: string open_interest = 2
     */
    openInterest: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class MarketsRequest$Type extends MessageType<MarketsRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.MarketsRequest", [
            { no: 1, name: "market_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_statuses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketsRequest>): MarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketStatus = "";
        message.quoteDenom = "";
        message.marketStatuses = [];
        if (value !== undefined)
            reflectionMergePartial<MarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketsRequest): MarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_status */ 1:
                    message.marketStatus = reader.string();
                    break;
                case /* string quote_denom */ 2:
                    message.quoteDenom = reader.string();
                    break;
                case /* repeated string market_statuses */ 3:
                    message.marketStatuses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_status = 1; */
        if (message.marketStatus !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketStatus);
        /* string quote_denom = 2; */
        if (message.quoteDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quoteDenom);
        /* repeated string market_statuses = 3; */
        for (let i = 0; i < message.marketStatuses.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.marketStatuses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.MarketsRequest
 */
export const MarketsRequest = new MarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketsResponse$Type extends MessageType<MarketsResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.MarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeMarketInfo }
        ]);
    }
    create(value?: PartialMessage<MarketsResponse>): MarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<MarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketsResponse): MarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativeMarketInfo markets */ 1:
                    message.markets.push(DerivativeMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativeMarketInfo markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            DerivativeMarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.MarketsResponse
 */
export const MarketsResponse = new MarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketInfo$Type extends MessageType<DerivativeMarketInfo> {
    constructor() {
        super("injective_derivative_exchange_rpc.DerivativeMarketInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "quote_token_meta", kind: "message", T: () => TokenMeta },
            { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "service_provider_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "is_perpetual", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "perpetual_market_info", kind: "message", T: () => PerpetualMarketInfo },
            { no: 19, name: "perpetual_market_funding", kind: "message", T: () => PerpetualMarketFunding },
            { no: 20, name: "expiry_futures_market_info", kind: "message", T: () => ExpiryFuturesMarketInfo },
            { no: 21, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketInfo>): DerivativeMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.marketStatus = "";
        message.ticker = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleType = "";
        message.oracleScaleFactor = 0;
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.quoteDenom = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.serviceProviderFee = "";
        message.isPerpetual = false;
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketInfo): DerivativeMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string market_status */ 2:
                    message.marketStatus = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_base */ 4:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 5:
                    message.oracleQuote = reader.string();
                    break;
                case /* string oracle_type */ 6:
                    message.oracleType = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 7:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* string initial_margin_ratio */ 8:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 9:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string quote_denom */ 10:
                    message.quoteDenom = reader.string();
                    break;
                case /* injective_derivative_exchange_rpc.TokenMeta quote_token_meta */ 11:
                    message.quoteTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.quoteTokenMeta);
                    break;
                case /* string maker_fee_rate */ 12:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 13:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string service_provider_fee */ 14:
                    message.serviceProviderFee = reader.string();
                    break;
                case /* bool is_perpetual */ 15:
                    message.isPerpetual = reader.bool();
                    break;
                case /* string min_price_tick_size */ 16:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 17:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info */ 18:
                    message.perpetualMarketInfo = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.perpetualMarketInfo);
                    break;
                case /* injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding */ 19:
                    message.perpetualMarketFunding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.perpetualMarketFunding);
                    break;
                case /* injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info */ 20:
                    message.expiryFuturesMarketInfo = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.expiryFuturesMarketInfo);
                    break;
                case /* string min_notional */ 21:
                    message.minNotional = reader.string();
                    break;
                case /* string reduce_margin_ratio */ 22:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective_derivative_exchange_rpc.OpenNotionalCap open_notional_cap */ 23:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string market_status = 2; */
        if (message.marketStatus !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketStatus);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_base = 4; */
        if (message.oracleBase !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 5; */
        if (message.oracleQuote !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
        /* string oracle_type = 6; */
        if (message.oracleType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.oracleType);
        /* uint32 oracle_scale_factor = 7; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
        /* string initial_margin_ratio = 8; */
        if (message.initialMarginRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 9; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string quote_denom = 10; */
        if (message.quoteDenom !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.quoteDenom);
        /* injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11; */
        if (message.quoteTokenMeta)
            TokenMeta.internalBinaryWrite(message.quoteTokenMeta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string maker_fee_rate = 12; */
        if (message.makerFeeRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 13; */
        if (message.takerFeeRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string service_provider_fee = 14; */
        if (message.serviceProviderFee !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.serviceProviderFee);
        /* bool is_perpetual = 15; */
        if (message.isPerpetual !== false)
            writer.tag(15, WireType.Varint).bool(message.isPerpetual);
        /* string min_price_tick_size = 16; */
        if (message.minPriceTickSize !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 17; */
        if (message.minQuantityTickSize !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info = 18; */
        if (message.perpetualMarketInfo)
            PerpetualMarketInfo.internalBinaryWrite(message.perpetualMarketInfo, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding = 19; */
        if (message.perpetualMarketFunding)
            PerpetualMarketFunding.internalBinaryWrite(message.perpetualMarketFunding, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info = 20; */
        if (message.expiryFuturesMarketInfo)
            ExpiryFuturesMarketInfo.internalBinaryWrite(message.expiryFuturesMarketInfo, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* string min_notional = 21; */
        if (message.minNotional !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.minNotional);
        /* string reduce_margin_ratio = 22; */
        if (message.reduceMarginRatio !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective_derivative_exchange_rpc.OpenNotionalCap open_notional_cap = 23; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeMarketInfo
 */
export const DerivativeMarketInfo = new DerivativeMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenMeta$Type extends MessageType<TokenMeta> {
    constructor() {
        super("injective_derivative_exchange_rpc.TokenMeta", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "logo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "decimals", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TokenMeta>): TokenMeta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.address = "";
        message.symbol = "";
        message.logo = "";
        message.decimals = 0;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<TokenMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenMeta): TokenMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string symbol */ 3:
                    message.symbol = reader.string();
                    break;
                case /* string logo */ 4:
                    message.logo = reader.string();
                    break;
                case /* sint32 decimals */ 5:
                    message.decimals = reader.sint32();
                    break;
                case /* sint64 updated_at */ 6:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string symbol = 3; */
        if (message.symbol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.symbol);
        /* string logo = 4; */
        if (message.logo !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.logo);
        /* sint32 decimals = 5; */
        if (message.decimals !== 0)
            writer.tag(5, WireType.Varint).sint32(message.decimals);
        /* sint64 updated_at = 6; */
        if (message.updatedAt !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.TokenMeta
 */
export const TokenMeta = new TokenMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketInfo$Type extends MessageType<PerpetualMarketInfo> {
    constructor() {
        super("injective_derivative_exchange_rpc.PerpetualMarketInfo", [
            { no: 1, name: "hourly_funding_rate_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hourly_interest_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "next_funding_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "funding_interval", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketInfo>): PerpetualMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hourlyFundingRateCap = "";
        message.hourlyInterestRate = "";
        message.nextFundingTimestamp = 0n;
        message.fundingInterval = 0n;
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketInfo): PerpetualMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hourly_funding_rate_cap */ 1:
                    message.hourlyFundingRateCap = reader.string();
                    break;
                case /* string hourly_interest_rate */ 2:
                    message.hourlyInterestRate = reader.string();
                    break;
                case /* sint64 next_funding_timestamp */ 3:
                    message.nextFundingTimestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 funding_interval */ 4:
                    message.fundingInterval = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hourly_funding_rate_cap = 1; */
        if (message.hourlyFundingRateCap !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
        /* string hourly_interest_rate = 2; */
        if (message.hourlyInterestRate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hourlyInterestRate);
        /* sint64 next_funding_timestamp = 3; */
        if (message.nextFundingTimestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.nextFundingTimestamp);
        /* sint64 funding_interval = 4; */
        if (message.fundingInterval !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.fundingInterval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PerpetualMarketInfo
 */
export const PerpetualMarketInfo = new PerpetualMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketFunding$Type extends MessageType<PerpetualMarketFunding> {
    constructor() {
        super("injective_derivative_exchange_rpc.PerpetualMarketFunding", [
            { no: 1, name: "cumulative_funding", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "last_funding_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketFunding>): PerpetualMarketFunding {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cumulativeFunding = "";
        message.cumulativePrice = "";
        message.lastTimestamp = 0n;
        message.lastFundingRate = "";
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketFunding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketFunding): PerpetualMarketFunding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cumulative_funding */ 1:
                    message.cumulativeFunding = reader.string();
                    break;
                case /* string cumulative_price */ 2:
                    message.cumulativePrice = reader.string();
                    break;
                case /* sint64 last_timestamp */ 3:
                    message.lastTimestamp = reader.sint64().toBigInt();
                    break;
                case /* string last_funding_rate */ 4:
                    message.lastFundingRate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketFunding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cumulative_funding = 1; */
        if (message.cumulativeFunding !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cumulativeFunding);
        /* string cumulative_price = 2; */
        if (message.cumulativePrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
        /* sint64 last_timestamp = 3; */
        if (message.lastTimestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.lastTimestamp);
        /* string last_funding_rate = 4; */
        if (message.lastFundingRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.lastFundingRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PerpetualMarketFunding
 */
export const PerpetualMarketFunding = new PerpetualMarketFunding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpiryFuturesMarketInfo$Type extends MessageType<ExpiryFuturesMarketInfo> {
    constructor() {
        super("injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo", [
            { no: 1, name: "expiration_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.expirationTimestamp = 0n;
        message.settlementPrice = "";
        if (value !== undefined)
            reflectionMergePartial<ExpiryFuturesMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpiryFuturesMarketInfo): ExpiryFuturesMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 expiration_timestamp */ 1:
                    message.expirationTimestamp = reader.sint64().toBigInt();
                    break;
                case /* string settlement_price */ 2:
                    message.settlementPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpiryFuturesMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 expiration_timestamp = 1; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.expirationTimestamp);
        /* string settlement_price = 2; */
        if (message.settlementPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settlementPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo
 */
export const ExpiryFuturesMarketInfo = new ExpiryFuturesMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenNotionalCap$Type extends MessageType<OpenNotionalCap> {
    constructor() {
        super("injective_derivative_exchange_rpc.OpenNotionalCap", [
            { no: 1, name: "cap", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OpenNotionalCap>): OpenNotionalCap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cap = "";
        if (value !== undefined)
            reflectionMergePartial<OpenNotionalCap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenNotionalCap): OpenNotionalCap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cap */ 1:
                    message.cap = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenNotionalCap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cap = 1; */
        if (message.cap !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cap);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OpenNotionalCap
 */
export const OpenNotionalCap = new OpenNotionalCap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketRequest$Type extends MessageType<MarketRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.MarketRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketRequest>): MarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketRequest): MarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.MarketRequest
 */
export const MarketRequest = new MarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketResponse$Type extends MessageType<MarketResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.MarketResponse", [
            { no: 1, name: "market", kind: "message", T: () => DerivativeMarketInfo }
        ]);
    }
    create(value?: PartialMessage<MarketResponse>): MarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketResponse): MarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeMarketInfo market */ 1:
                    message.market = DerivativeMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1; */
        if (message.market)
            DerivativeMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.MarketResponse
 */
export const MarketResponse = new MarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamMarketRequest$Type extends MessageType<StreamMarketRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamMarketRequest", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamMarketRequest>): StreamMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamMarketRequest): StreamMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamMarketRequest
 */
export const StreamMarketRequest = new StreamMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamMarketResponse$Type extends MessageType<StreamMarketResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamMarketResponse", [
            { no: 1, name: "market", kind: "message", T: () => DerivativeMarketInfo },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamMarketResponse>): StreamMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamMarketResponse): StreamMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeMarketInfo market */ 1:
                    message.market = DerivativeMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1; */
        if (message.market)
            DerivativeMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamMarketResponse
 */
export const StreamMarketResponse = new StreamMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarketsRequest$Type extends MessageType<BinaryOptionsMarketsRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest", [
            { no: 1, name: "market_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BinaryOptionsMarketsRequest>): BinaryOptionsMarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketStatus = "";
        message.quoteDenom = "";
        message.skip = 0n;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarketsRequest): BinaryOptionsMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_status */ 1:
                    message.marketStatus = reader.string();
                    break;
                case /* string quote_denom */ 2:
                    message.quoteDenom = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_status = 1; */
        if (message.marketStatus !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketStatus);
        /* string quote_denom = 2; */
        if (message.quoteDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quoteDenom);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest
 */
export const BinaryOptionsMarketsRequest = new BinaryOptionsMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarketsResponse$Type extends MessageType<BinaryOptionsMarketsResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BinaryOptionsMarketInfo },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<BinaryOptionsMarketsResponse>): BinaryOptionsMarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarketsResponse): BinaryOptionsMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets */ 1:
                    message.markets.push(BinaryOptionsMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            BinaryOptionsMarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse
 */
export const BinaryOptionsMarketsResponse = new BinaryOptionsMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarketInfo$Type extends MessageType<BinaryOptionsMarketInfo> {
    constructor() {
        super("injective_derivative_exchange_rpc.BinaryOptionsMarketInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "expiration_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "settlement_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "quote_token_meta", kind: "message", T: () => TokenMeta },
            { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "service_provider_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BinaryOptionsMarketInfo>): BinaryOptionsMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.marketStatus = "";
        message.ticker = "";
        message.oracleSymbol = "";
        message.oracleProvider = "";
        message.oracleType = "";
        message.oracleScaleFactor = 0;
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.quoteDenom = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.serviceProviderFee = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.settlementPrice = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarketInfo): BinaryOptionsMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string market_status */ 2:
                    message.marketStatus = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_symbol */ 4:
                    message.oracleSymbol = reader.string();
                    break;
                case /* string oracle_provider */ 5:
                    message.oracleProvider = reader.string();
                    break;
                case /* string oracle_type */ 6:
                    message.oracleType = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 7:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* sint64 expiration_timestamp */ 8:
                    message.expirationTimestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 settlement_timestamp */ 9:
                    message.settlementTimestamp = reader.sint64().toBigInt();
                    break;
                case /* string quote_denom */ 10:
                    message.quoteDenom = reader.string();
                    break;
                case /* injective_derivative_exchange_rpc.TokenMeta quote_token_meta */ 11:
                    message.quoteTokenMeta = TokenMeta.internalBinaryRead(reader, reader.uint32(), options, message.quoteTokenMeta);
                    break;
                case /* string maker_fee_rate */ 12:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 13:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string service_provider_fee */ 14:
                    message.serviceProviderFee = reader.string();
                    break;
                case /* string min_price_tick_size */ 15:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 16:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string settlement_price */ 17:
                    message.settlementPrice = reader.string();
                    break;
                case /* string min_notional */ 18:
                    message.minNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string market_status = 2; */
        if (message.marketStatus !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketStatus);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_symbol = 4; */
        if (message.oracleSymbol !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleSymbol);
        /* string oracle_provider = 5; */
        if (message.oracleProvider !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleProvider);
        /* string oracle_type = 6; */
        if (message.oracleType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.oracleType);
        /* uint32 oracle_scale_factor = 7; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
        /* sint64 expiration_timestamp = 8; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.expirationTimestamp);
        /* sint64 settlement_timestamp = 9; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.settlementTimestamp);
        /* string quote_denom = 10; */
        if (message.quoteDenom !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.quoteDenom);
        /* injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11; */
        if (message.quoteTokenMeta)
            TokenMeta.internalBinaryWrite(message.quoteTokenMeta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string maker_fee_rate = 12; */
        if (message.makerFeeRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 13; */
        if (message.takerFeeRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string service_provider_fee = 14; */
        if (message.serviceProviderFee !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.serviceProviderFee);
        /* string min_price_tick_size = 15; */
        if (message.minPriceTickSize !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 16; */
        if (message.minQuantityTickSize !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string settlement_price = 17; */
        if (message.settlementPrice !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.settlementPrice);
        /* string min_notional = 18; */
        if (message.minNotional !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.minNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketInfo
 */
export const BinaryOptionsMarketInfo = new BinaryOptionsMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Paging$Type extends MessageType<Paging> {
    constructor() {
        super("injective_derivative_exchange_rpc.Paging", [
            { no: 1, name: "total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "from", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "to", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "count_by_subaccount", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Paging>): Paging {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0n;
        message.from = 0;
        message.to = 0;
        message.countBySubaccount = 0n;
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<Paging>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Paging): Paging {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 total */ 1:
                    message.total = reader.sint64().toBigInt();
                    break;
                case /* sint32 from */ 2:
                    message.from = reader.sint32();
                    break;
                case /* sint32 to */ 3:
                    message.to = reader.sint32();
                    break;
                case /* sint64 count_by_subaccount */ 4:
                    message.countBySubaccount = reader.sint64().toBigInt();
                    break;
                case /* repeated string next */ 5:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Paging, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 total = 1; */
        if (message.total !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.total);
        /* sint32 from = 2; */
        if (message.from !== 0)
            writer.tag(2, WireType.Varint).sint32(message.from);
        /* sint32 to = 3; */
        if (message.to !== 0)
            writer.tag(3, WireType.Varint).sint32(message.to);
        /* sint64 count_by_subaccount = 4; */
        if (message.countBySubaccount !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
        /* repeated string next = 5; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.Paging
 */
export const Paging = new Paging$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarketRequest$Type extends MessageType<BinaryOptionsMarketRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.BinaryOptionsMarketRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BinaryOptionsMarketRequest>): BinaryOptionsMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarketRequest): BinaryOptionsMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketRequest
 */
export const BinaryOptionsMarketRequest = new BinaryOptionsMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarketResponse$Type extends MessageType<BinaryOptionsMarketResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.BinaryOptionsMarketResponse", [
            { no: 1, name: "market", kind: "message", T: () => BinaryOptionsMarketInfo }
        ]);
    }
    create(value?: PartialMessage<BinaryOptionsMarketResponse>): BinaryOptionsMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarketResponse): BinaryOptionsMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market */ 1:
                    message.market = BinaryOptionsMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market = 1; */
        if (message.market)
            BinaryOptionsMarketInfo.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketResponse
 */
export const BinaryOptionsMarketResponse = new BinaryOptionsMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookV2Request$Type extends MessageType<OrderbookV2Request> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrderbookV2Request", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbookV2Request>): OrderbookV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.depth = 0;
        if (value !== undefined)
            reflectionMergePartial<OrderbookV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookV2Request): OrderbookV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* sint32 depth */ 2:
                    message.depth = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* sint32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).sint32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbookV2Request
 */
export const OrderbookV2Request = new OrderbookV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookV2Response$Type extends MessageType<OrderbookV2Response> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrderbookV2Response", [
            { no: 1, name: "orderbook", kind: "message", T: () => DerivativeLimitOrderbookV2 }
        ]);
    }
    create(value?: PartialMessage<OrderbookV2Response>): OrderbookV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OrderbookV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookV2Response): OrderbookV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook */ 1:
                    message.orderbook = DerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1; */
        if (message.orderbook)
            DerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbookV2Response
 */
export const OrderbookV2Response = new OrderbookV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeLimitOrderbookV2$Type extends MessageType<DerivativeLimitOrderbookV2> {
    constructor() {
        super("injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2", [
            { no: 1, name: "buys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevel },
            { no: 2, name: "sells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevel },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeLimitOrderbookV2>): DerivativeLimitOrderbookV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buys = [];
        message.sells = [];
        message.sequence = 0n;
        message.timestamp = 0n;
        message.height = 0n;
        if (value !== undefined)
            reflectionMergePartial<DerivativeLimitOrderbookV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeLimitOrderbookV2): DerivativeLimitOrderbookV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.PriceLevel buys */ 1:
                    message.buys.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_derivative_exchange_rpc.PriceLevel sells */ 2:
                    message.sells.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 height */ 5:
                    message.height = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeLimitOrderbookV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.PriceLevel buys = 1; */
        for (let i = 0; i < message.buys.length; i++)
            PriceLevel.internalBinaryWrite(message.buys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_derivative_exchange_rpc.PriceLevel sells = 2; */
        for (let i = 0; i < message.sells.length; i++)
            PriceLevel.internalBinaryWrite(message.sells[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 sequence = 3; */
        if (message.sequence !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        /* sint64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2
 */
export const DerivativeLimitOrderbookV2 = new DerivativeLimitOrderbookV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevel$Type extends MessageType<PriceLevel> {
    constructor() {
        super("injective_derivative_exchange_rpc.PriceLevel", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceLevel>): PriceLevel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevel): PriceLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PriceLevel
 */
export const PriceLevel = new PriceLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbooksV2Request$Type extends MessageType<OrderbooksV2Request> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrderbooksV2Request", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbooksV2Request>): OrderbooksV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        message.depth = 0;
        if (value !== undefined)
            reflectionMergePartial<OrderbooksV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbooksV2Request): OrderbooksV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                case /* sint32 depth */ 2:
                    message.depth = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbooksV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        /* sint32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).sint32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbooksV2Request
 */
export const OrderbooksV2Request = new OrderbooksV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbooksV2Response$Type extends MessageType<OrderbooksV2Response> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrderbooksV2Response", [
            { no: 1, name: "orderbooks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SingleDerivativeLimitOrderbookV2 }
        ]);
    }
    create(value?: PartialMessage<OrderbooksV2Response>): OrderbooksV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderbooks = [];
        if (value !== undefined)
            reflectionMergePartial<OrderbooksV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbooksV2Response): OrderbooksV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks */ 1:
                    message.orderbooks.push(SingleDerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbooksV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks = 1; */
        for (let i = 0; i < message.orderbooks.length; i++)
            SingleDerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbooks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbooksV2Response
 */
export const OrderbooksV2Response = new OrderbooksV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SingleDerivativeLimitOrderbookV2$Type extends MessageType<SingleDerivativeLimitOrderbookV2> {
    constructor() {
        super("injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orderbook", kind: "message", T: () => DerivativeLimitOrderbookV2 }
        ]);
    }
    create(value?: PartialMessage<SingleDerivativeLimitOrderbookV2>): SingleDerivativeLimitOrderbookV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<SingleDerivativeLimitOrderbookV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SingleDerivativeLimitOrderbookV2): SingleDerivativeLimitOrderbookV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook */ 2:
                    message.orderbook = DerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SingleDerivativeLimitOrderbookV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 2; */
        if (message.orderbook)
            DerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2
 */
export const SingleDerivativeLimitOrderbookV2 = new SingleDerivativeLimitOrderbookV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookV2Request$Type extends MessageType<StreamOrderbookV2Request> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrderbookV2Request", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookV2Request>): StreamOrderbookV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookV2Request): StreamOrderbookV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrderbookV2Request
 */
export const StreamOrderbookV2Request = new StreamOrderbookV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookV2Response$Type extends MessageType<StreamOrderbookV2Response> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrderbookV2Response", [
            { no: 1, name: "orderbook", kind: "message", T: () => DerivativeLimitOrderbookV2 },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookV2Response>): StreamOrderbookV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookV2Response): StreamOrderbookV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook */ 1:
                    message.orderbook = DerivativeLimitOrderbookV2.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1; */
        if (message.orderbook)
            DerivativeLimitOrderbookV2.internalBinaryWrite(message.orderbook, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrderbookV2Response
 */
export const StreamOrderbookV2Response = new StreamOrderbookV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookUpdateRequest$Type extends MessageType<StreamOrderbookUpdateRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookUpdateRequest>): StreamOrderbookUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookUpdateRequest): StreamOrderbookUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest
 */
export const StreamOrderbookUpdateRequest = new StreamOrderbookUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrderbookUpdateResponse$Type extends MessageType<StreamOrderbookUpdateResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse", [
            { no: 1, name: "orderbook_level_updates", kind: "message", T: () => OrderbookLevelUpdates },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrderbookUpdateResponse>): StreamOrderbookUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<StreamOrderbookUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrderbookUpdateResponse): StreamOrderbookUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates */ 1:
                    message.orderbookLevelUpdates = OrderbookLevelUpdates.internalBinaryRead(reader, reader.uint32(), options, message.orderbookLevelUpdates);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrderbookUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1; */
        if (message.orderbookLevelUpdates)
            OrderbookLevelUpdates.internalBinaryWrite(message.orderbookLevelUpdates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse
 */
export const StreamOrderbookUpdateResponse = new StreamOrderbookUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookLevelUpdates$Type extends MessageType<OrderbookLevelUpdates> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrderbookLevelUpdates", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "buys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevelUpdate },
            { no: 4, name: "sells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceLevelUpdate },
            { no: 5, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbookLevelUpdates>): OrderbookLevelUpdates {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.sequence = 0n;
        message.buys = [];
        message.sells = [];
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<OrderbookLevelUpdates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookLevelUpdates): OrderbookLevelUpdates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* uint64 sequence */ 2:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* repeated injective_derivative_exchange_rpc.PriceLevelUpdate buys */ 3:
                    message.buys.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_derivative_exchange_rpc.PriceLevelUpdate sells */ 4:
                    message.sells.push(PriceLevelUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 updated_at */ 5:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookLevelUpdates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* uint64 sequence = 2; */
        if (message.sequence !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.sequence);
        /* repeated injective_derivative_exchange_rpc.PriceLevelUpdate buys = 3; */
        for (let i = 0; i < message.buys.length; i++)
            PriceLevelUpdate.internalBinaryWrite(message.buys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_derivative_exchange_rpc.PriceLevelUpdate sells = 4; */
        for (let i = 0; i < message.sells.length; i++)
            PriceLevelUpdate.internalBinaryWrite(message.sells[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sint64 updated_at = 5; */
        if (message.updatedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbookLevelUpdates
 */
export const OrderbookLevelUpdates = new OrderbookLevelUpdates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevelUpdate$Type extends MessageType<PriceLevelUpdate> {
    constructor() {
        super("injective_derivative_exchange_rpc.PriceLevelUpdate", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceLevelUpdate>): PriceLevelUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.isActive = false;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceLevelUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevelUpdate): PriceLevelUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PriceLevelUpdate
 */
export const PriceLevelUpdate = new PriceLevelUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersRequest$Type extends MessageType<OrdersRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "is_conditional", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "include_inactive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "subaccount_total_orders", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrdersRequest>): OrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.orderSide = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.isConditional = "";
        message.orderType = "";
        message.includeInactive = false;
        message.subaccountTotalOrders = false;
        message.tradeId = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<OrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersRequest): OrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 5:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 6:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 7:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 8:
                    message.marketIds.push(reader.string());
                    break;
                case /* string is_conditional */ 9:
                    message.isConditional = reader.string();
                    break;
                case /* string order_type */ 10:
                    message.orderType = reader.string();
                    break;
                case /* bool include_inactive */ 11:
                    message.includeInactive = reader.bool();
                    break;
                case /* bool subaccount_total_orders */ 12:
                    message.subaccountTotalOrders = reader.bool();
                    break;
                case /* string trade_id */ 13:
                    message.tradeId = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 5; */
        if (message.limit !== 0)
            writer.tag(5, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 7; */
        if (message.endTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 8; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
        /* string is_conditional = 9; */
        if (message.isConditional !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.isConditional);
        /* string order_type = 10; */
        if (message.orderType !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.orderType);
        /* bool include_inactive = 11; */
        if (message.includeInactive !== false)
            writer.tag(11, WireType.Varint).bool(message.includeInactive);
        /* bool subaccount_total_orders = 12; */
        if (message.subaccountTotalOrders !== false)
            writer.tag(12, WireType.Varint).bool(message.subaccountTotalOrders);
        /* string trade_id = 13; */
        if (message.tradeId !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.tradeId);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrdersRequest
 */
export const OrdersRequest = new OrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersResponse$Type extends MessageType<OrdersResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeLimitOrder },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<OrdersResponse>): OrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<OrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersResponse): OrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders */ 1:
                    message.orders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            DerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrdersResponse
 */
export const OrdersResponse = new OrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeLimitOrder$Type extends MessageType<DerivativeLimitOrder> {
    constructor() {
        super("injective_derivative_exchange_rpc.DerivativeLimitOrder", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_reduce_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "unfilled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "order_number", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "is_conditional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "trigger_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "placed_order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeLimitOrder>): DerivativeLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.orderSide = "";
        message.marketId = "";
        message.subaccountId = "";
        message.isReduceOnly = false;
        message.margin = "";
        message.price = "";
        message.quantity = "";
        message.unfilledQuantity = "";
        message.triggerPrice = "";
        message.feeRecipient = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.orderNumber = 0n;
        message.orderType = "";
        message.isConditional = false;
        message.triggerAt = 0n;
        message.placedOrderHash = "";
        message.executionType = "";
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeLimitOrder): DerivativeLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* bool is_reduce_only */ 5:
                    message.isReduceOnly = reader.bool();
                    break;
                case /* string margin */ 6:
                    message.margin = reader.string();
                    break;
                case /* string price */ 7:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 8:
                    message.quantity = reader.string();
                    break;
                case /* string unfilled_quantity */ 9:
                    message.unfilledQuantity = reader.string();
                    break;
                case /* string trigger_price */ 10:
                    message.triggerPrice = reader.string();
                    break;
                case /* string fee_recipient */ 11:
                    message.feeRecipient = reader.string();
                    break;
                case /* string state */ 12:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 13:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 14:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 order_number */ 15:
                    message.orderNumber = reader.sint64().toBigInt();
                    break;
                case /* string order_type */ 16:
                    message.orderType = reader.string();
                    break;
                case /* bool is_conditional */ 17:
                    message.isConditional = reader.bool();
                    break;
                case /* uint64 trigger_at */ 18:
                    message.triggerAt = reader.uint64().toBigInt();
                    break;
                case /* string placed_order_hash */ 19:
                    message.placedOrderHash = reader.string();
                    break;
                case /* string execution_type */ 20:
                    message.executionType = reader.string();
                    break;
                case /* string tx_hash */ 21:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 22:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* bool is_reduce_only = 5; */
        if (message.isReduceOnly !== false)
            writer.tag(5, WireType.Varint).bool(message.isReduceOnly);
        /* string margin = 6; */
        if (message.margin !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.margin);
        /* string price = 7; */
        if (message.price !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.price);
        /* string quantity = 8; */
        if (message.quantity !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.quantity);
        /* string unfilled_quantity = 9; */
        if (message.unfilledQuantity !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.unfilledQuantity);
        /* string trigger_price = 10; */
        if (message.triggerPrice !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.triggerPrice);
        /* string fee_recipient = 11; */
        if (message.feeRecipient !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.feeRecipient);
        /* string state = 12; */
        if (message.state !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 13; */
        if (message.createdAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 14; */
        if (message.updatedAt !== 0n)
            writer.tag(14, WireType.Varint).sint64(message.updatedAt);
        /* sint64 order_number = 15; */
        if (message.orderNumber !== 0n)
            writer.tag(15, WireType.Varint).sint64(message.orderNumber);
        /* string order_type = 16; */
        if (message.orderType !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.orderType);
        /* bool is_conditional = 17; */
        if (message.isConditional !== false)
            writer.tag(17, WireType.Varint).bool(message.isConditional);
        /* uint64 trigger_at = 18; */
        if (message.triggerAt !== 0n)
            writer.tag(18, WireType.Varint).uint64(message.triggerAt);
        /* string placed_order_hash = 19; */
        if (message.placedOrderHash !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.placedOrderHash);
        /* string execution_type = 20; */
        if (message.executionType !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.executionType);
        /* string tx_hash = 21; */
        if (message.txHash !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 22; */
        if (message.cid !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrder
 */
export const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsRequest$Type extends MessageType<PositionsRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.PositionsRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "subaccount_total_positions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsRequest>): PositionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.direction = "";
        message.subaccountTotalPositions = false;
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<PositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsRequest): PositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 5:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 6:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 7:
                    message.marketIds.push(reader.string());
                    break;
                case /* string direction */ 8:
                    message.direction = reader.string();
                    break;
                case /* bool subaccount_total_positions */ 9:
                    message.subaccountTotalPositions = reader.bool();
                    break;
                case /* string account_address */ 10:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 5; */
        if (message.startTime !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 6; */
        if (message.endTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 7; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.marketIds[i]);
        /* string direction = 8; */
        if (message.direction !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.direction);
        /* bool subaccount_total_positions = 9; */
        if (message.subaccountTotalPositions !== false)
            writer.tag(9, WireType.Varint).bool(message.subaccountTotalPositions);
        /* string account_address = 10; */
        if (message.accountAddress !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionsRequest
 */
export const PositionsRequest = new PositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsResponse$Type extends MessageType<PositionsResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.PositionsResponse", [
            { no: 1, name: "positions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativePosition },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<PositionsResponse>): PositionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.positions = [];
        if (value !== undefined)
            reflectionMergePartial<PositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsResponse): PositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativePosition positions */ 1:
                    message.positions.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativePosition positions = 1; */
        for (let i = 0; i < message.positions.length; i++)
            DerivativePosition.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionsResponse
 */
export const PositionsResponse = new PositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativePosition$Type extends MessageType<DerivativePosition> {
    constructor() {
        super("injective_derivative_exchange_rpc.DerivativePosition", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "liquidation_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "mark_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "aggregate_reduce_only_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "funding_last", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "funding_sum", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "effective_cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativePosition>): DerivativePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.marketId = "";
        message.subaccountId = "";
        message.direction = "";
        message.quantity = "";
        message.entryPrice = "";
        message.margin = "";
        message.liquidationPrice = "";
        message.markPrice = "";
        message.aggregateReduceOnlyQuantity = "";
        message.updatedAt = 0n;
        message.createdAt = 0n;
        message.fundingLast = "";
        message.fundingSum = "";
        message.cumulativeFundingEntry = "";
        message.effectiveCumulativeFundingEntry = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativePosition): DerivativePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* string quantity */ 5:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 6:
                    message.entryPrice = reader.string();
                    break;
                case /* string margin */ 7:
                    message.margin = reader.string();
                    break;
                case /* string liquidation_price */ 8:
                    message.liquidationPrice = reader.string();
                    break;
                case /* string mark_price */ 9:
                    message.markPrice = reader.string();
                    break;
                case /* string aggregate_reduce_only_quantity */ 11:
                    message.aggregateReduceOnlyQuantity = reader.string();
                    break;
                case /* sint64 updated_at */ 12:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 13:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* string funding_last */ 14:
                    message.fundingLast = reader.string();
                    break;
                case /* string funding_sum */ 15:
                    message.fundingSum = reader.string();
                    break;
                case /* string cumulative_funding_entry */ 16:
                    message.cumulativeFundingEntry = reader.string();
                    break;
                case /* string effective_cumulative_funding_entry */ 17:
                    message.effectiveCumulativeFundingEntry = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* string quantity = 5; */
        if (message.quantity !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 6; */
        if (message.entryPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
        /* string margin = 7; */
        if (message.margin !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.margin);
        /* string liquidation_price = 8; */
        if (message.liquidationPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
        /* string mark_price = 9; */
        if (message.markPrice !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
        /* string aggregate_reduce_only_quantity = 11; */
        if (message.aggregateReduceOnlyQuantity !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.aggregateReduceOnlyQuantity);
        /* sint64 updated_at = 12; */
        if (message.updatedAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.updatedAt);
        /* sint64 created_at = 13; */
        if (message.createdAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.createdAt);
        /* string funding_last = 14; */
        if (message.fundingLast !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.fundingLast);
        /* string funding_sum = 15; */
        if (message.fundingSum !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.fundingSum);
        /* string cumulative_funding_entry = 16; */
        if (message.cumulativeFundingEntry !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
        /* string effective_cumulative_funding_entry = 17; */
        if (message.effectiveCumulativeFundingEntry !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.effectiveCumulativeFundingEntry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativePosition
 */
export const DerivativePosition = new DerivativePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsV2Request$Type extends MessageType<PositionsV2Request> {
    constructor() {
        super("injective_derivative_exchange_rpc.PositionsV2Request", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "subaccount_total_positions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsV2Request>): PositionsV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.direction = "";
        message.subaccountTotalPositions = false;
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<PositionsV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsV2Request): PositionsV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 5:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 6:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 7:
                    message.marketIds.push(reader.string());
                    break;
                case /* string direction */ 8:
                    message.direction = reader.string();
                    break;
                case /* bool subaccount_total_positions */ 9:
                    message.subaccountTotalPositions = reader.bool();
                    break;
                case /* string account_address */ 10:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 5; */
        if (message.startTime !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 6; */
        if (message.endTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 7; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.marketIds[i]);
        /* string direction = 8; */
        if (message.direction !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.direction);
        /* bool subaccount_total_positions = 9; */
        if (message.subaccountTotalPositions !== false)
            writer.tag(9, WireType.Varint).bool(message.subaccountTotalPositions);
        /* string account_address = 10; */
        if (message.accountAddress !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionsV2Request
 */
export const PositionsV2Request = new PositionsV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsV2Response$Type extends MessageType<PositionsV2Response> {
    constructor() {
        super("injective_derivative_exchange_rpc.PositionsV2Response", [
            { no: 1, name: "positions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativePositionV2 },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<PositionsV2Response>): PositionsV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.positions = [];
        if (value !== undefined)
            reflectionMergePartial<PositionsV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsV2Response): PositionsV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativePositionV2 positions */ 1:
                    message.positions.push(DerivativePositionV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativePositionV2 positions = 1; */
        for (let i = 0; i < message.positions.length; i++)
            DerivativePositionV2.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionsV2Response
 */
export const PositionsV2Response = new PositionsV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativePositionV2$Type extends MessageType<DerivativePositionV2> {
    constructor() {
        super("injective_derivative_exchange_rpc.DerivativePositionV2", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "liquidation_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "mark_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "funding_last", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "funding_sum", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "effective_cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativePositionV2>): DerivativePositionV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.marketId = "";
        message.subaccountId = "";
        message.direction = "";
        message.quantity = "";
        message.entryPrice = "";
        message.margin = "";
        message.liquidationPrice = "";
        message.markPrice = "";
        message.updatedAt = 0n;
        message.denom = "";
        message.fundingLast = "";
        message.fundingSum = "";
        message.cumulativeFundingEntry = "";
        message.effectiveCumulativeFundingEntry = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativePositionV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativePositionV2): DerivativePositionV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* string quantity */ 5:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 6:
                    message.entryPrice = reader.string();
                    break;
                case /* string margin */ 7:
                    message.margin = reader.string();
                    break;
                case /* string liquidation_price */ 8:
                    message.liquidationPrice = reader.string();
                    break;
                case /* string mark_price */ 9:
                    message.markPrice = reader.string();
                    break;
                case /* sint64 updated_at */ 11:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string denom */ 12:
                    message.denom = reader.string();
                    break;
                case /* string funding_last */ 13:
                    message.fundingLast = reader.string();
                    break;
                case /* string funding_sum */ 14:
                    message.fundingSum = reader.string();
                    break;
                case /* string cumulative_funding_entry */ 15:
                    message.cumulativeFundingEntry = reader.string();
                    break;
                case /* string effective_cumulative_funding_entry */ 16:
                    message.effectiveCumulativeFundingEntry = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativePositionV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* string quantity = 5; */
        if (message.quantity !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 6; */
        if (message.entryPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
        /* string margin = 7; */
        if (message.margin !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.margin);
        /* string liquidation_price = 8; */
        if (message.liquidationPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
        /* string mark_price = 9; */
        if (message.markPrice !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
        /* sint64 updated_at = 11; */
        if (message.updatedAt !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.updatedAt);
        /* string denom = 12; */
        if (message.denom !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.denom);
        /* string funding_last = 13; */
        if (message.fundingLast !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.fundingLast);
        /* string funding_sum = 14; */
        if (message.fundingSum !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.fundingSum);
        /* string cumulative_funding_entry = 15; */
        if (message.cumulativeFundingEntry !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
        /* string effective_cumulative_funding_entry = 16; */
        if (message.effectiveCumulativeFundingEntry !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.effectiveCumulativeFundingEntry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativePositionV2
 */
export const DerivativePositionV2 = new DerivativePositionV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiquidablePositionsRequest$Type extends MessageType<LiquidablePositionsRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.LiquidablePositionsRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LiquidablePositionsRequest>): LiquidablePositionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<LiquidablePositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiquidablePositionsRequest): LiquidablePositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 2:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiquidablePositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 2; */
        if (message.skip !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.LiquidablePositionsRequest
 */
export const LiquidablePositionsRequest = new LiquidablePositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiquidablePositionsResponse$Type extends MessageType<LiquidablePositionsResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.LiquidablePositionsResponse", [
            { no: 1, name: "positions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativePosition }
        ]);
    }
    create(value?: PartialMessage<LiquidablePositionsResponse>): LiquidablePositionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.positions = [];
        if (value !== undefined)
            reflectionMergePartial<LiquidablePositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiquidablePositionsResponse): LiquidablePositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativePosition positions */ 1:
                    message.positions.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiquidablePositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativePosition positions = 1; */
        for (let i = 0; i < message.positions.length; i++)
            DerivativePosition.internalBinaryWrite(message.positions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.LiquidablePositionsResponse
 */
export const LiquidablePositionsResponse = new LiquidablePositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingPaymentsRequest$Type extends MessageType<FundingPaymentsRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.FundingPaymentsRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FundingPaymentsRequest>): FundingPaymentsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        message.endTime = 0n;
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<FundingPaymentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPaymentsRequest): FundingPaymentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 end_time */ 5:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 6:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* sint64 end_time = 5; */
        if (message.endTime !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 6; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingPaymentsRequest
 */
export const FundingPaymentsRequest = new FundingPaymentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingPaymentsResponse$Type extends MessageType<FundingPaymentsResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.FundingPaymentsResponse", [
            { no: 1, name: "payments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FundingPayment },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<FundingPaymentsResponse>): FundingPaymentsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payments = [];
        if (value !== undefined)
            reflectionMergePartial<FundingPaymentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPaymentsResponse): FundingPaymentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.FundingPayment payments */ 1:
                    message.payments.push(FundingPayment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingPaymentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.FundingPayment payments = 1; */
        for (let i = 0; i < message.payments.length; i++)
            FundingPayment.internalBinaryWrite(message.payments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingPaymentsResponse
 */
export const FundingPaymentsResponse = new FundingPaymentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingPayment$Type extends MessageType<FundingPayment> {
    constructor() {
        super("injective_derivative_exchange_rpc.FundingPayment", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FundingPayment>): FundingPayment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.amount = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<FundingPayment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingPayment): FundingPayment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingPayment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingPayment
 */
export const FundingPayment = new FundingPayment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingRatesRequest$Type extends MessageType<FundingRatesRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.FundingRatesRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FundingRatesRequest>): FundingRatesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        message.endTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<FundingRatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingRatesRequest): FundingRatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 2:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 end_time */ 4:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingRatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 2; */
        if (message.skip !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* sint64 end_time = 4; */
        if (message.endTime !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingRatesRequest
 */
export const FundingRatesRequest = new FundingRatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingRatesResponse$Type extends MessageType<FundingRatesResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.FundingRatesResponse", [
            { no: 1, name: "funding_rates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FundingRate },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<FundingRatesResponse>): FundingRatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fundingRates = [];
        if (value !== undefined)
            reflectionMergePartial<FundingRatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingRatesResponse): FundingRatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.FundingRate funding_rates */ 1:
                    message.fundingRates.push(FundingRate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingRatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.FundingRate funding_rates = 1; */
        for (let i = 0; i < message.fundingRates.length; i++)
            FundingRate.internalBinaryWrite(message.fundingRates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingRatesResponse
 */
export const FundingRatesResponse = new FundingRatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FundingRate$Type extends MessageType<FundingRate> {
    constructor() {
        super("injective_derivative_exchange_rpc.FundingRate", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FundingRate>): FundingRate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.rate = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<FundingRate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FundingRate): FundingRate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string rate */ 2:
                    message.rate = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FundingRate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string rate = 2; */
        if (message.rate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.rate);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingRate
 */
export const FundingRate = new FundingRate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamPositionsRequest$Type extends MessageType<StreamPositionsRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamPositionsRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamPositionsRequest>): StreamPositionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.marketIds = [];
        message.subaccountIds = [];
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<StreamPositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamPositionsRequest): StreamPositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* repeated string market_ids */ 3:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 4:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* string account_address */ 5:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamPositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* repeated string market_ids = 3; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 4; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* string account_address = 5; */
        if (message.accountAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamPositionsRequest
 */
export const StreamPositionsRequest = new StreamPositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamPositionsResponse$Type extends MessageType<StreamPositionsResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamPositionsResponse", [
            { no: 1, name: "position", kind: "message", T: () => DerivativePosition },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamPositionsResponse>): StreamPositionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamPositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamPositionsResponse): StreamPositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativePosition position */ 1:
                    message.position = DerivativePosition.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamPositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativePosition position = 1; */
        if (message.position)
            DerivativePosition.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamPositionsResponse
 */
export const StreamPositionsResponse = new StreamPositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamPositionsV2Request$Type extends MessageType<StreamPositionsV2Request> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamPositionsV2Request", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamPositionsV2Request>): StreamPositionsV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.marketIds = [];
        message.subaccountIds = [];
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<StreamPositionsV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamPositionsV2Request): StreamPositionsV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* repeated string market_ids */ 3:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 4:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* string account_address */ 5:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamPositionsV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* repeated string market_ids = 3; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 4; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* string account_address = 5; */
        if (message.accountAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamPositionsV2Request
 */
export const StreamPositionsV2Request = new StreamPositionsV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamPositionsV2Response$Type extends MessageType<StreamPositionsV2Response> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamPositionsV2Response", [
            { no: 1, name: "position", kind: "message", T: () => DerivativePositionV2 },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamPositionsV2Response>): StreamPositionsV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamPositionsV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamPositionsV2Response): StreamPositionsV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativePositionV2 position */ 1:
                    message.position = DerivativePositionV2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamPositionsV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativePositionV2 position = 1; */
        if (message.position)
            DerivativePositionV2.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamPositionsV2Response
 */
export const StreamPositionsV2Response = new StreamPositionsV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersRequest$Type extends MessageType<StreamOrdersRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "is_conditional", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "include_inactive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "subaccount_total_orders", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersRequest>): StreamOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.orderSide = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.isConditional = "";
        message.orderType = "";
        message.includeInactive = false;
        message.subaccountTotalOrders = false;
        message.tradeId = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersRequest): StreamOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string order_side */ 2:
                    message.orderSide = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 4:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 5:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 6:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 7:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 8:
                    message.marketIds.push(reader.string());
                    break;
                case /* string is_conditional */ 9:
                    message.isConditional = reader.string();
                    break;
                case /* string order_type */ 10:
                    message.orderType = reader.string();
                    break;
                case /* bool include_inactive */ 11:
                    message.includeInactive = reader.bool();
                    break;
                case /* bool subaccount_total_orders */ 12:
                    message.subaccountTotalOrders = reader.bool();
                    break;
                case /* string trade_id */ 13:
                    message.tradeId = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string order_side = 2; */
        if (message.orderSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderSide);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 4; */
        if (message.skip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 5; */
        if (message.limit !== 0)
            writer.tag(5, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 7; */
        if (message.endTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 8; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.marketIds[i]);
        /* string is_conditional = 9; */
        if (message.isConditional !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.isConditional);
        /* string order_type = 10; */
        if (message.orderType !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.orderType);
        /* bool include_inactive = 11; */
        if (message.includeInactive !== false)
            writer.tag(11, WireType.Varint).bool(message.includeInactive);
        /* bool subaccount_total_orders = 12; */
        if (message.subaccountTotalOrders !== false)
            writer.tag(12, WireType.Varint).bool(message.subaccountTotalOrders);
        /* string trade_id = 13; */
        if (message.tradeId !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.tradeId);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrdersRequest
 */
export const StreamOrdersRequest = new StreamOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersResponse$Type extends MessageType<StreamOrdersResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrdersResponse", [
            { no: 1, name: "order", kind: "message", T: () => DerivativeLimitOrder },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersResponse>): StreamOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersResponse): StreamOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeLimitOrder order */ 1:
                    message.order = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeLimitOrder order = 1; */
        if (message.order)
            DerivativeLimitOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrdersResponse
 */
export const StreamOrdersResponse = new StreamOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesRequest$Type extends MessageType<TradesRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.TradesRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradesRequest>): TradesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<TradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesRequest): TradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.TradesRequest
 */
export const TradesRequest = new TradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesResponse$Type extends MessageType<TradesResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.TradesResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeTrade },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<TradesResponse>): TradesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<TradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesResponse): TradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades */ 1:
                    message.trades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            DerivativeTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.TradesResponse
 */
export const TradesResponse = new TradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeTrade$Type extends MessageType<DerivativeTrade> {
    constructor() {
        super("injective_derivative_exchange_rpc.DerivativeTrade", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "trade_execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_liquidation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "position_delta", kind: "message", T: () => PositionDelta },
            { no: 7, name: "payout", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeTrade>): DerivativeTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.subaccountId = "";
        message.marketId = "";
        message.tradeExecutionType = "";
        message.isLiquidation = false;
        message.payout = "";
        message.fee = "";
        message.executedAt = 0n;
        message.feeRecipient = "";
        message.tradeId = "";
        message.executionSide = "";
        message.cid = "";
        message.pnl = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeTrade): DerivativeTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string trade_execution_type */ 4:
                    message.tradeExecutionType = reader.string();
                    break;
                case /* bool is_liquidation */ 5:
                    message.isLiquidation = reader.bool();
                    break;
                case /* injective_derivative_exchange_rpc.PositionDelta position_delta */ 6:
                    message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
                    break;
                case /* string payout */ 7:
                    message.payout = reader.string();
                    break;
                case /* string fee */ 8:
                    message.fee = reader.string();
                    break;
                case /* sint64 executed_at */ 9:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* string fee_recipient */ 10:
                    message.feeRecipient = reader.string();
                    break;
                case /* string trade_id */ 11:
                    message.tradeId = reader.string();
                    break;
                case /* string execution_side */ 12:
                    message.executionSide = reader.string();
                    break;
                case /* string cid */ 13:
                    message.cid = reader.string();
                    break;
                case /* string pnl */ 14:
                    message.pnl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string trade_execution_type = 4; */
        if (message.tradeExecutionType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tradeExecutionType);
        /* bool is_liquidation = 5; */
        if (message.isLiquidation !== false)
            writer.tag(5, WireType.Varint).bool(message.isLiquidation);
        /* injective_derivative_exchange_rpc.PositionDelta position_delta = 6; */
        if (message.positionDelta)
            PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string payout = 7; */
        if (message.payout !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.payout);
        /* string fee = 8; */
        if (message.fee !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.fee);
        /* sint64 executed_at = 9; */
        if (message.executedAt !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.executedAt);
        /* string fee_recipient = 10; */
        if (message.feeRecipient !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.feeRecipient);
        /* string trade_id = 11; */
        if (message.tradeId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
        /* string execution_side = 12; */
        if (message.executionSide !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.executionSide);
        /* string cid = 13; */
        if (message.cid !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.cid);
        /* string pnl = 14; */
        if (message.pnl !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.pnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeTrade
 */
export const DerivativeTrade = new DerivativeTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionDelta$Type extends MessageType<PositionDelta> {
    constructor() {
        super("injective_derivative_exchange_rpc.PositionDelta", [
            { no: 1, name: "trade_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "execution_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "execution_margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionDelta>): PositionDelta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeDirection = "";
        message.executionPrice = "";
        message.executionQuantity = "";
        message.executionMargin = "";
        if (value !== undefined)
            reflectionMergePartial<PositionDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionDelta): PositionDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_direction */ 1:
                    message.tradeDirection = reader.string();
                    break;
                case /* string execution_price */ 2:
                    message.executionPrice = reader.string();
                    break;
                case /* string execution_quantity */ 3:
                    message.executionQuantity = reader.string();
                    break;
                case /* string execution_margin */ 4:
                    message.executionMargin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_direction = 1; */
        if (message.tradeDirection !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeDirection);
        /* string execution_price = 2; */
        if (message.executionPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionPrice);
        /* string execution_quantity = 3; */
        if (message.executionQuantity !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionQuantity);
        /* string execution_margin = 4; */
        if (message.executionMargin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.executionMargin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionDelta
 */
export const PositionDelta = new PositionDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesV2Request$Type extends MessageType<TradesV2Request> {
    constructor() {
        super("injective_derivative_exchange_rpc.TradesV2Request", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradesV2Request>): TradesV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<TradesV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesV2Request): TradesV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.TradesV2Request
 */
export const TradesV2Request = new TradesV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesV2Response$Type extends MessageType<TradesV2Response> {
    constructor() {
        super("injective_derivative_exchange_rpc.TradesV2Response", [
            { no: 1, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeTrade },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<TradesV2Response>): TradesV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<TradesV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesV2Response): TradesV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades */ 1:
                    message.trades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            DerivativeTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.TradesV2Response
 */
export const TradesV2Response = new TradesV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesRequest$Type extends MessageType<StreamTradesRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamTradesRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesRequest>): StreamTradesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<StreamTradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesRequest): StreamTradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamTradesRequest
 */
export const StreamTradesRequest = new StreamTradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesResponse$Type extends MessageType<StreamTradesResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamTradesResponse", [
            { no: 1, name: "trade", kind: "message", T: () => DerivativeTrade },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesResponse>): StreamTradesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamTradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesResponse): StreamTradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeTrade trade */ 1:
                    message.trade = DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeTrade trade = 1; */
        if (message.trade)
            DerivativeTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamTradesResponse
 */
export const StreamTradesResponse = new StreamTradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesV2Request$Type extends MessageType<StreamTradesV2Request> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamTradesV2Request", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesV2Request>): StreamTradesV2Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.executionSide = "";
        message.direction = "";
        message.subaccountId = "";
        message.skip = 0n;
        message.limit = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        message.marketIds = [];
        message.subaccountIds = [];
        message.executionTypes = [];
        message.tradeId = "";
        message.accountAddress = "";
        message.cid = "";
        message.feeRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<StreamTradesV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesV2Request): StreamTradesV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string execution_side */ 2:
                    message.executionSide = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* repeated string market_ids */ 9:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string subaccount_ids */ 10:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string execution_types */ 11:
                    message.executionTypes.push(reader.string());
                    break;
                case /* string trade_id */ 12:
                    message.tradeId = reader.string();
                    break;
                case /* string account_address */ 13:
                    message.accountAddress = reader.string();
                    break;
                case /* string cid */ 14:
                    message.cid = reader.string();
                    break;
                case /* string fee_recipient */ 15:
                    message.feeRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string execution_side = 2; */
        if (message.executionSide !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionSide);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* repeated string market_ids = 9; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string subaccount_ids = 10; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string execution_types = 11; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* string trade_id = 12; */
        if (message.tradeId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.tradeId);
        /* string account_address = 13; */
        if (message.accountAddress !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.accountAddress);
        /* string cid = 14; */
        if (message.cid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cid);
        /* string fee_recipient = 15; */
        if (message.feeRecipient !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.feeRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamTradesV2Request
 */
export const StreamTradesV2Request = new StreamTradesV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTradesV2Response$Type extends MessageType<StreamTradesV2Response> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamTradesV2Response", [
            { no: 1, name: "trade", kind: "message", T: () => DerivativeTrade },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTradesV2Response>): StreamTradesV2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamTradesV2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTradesV2Response): StreamTradesV2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeTrade trade */ 1:
                    message.trade = DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options, message.trade);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTradesV2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeTrade trade = 1; */
        if (message.trade)
            DerivativeTrade.internalBinaryWrite(message.trade, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamTradesV2Response
 */
export const StreamTradesV2Response = new StreamTradesV2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrdersListRequest$Type extends MessageType<SubaccountOrdersListRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.SubaccountOrdersListRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrdersListRequest>): SubaccountOrdersListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrdersListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrdersListRequest): SubaccountOrdersListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrdersListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.SubaccountOrdersListRequest
 */
export const SubaccountOrdersListRequest = new SubaccountOrdersListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrdersListResponse$Type extends MessageType<SubaccountOrdersListResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.SubaccountOrdersListResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeLimitOrder },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrdersListResponse>): SubaccountOrdersListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrdersListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrdersListResponse): SubaccountOrdersListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders */ 1:
                    message.orders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrdersListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            DerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.SubaccountOrdersListResponse
 */
export const SubaccountOrdersListResponse = new SubaccountOrdersListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountTradesListRequest$Type extends MessageType<SubaccountTradesListRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.SubaccountTradesListRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountTradesListRequest>): SubaccountTradesListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.executionType = "";
        message.direction = "";
        message.skip = 0n;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<SubaccountTradesListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountTradesListRequest): SubaccountTradesListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string execution_type */ 3:
                    message.executionType = reader.string();
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* uint64 skip */ 5:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 6:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountTradesListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string execution_type = 3; */
        if (message.executionType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionType);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* uint64 skip = 5; */
        if (message.skip !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 6; */
        if (message.limit !== 0)
            writer.tag(6, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.SubaccountTradesListRequest
 */
export const SubaccountTradesListRequest = new SubaccountTradesListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountTradesListResponse$Type extends MessageType<SubaccountTradesListResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.SubaccountTradesListResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeTrade }
        ]);
    }
    create(value?: PartialMessage<SubaccountTradesListResponse>): SubaccountTradesListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountTradesListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountTradesListResponse): SubaccountTradesListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades */ 1:
                    message.trades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountTradesListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            DerivativeTrade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.SubaccountTradesListResponse
 */
export const SubaccountTradesListResponse = new SubaccountTradesListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersHistoryRequest$Type extends MessageType<OrdersHistoryRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrdersHistoryRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "order_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "is_conditional", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "active_markets_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrdersHistoryRequest>): OrdersHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.skip = 0n;
        message.limit = 0;
        message.orderTypes = [];
        message.direction = "";
        message.startTime = 0n;
        message.endTime = 0n;
        message.isConditional = "";
        message.orderType = "";
        message.state = "";
        message.executionTypes = [];
        message.marketIds = [];
        message.tradeId = "";
        message.activeMarketsOnly = false;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<OrdersHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersHistoryRequest): OrdersHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* uint64 skip */ 3:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                case /* repeated string order_types */ 5:
                    message.orderTypes.push(reader.string());
                    break;
                case /* string direction */ 6:
                    message.direction = reader.string();
                    break;
                case /* sint64 start_time */ 7:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 8:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* string is_conditional */ 9:
                    message.isConditional = reader.string();
                    break;
                case /* string order_type */ 10:
                    message.orderType = reader.string();
                    break;
                case /* string state */ 11:
                    message.state = reader.string();
                    break;
                case /* repeated string execution_types */ 12:
                    message.executionTypes.push(reader.string());
                    break;
                case /* repeated string market_ids */ 13:
                    message.marketIds.push(reader.string());
                    break;
                case /* string trade_id */ 14:
                    message.tradeId = reader.string();
                    break;
                case /* bool active_markets_only */ 15:
                    message.activeMarketsOnly = reader.bool();
                    break;
                case /* string cid */ 16:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* uint64 skip = 3; */
        if (message.skip !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.skip);
        /* sint32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        /* repeated string order_types = 5; */
        for (let i = 0; i < message.orderTypes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.orderTypes[i]);
        /* string direction = 6; */
        if (message.direction !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.direction);
        /* sint64 start_time = 7; */
        if (message.startTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 8; */
        if (message.endTime !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.endTime);
        /* string is_conditional = 9; */
        if (message.isConditional !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.isConditional);
        /* string order_type = 10; */
        if (message.orderType !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.orderType);
        /* string state = 11; */
        if (message.state !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.state);
        /* repeated string execution_types = 12; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.executionTypes[i]);
        /* repeated string market_ids = 13; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.marketIds[i]);
        /* string trade_id = 14; */
        if (message.tradeId !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.tradeId);
        /* bool active_markets_only = 15; */
        if (message.activeMarketsOnly !== false)
            writer.tag(15, WireType.Varint).bool(message.activeMarketsOnly);
        /* string cid = 16; */
        if (message.cid !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrdersHistoryRequest
 */
export const OrdersHistoryRequest = new OrdersHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersHistoryResponse$Type extends MessageType<OrdersHistoryResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.OrdersHistoryResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrderHistory },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<OrdersHistoryResponse>): OrdersHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<OrdersHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersHistoryResponse): OrdersHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.DerivativeOrderHistory orders */ 1:
                    message.orders.push(DerivativeOrderHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_derivative_exchange_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.DerivativeOrderHistory orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            DerivativeOrderHistory.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_derivative_exchange_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrdersHistoryResponse
 */
export const OrdersHistoryResponse = new OrdersHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeOrderHistory$Type extends MessageType<DerivativeOrderHistory> {
    constructor() {
        super("injective_derivative_exchange_rpc.DerivativeOrderHistory", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "execution_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "filled_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "is_reduce_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "is_conditional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "trigger_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "placed_order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeOrderHistory>): DerivativeOrderHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.marketId = "";
        message.isActive = false;
        message.subaccountId = "";
        message.executionType = "";
        message.orderType = "";
        message.price = "";
        message.triggerPrice = "";
        message.quantity = "";
        message.filledQuantity = "";
        message.state = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.isReduceOnly = false;
        message.direction = "";
        message.isConditional = false;
        message.triggerAt = 0n;
        message.placedOrderHash = "";
        message.margin = "";
        message.txHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeOrderHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeOrderHistory): DerivativeOrderHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* string execution_type */ 5:
                    message.executionType = reader.string();
                    break;
                case /* string order_type */ 6:
                    message.orderType = reader.string();
                    break;
                case /* string price */ 7:
                    message.price = reader.string();
                    break;
                case /* string trigger_price */ 8:
                    message.triggerPrice = reader.string();
                    break;
                case /* string quantity */ 9:
                    message.quantity = reader.string();
                    break;
                case /* string filled_quantity */ 10:
                    message.filledQuantity = reader.string();
                    break;
                case /* string state */ 11:
                    message.state = reader.string();
                    break;
                case /* sint64 created_at */ 12:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 13:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* bool is_reduce_only */ 14:
                    message.isReduceOnly = reader.bool();
                    break;
                case /* string direction */ 15:
                    message.direction = reader.string();
                    break;
                case /* bool is_conditional */ 16:
                    message.isConditional = reader.bool();
                    break;
                case /* uint64 trigger_at */ 17:
                    message.triggerAt = reader.uint64().toBigInt();
                    break;
                case /* string placed_order_hash */ 18:
                    message.placedOrderHash = reader.string();
                    break;
                case /* string margin */ 19:
                    message.margin = reader.string();
                    break;
                case /* string tx_hash */ 20:
                    message.txHash = reader.string();
                    break;
                case /* string cid */ 21:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeOrderHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* string execution_type = 5; */
        if (message.executionType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.executionType);
        /* string order_type = 6; */
        if (message.orderType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orderType);
        /* string price = 7; */
        if (message.price !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.price);
        /* string trigger_price = 8; */
        if (message.triggerPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.triggerPrice);
        /* string quantity = 9; */
        if (message.quantity !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.quantity);
        /* string filled_quantity = 10; */
        if (message.filledQuantity !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.filledQuantity);
        /* string state = 11; */
        if (message.state !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.state);
        /* sint64 created_at = 12; */
        if (message.createdAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 13; */
        if (message.updatedAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.updatedAt);
        /* bool is_reduce_only = 14; */
        if (message.isReduceOnly !== false)
            writer.tag(14, WireType.Varint).bool(message.isReduceOnly);
        /* string direction = 15; */
        if (message.direction !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.direction);
        /* bool is_conditional = 16; */
        if (message.isConditional !== false)
            writer.tag(16, WireType.Varint).bool(message.isConditional);
        /* uint64 trigger_at = 17; */
        if (message.triggerAt !== 0n)
            writer.tag(17, WireType.Varint).uint64(message.triggerAt);
        /* string placed_order_hash = 18; */
        if (message.placedOrderHash !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.placedOrderHash);
        /* string margin = 19; */
        if (message.margin !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.margin);
        /* string tx_hash = 20; */
        if (message.txHash !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.txHash);
        /* string cid = 21; */
        if (message.cid !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeOrderHistory
 */
export const DerivativeOrderHistory = new DerivativeOrderHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersHistoryRequest$Type extends MessageType<StreamOrdersHistoryRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrdersHistoryRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "execution_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersHistoryRequest>): StreamOrdersHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        message.orderTypes = [];
        message.direction = "";
        message.state = "";
        message.executionTypes = [];
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersHistoryRequest): StreamOrdersHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* repeated string order_types */ 3:
                    message.orderTypes.push(reader.string());
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* string state */ 5:
                    message.state = reader.string();
                    break;
                case /* repeated string execution_types */ 6:
                    message.executionTypes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* repeated string order_types = 3; */
        for (let i = 0; i < message.orderTypes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.orderTypes[i]);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* string state = 5; */
        if (message.state !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.state);
        /* repeated string execution_types = 6; */
        for (let i = 0; i < message.executionTypes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.executionTypes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrdersHistoryRequest
 */
export const StreamOrdersHistoryRequest = new StreamOrdersHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamOrdersHistoryResponse$Type extends MessageType<StreamOrdersHistoryResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.StreamOrdersHistoryResponse", [
            { no: 1, name: "order", kind: "message", T: () => DerivativeOrderHistory },
            { no: 2, name: "operation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamOrdersHistoryResponse>): StreamOrdersHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamOrdersHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamOrdersHistoryResponse): StreamOrdersHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_derivative_exchange_rpc.DerivativeOrderHistory order */ 1:
                    message.order = DerivativeOrderHistory.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* string operation_type */ 2:
                    message.operationType = reader.string();
                    break;
                case /* sint64 timestamp */ 3:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamOrdersHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_derivative_exchange_rpc.DerivativeOrderHistory order = 1; */
        if (message.order)
            DerivativeOrderHistory.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string operation_type = 2; */
        if (message.operationType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationType);
        /* sint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrdersHistoryResponse
 */
export const StreamOrdersHistoryResponse = new StreamOrdersHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenInterestRequest$Type extends MessageType<OpenInterestRequest> {
    constructor() {
        super("injective_derivative_exchange_rpc.OpenInterestRequest", [
            { no: 1, name: "market_i_ds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OpenInterestRequest>): OpenInterestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIDs = [];
        if (value !== undefined)
            reflectionMergePartial<OpenInterestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenInterestRequest): OpenInterestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_i_ds */ 1:
                    message.marketIDs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenInterestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_i_ds = 1; */
        for (let i = 0; i < message.marketIDs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OpenInterestRequest
 */
export const OpenInterestRequest = new OpenInterestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenInterestResponse$Type extends MessageType<OpenInterestResponse> {
    constructor() {
        super("injective_derivative_exchange_rpc.OpenInterestResponse", [
            { no: 1, name: "open_interests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketOpenInterest }
        ]);
    }
    create(value?: PartialMessage<OpenInterestResponse>): OpenInterestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.openInterests = [];
        if (value !== undefined)
            reflectionMergePartial<OpenInterestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenInterestResponse): OpenInterestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_derivative_exchange_rpc.MarketOpenInterest open_interests */ 1:
                    message.openInterests.push(MarketOpenInterest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenInterestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_derivative_exchange_rpc.MarketOpenInterest open_interests = 1; */
        for (let i = 0; i < message.openInterests.length; i++)
            MarketOpenInterest.internalBinaryWrite(message.openInterests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OpenInterestResponse
 */
export const OpenInterestResponse = new OpenInterestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketOpenInterest$Type extends MessageType<MarketOpenInterest> {
    constructor() {
        super("injective_derivative_exchange_rpc.MarketOpenInterest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "open_interest", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketOpenInterest>): MarketOpenInterest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.openInterest = "";
        if (value !== undefined)
            reflectionMergePartial<MarketOpenInterest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketOpenInterest): MarketOpenInterest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string open_interest */ 2:
                    message.openInterest = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketOpenInterest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string open_interest = 2; */
        if (message.openInterest !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.openInterest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.MarketOpenInterest
 */
export const MarketOpenInterest = new MarketOpenInterest$Type();
/**
 * @generated ServiceType for protobuf service injective_derivative_exchange_rpc.InjectiveDerivativeExchangeRPC
 */
export const InjectiveDerivativeExchangeRPC = new ServiceType("injective_derivative_exchange_rpc.InjectiveDerivativeExchangeRPC", [
    { name: "Markets", options: {}, I: MarketsRequest, O: MarketsResponse },
    { name: "Market", options: {}, I: MarketRequest, O: MarketResponse },
    { name: "StreamMarket", serverStreaming: true, options: {}, I: StreamMarketRequest, O: StreamMarketResponse },
    { name: "BinaryOptionsMarkets", options: {}, I: BinaryOptionsMarketsRequest, O: BinaryOptionsMarketsResponse },
    { name: "BinaryOptionsMarket", options: {}, I: BinaryOptionsMarketRequest, O: BinaryOptionsMarketResponse },
    { name: "OrderbookV2", options: {}, I: OrderbookV2Request, O: OrderbookV2Response },
    { name: "OrderbooksV2", options: {}, I: OrderbooksV2Request, O: OrderbooksV2Response },
    { name: "StreamOrderbookV2", serverStreaming: true, options: {}, I: StreamOrderbookV2Request, O: StreamOrderbookV2Response },
    { name: "StreamOrderbookUpdate", serverStreaming: true, options: {}, I: StreamOrderbookUpdateRequest, O: StreamOrderbookUpdateResponse },
    { name: "Orders", options: {}, I: OrdersRequest, O: OrdersResponse },
    { name: "Positions", options: {}, I: PositionsRequest, O: PositionsResponse },
    { name: "PositionsV2", options: {}, I: PositionsV2Request, O: PositionsV2Response },
    { name: "LiquidablePositions", options: {}, I: LiquidablePositionsRequest, O: LiquidablePositionsResponse },
    { name: "FundingPayments", options: {}, I: FundingPaymentsRequest, O: FundingPaymentsResponse },
    { name: "FundingRates", options: {}, I: FundingRatesRequest, O: FundingRatesResponse },
    { name: "StreamPositions", serverStreaming: true, options: {}, I: StreamPositionsRequest, O: StreamPositionsResponse },
    { name: "StreamPositionsV2", serverStreaming: true, options: {}, I: StreamPositionsV2Request, O: StreamPositionsV2Response },
    { name: "StreamOrders", serverStreaming: true, options: {}, I: StreamOrdersRequest, O: StreamOrdersResponse },
    { name: "Trades", options: {}, I: TradesRequest, O: TradesResponse },
    { name: "TradesV2", options: {}, I: TradesV2Request, O: TradesV2Response },
    { name: "StreamTrades", serverStreaming: true, options: {}, I: StreamTradesRequest, O: StreamTradesResponse },
    { name: "StreamTradesV2", serverStreaming: true, options: {}, I: StreamTradesV2Request, O: StreamTradesV2Response },
    { name: "SubaccountOrdersList", options: {}, I: SubaccountOrdersListRequest, O: SubaccountOrdersListResponse },
    { name: "SubaccountTradesList", options: {}, I: SubaccountTradesListRequest, O: SubaccountTradesListResponse },
    { name: "OrdersHistory", options: {}, I: OrdersHistoryRequest, O: OrdersHistoryResponse },
    { name: "StreamOrdersHistory", serverStreaming: true, options: {}, I: StreamOrdersHistoryRequest, O: StreamOrdersHistoryResponse },
    { name: "OpenInterest", options: {}, I: OpenInterestRequest, O: OpenInterestResponse }
]);
