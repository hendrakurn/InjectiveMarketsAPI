// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_portfolio_rpc.proto" (package "injective_portfolio_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectivePortfolioRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_portfolio_rpc.TokenHoldersRequest
 */
export interface TokenHoldersRequest {
    /**
     * Denom of the token
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * Cursor for pagination
     *
     * @generated from protobuf field: string cursor = 2
     */
    cursor: string;
    /**
     * @generated from protobuf field: sint32 limit = 3
     */
    limit: number;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.TokenHoldersResponse
 */
export interface TokenHoldersResponse {
    /**
     * @generated from protobuf field: repeated injective_portfolio_rpc.Holder holders = 1
     */
    holders: Holder[];
    /**
     * Next cursors for pagination
     *
     * @generated from protobuf field: repeated string next_cursors = 2
     */
    nextCursors: string[];
}
/**
 * @generated from protobuf message injective_portfolio_rpc.Holder
 */
export interface Holder {
    /**
     * Account address for the holder
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * The balance of the holder
     *
     * @generated from protobuf field: string balance = 2
     */
    balance: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.AccountPortfolioRequest
 */
export interface AccountPortfolioRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.AccountPortfolioResponse
 */
export interface AccountPortfolioResponse {
    /**
     * The portfolio of this account
     *
     * @generated from protobuf field: injective_portfolio_rpc.Portfolio portfolio = 1
     */
    portfolio?: Portfolio;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.Portfolio
 */
export interface Portfolio {
    /**
     * The account's portfolio address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Account available bank balances
     *
     * @generated from protobuf field: repeated injective_portfolio_rpc.Coin bank_balances = 2
     */
    bankBalances: Coin[];
    /**
     * Subaccounts list
     *
     * @generated from protobuf field: repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts = 3
     */
    subaccounts: SubaccountBalanceV2[];
    /**
     * All positions for all subaccounts, with unrealized PNL
     *
     * @generated from protobuf field: repeated injective_portfolio_rpc.PositionsWithUPNL positions_with_upnl = 4
     */
    positionsWithUpnl: PositionsWithUPNL[];
}
/**
 * @generated from protobuf message injective_portfolio_rpc.Coin
 */
export interface Coin {
    /**
     * Denom of the coin
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * @generated from protobuf field: string usd_value = 3
     */
    usdValue: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.SubaccountBalanceV2
 */
export interface SubaccountBalanceV2 {
    /**
     * Related subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * Coin denom on the chain.
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * @generated from protobuf field: injective_portfolio_rpc.SubaccountDeposit deposit = 3
     */
    deposit?: SubaccountDeposit;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.SubaccountDeposit
 */
export interface SubaccountDeposit {
    /**
     * @generated from protobuf field: string total_balance = 1
     */
    totalBalance: string;
    /**
     * @generated from protobuf field: string available_balance = 2
     */
    availableBalance: string;
    /**
     * @generated from protobuf field: string total_balance_usd = 3
     */
    totalBalanceUsd: string;
    /**
     * @generated from protobuf field: string available_balance_usd = 4
     */
    availableBalanceUsd: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.PositionsWithUPNL
 */
export interface PositionsWithUPNL {
    /**
     * @generated from protobuf field: injective_portfolio_rpc.DerivativePosition position = 1
     */
    position?: DerivativePosition;
    /**
     * Unrealized PNL
     *
     * @generated from protobuf field: string unrealized_pnl = 2
     */
    unrealizedPnl: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.DerivativePosition
 */
export interface DerivativePosition {
    /**
     * Ticker of the derivative market
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Derivative Market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * The subaccountId that the position belongs to
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Direction of the position
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Quantity of the position
     *
     * @generated from protobuf field: string quantity = 5
     */
    quantity: string;
    /**
     * Price of the position
     *
     * @generated from protobuf field: string entry_price = 6
     */
    entryPrice: string;
    /**
     * Margin of the position
     *
     * @generated from protobuf field: string margin = 7
     */
    margin: string;
    /**
     * LiquidationPrice of the position
     *
     * @generated from protobuf field: string liquidation_price = 8
     */
    liquidationPrice: string;
    /**
     * MarkPrice of the position
     *
     * @generated from protobuf field: string mark_price = 9
     */
    markPrice: string;
    /**
     * Aggregate Quantity of the Reduce Only orders associated with the position
     *
     * @generated from protobuf field: string aggregate_reduce_only_quantity = 11
     */
    aggregateReduceOnlyQuantity: string;
    /**
     * Position updated timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 12
     */
    updatedAt: bigint;
    /**
     * Position created timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 13
     */
    createdAt: bigint;
    /**
     * Last funding fees since position opened
     *
     * @generated from protobuf field: string funding_last = 14
     */
    fundingLast: string;
    /**
     * Net funding fees since position opened
     *
     * @generated from protobuf field: string funding_sum = 15
     */
    fundingSum: string;
    /**
     * Cumulative funding entry of the position
     *
     * @generated from protobuf field: string cumulative_funding_entry = 16
     */
    cumulativeFundingEntry: string;
    /**
     * Effective cumulative funding entry of the position
     *
     * @generated from protobuf field: string effective_cumulative_funding_entry = 17
     */
    effectiveCumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.AccountPortfolioBalancesRequest
 */
export interface AccountPortfolioBalancesRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Whether to return USD values for the balances
     *
     * @generated from protobuf field: bool usd = 2
     */
    usd: boolean;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.AccountPortfolioBalancesResponse
 */
export interface AccountPortfolioBalancesResponse {
    /**
     * The portfolio balances of this account
     *
     * @generated from protobuf field: injective_portfolio_rpc.PortfolioBalances portfolio = 1
     */
    portfolio?: PortfolioBalances;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.PortfolioBalances
 */
export interface PortfolioBalances {
    /**
     * The account's portfolio address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Account available bank balances
     *
     * @generated from protobuf field: repeated injective_portfolio_rpc.Coin bank_balances = 2
     */
    bankBalances: Coin[];
    /**
     * Subaccounts list
     *
     * @generated from protobuf field: repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts = 3
     */
    subaccounts: SubaccountBalanceV2[];
    /**
     * USD value of the portfolio
     *
     * @generated from protobuf field: string total_usd = 4
     */
    totalUsd: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.StreamAccountPortfolioRequest
 */
export interface StreamAccountPortfolioRequest {
    /**
     * The account's portfolio address
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Related subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * @generated from protobuf field: string type = 3
     */
    type: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.StreamAccountPortfolioResponse
 */
export interface StreamAccountPortfolioResponse {
    /**
     * type of portfolio entry
     *
     * @generated from protobuf field: string type = 1
     */
    type: string;
    /**
     * denom of portfolio entry
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * amount of portfolio entry
     *
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
    /**
     * subaccount id of portfolio entry
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * Operation timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 timestamp = 5
     */
    timestamp: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class TokenHoldersRequest$Type extends MessageType<TokenHoldersRequest> {
    constructor() {
        super("injective_portfolio_rpc.TokenHoldersRequest", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TokenHoldersRequest>): TokenHoldersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.cursor = "";
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<TokenHoldersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenHoldersRequest): TokenHoldersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string cursor */ 2:
                    message.cursor = reader.string();
                    break;
                case /* sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenHoldersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string cursor = 2; */
        if (message.cursor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cursor);
        /* sint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.TokenHoldersRequest
 */
export const TokenHoldersRequest = new TokenHoldersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenHoldersResponse$Type extends MessageType<TokenHoldersResponse> {
    constructor() {
        super("injective_portfolio_rpc.TokenHoldersResponse", [
            { no: 1, name: "holders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Holder },
            { no: 2, name: "next_cursors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenHoldersResponse>): TokenHoldersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.holders = [];
        message.nextCursors = [];
        if (value !== undefined)
            reflectionMergePartial<TokenHoldersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenHoldersResponse): TokenHoldersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_portfolio_rpc.Holder holders */ 1:
                    message.holders.push(Holder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string next_cursors */ 2:
                    message.nextCursors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenHoldersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_portfolio_rpc.Holder holders = 1; */
        for (let i = 0; i < message.holders.length; i++)
            Holder.internalBinaryWrite(message.holders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string next_cursors = 2; */
        for (let i = 0; i < message.nextCursors.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.nextCursors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.TokenHoldersResponse
 */
export const TokenHoldersResponse = new TokenHoldersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Holder$Type extends MessageType<Holder> {
    constructor() {
        super("injective_portfolio_rpc.Holder", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Holder>): Holder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.balance = "";
        if (value !== undefined)
            reflectionMergePartial<Holder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Holder): Holder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* string balance */ 2:
                    message.balance = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Holder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* string balance = 2; */
        if (message.balance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.balance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.Holder
 */
export const Holder = new Holder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountPortfolioRequest$Type extends MessageType<AccountPortfolioRequest> {
    constructor() {
        super("injective_portfolio_rpc.AccountPortfolioRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountPortfolioRequest>): AccountPortfolioRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<AccountPortfolioRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountPortfolioRequest): AccountPortfolioRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountPortfolioRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.AccountPortfolioRequest
 */
export const AccountPortfolioRequest = new AccountPortfolioRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountPortfolioResponse$Type extends MessageType<AccountPortfolioResponse> {
    constructor() {
        super("injective_portfolio_rpc.AccountPortfolioResponse", [
            { no: 1, name: "portfolio", kind: "message", T: () => Portfolio }
        ]);
    }
    create(value?: PartialMessage<AccountPortfolioResponse>): AccountPortfolioResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccountPortfolioResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountPortfolioResponse): AccountPortfolioResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_portfolio_rpc.Portfolio portfolio */ 1:
                    message.portfolio = Portfolio.internalBinaryRead(reader, reader.uint32(), options, message.portfolio);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountPortfolioResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_portfolio_rpc.Portfolio portfolio = 1; */
        if (message.portfolio)
            Portfolio.internalBinaryWrite(message.portfolio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.AccountPortfolioResponse
 */
export const AccountPortfolioResponse = new AccountPortfolioResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Portfolio$Type extends MessageType<Portfolio> {
    constructor() {
        super("injective_portfolio_rpc.Portfolio", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bank_balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 3, name: "subaccounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountBalanceV2 },
            { no: 4, name: "positions_with_upnl", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PositionsWithUPNL }
        ]);
    }
    create(value?: PartialMessage<Portfolio>): Portfolio {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.bankBalances = [];
        message.subaccounts = [];
        message.positionsWithUpnl = [];
        if (value !== undefined)
            reflectionMergePartial<Portfolio>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Portfolio): Portfolio {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* repeated injective_portfolio_rpc.Coin bank_balances */ 2:
                    message.bankBalances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts */ 3:
                    message.subaccounts.push(SubaccountBalanceV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_portfolio_rpc.PositionsWithUPNL positions_with_upnl */ 4:
                    message.positionsWithUpnl.push(PositionsWithUPNL.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Portfolio, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* repeated injective_portfolio_rpc.Coin bank_balances = 2; */
        for (let i = 0; i < message.bankBalances.length; i++)
            Coin.internalBinaryWrite(message.bankBalances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts = 3; */
        for (let i = 0; i < message.subaccounts.length; i++)
            SubaccountBalanceV2.internalBinaryWrite(message.subaccounts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_portfolio_rpc.PositionsWithUPNL positions_with_upnl = 4; */
        for (let i = 0; i < message.positionsWithUpnl.length; i++)
            PositionsWithUPNL.internalBinaryWrite(message.positionsWithUpnl[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.Portfolio
 */
export const Portfolio = new Portfolio$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Coin$Type extends MessageType<Coin> {
    constructor() {
        super("injective_portfolio_rpc.Coin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Coin>): Coin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        message.usdValue = "";
        if (value !== undefined)
            reflectionMergePartial<Coin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coin): Coin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* string usd_value */ 3:
                    message.usdValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* string usd_value = 3; */
        if (message.usdValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.Coin
 */
export const Coin = new Coin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalanceV2$Type extends MessageType<SubaccountBalanceV2> {
    constructor() {
        super("injective_portfolio_rpc.SubaccountBalanceV2", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deposit", kind: "message", T: () => SubaccountDeposit }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalanceV2>): SubaccountBalanceV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalanceV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalanceV2): SubaccountBalanceV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* injective_portfolio_rpc.SubaccountDeposit deposit */ 3:
                    message.deposit = SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalanceV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* injective_portfolio_rpc.SubaccountDeposit deposit = 3; */
        if (message.deposit)
            SubaccountDeposit.internalBinaryWrite(message.deposit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.SubaccountBalanceV2
 */
export const SubaccountBalanceV2 = new SubaccountBalanceV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountDeposit$Type extends MessageType<SubaccountDeposit> {
    constructor() {
        super("injective_portfolio_rpc.SubaccountDeposit", [
            { no: 1, name: "total_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "available_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total_balance_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "available_balance_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountDeposit>): SubaccountDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalBalance = "";
        message.availableBalance = "";
        message.totalBalanceUsd = "";
        message.availableBalanceUsd = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountDeposit): SubaccountDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string total_balance */ 1:
                    message.totalBalance = reader.string();
                    break;
                case /* string available_balance */ 2:
                    message.availableBalance = reader.string();
                    break;
                case /* string total_balance_usd */ 3:
                    message.totalBalanceUsd = reader.string();
                    break;
                case /* string available_balance_usd */ 4:
                    message.availableBalanceUsd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string total_balance = 1; */
        if (message.totalBalance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.totalBalance);
        /* string available_balance = 2; */
        if (message.availableBalance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.availableBalance);
        /* string total_balance_usd = 3; */
        if (message.totalBalanceUsd !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.totalBalanceUsd);
        /* string available_balance_usd = 4; */
        if (message.availableBalanceUsd !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.availableBalanceUsd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.SubaccountDeposit
 */
export const SubaccountDeposit = new SubaccountDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsWithUPNL$Type extends MessageType<PositionsWithUPNL> {
    constructor() {
        super("injective_portfolio_rpc.PositionsWithUPNL", [
            { no: 1, name: "position", kind: "message", T: () => DerivativePosition },
            { no: 2, name: "unrealized_pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsWithUPNL>): PositionsWithUPNL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unrealizedPnl = "";
        if (value !== undefined)
            reflectionMergePartial<PositionsWithUPNL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsWithUPNL): PositionsWithUPNL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_portfolio_rpc.DerivativePosition position */ 1:
                    message.position = DerivativePosition.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* string unrealized_pnl */ 2:
                    message.unrealizedPnl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsWithUPNL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_portfolio_rpc.DerivativePosition position = 1; */
        if (message.position)
            DerivativePosition.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string unrealized_pnl = 2; */
        if (message.unrealizedPnl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.unrealizedPnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.PositionsWithUPNL
 */
export const PositionsWithUPNL = new PositionsWithUPNL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativePosition$Type extends MessageType<DerivativePosition> {
    constructor() {
        super("injective_portfolio_rpc.DerivativePosition", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "liquidation_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "mark_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "aggregate_reduce_only_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "funding_last", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "funding_sum", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "effective_cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativePosition>): DerivativePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.marketId = "";
        message.subaccountId = "";
        message.direction = "";
        message.quantity = "";
        message.entryPrice = "";
        message.margin = "";
        message.liquidationPrice = "";
        message.markPrice = "";
        message.aggregateReduceOnlyQuantity = "";
        message.updatedAt = 0n;
        message.createdAt = 0n;
        message.fundingLast = "";
        message.fundingSum = "";
        message.cumulativeFundingEntry = "";
        message.effectiveCumulativeFundingEntry = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativePosition): DerivativePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* string quantity */ 5:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 6:
                    message.entryPrice = reader.string();
                    break;
                case /* string margin */ 7:
                    message.margin = reader.string();
                    break;
                case /* string liquidation_price */ 8:
                    message.liquidationPrice = reader.string();
                    break;
                case /* string mark_price */ 9:
                    message.markPrice = reader.string();
                    break;
                case /* string aggregate_reduce_only_quantity */ 11:
                    message.aggregateReduceOnlyQuantity = reader.string();
                    break;
                case /* sint64 updated_at */ 12:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 13:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* string funding_last */ 14:
                    message.fundingLast = reader.string();
                    break;
                case /* string funding_sum */ 15:
                    message.fundingSum = reader.string();
                    break;
                case /* string cumulative_funding_entry */ 16:
                    message.cumulativeFundingEntry = reader.string();
                    break;
                case /* string effective_cumulative_funding_entry */ 17:
                    message.effectiveCumulativeFundingEntry = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* string quantity = 5; */
        if (message.quantity !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 6; */
        if (message.entryPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.entryPrice);
        /* string margin = 7; */
        if (message.margin !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.margin);
        /* string liquidation_price = 8; */
        if (message.liquidationPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.liquidationPrice);
        /* string mark_price = 9; */
        if (message.markPrice !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.markPrice);
        /* string aggregate_reduce_only_quantity = 11; */
        if (message.aggregateReduceOnlyQuantity !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.aggregateReduceOnlyQuantity);
        /* sint64 updated_at = 12; */
        if (message.updatedAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.updatedAt);
        /* sint64 created_at = 13; */
        if (message.createdAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.createdAt);
        /* string funding_last = 14; */
        if (message.fundingLast !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.fundingLast);
        /* string funding_sum = 15; */
        if (message.fundingSum !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.fundingSum);
        /* string cumulative_funding_entry = 16; */
        if (message.cumulativeFundingEntry !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
        /* string effective_cumulative_funding_entry = 17; */
        if (message.effectiveCumulativeFundingEntry !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.effectiveCumulativeFundingEntry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.DerivativePosition
 */
export const DerivativePosition = new DerivativePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountPortfolioBalancesRequest$Type extends MessageType<AccountPortfolioBalancesRequest> {
    constructor() {
        super("injective_portfolio_rpc.AccountPortfolioBalancesRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "usd", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AccountPortfolioBalancesRequest>): AccountPortfolioBalancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.usd = false;
        if (value !== undefined)
            reflectionMergePartial<AccountPortfolioBalancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountPortfolioBalancesRequest): AccountPortfolioBalancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* bool usd */ 2:
                    message.usd = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountPortfolioBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* bool usd = 2; */
        if (message.usd !== false)
            writer.tag(2, WireType.Varint).bool(message.usd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.AccountPortfolioBalancesRequest
 */
export const AccountPortfolioBalancesRequest = new AccountPortfolioBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountPortfolioBalancesResponse$Type extends MessageType<AccountPortfolioBalancesResponse> {
    constructor() {
        super("injective_portfolio_rpc.AccountPortfolioBalancesResponse", [
            { no: 1, name: "portfolio", kind: "message", T: () => PortfolioBalances }
        ]);
    }
    create(value?: PartialMessage<AccountPortfolioBalancesResponse>): AccountPortfolioBalancesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccountPortfolioBalancesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountPortfolioBalancesResponse): AccountPortfolioBalancesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_portfolio_rpc.PortfolioBalances portfolio */ 1:
                    message.portfolio = PortfolioBalances.internalBinaryRead(reader, reader.uint32(), options, message.portfolio);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountPortfolioBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_portfolio_rpc.PortfolioBalances portfolio = 1; */
        if (message.portfolio)
            PortfolioBalances.internalBinaryWrite(message.portfolio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.AccountPortfolioBalancesResponse
 */
export const AccountPortfolioBalancesResponse = new AccountPortfolioBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioBalances$Type extends MessageType<PortfolioBalances> {
    constructor() {
        super("injective_portfolio_rpc.PortfolioBalances", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bank_balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 3, name: "subaccounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountBalanceV2 },
            { no: 4, name: "total_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PortfolioBalances>): PortfolioBalances {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.bankBalances = [];
        message.subaccounts = [];
        message.totalUsd = "";
        if (value !== undefined)
            reflectionMergePartial<PortfolioBalances>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioBalances): PortfolioBalances {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* repeated injective_portfolio_rpc.Coin bank_balances */ 2:
                    message.bankBalances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts */ 3:
                    message.subaccounts.push(SubaccountBalanceV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string total_usd */ 4:
                    message.totalUsd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioBalances, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* repeated injective_portfolio_rpc.Coin bank_balances = 2; */
        for (let i = 0; i < message.bankBalances.length; i++)
            Coin.internalBinaryWrite(message.bankBalances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts = 3; */
        for (let i = 0; i < message.subaccounts.length; i++)
            SubaccountBalanceV2.internalBinaryWrite(message.subaccounts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string total_usd = 4; */
        if (message.totalUsd !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.totalUsd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.PortfolioBalances
 */
export const PortfolioBalances = new PortfolioBalances$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamAccountPortfolioRequest$Type extends MessageType<StreamAccountPortfolioRequest> {
    constructor() {
        super("injective_portfolio_rpc.StreamAccountPortfolioRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamAccountPortfolioRequest>): StreamAccountPortfolioRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.subaccountId = "";
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<StreamAccountPortfolioRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamAccountPortfolioRequest): StreamAccountPortfolioRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamAccountPortfolioRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.StreamAccountPortfolioRequest
 */
export const StreamAccountPortfolioRequest = new StreamAccountPortfolioRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamAccountPortfolioResponse$Type extends MessageType<StreamAccountPortfolioResponse> {
    constructor() {
        super("injective_portfolio_rpc.StreamAccountPortfolioResponse", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamAccountPortfolioResponse>): StreamAccountPortfolioResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.denom = "";
        message.amount = "";
        message.subaccountId = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamAccountPortfolioResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamAccountPortfolioResponse): StreamAccountPortfolioResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* sint64 timestamp */ 5:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamAccountPortfolioResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* sint64 timestamp = 5; */
        if (message.timestamp !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.StreamAccountPortfolioResponse
 */
export const StreamAccountPortfolioResponse = new StreamAccountPortfolioResponse$Type();
/**
 * @generated ServiceType for protobuf service injective_portfolio_rpc.InjectivePortfolioRPC
 */
export const InjectivePortfolioRPC = new ServiceType("injective_portfolio_rpc.InjectivePortfolioRPC", [
    { name: "TokenHolders", options: {}, I: TokenHoldersRequest, O: TokenHoldersResponse },
    { name: "AccountPortfolio", options: {}, I: AccountPortfolioRequest, O: AccountPortfolioResponse },
    { name: "AccountPortfolioBalances", options: {}, I: AccountPortfolioBalancesRequest, O: AccountPortfolioBalancesResponse },
    { name: "StreamAccountPortfolio", serverStreaming: true, options: {}, I: StreamAccountPortfolioRequest, O: StreamAccountPortfolioResponse }
]);
