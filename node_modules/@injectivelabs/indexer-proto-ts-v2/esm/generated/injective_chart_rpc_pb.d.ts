// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_chart_rpc.proto" (package "injective_chart_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveChartRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_chart_rpc.SpotMarketHistoryRequest
 */
export interface SpotMarketHistoryRequest {
    /**
     * Specify unique ticker to search
     *
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * As an alternative is possible to provide a marketId
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Symbol resolution. Possible resolutions are daily (D or 1D, 2D ... ), weekly
     * (1W, 2W ...), monthly (1M, 2M...) and an intra-day resolution – minutes(1, 2
     * ...).
     *
     * @generated from protobuf field: string resolution = 3
     */
    resolution: string;
    /**
     * Unix timestamp (UTC) of the leftmost required bar, including from
     *
     * @generated from protobuf field: sint32 from = 4
     */
    from: number;
    /**
     * Unix timestamp (UTC) of the rightmost required bar, including to. It can be
     * in the future. In this case, the rightmost required bar is the latest
     * available bar.
     *
     * @generated from protobuf field: sint32 to = 5
     */
    to: number;
    /**
     * Number of bars (higher priority than from) starting with to. If countback is
     * set, from should be ignored.
     *
     * @generated from protobuf field: sint32 countback = 6
     */
    countback: number;
}
/**
 * @generated from protobuf message injective_chart_rpc.SpotMarketHistoryResponse
 */
export interface SpotMarketHistoryResponse {
    /**
     * Bar time, Unix timestamp (UTC). Daily bars should only have the date part,
     * time should be 0.
     *
     * @generated from protobuf field: repeated sint32 t = 1
     */
    t: number[];
    /**
     * Open price.
     *
     * @generated from protobuf field: repeated double o = 2
     */
    o: number[];
    /**
     * High price.
     *
     * @generated from protobuf field: repeated double h = 3
     */
    h: number[];
    /**
     * Low price.
     *
     * @generated from protobuf field: repeated double l = 4
     */
    l: number[];
    /**
     * Close price.
     *
     * @generated from protobuf field: repeated double c = 5
     */
    c: number[];
    /**
     * Volume.
     *
     * @generated from protobuf field: repeated double v = 6
     */
    v: number[];
    /**
     * Status of the request.
     *
     * @generated from protobuf field: string s = 7
     */
    s: string;
}
/**
 * @generated from protobuf message injective_chart_rpc.DerivativeMarketHistoryRequest
 */
export interface DerivativeMarketHistoryRequest {
    /**
     * Specify unique ticker to search.
     *
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * As an alternative is possible to provide a marketId
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Symbol resolution. Possible resolutions are daily (D or 1D, 2D ... ), weekly
     * (1W, 2W ...), monthly (1M, 2M...) and an intra-day resolution – minutes(1, 2
     * ...).
     *
     * @generated from protobuf field: string resolution = 3
     */
    resolution: string;
    /**
     * Unix timestamp (UTC) of the leftmost required bar, including from
     *
     * @generated from protobuf field: sint32 from = 4
     */
    from: number;
    /**
     * Unix timestamp (UTC) of the rightmost required bar, including to. It can be
     * in the future. In this case, the rightmost required bar is the latest
     * available bar.
     *
     * @generated from protobuf field: sint32 to = 5
     */
    to: number;
    /**
     * Number of bars (higher priority than from) starting with to. If countback is
     * set, from should be ignored.
     *
     * @generated from protobuf field: sint32 countback = 6
     */
    countback: number;
}
/**
 * @generated from protobuf message injective_chart_rpc.DerivativeMarketHistoryResponse
 */
export interface DerivativeMarketHistoryResponse {
    /**
     * Bar time, Unix timestamp (UTC). Daily bars should only have the date part,
     * time should be 0.
     *
     * @generated from protobuf field: repeated sint32 t = 1
     */
    t: number[];
    /**
     * Open price.
     *
     * @generated from protobuf field: repeated double o = 2
     */
    o: number[];
    /**
     * High price.
     *
     * @generated from protobuf field: repeated double h = 3
     */
    h: number[];
    /**
     * Low price.
     *
     * @generated from protobuf field: repeated double l = 4
     */
    l: number[];
    /**
     * Close price.
     *
     * @generated from protobuf field: repeated double c = 5
     */
    c: number[];
    /**
     * Volume.
     *
     * @generated from protobuf field: repeated double v = 6
     */
    v: number[];
    /**
     * Status of the request.
     *
     * @generated from protobuf field: string s = 7
     */
    s: string;
}
/**
 * @generated from protobuf message injective_chart_rpc.SpotMarketSummaryRequest
 */
export interface SpotMarketSummaryRequest {
    /**
     * Market ID of the spot market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Specify the resolution
     *
     * @generated from protobuf field: string resolution = 2
     */
    resolution: string;
}
/**
 * @generated from protobuf message injective_chart_rpc.SpotMarketSummaryResponse
 */
export interface SpotMarketSummaryResponse {
    /**
     * Market ID of the derivativeMarket market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Open price.
     *
     * @generated from protobuf field: double open = 2
     */
    open: number;
    /**
     * High price.
     *
     * @generated from protobuf field: double high = 3
     */
    high: number;
    /**
     * Low price.
     *
     * @generated from protobuf field: double low = 4
     */
    low: number;
    /**
     * Volume.
     *
     * @generated from protobuf field: double volume = 5
     */
    volume: number;
    /**
     * Current price based on latest fill event.
     *
     * @generated from protobuf field: double price = 6
     */
    price: number;
    /**
     * Change percent from opening price.
     *
     * @generated from protobuf field: double change = 7
     */
    change: number;
}
/**
 * @generated from protobuf message injective_chart_rpc.AllSpotMarketSummaryRequest
 */
export interface AllSpotMarketSummaryRequest {
    /**
     * Specify the resolution
     *
     * @generated from protobuf field: string resolution = 1
     */
    resolution: string;
}
/**
 * @generated from protobuf message injective_chart_rpc.AllSpotMarketSummaryResponse
 */
export interface AllSpotMarketSummaryResponse {
    /**
     * @generated from protobuf field: repeated injective_chart_rpc.MarketSummaryResp field = 1
     */
    field: MarketSummaryResp[];
}
/**
 * @generated from protobuf message injective_chart_rpc.MarketSummaryResp
 */
export interface MarketSummaryResp {
    /**
     * Market ID of the derivativeMarket market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Open price.
     *
     * @generated from protobuf field: double open = 2
     */
    open: number;
    /**
     * High price.
     *
     * @generated from protobuf field: double high = 3
     */
    high: number;
    /**
     * Low price.
     *
     * @generated from protobuf field: double low = 4
     */
    low: number;
    /**
     * Volume.
     *
     * @generated from protobuf field: double volume = 5
     */
    volume: number;
    /**
     * Current price based on latest fill event.
     *
     * @generated from protobuf field: double price = 6
     */
    price: number;
    /**
     * Change percent from opening price.
     *
     * @generated from protobuf field: double change = 7
     */
    change: number;
}
/**
 * @generated from protobuf message injective_chart_rpc.DerivativeMarketSummaryRequest
 */
export interface DerivativeMarketSummaryRequest {
    /**
     * Market ID of the derivative market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Request the summary of index price feed
     *
     * @generated from protobuf field: bool index_price = 2
     */
    indexPrice: boolean;
    /**
     * Specify the resolution
     *
     * @generated from protobuf field: string resolution = 3
     */
    resolution: string;
}
/**
 * @generated from protobuf message injective_chart_rpc.DerivativeMarketSummaryResponse
 */
export interface DerivativeMarketSummaryResponse {
    /**
     * Market ID of the derivativeMarket market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Open price.
     *
     * @generated from protobuf field: double open = 2
     */
    open: number;
    /**
     * High price.
     *
     * @generated from protobuf field: double high = 3
     */
    high: number;
    /**
     * Low price.
     *
     * @generated from protobuf field: double low = 4
     */
    low: number;
    /**
     * Volume.
     *
     * @generated from protobuf field: double volume = 5
     */
    volume: number;
    /**
     * Current price based on latest fill event.
     *
     * @generated from protobuf field: double price = 6
     */
    price: number;
    /**
     * Change percent from opening price.
     *
     * @generated from protobuf field: double change = 7
     */
    change: number;
}
/**
 * @generated from protobuf message injective_chart_rpc.AllDerivativeMarketSummaryRequest
 */
export interface AllDerivativeMarketSummaryRequest {
    /**
     * Specify the resolution
     *
     * @generated from protobuf field: string resolution = 1
     */
    resolution: string;
}
/**
 * @generated from protobuf message injective_chart_rpc.AllDerivativeMarketSummaryResponse
 */
export interface AllDerivativeMarketSummaryResponse {
    /**
     * @generated from protobuf field: repeated injective_chart_rpc.MarketSummaryResp field = 1
     */
    field: MarketSummaryResp[];
}
/**
 * @generated from protobuf message injective_chart_rpc.MarketSnapshotRequest
 */
export interface MarketSnapshotRequest {
    /**
     * Specify multiple marketIDs to search.
     *
     * @generated from protobuf field: repeated string market_i_ds = 1
     */
    marketIDs: string[];
    /**
     * Symbols resolution(minutes). Default is 1
     *
     * @generated from protobuf field: string resolution = 2
     */
    resolution: string;
    /**
     * Number of bars returned, starting from the recent ones.
     *
     * @generated from protobuf field: sint32 countback = 3
     */
    countback: number;
}
/**
 * @generated from protobuf message injective_chart_rpc.MarketSnapshotResponse
 */
export interface MarketSnapshotResponse {
    /**
     * @generated from protobuf field: repeated injective_chart_rpc.MarketSnapshotHistoryResponse field = 1
     */
    field: MarketSnapshotHistoryResponse[];
}
/**
 * @generated from protobuf message injective_chart_rpc.MarketSnapshotHistoryResponse
 */
export interface MarketSnapshotHistoryResponse {
    /**
     * Market identifier.
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Symbol resolution
     *
     * @generated from protobuf field: string resolution = 2
     */
    resolution: string;
    /**
     * Bar time, Unix timestamp (UTC). Daily bars should only have the date part,
     * time should be 0.
     *
     * @generated from protobuf field: repeated sint32 t = 3
     */
    t: number[];
    /**
     * Open price.
     *
     * @generated from protobuf field: repeated double o = 4
     */
    o: number[];
    /**
     * High price.
     *
     * @generated from protobuf field: repeated double h = 5
     */
    h: number[];
    /**
     * Low price.
     *
     * @generated from protobuf field: repeated double l = 6
     */
    l: number[];
    /**
     * Close price.
     *
     * @generated from protobuf field: repeated double c = 7
     */
    c: number[];
    /**
     * Volume.
     *
     * @generated from protobuf field: repeated double v = 8
     */
    v: number[];
}
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketHistoryRequest$Type extends MessageType<SpotMarketHistoryRequest> {
    constructor() {
        super("injective_chart_rpc.SpotMarketHistoryRequest", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "from", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "to", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "countback", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpotMarketHistoryRequest>): SpotMarketHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        message.marketId = "";
        message.resolution = "";
        message.from = 0;
        message.to = 0;
        message.countback = 0;
        if (value !== undefined)
            reflectionMergePartial<SpotMarketHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketHistoryRequest): SpotMarketHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string resolution */ 3:
                    message.resolution = reader.string();
                    break;
                case /* sint32 from */ 4:
                    message.from = reader.sint32();
                    break;
                case /* sint32 to */ 5:
                    message.to = reader.sint32();
                    break;
                case /* sint32 countback */ 6:
                    message.countback = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string resolution = 3; */
        if (message.resolution !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resolution);
        /* sint32 from = 4; */
        if (message.from !== 0)
            writer.tag(4, WireType.Varint).sint32(message.from);
        /* sint32 to = 5; */
        if (message.to !== 0)
            writer.tag(5, WireType.Varint).sint32(message.to);
        /* sint32 countback = 6; */
        if (message.countback !== 0)
            writer.tag(6, WireType.Varint).sint32(message.countback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.SpotMarketHistoryRequest
 */
export const SpotMarketHistoryRequest = new SpotMarketHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketHistoryResponse$Type extends MessageType<SpotMarketHistoryResponse> {
    constructor() {
        super("injective_chart_rpc.SpotMarketHistoryResponse", [
            { no: 1, name: "t", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "o", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "h", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "l", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "c", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "v", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotMarketHistoryResponse>): SpotMarketHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = [];
        message.o = [];
        message.h = [];
        message.l = [];
        message.c = [];
        message.v = [];
        message.s = "";
        if (value !== undefined)
            reflectionMergePartial<SpotMarketHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketHistoryResponse): SpotMarketHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sint32 t */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.t.push(reader.sint32());
                    else
                        message.t.push(reader.sint32());
                    break;
                case /* repeated double o */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.o.push(reader.double());
                    else
                        message.o.push(reader.double());
                    break;
                case /* repeated double h */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.h.push(reader.double());
                    else
                        message.h.push(reader.double());
                    break;
                case /* repeated double l */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.l.push(reader.double());
                    else
                        message.l.push(reader.double());
                    break;
                case /* repeated double c */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.c.push(reader.double());
                    else
                        message.c.push(reader.double());
                    break;
                case /* repeated double v */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.v.push(reader.double());
                    else
                        message.v.push(reader.double());
                    break;
                case /* string s */ 7:
                    message.s = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sint32 t = 1; */
        if (message.t.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.t.length; i++)
                writer.sint32(message.t[i]);
            writer.join();
        }
        /* repeated double o = 2; */
        if (message.o.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.o.length; i++)
                writer.double(message.o[i]);
            writer.join();
        }
        /* repeated double h = 3; */
        if (message.h.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.h.length; i++)
                writer.double(message.h[i]);
            writer.join();
        }
        /* repeated double l = 4; */
        if (message.l.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.l.length; i++)
                writer.double(message.l[i]);
            writer.join();
        }
        /* repeated double c = 5; */
        if (message.c.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.c.length; i++)
                writer.double(message.c[i]);
            writer.join();
        }
        /* repeated double v = 6; */
        if (message.v.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.v.length; i++)
                writer.double(message.v[i]);
            writer.join();
        }
        /* string s = 7; */
        if (message.s !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.s);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.SpotMarketHistoryResponse
 */
export const SpotMarketHistoryResponse = new SpotMarketHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketHistoryRequest$Type extends MessageType<DerivativeMarketHistoryRequest> {
    constructor() {
        super("injective_chart_rpc.DerivativeMarketHistoryRequest", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "from", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "to", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "countback", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketHistoryRequest>): DerivativeMarketHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        message.marketId = "";
        message.resolution = "";
        message.from = 0;
        message.to = 0;
        message.countback = 0;
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketHistoryRequest): DerivativeMarketHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string resolution */ 3:
                    message.resolution = reader.string();
                    break;
                case /* sint32 from */ 4:
                    message.from = reader.sint32();
                    break;
                case /* sint32 to */ 5:
                    message.to = reader.sint32();
                    break;
                case /* sint32 countback */ 6:
                    message.countback = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string resolution = 3; */
        if (message.resolution !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resolution);
        /* sint32 from = 4; */
        if (message.from !== 0)
            writer.tag(4, WireType.Varint).sint32(message.from);
        /* sint32 to = 5; */
        if (message.to !== 0)
            writer.tag(5, WireType.Varint).sint32(message.to);
        /* sint32 countback = 6; */
        if (message.countback !== 0)
            writer.tag(6, WireType.Varint).sint32(message.countback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.DerivativeMarketHistoryRequest
 */
export const DerivativeMarketHistoryRequest = new DerivativeMarketHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketHistoryResponse$Type extends MessageType<DerivativeMarketHistoryResponse> {
    constructor() {
        super("injective_chart_rpc.DerivativeMarketHistoryResponse", [
            { no: 1, name: "t", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "o", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "h", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "l", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "c", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "v", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketHistoryResponse>): DerivativeMarketHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = [];
        message.o = [];
        message.h = [];
        message.l = [];
        message.c = [];
        message.v = [];
        message.s = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketHistoryResponse): DerivativeMarketHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sint32 t */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.t.push(reader.sint32());
                    else
                        message.t.push(reader.sint32());
                    break;
                case /* repeated double o */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.o.push(reader.double());
                    else
                        message.o.push(reader.double());
                    break;
                case /* repeated double h */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.h.push(reader.double());
                    else
                        message.h.push(reader.double());
                    break;
                case /* repeated double l */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.l.push(reader.double());
                    else
                        message.l.push(reader.double());
                    break;
                case /* repeated double c */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.c.push(reader.double());
                    else
                        message.c.push(reader.double());
                    break;
                case /* repeated double v */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.v.push(reader.double());
                    else
                        message.v.push(reader.double());
                    break;
                case /* string s */ 7:
                    message.s = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sint32 t = 1; */
        if (message.t.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.t.length; i++)
                writer.sint32(message.t[i]);
            writer.join();
        }
        /* repeated double o = 2; */
        if (message.o.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.o.length; i++)
                writer.double(message.o[i]);
            writer.join();
        }
        /* repeated double h = 3; */
        if (message.h.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.h.length; i++)
                writer.double(message.h[i]);
            writer.join();
        }
        /* repeated double l = 4; */
        if (message.l.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.l.length; i++)
                writer.double(message.l[i]);
            writer.join();
        }
        /* repeated double c = 5; */
        if (message.c.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.c.length; i++)
                writer.double(message.c[i]);
            writer.join();
        }
        /* repeated double v = 6; */
        if (message.v.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.v.length; i++)
                writer.double(message.v[i]);
            writer.join();
        }
        /* string s = 7; */
        if (message.s !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.s);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.DerivativeMarketHistoryResponse
 */
export const DerivativeMarketHistoryResponse = new DerivativeMarketHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketSummaryRequest$Type extends MessageType<SpotMarketSummaryRequest> {
    constructor() {
        super("injective_chart_rpc.SpotMarketSummaryRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotMarketSummaryRequest>): SpotMarketSummaryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.resolution = "";
        if (value !== undefined)
            reflectionMergePartial<SpotMarketSummaryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketSummaryRequest): SpotMarketSummaryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string resolution */ 2:
                    message.resolution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketSummaryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string resolution = 2; */
        if (message.resolution !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resolution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.SpotMarketSummaryRequest
 */
export const SpotMarketSummaryRequest = new SpotMarketSummaryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketSummaryResponse$Type extends MessageType<SpotMarketSummaryResponse> {
    constructor() {
        super("injective_chart_rpc.SpotMarketSummaryResponse", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "open", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "high", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "low", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "change", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SpotMarketSummaryResponse>): SpotMarketSummaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.open = 0;
        message.high = 0;
        message.low = 0;
        message.volume = 0;
        message.price = 0;
        message.change = 0;
        if (value !== undefined)
            reflectionMergePartial<SpotMarketSummaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketSummaryResponse): SpotMarketSummaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* double open */ 2:
                    message.open = reader.double();
                    break;
                case /* double high */ 3:
                    message.high = reader.double();
                    break;
                case /* double low */ 4:
                    message.low = reader.double();
                    break;
                case /* double volume */ 5:
                    message.volume = reader.double();
                    break;
                case /* double price */ 6:
                    message.price = reader.double();
                    break;
                case /* double change */ 7:
                    message.change = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketSummaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* double open = 2; */
        if (message.open !== 0)
            writer.tag(2, WireType.Bit64).double(message.open);
        /* double high = 3; */
        if (message.high !== 0)
            writer.tag(3, WireType.Bit64).double(message.high);
        /* double low = 4; */
        if (message.low !== 0)
            writer.tag(4, WireType.Bit64).double(message.low);
        /* double volume = 5; */
        if (message.volume !== 0)
            writer.tag(5, WireType.Bit64).double(message.volume);
        /* double price = 6; */
        if (message.price !== 0)
            writer.tag(6, WireType.Bit64).double(message.price);
        /* double change = 7; */
        if (message.change !== 0)
            writer.tag(7, WireType.Bit64).double(message.change);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.SpotMarketSummaryResponse
 */
export const SpotMarketSummaryResponse = new SpotMarketSummaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllSpotMarketSummaryRequest$Type extends MessageType<AllSpotMarketSummaryRequest> {
    constructor() {
        super("injective_chart_rpc.AllSpotMarketSummaryRequest", [
            { no: 1, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AllSpotMarketSummaryRequest>): AllSpotMarketSummaryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resolution = "";
        if (value !== undefined)
            reflectionMergePartial<AllSpotMarketSummaryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllSpotMarketSummaryRequest): AllSpotMarketSummaryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resolution */ 1:
                    message.resolution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllSpotMarketSummaryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resolution = 1; */
        if (message.resolution !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resolution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.AllSpotMarketSummaryRequest
 */
export const AllSpotMarketSummaryRequest = new AllSpotMarketSummaryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllSpotMarketSummaryResponse$Type extends MessageType<AllSpotMarketSummaryResponse> {
    constructor() {
        super("injective_chart_rpc.AllSpotMarketSummaryResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketSummaryResp }
        ]);
    }
    create(value?: PartialMessage<AllSpotMarketSummaryResponse>): AllSpotMarketSummaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<AllSpotMarketSummaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllSpotMarketSummaryResponse): AllSpotMarketSummaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_chart_rpc.MarketSummaryResp field */ 1:
                    message.field.push(MarketSummaryResp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllSpotMarketSummaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_chart_rpc.MarketSummaryResp field = 1; */
        for (let i = 0; i < message.field.length; i++)
            MarketSummaryResp.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.AllSpotMarketSummaryResponse
 */
export const AllSpotMarketSummaryResponse = new AllSpotMarketSummaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketSummaryResp$Type extends MessageType<MarketSummaryResp> {
    constructor() {
        super("injective_chart_rpc.MarketSummaryResp", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "open", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "high", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "low", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "change", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<MarketSummaryResp>): MarketSummaryResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.open = 0;
        message.high = 0;
        message.low = 0;
        message.volume = 0;
        message.price = 0;
        message.change = 0;
        if (value !== undefined)
            reflectionMergePartial<MarketSummaryResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketSummaryResp): MarketSummaryResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* double open */ 2:
                    message.open = reader.double();
                    break;
                case /* double high */ 3:
                    message.high = reader.double();
                    break;
                case /* double low */ 4:
                    message.low = reader.double();
                    break;
                case /* double volume */ 5:
                    message.volume = reader.double();
                    break;
                case /* double price */ 6:
                    message.price = reader.double();
                    break;
                case /* double change */ 7:
                    message.change = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketSummaryResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* double open = 2; */
        if (message.open !== 0)
            writer.tag(2, WireType.Bit64).double(message.open);
        /* double high = 3; */
        if (message.high !== 0)
            writer.tag(3, WireType.Bit64).double(message.high);
        /* double low = 4; */
        if (message.low !== 0)
            writer.tag(4, WireType.Bit64).double(message.low);
        /* double volume = 5; */
        if (message.volume !== 0)
            writer.tag(5, WireType.Bit64).double(message.volume);
        /* double price = 6; */
        if (message.price !== 0)
            writer.tag(6, WireType.Bit64).double(message.price);
        /* double change = 7; */
        if (message.change !== 0)
            writer.tag(7, WireType.Bit64).double(message.change);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.MarketSummaryResp
 */
export const MarketSummaryResp = new MarketSummaryResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketSummaryRequest$Type extends MessageType<DerivativeMarketSummaryRequest> {
    constructor() {
        super("injective_chart_rpc.DerivativeMarketSummaryRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "index_price", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketSummaryRequest>): DerivativeMarketSummaryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.indexPrice = false;
        message.resolution = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketSummaryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketSummaryRequest): DerivativeMarketSummaryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool index_price */ 2:
                    message.indexPrice = reader.bool();
                    break;
                case /* string resolution */ 3:
                    message.resolution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketSummaryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool index_price = 2; */
        if (message.indexPrice !== false)
            writer.tag(2, WireType.Varint).bool(message.indexPrice);
        /* string resolution = 3; */
        if (message.resolution !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resolution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.DerivativeMarketSummaryRequest
 */
export const DerivativeMarketSummaryRequest = new DerivativeMarketSummaryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketSummaryResponse$Type extends MessageType<DerivativeMarketSummaryResponse> {
    constructor() {
        super("injective_chart_rpc.DerivativeMarketSummaryResponse", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "open", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "high", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "low", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "change", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketSummaryResponse>): DerivativeMarketSummaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.open = 0;
        message.high = 0;
        message.low = 0;
        message.volume = 0;
        message.price = 0;
        message.change = 0;
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketSummaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketSummaryResponse): DerivativeMarketSummaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* double open */ 2:
                    message.open = reader.double();
                    break;
                case /* double high */ 3:
                    message.high = reader.double();
                    break;
                case /* double low */ 4:
                    message.low = reader.double();
                    break;
                case /* double volume */ 5:
                    message.volume = reader.double();
                    break;
                case /* double price */ 6:
                    message.price = reader.double();
                    break;
                case /* double change */ 7:
                    message.change = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketSummaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* double open = 2; */
        if (message.open !== 0)
            writer.tag(2, WireType.Bit64).double(message.open);
        /* double high = 3; */
        if (message.high !== 0)
            writer.tag(3, WireType.Bit64).double(message.high);
        /* double low = 4; */
        if (message.low !== 0)
            writer.tag(4, WireType.Bit64).double(message.low);
        /* double volume = 5; */
        if (message.volume !== 0)
            writer.tag(5, WireType.Bit64).double(message.volume);
        /* double price = 6; */
        if (message.price !== 0)
            writer.tag(6, WireType.Bit64).double(message.price);
        /* double change = 7; */
        if (message.change !== 0)
            writer.tag(7, WireType.Bit64).double(message.change);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.DerivativeMarketSummaryResponse
 */
export const DerivativeMarketSummaryResponse = new DerivativeMarketSummaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllDerivativeMarketSummaryRequest$Type extends MessageType<AllDerivativeMarketSummaryRequest> {
    constructor() {
        super("injective_chart_rpc.AllDerivativeMarketSummaryRequest", [
            { no: 1, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AllDerivativeMarketSummaryRequest>): AllDerivativeMarketSummaryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resolution = "";
        if (value !== undefined)
            reflectionMergePartial<AllDerivativeMarketSummaryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllDerivativeMarketSummaryRequest): AllDerivativeMarketSummaryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resolution */ 1:
                    message.resolution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllDerivativeMarketSummaryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resolution = 1; */
        if (message.resolution !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resolution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.AllDerivativeMarketSummaryRequest
 */
export const AllDerivativeMarketSummaryRequest = new AllDerivativeMarketSummaryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllDerivativeMarketSummaryResponse$Type extends MessageType<AllDerivativeMarketSummaryResponse> {
    constructor() {
        super("injective_chart_rpc.AllDerivativeMarketSummaryResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketSummaryResp }
        ]);
    }
    create(value?: PartialMessage<AllDerivativeMarketSummaryResponse>): AllDerivativeMarketSummaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<AllDerivativeMarketSummaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllDerivativeMarketSummaryResponse): AllDerivativeMarketSummaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_chart_rpc.MarketSummaryResp field */ 1:
                    message.field.push(MarketSummaryResp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllDerivativeMarketSummaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_chart_rpc.MarketSummaryResp field = 1; */
        for (let i = 0; i < message.field.length; i++)
            MarketSummaryResp.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.AllDerivativeMarketSummaryResponse
 */
export const AllDerivativeMarketSummaryResponse = new AllDerivativeMarketSummaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketSnapshotRequest$Type extends MessageType<MarketSnapshotRequest> {
    constructor() {
        super("injective_chart_rpc.MarketSnapshotRequest", [
            { no: 1, name: "market_i_ds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "countback", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MarketSnapshotRequest>): MarketSnapshotRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIDs = [];
        message.resolution = "";
        message.countback = 0;
        if (value !== undefined)
            reflectionMergePartial<MarketSnapshotRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketSnapshotRequest): MarketSnapshotRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_i_ds */ 1:
                    message.marketIDs.push(reader.string());
                    break;
                case /* string resolution */ 2:
                    message.resolution = reader.string();
                    break;
                case /* sint32 countback */ 3:
                    message.countback = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketSnapshotRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_i_ds = 1; */
        for (let i = 0; i < message.marketIDs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIDs[i]);
        /* string resolution = 2; */
        if (message.resolution !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resolution);
        /* sint32 countback = 3; */
        if (message.countback !== 0)
            writer.tag(3, WireType.Varint).sint32(message.countback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.MarketSnapshotRequest
 */
export const MarketSnapshotRequest = new MarketSnapshotRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketSnapshotResponse$Type extends MessageType<MarketSnapshotResponse> {
    constructor() {
        super("injective_chart_rpc.MarketSnapshotResponse", [
            { no: 1, name: "field", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketSnapshotHistoryResponse }
        ]);
    }
    create(value?: PartialMessage<MarketSnapshotResponse>): MarketSnapshotResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<MarketSnapshotResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketSnapshotResponse): MarketSnapshotResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_chart_rpc.MarketSnapshotHistoryResponse field */ 1:
                    message.field.push(MarketSnapshotHistoryResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketSnapshotResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_chart_rpc.MarketSnapshotHistoryResponse field = 1; */
        for (let i = 0; i < message.field.length; i++)
            MarketSnapshotHistoryResponse.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.MarketSnapshotResponse
 */
export const MarketSnapshotResponse = new MarketSnapshotResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketSnapshotHistoryResponse$Type extends MessageType<MarketSnapshotHistoryResponse> {
    constructor() {
        super("injective_chart_rpc.MarketSnapshotHistoryResponse", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resolution", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "t", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "o", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "h", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "l", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "c", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "v", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<MarketSnapshotHistoryResponse>): MarketSnapshotHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.resolution = "";
        message.t = [];
        message.o = [];
        message.h = [];
        message.l = [];
        message.c = [];
        message.v = [];
        if (value !== undefined)
            reflectionMergePartial<MarketSnapshotHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketSnapshotHistoryResponse): MarketSnapshotHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string resolution */ 2:
                    message.resolution = reader.string();
                    break;
                case /* repeated sint32 t */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.t.push(reader.sint32());
                    else
                        message.t.push(reader.sint32());
                    break;
                case /* repeated double o */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.o.push(reader.double());
                    else
                        message.o.push(reader.double());
                    break;
                case /* repeated double h */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.h.push(reader.double());
                    else
                        message.h.push(reader.double());
                    break;
                case /* repeated double l */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.l.push(reader.double());
                    else
                        message.l.push(reader.double());
                    break;
                case /* repeated double c */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.c.push(reader.double());
                    else
                        message.c.push(reader.double());
                    break;
                case /* repeated double v */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.v.push(reader.double());
                    else
                        message.v.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketSnapshotHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string resolution = 2; */
        if (message.resolution !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resolution);
        /* repeated sint32 t = 3; */
        if (message.t.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.t.length; i++)
                writer.sint32(message.t[i]);
            writer.join();
        }
        /* repeated double o = 4; */
        if (message.o.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.o.length; i++)
                writer.double(message.o[i]);
            writer.join();
        }
        /* repeated double h = 5; */
        if (message.h.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.h.length; i++)
                writer.double(message.h[i]);
            writer.join();
        }
        /* repeated double l = 6; */
        if (message.l.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.l.length; i++)
                writer.double(message.l[i]);
            writer.join();
        }
        /* repeated double c = 7; */
        if (message.c.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.c.length; i++)
                writer.double(message.c[i]);
            writer.join();
        }
        /* repeated double v = 8; */
        if (message.v.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.v.length; i++)
                writer.double(message.v[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_chart_rpc.MarketSnapshotHistoryResponse
 */
export const MarketSnapshotHistoryResponse = new MarketSnapshotHistoryResponse$Type();
/**
 * @generated ServiceType for protobuf service injective_chart_rpc.InjectiveChartRPC
 */
export const InjectiveChartRPC = new ServiceType("injective_chart_rpc.InjectiveChartRPC", [
    { name: "SpotMarketHistory", options: {}, I: SpotMarketHistoryRequest, O: SpotMarketHistoryResponse },
    { name: "DerivativeMarketHistory", options: {}, I: DerivativeMarketHistoryRequest, O: DerivativeMarketHistoryResponse },
    { name: "SpotMarketSummary", options: {}, I: SpotMarketSummaryRequest, O: SpotMarketSummaryResponse },
    { name: "AllSpotMarketSummary", options: {}, I: AllSpotMarketSummaryRequest, O: AllSpotMarketSummaryResponse },
    { name: "DerivativeMarketSummary", options: {}, I: DerivativeMarketSummaryRequest, O: DerivativeMarketSummaryResponse },
    { name: "AllDerivativeMarketSummary", options: {}, I: AllDerivativeMarketSummaryRequest, O: AllDerivativeMarketSummaryResponse },
    { name: "MarketSnapshot", options: {}, I: MarketSnapshotRequest, O: MarketSnapshotResponse }
]);
