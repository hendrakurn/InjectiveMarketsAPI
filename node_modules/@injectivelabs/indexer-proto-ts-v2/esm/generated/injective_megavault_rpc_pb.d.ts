// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_megavault_rpc.proto" (package "injective_megavault_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveMegavaultRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_megavault_rpc.GetVaultRequest
 */
export interface GetVaultRequest {
    /**
     * Vault address
     *
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.GetVaultResponse
 */
export interface GetVaultResponse {
    /**
     * The vault
     *
     * @generated from protobuf field: injective_megavault_rpc.Vault vault = 1
     */
    vault?: Vault;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Vault
 */
export interface Vault {
    /**
     * Contract address
     *
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * Contract name
     *
     * @generated from protobuf field: string contract_name = 2
     */
    contractName: string;
    /**
     * Contract version
     *
     * @generated from protobuf field: string contract_version = 3
     */
    contractVersion: string;
    /**
     * Admin
     *
     * @generated from protobuf field: string admin = 4
     */
    admin: string;
    /**
     * LP denom
     *
     * @generated from protobuf field: string lp_denom = 5
     */
    lpDenom: string;
    /**
     * Quote denom
     *
     * @generated from protobuf field: string quote_denom = 6
     */
    quoteDenom: string;
    /**
     * Operators
     *
     * @generated from protobuf field: repeated injective_megavault_rpc.Operator operators = 7
     */
    operators: Operator[];
    /**
     * Incentives
     *
     * @generated from protobuf field: injective_megavault_rpc.Incentives incentives = 8
     */
    incentives?: Incentives;
    /**
     * TargetApr
     *
     * @generated from protobuf field: injective_megavault_rpc.TargetApr target_apr = 9
     */
    targetApr?: TargetApr;
    /**
     * Operators
     *
     * @generated from protobuf field: injective_megavault_rpc.VaultStats stats = 10
     */
    stats?: VaultStats;
    /**
     * Block height when the vault was created.
     *
     * @generated from protobuf field: sint64 created_height = 11
     */
    createdHeight: bigint;
    /**
     * CreatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 12
     */
    createdAt: bigint;
    /**
     * Block height when the vault was updated.
     *
     * @generated from protobuf field: sint64 updated_height = 13
     */
    updatedHeight: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 14
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Operator
 */
export interface Operator {
    /**
     * Operator address
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Total amount
     *
     * @generated from protobuf field: string total_amount = 2
     */
    totalAmount: string;
    /**
     * Total liquid amount
     *
     * @generated from protobuf field: string total_liquid_amount = 3
     */
    totalLiquidAmount: string;
    /**
     * Block height when the operator was updated.
     *
     * @generated from protobuf field: sint64 updated_height = 4
     */
    updatedHeight: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 5
     */
    updatedAt: bigint;
    /**
     * Percentage of the operator
     *
     * @generated from protobuf field: string percentage = 6
     */
    percentage: string;
    /**
     * Subaccount ID of the operator
     *
     * @generated from protobuf field: string subaccount_id = 7
     */
    subaccountId: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Incentives
 */
export interface Incentives {
    /**
     * Operator address
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Amount
     *
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
    /**
     * Block height when the target APR was updated.
     *
     * @generated from protobuf field: sint64 updated_height = 3
     */
    updatedHeight: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 4
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.TargetApr
 */
export interface TargetApr {
    /**
     * APR
     *
     * @generated from protobuf field: string apr = 1
     */
    apr: string;
    /**
     * Upper threshold
     *
     * @generated from protobuf field: string upper_threshold = 2
     */
    upperThreshold: string;
    /**
     * Lower threshold
     *
     * @generated from protobuf field: string lower_threshold = 3
     */
    lowerThreshold: string;
    /**
     * Block height when the target APR was updated.
     *
     * @generated from protobuf field: sint64 updated_height = 4
     */
    updatedHeight: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 5
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.VaultStats
 */
export interface VaultStats {
    /**
     * Total subscribed amount in the vault
     *
     * @generated from protobuf field: string total_subscribed_amount = 1
     */
    totalSubscribedAmount: string;
    /**
     * Total redeemed amount in the vault
     *
     * @generated from protobuf field: string total_redeemed_amount = 2
     */
    totalRedeemedAmount: string;
    /**
     * Current amount in the vault
     *
     * @generated from protobuf field: string current_amount = 3
     */
    currentAmount: string;
    /**
     * Current amount in the vault without taking into account the incentives
     *
     * @generated from protobuf field: string current_amount_without_incentives = 4
     */
    currentAmountWithoutIncentives: string;
    /**
     * Current amount of LP tokens in the vault
     *
     * @generated from protobuf field: string current_lp_amount = 5
     */
    currentLpAmount: string;
    /**
     * Current LP price
     *
     * @generated from protobuf field: string current_lp_price = 6
     */
    currentLpPrice: string;
    /**
     * PnL statistics
     *
     * @generated from protobuf field: injective_megavault_rpc.PnlStats pnl = 7
     */
    pnl?: PnlStats;
    /**
     * Volatility statistics
     *
     * @generated from protobuf field: injective_megavault_rpc.VolatilityStats volatility = 8
     */
    volatility?: VolatilityStats;
    /**
     * APR statistics
     *
     * @generated from protobuf field: injective_megavault_rpc.AprStats apr = 9
     */
    apr?: AprStats;
    /**
     * Max drawdown
     *
     * @generated from protobuf field: injective_megavault_rpc.MaxDrawdown max_drawdown = 10
     */
    maxDrawdown?: MaxDrawdown;
}
/**
 * @generated from protobuf message injective_megavault_rpc.PnlStats
 */
export interface PnlStats {
    /**
     * Unrealized PnL
     *
     * @generated from protobuf field: injective_megavault_rpc.UnrealizedPnl unrealized = 1
     */
    unrealized?: UnrealizedPnl;
    /**
     * All-time PnL
     *
     * @generated from protobuf field: injective_megavault_rpc.Pnl all_time = 2
     */
    allTime?: Pnl;
}
/**
 * @generated from protobuf message injective_megavault_rpc.UnrealizedPnl
 */
export interface UnrealizedPnl {
    /**
     * Unrealized PnL value
     *
     * @generated from protobuf field: string value = 1
     */
    value: string;
    /**
     * Unrealized PnL percentage
     *
     * @generated from protobuf field: string percentage = 2
     */
    percentage: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Pnl
 */
export interface Pnl {
    /**
     * PnL value
     *
     * @generated from protobuf field: string value = 1
     */
    value: string;
    /**
     * PnL percentage
     *
     * @generated from protobuf field: string percentage = 2
     */
    percentage: string;
    /**
     * Total amount subscribed
     *
     * @generated from protobuf field: string total_amount_subscribed = 3
     */
    totalAmountSubscribed: string;
    /**
     * Total amount redeemed
     *
     * @generated from protobuf field: string total_amount_redeemed = 4
     */
    totalAmountRedeemed: string;
    /**
     * Current amount
     *
     * @generated from protobuf field: string current_amount = 5
     */
    currentAmount: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.VolatilityStats
 */
export interface VolatilityStats {
    /**
     * 30-days volatility
     *
     * @generated from protobuf field: injective_megavault_rpc.Volatility thirty_days = 1
     */
    thirtyDays?: Volatility;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Volatility
 */
export interface Volatility {
    /**
     * Volatility value
     *
     * @generated from protobuf field: string value = 1
     */
    value: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.AprStats
 */
export interface AprStats {
    /**
     * 30-day APR
     *
     * @generated from protobuf field: injective_megavault_rpc.Apr thirty_days = 1
     */
    thirtyDays?: Apr;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Apr
 */
export interface Apr {
    /**
     * APR value
     *
     * @generated from protobuf field: string value = 1
     */
    value: string;
    /**
     * Original LP price
     *
     * @generated from protobuf field: string original_lp_price = 2
     */
    originalLpPrice: string;
    /**
     * Current LP price
     *
     * @generated from protobuf field: string current_lp_price = 3
     */
    currentLpPrice: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.MaxDrawdown
 */
export interface MaxDrawdown {
    /**
     * Max drawdown value
     *
     * @generated from protobuf field: string value = 1
     */
    value: string;
    /**
     * Latest PnL peak
     *
     * @generated from protobuf field: string latest_pn_l_peak = 2
     */
    latestPnLPeak: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.GetUserRequest
 */
export interface GetUserRequest {
    /**
     * Vault address
     *
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * User address
     *
     * @generated from protobuf field: string user_address = 2
     */
    userAddress: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.GetUserResponse
 */
export interface GetUserResponse {
    /**
     * The user
     *
     * @generated from protobuf field: injective_megavault_rpc.User user = 1
     */
    user?: User;
}
/**
 * @generated from protobuf message injective_megavault_rpc.User
 */
export interface User {
    /**
     * User address
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Contract address
     *
     * @generated from protobuf field: string contract_address = 2
     */
    contractAddress: string;
    /**
     * User stats
     *
     * @generated from protobuf field: injective_megavault_rpc.UserStats stats = 3
     */
    stats?: UserStats;
    /**
     * Block height when the vault was created.
     *
     * @generated from protobuf field: sint64 created_height = 4
     */
    createdHeight: bigint;
    /**
     * CreatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 5
     */
    createdAt: bigint;
    /**
     * Block height when the vault was updated.
     *
     * @generated from protobuf field: sint64 updated_height = 6
     */
    updatedHeight: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 7
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.UserStats
 */
export interface UserStats {
    /**
     * Current subscribed amount in the vault
     *
     * @generated from protobuf field: string current_amount = 1
     */
    currentAmount: string;
    /**
     * Current amount of LP tokens in the vault
     *
     * @generated from protobuf field: string current_lp_amount = 2
     */
    currentLpAmount: string;
    /**
     * PnL statistics
     *
     * @generated from protobuf field: injective_megavault_rpc.PnlStats pnl = 3
     */
    pnl?: PnlStats;
    /**
     * Current deposisted value
     *
     * @generated from protobuf field: string deposited_value = 4
     */
    depositedValue: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.ListSubscriptionsRequest
 */
export interface ListSubscriptionsRequest {
    /**
     * Vault address
     *
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * User address
     *
     * @generated from protobuf field: string user_address = 2
     */
    userAddress: string;
    /**
     * Status of the redemption
     *
     * @generated from protobuf field: string status = 3
     */
    status: string;
    /**
     * @generated from protobuf field: sint32 per_page = 4
     */
    perPage: number;
    /**
     * @generated from protobuf field: string token = 5
     */
    token: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.ListSubscriptionsResponse
 */
export interface ListSubscriptionsResponse {
    /**
     * List of subscriptions
     *
     * @generated from protobuf field: repeated injective_megavault_rpc.Subscription subscriptions = 1
     */
    subscriptions: Subscription[];
    /**
     * Next tokens for pagination
     *
     * @generated from protobuf field: repeated string next = 2
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.Subscription
 */
export interface Subscription {
    /**
     * Contract address
     *
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * User
     *
     * @generated from protobuf field: string user = 2
     */
    user: string;
    /**
     * Index number of the subscription
     *
     * @generated from protobuf field: sint64 index = 3
     */
    index: bigint;
    /**
     * Amount of LP tokens given to the user for the subscription
     *
     * @generated from protobuf field: string lp_amount = 4
     */
    lpAmount: string;
    /**
     * Amount in USDT the user gave for the subscription
     *
     * @generated from protobuf field: string amount = 5
     */
    amount: string;
    /**
     * Status of the subscription
     *
     * @generated from protobuf field: string status = 6
     */
    status: string;
    /**
     * Block height when the subscription was created.
     *
     * @generated from protobuf field: sint64 created_height = 7
     */
    createdHeight: bigint;
    /**
     * CreatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 8
     */
    createdAt: bigint;
    /**
     * Block height when the subscription was executed.
     *
     * @generated from protobuf field: sint64 executed_height = 9
     */
    executedHeight: bigint;
    /**
     * ExecutedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 executed_at = 10
     */
    executedAt: bigint;
    /**
     * Subscription status log
     *
     * @generated from protobuf field: repeated injective_megavault_rpc.OperationStatusLogEntry log = 11
     */
    log: OperationStatusLogEntry[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.OperationStatusLogEntry
 */
export interface OperationStatusLogEntry {
    /**
     * Status of the subscription at this log entry
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
    /**
     * Transaction hash associated with this log entry
     *
     * @generated from protobuf field: string tx_hash = 2
     */
    txHash: string;
    /**
     * Block height when this log entry occurred
     *
     * @generated from protobuf field: sint64 block_height = 3
     */
    blockHeight: bigint;
    /**
     * Timestamp when this log entry occurred in UNIX millis.
     *
     * @generated from protobuf field: sint64 block_time = 4
     */
    blockTime: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.ListRedemptionsRequest
 */
export interface ListRedemptionsRequest {
    /**
     * Vault address
     *
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * User address
     *
     * @generated from protobuf field: string user_address = 2
     */
    userAddress: string;
    /**
     * Status of the redemption
     *
     * @generated from protobuf field: string status = 3
     */
    status: string;
    /**
     * @generated from protobuf field: sint32 per_page = 4
     */
    perPage: number;
    /**
     * @generated from protobuf field: string token = 5
     */
    token: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.ListRedemptionsResponse
 */
export interface ListRedemptionsResponse {
    /**
     * List of subscriptions
     *
     * @generated from protobuf field: repeated injective_megavault_rpc.Redemption redemptions = 1
     */
    redemptions: Redemption[];
    /**
     * Next tokens for pagination
     *
     * @generated from protobuf field: repeated string next = 2
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.Redemption
 */
export interface Redemption {
    /**
     * Contract address
     *
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * User
     *
     * @generated from protobuf field: string user = 2
     */
    user: string;
    /**
     * Index number of the redemption
     *
     * @generated from protobuf field: sint64 index = 3
     */
    index: bigint;
    /**
     * Amount of LP tokens given to the user for the redemption
     *
     * @generated from protobuf field: string lp_amount = 4
     */
    lpAmount: string;
    /**
     * Amount in USDT the user gave for the redemption
     *
     * @generated from protobuf field: string amount = 5
     */
    amount: string;
    /**
     * Status of the subscription
     *
     * @generated from protobuf field: string status = 6
     */
    status: string;
    /**
     * DueAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 due_at = 7
     */
    dueAt: bigint;
    /**
     * Block height when the subscription was created.
     *
     * @generated from protobuf field: sint64 created_height = 8
     */
    createdHeight: bigint;
    /**
     * CreatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 9
     */
    createdAt: bigint;
    /**
     * Block height when the subscription was executed.
     *
     * @generated from protobuf field: sint64 executed_height = 10
     */
    executedHeight: bigint;
    /**
     * ExecutedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 executed_at = 11
     */
    executedAt: bigint;
    /**
     * Redemption status log
     *
     * @generated from protobuf field: repeated injective_megavault_rpc.OperationStatusLogEntry log = 12
     */
    log: OperationStatusLogEntry[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.GetOperatorRedemptionBucketsRequest
 */
export interface GetOperatorRedemptionBucketsRequest {
    /**
     * Vault address
     *
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * Operator address
     *
     * @generated from protobuf field: string operator_address = 2
     */
    operatorAddress: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.GetOperatorRedemptionBucketsResponse
 */
export interface GetOperatorRedemptionBucketsResponse {
    /**
     * The redemption buckets
     *
     * @generated from protobuf field: repeated injective_megavault_rpc.RedemptionBucket buckets = 1
     */
    buckets: RedemptionBucket[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.RedemptionBucket
 */
export interface RedemptionBucket {
    /**
     * Bucket
     *
     * @generated from protobuf field: string bucket = 1
     */
    bucket: string;
    /**
     * Amount of LP tokens to redeem
     *
     * @generated from protobuf field: string lp_amount_to_redeem = 2
     */
    lpAmountToRedeem: string;
    /**
     * Amount needed to cover all the redemptions in the bucket
     *
     * @generated from protobuf field: string needed_amount = 3
     */
    neededAmount: string;
    /**
     * Amount of liquidity missing needed to cover all the redemptions in the bucket
     *
     * @generated from protobuf field: string missing_liquidity = 4
     */
    missingLiquidity: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.TvlHistoryRequest
 */
export interface TvlHistoryRequest {
    /**
     * Vault address
     *
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * timestamp from which to start the query in milliseconds (UTC)
     *
     * @generated from protobuf field: sint64 since = 2
     */
    since: bigint;
    /**
     * amount of data points to return
     *
     * @generated from protobuf field: sint32 max_data_points = 3
     */
    maxDataPoints: number;
}
/**
 * @generated from protobuf message injective_megavault_rpc.TvlHistoryResponse
 */
export interface TvlHistoryResponse {
    /**
     * @generated from protobuf field: repeated injective_megavault_rpc.HistoricalTVL history = 1
     */
    history: HistoricalTVL[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.HistoricalTVL
 */
export interface HistoricalTVL {
    /**
     * Time, Unix timestamp in milliseconds (UTC)
     *
     * @generated from protobuf field: sint64 t = 1
     */
    t: bigint;
    /**
     * TVL Value
     *
     * @generated from protobuf field: string v = 2
     */
    v: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.PnlHistoryRequest
 */
export interface PnlHistoryRequest {
    /**
     * Vault address
     *
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * timestamp from which to start the query in milliseconds (UTC)
     *
     * @generated from protobuf field: sint64 since = 2
     */
    since: bigint;
    /**
     * amount of data points to return
     *
     * @generated from protobuf field: sint32 max_data_points = 3
     */
    maxDataPoints: number;
}
/**
 * @generated from protobuf message injective_megavault_rpc.PnlHistoryResponse
 */
export interface PnlHistoryResponse {
    /**
     * @generated from protobuf field: repeated injective_megavault_rpc.HistoricalPnL history = 1
     */
    history: HistoricalPnL[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.HistoricalPnL
 */
export interface HistoricalPnL {
    /**
     * Time, Unix timestamp in milliseconds (UTC)
     *
     * @generated from protobuf field: sint64 t = 1
     */
    t: bigint;
    /**
     * PnL Value
     *
     * @generated from protobuf field: string v = 2
     */
    v: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultRequest$Type extends MessageType<GetVaultRequest> {
    constructor() {
        super("injective_megavault_rpc.GetVaultRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetVaultRequest>): GetVaultRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetVaultRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultRequest): GetVaultRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetVaultRequest
 */
export const GetVaultRequest = new GetVaultRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultResponse$Type extends MessageType<GetVaultResponse> {
    constructor() {
        super("injective_megavault_rpc.GetVaultResponse", [
            { no: 1, name: "vault", kind: "message", T: () => Vault }
        ]);
    }
    create(value?: PartialMessage<GetVaultResponse>): GetVaultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetVaultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultResponse): GetVaultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_megavault_rpc.Vault vault */ 1:
                    message.vault = Vault.internalBinaryRead(reader, reader.uint32(), options, message.vault);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_megavault_rpc.Vault vault = 1; */
        if (message.vault)
            Vault.internalBinaryWrite(message.vault, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetVaultResponse
 */
export const GetVaultResponse = new GetVaultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vault$Type extends MessageType<Vault> {
    constructor() {
        super("injective_megavault_rpc.Vault", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "contract_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lp_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "operators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Operator },
            { no: 8, name: "incentives", kind: "message", T: () => Incentives },
            { no: 9, name: "target_apr", kind: "message", T: () => TargetApr },
            { no: 10, name: "stats", kind: "message", T: () => VaultStats },
            { no: 11, name: "created_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "updated_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Vault>): Vault {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        message.contractName = "";
        message.contractVersion = "";
        message.admin = "";
        message.lpDenom = "";
        message.quoteDenom = "";
        message.operators = [];
        message.createdHeight = 0n;
        message.createdAt = 0n;
        message.updatedHeight = 0n;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<Vault>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vault): Vault {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* string contract_name */ 2:
                    message.contractName = reader.string();
                    break;
                case /* string contract_version */ 3:
                    message.contractVersion = reader.string();
                    break;
                case /* string admin */ 4:
                    message.admin = reader.string();
                    break;
                case /* string lp_denom */ 5:
                    message.lpDenom = reader.string();
                    break;
                case /* string quote_denom */ 6:
                    message.quoteDenom = reader.string();
                    break;
                case /* repeated injective_megavault_rpc.Operator operators */ 7:
                    message.operators.push(Operator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_megavault_rpc.Incentives incentives */ 8:
                    message.incentives = Incentives.internalBinaryRead(reader, reader.uint32(), options, message.incentives);
                    break;
                case /* injective_megavault_rpc.TargetApr target_apr */ 9:
                    message.targetApr = TargetApr.internalBinaryRead(reader, reader.uint32(), options, message.targetApr);
                    break;
                case /* injective_megavault_rpc.VaultStats stats */ 10:
                    message.stats = VaultStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* sint64 created_height */ 11:
                    message.createdHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 12:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_height */ 13:
                    message.updatedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 14:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vault, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* string contract_name = 2; */
        if (message.contractName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractName);
        /* string contract_version = 3; */
        if (message.contractVersion !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contractVersion);
        /* string admin = 4; */
        if (message.admin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.admin);
        /* string lp_denom = 5; */
        if (message.lpDenom !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.lpDenom);
        /* string quote_denom = 6; */
        if (message.quoteDenom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
        /* repeated injective_megavault_rpc.Operator operators = 7; */
        for (let i = 0; i < message.operators.length; i++)
            Operator.internalBinaryWrite(message.operators[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* injective_megavault_rpc.Incentives incentives = 8; */
        if (message.incentives)
            Incentives.internalBinaryWrite(message.incentives, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* injective_megavault_rpc.TargetApr target_apr = 9; */
        if (message.targetApr)
            TargetApr.internalBinaryWrite(message.targetApr, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* injective_megavault_rpc.VaultStats stats = 10; */
        if (message.stats)
            VaultStats.internalBinaryWrite(message.stats, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* sint64 created_height = 11; */
        if (message.createdHeight !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.createdHeight);
        /* sint64 created_at = 12; */
        if (message.createdAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_height = 13; */
        if (message.updatedHeight !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.updatedHeight);
        /* sint64 updated_at = 14; */
        if (message.updatedAt !== 0n)
            writer.tag(14, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Vault
 */
export const Vault = new Vault$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operator$Type extends MessageType<Operator> {
    constructor() {
        super("injective_megavault_rpc.Operator", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total_liquid_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "updated_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Operator>): Operator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.totalAmount = "";
        message.totalLiquidAmount = "";
        message.updatedHeight = 0n;
        message.updatedAt = 0n;
        message.percentage = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<Operator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operator): Operator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string total_amount */ 2:
                    message.totalAmount = reader.string();
                    break;
                case /* string total_liquid_amount */ 3:
                    message.totalLiquidAmount = reader.string();
                    break;
                case /* sint64 updated_height */ 4:
                    message.updatedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 5:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string percentage */ 6:
                    message.percentage = reader.string();
                    break;
                case /* string subaccount_id */ 7:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string total_amount = 2; */
        if (message.totalAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.totalAmount);
        /* string total_liquid_amount = 3; */
        if (message.totalLiquidAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.totalLiquidAmount);
        /* sint64 updated_height = 4; */
        if (message.updatedHeight !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.updatedHeight);
        /* sint64 updated_at = 5; */
        if (message.updatedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.updatedAt);
        /* string percentage = 6; */
        if (message.percentage !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.percentage);
        /* string subaccount_id = 7; */
        if (message.subaccountId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Operator
 */
export const Operator = new Operator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Incentives$Type extends MessageType<Incentives> {
    constructor() {
        super("injective_megavault_rpc.Incentives", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Incentives>): Incentives {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.amount = "";
        message.updatedHeight = 0n;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<Incentives>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Incentives): Incentives {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                case /* sint64 updated_height */ 3:
                    message.updatedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 4:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Incentives, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        /* sint64 updated_height = 3; */
        if (message.updatedHeight !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.updatedHeight);
        /* sint64 updated_at = 4; */
        if (message.updatedAt !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Incentives
 */
export const Incentives = new Incentives$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TargetApr$Type extends MessageType<TargetApr> {
    constructor() {
        super("injective_megavault_rpc.TargetApr", [
            { no: 1, name: "apr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "upper_threshold", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "lower_threshold", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "updated_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TargetApr>): TargetApr {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apr = "";
        message.upperThreshold = "";
        message.lowerThreshold = "";
        message.updatedHeight = 0n;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<TargetApr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TargetApr): TargetApr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string apr */ 1:
                    message.apr = reader.string();
                    break;
                case /* string upper_threshold */ 2:
                    message.upperThreshold = reader.string();
                    break;
                case /* string lower_threshold */ 3:
                    message.lowerThreshold = reader.string();
                    break;
                case /* sint64 updated_height */ 4:
                    message.updatedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 5:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TargetApr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string apr = 1; */
        if (message.apr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apr);
        /* string upper_threshold = 2; */
        if (message.upperThreshold !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.upperThreshold);
        /* string lower_threshold = 3; */
        if (message.lowerThreshold !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lowerThreshold);
        /* sint64 updated_height = 4; */
        if (message.updatedHeight !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.updatedHeight);
        /* sint64 updated_at = 5; */
        if (message.updatedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.TargetApr
 */
export const TargetApr = new TargetApr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VaultStats$Type extends MessageType<VaultStats> {
    constructor() {
        super("injective_megavault_rpc.VaultStats", [
            { no: 1, name: "total_subscribed_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_redeemed_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "current_amount_without_incentives", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "current_lp_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "current_lp_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "pnl", kind: "message", T: () => PnlStats },
            { no: 8, name: "volatility", kind: "message", T: () => VolatilityStats },
            { no: 9, name: "apr", kind: "message", T: () => AprStats },
            { no: 10, name: "max_drawdown", kind: "message", T: () => MaxDrawdown }
        ]);
    }
    create(value?: PartialMessage<VaultStats>): VaultStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalSubscribedAmount = "";
        message.totalRedeemedAmount = "";
        message.currentAmount = "";
        message.currentAmountWithoutIncentives = "";
        message.currentLpAmount = "";
        message.currentLpPrice = "";
        if (value !== undefined)
            reflectionMergePartial<VaultStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VaultStats): VaultStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string total_subscribed_amount */ 1:
                    message.totalSubscribedAmount = reader.string();
                    break;
                case /* string total_redeemed_amount */ 2:
                    message.totalRedeemedAmount = reader.string();
                    break;
                case /* string current_amount */ 3:
                    message.currentAmount = reader.string();
                    break;
                case /* string current_amount_without_incentives */ 4:
                    message.currentAmountWithoutIncentives = reader.string();
                    break;
                case /* string current_lp_amount */ 5:
                    message.currentLpAmount = reader.string();
                    break;
                case /* string current_lp_price */ 6:
                    message.currentLpPrice = reader.string();
                    break;
                case /* injective_megavault_rpc.PnlStats pnl */ 7:
                    message.pnl = PnlStats.internalBinaryRead(reader, reader.uint32(), options, message.pnl);
                    break;
                case /* injective_megavault_rpc.VolatilityStats volatility */ 8:
                    message.volatility = VolatilityStats.internalBinaryRead(reader, reader.uint32(), options, message.volatility);
                    break;
                case /* injective_megavault_rpc.AprStats apr */ 9:
                    message.apr = AprStats.internalBinaryRead(reader, reader.uint32(), options, message.apr);
                    break;
                case /* injective_megavault_rpc.MaxDrawdown max_drawdown */ 10:
                    message.maxDrawdown = MaxDrawdown.internalBinaryRead(reader, reader.uint32(), options, message.maxDrawdown);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VaultStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string total_subscribed_amount = 1; */
        if (message.totalSubscribedAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.totalSubscribedAmount);
        /* string total_redeemed_amount = 2; */
        if (message.totalRedeemedAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.totalRedeemedAmount);
        /* string current_amount = 3; */
        if (message.currentAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentAmount);
        /* string current_amount_without_incentives = 4; */
        if (message.currentAmountWithoutIncentives !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.currentAmountWithoutIncentives);
        /* string current_lp_amount = 5; */
        if (message.currentLpAmount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.currentLpAmount);
        /* string current_lp_price = 6; */
        if (message.currentLpPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currentLpPrice);
        /* injective_megavault_rpc.PnlStats pnl = 7; */
        if (message.pnl)
            PnlStats.internalBinaryWrite(message.pnl, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* injective_megavault_rpc.VolatilityStats volatility = 8; */
        if (message.volatility)
            VolatilityStats.internalBinaryWrite(message.volatility, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* injective_megavault_rpc.AprStats apr = 9; */
        if (message.apr)
            AprStats.internalBinaryWrite(message.apr, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* injective_megavault_rpc.MaxDrawdown max_drawdown = 10; */
        if (message.maxDrawdown)
            MaxDrawdown.internalBinaryWrite(message.maxDrawdown, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.VaultStats
 */
export const VaultStats = new VaultStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PnlStats$Type extends MessageType<PnlStats> {
    constructor() {
        super("injective_megavault_rpc.PnlStats", [
            { no: 1, name: "unrealized", kind: "message", T: () => UnrealizedPnl },
            { no: 2, name: "all_time", kind: "message", T: () => Pnl }
        ]);
    }
    create(value?: PartialMessage<PnlStats>): PnlStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PnlStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PnlStats): PnlStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_megavault_rpc.UnrealizedPnl unrealized */ 1:
                    message.unrealized = UnrealizedPnl.internalBinaryRead(reader, reader.uint32(), options, message.unrealized);
                    break;
                case /* injective_megavault_rpc.Pnl all_time */ 2:
                    message.allTime = Pnl.internalBinaryRead(reader, reader.uint32(), options, message.allTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PnlStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_megavault_rpc.UnrealizedPnl unrealized = 1; */
        if (message.unrealized)
            UnrealizedPnl.internalBinaryWrite(message.unrealized, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_megavault_rpc.Pnl all_time = 2; */
        if (message.allTime)
            Pnl.internalBinaryWrite(message.allTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.PnlStats
 */
export const PnlStats = new PnlStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnrealizedPnl$Type extends MessageType<UnrealizedPnl> {
    constructor() {
        super("injective_megavault_rpc.UnrealizedPnl", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnrealizedPnl>): UnrealizedPnl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        message.percentage = "";
        if (value !== undefined)
            reflectionMergePartial<UnrealizedPnl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnrealizedPnl): UnrealizedPnl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* string percentage */ 2:
                    message.percentage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnrealizedPnl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* string percentage = 2; */
        if (message.percentage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.percentage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.UnrealizedPnl
 */
export const UnrealizedPnl = new UnrealizedPnl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pnl$Type extends MessageType<Pnl> {
    constructor() {
        super("injective_megavault_rpc.Pnl", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total_amount_subscribed", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "total_amount_redeemed", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "current_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Pnl>): Pnl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        message.percentage = "";
        message.totalAmountSubscribed = "";
        message.totalAmountRedeemed = "";
        message.currentAmount = "";
        if (value !== undefined)
            reflectionMergePartial<Pnl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pnl): Pnl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* string percentage */ 2:
                    message.percentage = reader.string();
                    break;
                case /* string total_amount_subscribed */ 3:
                    message.totalAmountSubscribed = reader.string();
                    break;
                case /* string total_amount_redeemed */ 4:
                    message.totalAmountRedeemed = reader.string();
                    break;
                case /* string current_amount */ 5:
                    message.currentAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pnl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* string percentage = 2; */
        if (message.percentage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.percentage);
        /* string total_amount_subscribed = 3; */
        if (message.totalAmountSubscribed !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.totalAmountSubscribed);
        /* string total_amount_redeemed = 4; */
        if (message.totalAmountRedeemed !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.totalAmountRedeemed);
        /* string current_amount = 5; */
        if (message.currentAmount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.currentAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Pnl
 */
export const Pnl = new Pnl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolatilityStats$Type extends MessageType<VolatilityStats> {
    constructor() {
        super("injective_megavault_rpc.VolatilityStats", [
            { no: 1, name: "thirty_days", kind: "message", T: () => Volatility }
        ]);
    }
    create(value?: PartialMessage<VolatilityStats>): VolatilityStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VolatilityStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolatilityStats): VolatilityStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_megavault_rpc.Volatility thirty_days */ 1:
                    message.thirtyDays = Volatility.internalBinaryRead(reader, reader.uint32(), options, message.thirtyDays);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolatilityStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_megavault_rpc.Volatility thirty_days = 1; */
        if (message.thirtyDays)
            Volatility.internalBinaryWrite(message.thirtyDays, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.VolatilityStats
 */
export const VolatilityStats = new VolatilityStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Volatility$Type extends MessageType<Volatility> {
    constructor() {
        super("injective_megavault_rpc.Volatility", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Volatility>): Volatility {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<Volatility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Volatility): Volatility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Volatility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Volatility
 */
export const Volatility = new Volatility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AprStats$Type extends MessageType<AprStats> {
    constructor() {
        super("injective_megavault_rpc.AprStats", [
            { no: 1, name: "thirty_days", kind: "message", T: () => Apr }
        ]);
    }
    create(value?: PartialMessage<AprStats>): AprStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AprStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AprStats): AprStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_megavault_rpc.Apr thirty_days */ 1:
                    message.thirtyDays = Apr.internalBinaryRead(reader, reader.uint32(), options, message.thirtyDays);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AprStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_megavault_rpc.Apr thirty_days = 1; */
        if (message.thirtyDays)
            Apr.internalBinaryWrite(message.thirtyDays, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.AprStats
 */
export const AprStats = new AprStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Apr$Type extends MessageType<Apr> {
    constructor() {
        super("injective_megavault_rpc.Apr", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "original_lp_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_lp_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Apr>): Apr {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        message.originalLpPrice = "";
        message.currentLpPrice = "";
        if (value !== undefined)
            reflectionMergePartial<Apr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Apr): Apr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* string original_lp_price */ 2:
                    message.originalLpPrice = reader.string();
                    break;
                case /* string current_lp_price */ 3:
                    message.currentLpPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Apr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* string original_lp_price = 2; */
        if (message.originalLpPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.originalLpPrice);
        /* string current_lp_price = 3; */
        if (message.currentLpPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentLpPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Apr
 */
export const Apr = new Apr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaxDrawdown$Type extends MessageType<MaxDrawdown> {
    constructor() {
        super("injective_megavault_rpc.MaxDrawdown", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "latest_pn_l_peak", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MaxDrawdown>): MaxDrawdown {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        message.latestPnLPeak = "";
        if (value !== undefined)
            reflectionMergePartial<MaxDrawdown>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaxDrawdown): MaxDrawdown {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* string latest_pn_l_peak */ 2:
                    message.latestPnLPeak = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaxDrawdown, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* string latest_pn_l_peak = 2; */
        if (message.latestPnLPeak !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.latestPnLPeak);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.MaxDrawdown
 */
export const MaxDrawdown = new MaxDrawdown$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserRequest$Type extends MessageType<GetUserRequest> {
    constructor() {
        super("injective_megavault_rpc.GetUserRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserRequest>): GetUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        message.userAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserRequest): GetUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* string user_address */ 2:
                    message.userAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* string user_address = 2; */
        if (message.userAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetUserRequest
 */
export const GetUserRequest = new GetUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserResponse$Type extends MessageType<GetUserResponse> {
    constructor() {
        super("injective_megavault_rpc.GetUserResponse", [
            { no: 1, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<GetUserResponse>): GetUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserResponse): GetUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_megavault_rpc.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_megavault_rpc.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetUserResponse
 */
export const GetUserResponse = new GetUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("injective_megavault_rpc.User", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "stats", kind: "message", T: () => UserStats },
            { no: 4, name: "created_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "updated_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.contractAddress = "";
        message.createdHeight = 0n;
        message.createdAt = 0n;
        message.updatedHeight = 0n;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string contract_address */ 2:
                    message.contractAddress = reader.string();
                    break;
                case /* injective_megavault_rpc.UserStats stats */ 3:
                    message.stats = UserStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* sint64 created_height */ 4:
                    message.createdHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 5:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_height */ 6:
                    message.updatedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 7:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string contract_address = 2; */
        if (message.contractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
        /* injective_megavault_rpc.UserStats stats = 3; */
        if (message.stats)
            UserStats.internalBinaryWrite(message.stats, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sint64 created_height = 4; */
        if (message.createdHeight !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.createdHeight);
        /* sint64 created_at = 5; */
        if (message.createdAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_height = 6; */
        if (message.updatedHeight !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.updatedHeight);
        /* sint64 updated_at = 7; */
        if (message.updatedAt !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserStats$Type extends MessageType<UserStats> {
    constructor() {
        super("injective_megavault_rpc.UserStats", [
            { no: 1, name: "current_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "current_lp_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pnl", kind: "message", T: () => PnlStats },
            { no: 4, name: "deposited_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserStats>): UserStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentAmount = "";
        message.currentLpAmount = "";
        message.depositedValue = "";
        if (value !== undefined)
            reflectionMergePartial<UserStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserStats): UserStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string current_amount */ 1:
                    message.currentAmount = reader.string();
                    break;
                case /* string current_lp_amount */ 2:
                    message.currentLpAmount = reader.string();
                    break;
                case /* injective_megavault_rpc.PnlStats pnl */ 3:
                    message.pnl = PnlStats.internalBinaryRead(reader, reader.uint32(), options, message.pnl);
                    break;
                case /* string deposited_value */ 4:
                    message.depositedValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string current_amount = 1; */
        if (message.currentAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.currentAmount);
        /* string current_lp_amount = 2; */
        if (message.currentLpAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.currentLpAmount);
        /* injective_megavault_rpc.PnlStats pnl = 3; */
        if (message.pnl)
            PnlStats.internalBinaryWrite(message.pnl, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string deposited_value = 4; */
        if (message.depositedValue !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.depositedValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.UserStats
 */
export const UserStats = new UserStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSubscriptionsRequest$Type extends MessageType<ListSubscriptionsRequest> {
    constructor() {
        super("injective_megavault_rpc.ListSubscriptionsRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListSubscriptionsRequest>): ListSubscriptionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        message.userAddress = "";
        message.status = "";
        message.perPage = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<ListSubscriptionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSubscriptionsRequest): ListSubscriptionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* string user_address */ 2:
                    message.userAddress = reader.string();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                case /* sint32 per_page */ 4:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 5:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSubscriptionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* string user_address = 2; */
        if (message.userAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userAddress);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* sint32 per_page = 4; */
        if (message.perPage !== 0)
            writer.tag(4, WireType.Varint).sint32(message.perPage);
        /* string token = 5; */
        if (message.token !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.ListSubscriptionsRequest
 */
export const ListSubscriptionsRequest = new ListSubscriptionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSubscriptionsResponse$Type extends MessageType<ListSubscriptionsResponse> {
    constructor() {
        super("injective_megavault_rpc.ListSubscriptionsResponse", [
            { no: 1, name: "subscriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Subscription },
            { no: 2, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListSubscriptionsResponse>): ListSubscriptionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptions = [];
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<ListSubscriptionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSubscriptionsResponse): ListSubscriptionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_megavault_rpc.Subscription subscriptions */ 1:
                    message.subscriptions.push(Subscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string next */ 2:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSubscriptionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_megavault_rpc.Subscription subscriptions = 1; */
        for (let i = 0; i < message.subscriptions.length; i++)
            Subscription.internalBinaryWrite(message.subscriptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string next = 2; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.ListSubscriptionsResponse
 */
export const ListSubscriptionsResponse = new ListSubscriptionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subscription$Type extends MessageType<Subscription> {
    constructor() {
        super("injective_megavault_rpc.Subscription", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "lp_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "executed_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "log", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OperationStatusLogEntry }
        ]);
    }
    create(value?: PartialMessage<Subscription>): Subscription {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        message.user = "";
        message.index = 0n;
        message.lpAmount = "";
        message.amount = "";
        message.status = "";
        message.createdHeight = 0n;
        message.createdAt = 0n;
        message.executedHeight = 0n;
        message.executedAt = 0n;
        message.log = [];
        if (value !== undefined)
            reflectionMergePartial<Subscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subscription): Subscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* string user */ 2:
                    message.user = reader.string();
                    break;
                case /* sint64 index */ 3:
                    message.index = reader.sint64().toBigInt();
                    break;
                case /* string lp_amount */ 4:
                    message.lpAmount = reader.string();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* sint64 created_height */ 7:
                    message.createdHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 8:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 executed_height */ 9:
                    message.executedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 executed_at */ 10:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* repeated injective_megavault_rpc.OperationStatusLogEntry log */ 11:
                    message.log.push(OperationStatusLogEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* string user = 2; */
        if (message.user !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.user);
        /* sint64 index = 3; */
        if (message.index !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.index);
        /* string lp_amount = 4; */
        if (message.lpAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.lpAmount);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* sint64 created_height = 7; */
        if (message.createdHeight !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.createdHeight);
        /* sint64 created_at = 8; */
        if (message.createdAt !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.createdAt);
        /* sint64 executed_height = 9; */
        if (message.executedHeight !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.executedHeight);
        /* sint64 executed_at = 10; */
        if (message.executedAt !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.executedAt);
        /* repeated injective_megavault_rpc.OperationStatusLogEntry log = 11; */
        for (let i = 0; i < message.log.length; i++)
            OperationStatusLogEntry.internalBinaryWrite(message.log[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Subscription
 */
export const Subscription = new Subscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationStatusLogEntry$Type extends MessageType<OperationStatusLogEntry> {
    constructor() {
        super("injective_megavault_rpc.OperationStatusLogEntry", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "block_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "block_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OperationStatusLogEntry>): OperationStatusLogEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.txHash = "";
        message.blockHeight = 0n;
        message.blockTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<OperationStatusLogEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationStatusLogEntry): OperationStatusLogEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* string tx_hash */ 2:
                    message.txHash = reader.string();
                    break;
                case /* sint64 block_height */ 3:
                    message.blockHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 block_time */ 4:
                    message.blockTime = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationStatusLogEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* string tx_hash = 2; */
        if (message.txHash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.txHash);
        /* sint64 block_height = 3; */
        if (message.blockHeight !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.blockHeight);
        /* sint64 block_time = 4; */
        if (message.blockTime !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.blockTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.OperationStatusLogEntry
 */
export const OperationStatusLogEntry = new OperationStatusLogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRedemptionsRequest$Type extends MessageType<ListRedemptionsRequest> {
    constructor() {
        super("injective_megavault_rpc.ListRedemptionsRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "per_page", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListRedemptionsRequest>): ListRedemptionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        message.userAddress = "";
        message.status = "";
        message.perPage = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<ListRedemptionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRedemptionsRequest): ListRedemptionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* string user_address */ 2:
                    message.userAddress = reader.string();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                case /* sint32 per_page */ 4:
                    message.perPage = reader.sint32();
                    break;
                case /* string token */ 5:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListRedemptionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* string user_address = 2; */
        if (message.userAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userAddress);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* sint32 per_page = 4; */
        if (message.perPage !== 0)
            writer.tag(4, WireType.Varint).sint32(message.perPage);
        /* string token = 5; */
        if (message.token !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.ListRedemptionsRequest
 */
export const ListRedemptionsRequest = new ListRedemptionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRedemptionsResponse$Type extends MessageType<ListRedemptionsResponse> {
    constructor() {
        super("injective_megavault_rpc.ListRedemptionsResponse", [
            { no: 1, name: "redemptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Redemption },
            { no: 2, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListRedemptionsResponse>): ListRedemptionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.redemptions = [];
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<ListRedemptionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRedemptionsResponse): ListRedemptionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_megavault_rpc.Redemption redemptions */ 1:
                    message.redemptions.push(Redemption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string next */ 2:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListRedemptionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_megavault_rpc.Redemption redemptions = 1; */
        for (let i = 0; i < message.redemptions.length; i++)
            Redemption.internalBinaryWrite(message.redemptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string next = 2; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.ListRedemptionsResponse
 */
export const ListRedemptionsResponse = new ListRedemptionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Redemption$Type extends MessageType<Redemption> {
    constructor() {
        super("injective_megavault_rpc.Redemption", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "lp_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "due_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "created_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "executed_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "log", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OperationStatusLogEntry }
        ]);
    }
    create(value?: PartialMessage<Redemption>): Redemption {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        message.user = "";
        message.index = 0n;
        message.lpAmount = "";
        message.amount = "";
        message.status = "";
        message.dueAt = 0n;
        message.createdHeight = 0n;
        message.createdAt = 0n;
        message.executedHeight = 0n;
        message.executedAt = 0n;
        message.log = [];
        if (value !== undefined)
            reflectionMergePartial<Redemption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Redemption): Redemption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* string user */ 2:
                    message.user = reader.string();
                    break;
                case /* sint64 index */ 3:
                    message.index = reader.sint64().toBigInt();
                    break;
                case /* string lp_amount */ 4:
                    message.lpAmount = reader.string();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* sint64 due_at */ 7:
                    message.dueAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_height */ 8:
                    message.createdHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 9:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 executed_height */ 10:
                    message.executedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 executed_at */ 11:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* repeated injective_megavault_rpc.OperationStatusLogEntry log */ 12:
                    message.log.push(OperationStatusLogEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Redemption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* string user = 2; */
        if (message.user !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.user);
        /* sint64 index = 3; */
        if (message.index !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.index);
        /* string lp_amount = 4; */
        if (message.lpAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.lpAmount);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* sint64 due_at = 7; */
        if (message.dueAt !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.dueAt);
        /* sint64 created_height = 8; */
        if (message.createdHeight !== 0n)
            writer.tag(8, WireType.Varint).sint64(message.createdHeight);
        /* sint64 created_at = 9; */
        if (message.createdAt !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.createdAt);
        /* sint64 executed_height = 10; */
        if (message.executedHeight !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.executedHeight);
        /* sint64 executed_at = 11; */
        if (message.executedAt !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.executedAt);
        /* repeated injective_megavault_rpc.OperationStatusLogEntry log = 12; */
        for (let i = 0; i < message.log.length; i++)
            OperationStatusLogEntry.internalBinaryWrite(message.log[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Redemption
 */
export const Redemption = new Redemption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperatorRedemptionBucketsRequest$Type extends MessageType<GetOperatorRedemptionBucketsRequest> {
    constructor() {
        super("injective_megavault_rpc.GetOperatorRedemptionBucketsRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "operator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOperatorRedemptionBucketsRequest>): GetOperatorRedemptionBucketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        message.operatorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetOperatorRedemptionBucketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOperatorRedemptionBucketsRequest): GetOperatorRedemptionBucketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* string operator_address */ 2:
                    message.operatorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOperatorRedemptionBucketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* string operator_address = 2; */
        if (message.operatorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operatorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetOperatorRedemptionBucketsRequest
 */
export const GetOperatorRedemptionBucketsRequest = new GetOperatorRedemptionBucketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperatorRedemptionBucketsResponse$Type extends MessageType<GetOperatorRedemptionBucketsResponse> {
    constructor() {
        super("injective_megavault_rpc.GetOperatorRedemptionBucketsResponse", [
            { no: 1, name: "buckets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RedemptionBucket }
        ]);
    }
    create(value?: PartialMessage<GetOperatorRedemptionBucketsResponse>): GetOperatorRedemptionBucketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buckets = [];
        if (value !== undefined)
            reflectionMergePartial<GetOperatorRedemptionBucketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOperatorRedemptionBucketsResponse): GetOperatorRedemptionBucketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_megavault_rpc.RedemptionBucket buckets */ 1:
                    message.buckets.push(RedemptionBucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOperatorRedemptionBucketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_megavault_rpc.RedemptionBucket buckets = 1; */
        for (let i = 0; i < message.buckets.length; i++)
            RedemptionBucket.internalBinaryWrite(message.buckets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetOperatorRedemptionBucketsResponse
 */
export const GetOperatorRedemptionBucketsResponse = new GetOperatorRedemptionBucketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedemptionBucket$Type extends MessageType<RedemptionBucket> {
    constructor() {
        super("injective_megavault_rpc.RedemptionBucket", [
            { no: 1, name: "bucket", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "lp_amount_to_redeem", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "needed_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "missing_liquidity", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RedemptionBucket>): RedemptionBucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucket = "";
        message.lpAmountToRedeem = "";
        message.neededAmount = "";
        message.missingLiquidity = "";
        if (value !== undefined)
            reflectionMergePartial<RedemptionBucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedemptionBucket): RedemptionBucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket */ 1:
                    message.bucket = reader.string();
                    break;
                case /* string lp_amount_to_redeem */ 2:
                    message.lpAmountToRedeem = reader.string();
                    break;
                case /* string needed_amount */ 3:
                    message.neededAmount = reader.string();
                    break;
                case /* string missing_liquidity */ 4:
                    message.missingLiquidity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedemptionBucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket = 1; */
        if (message.bucket !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucket);
        /* string lp_amount_to_redeem = 2; */
        if (message.lpAmountToRedeem !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lpAmountToRedeem);
        /* string needed_amount = 3; */
        if (message.neededAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.neededAmount);
        /* string missing_liquidity = 4; */
        if (message.missingLiquidity !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.missingLiquidity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.RedemptionBucket
 */
export const RedemptionBucket = new RedemptionBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TvlHistoryRequest$Type extends MessageType<TvlHistoryRequest> {
    constructor() {
        super("injective_megavault_rpc.TvlHistoryRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "since", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_data_points", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TvlHistoryRequest>): TvlHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        message.since = 0n;
        message.maxDataPoints = 0;
        if (value !== undefined)
            reflectionMergePartial<TvlHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TvlHistoryRequest): TvlHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* sint64 since */ 2:
                    message.since = reader.sint64().toBigInt();
                    break;
                case /* sint32 max_data_points */ 3:
                    message.maxDataPoints = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TvlHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* sint64 since = 2; */
        if (message.since !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.since);
        /* sint32 max_data_points = 3; */
        if (message.maxDataPoints !== 0)
            writer.tag(3, WireType.Varint).sint32(message.maxDataPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.TvlHistoryRequest
 */
export const TvlHistoryRequest = new TvlHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TvlHistoryResponse$Type extends MessageType<TvlHistoryResponse> {
    constructor() {
        super("injective_megavault_rpc.TvlHistoryResponse", [
            { no: 1, name: "history", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HistoricalTVL }
        ]);
    }
    create(value?: PartialMessage<TvlHistoryResponse>): TvlHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.history = [];
        if (value !== undefined)
            reflectionMergePartial<TvlHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TvlHistoryResponse): TvlHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_megavault_rpc.HistoricalTVL history */ 1:
                    message.history.push(HistoricalTVL.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TvlHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_megavault_rpc.HistoricalTVL history = 1; */
        for (let i = 0; i < message.history.length; i++)
            HistoricalTVL.internalBinaryWrite(message.history[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.TvlHistoryResponse
 */
export const TvlHistoryResponse = new TvlHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalTVL$Type extends MessageType<HistoricalTVL> {
    constructor() {
        super("injective_megavault_rpc.HistoricalTVL", [
            { no: 1, name: "t", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "v", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalTVL>): HistoricalTVL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0n;
        message.v = "";
        if (value !== undefined)
            reflectionMergePartial<HistoricalTVL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalTVL): HistoricalTVL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 t */ 1:
                    message.t = reader.sint64().toBigInt();
                    break;
                case /* string v */ 2:
                    message.v = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalTVL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 t = 1; */
        if (message.t !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.t);
        /* string v = 2; */
        if (message.v !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.v);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.HistoricalTVL
 */
export const HistoricalTVL = new HistoricalTVL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PnlHistoryRequest$Type extends MessageType<PnlHistoryRequest> {
    constructor() {
        super("injective_megavault_rpc.PnlHistoryRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "since", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_data_points", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PnlHistoryRequest>): PnlHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        message.since = 0n;
        message.maxDataPoints = 0;
        if (value !== undefined)
            reflectionMergePartial<PnlHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PnlHistoryRequest): PnlHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* sint64 since */ 2:
                    message.since = reader.sint64().toBigInt();
                    break;
                case /* sint32 max_data_points */ 3:
                    message.maxDataPoints = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PnlHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* sint64 since = 2; */
        if (message.since !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.since);
        /* sint32 max_data_points = 3; */
        if (message.maxDataPoints !== 0)
            writer.tag(3, WireType.Varint).sint32(message.maxDataPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.PnlHistoryRequest
 */
export const PnlHistoryRequest = new PnlHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PnlHistoryResponse$Type extends MessageType<PnlHistoryResponse> {
    constructor() {
        super("injective_megavault_rpc.PnlHistoryResponse", [
            { no: 1, name: "history", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HistoricalPnL }
        ]);
    }
    create(value?: PartialMessage<PnlHistoryResponse>): PnlHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.history = [];
        if (value !== undefined)
            reflectionMergePartial<PnlHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PnlHistoryResponse): PnlHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_megavault_rpc.HistoricalPnL history */ 1:
                    message.history.push(HistoricalPnL.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PnlHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_megavault_rpc.HistoricalPnL history = 1; */
        for (let i = 0; i < message.history.length; i++)
            HistoricalPnL.internalBinaryWrite(message.history[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.PnlHistoryResponse
 */
export const PnlHistoryResponse = new PnlHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalPnL$Type extends MessageType<HistoricalPnL> {
    constructor() {
        super("injective_megavault_rpc.HistoricalPnL", [
            { no: 1, name: "t", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "v", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalPnL>): HistoricalPnL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0n;
        message.v = "";
        if (value !== undefined)
            reflectionMergePartial<HistoricalPnL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalPnL): HistoricalPnL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 t */ 1:
                    message.t = reader.sint64().toBigInt();
                    break;
                case /* string v */ 2:
                    message.v = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalPnL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 t = 1; */
        if (message.t !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.t);
        /* string v = 2; */
        if (message.v !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.v);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.HistoricalPnL
 */
export const HistoricalPnL = new HistoricalPnL$Type();
/**
 * @generated ServiceType for protobuf service injective_megavault_rpc.InjectiveMegavaultRPC
 */
export const InjectiveMegavaultRPC = new ServiceType("injective_megavault_rpc.InjectiveMegavaultRPC", [
    { name: "GetVault", options: {}, I: GetVaultRequest, O: GetVaultResponse },
    { name: "GetUser", options: {}, I: GetUserRequest, O: GetUserResponse },
    { name: "ListSubscriptions", options: {}, I: ListSubscriptionsRequest, O: ListSubscriptionsResponse },
    { name: "ListRedemptions", options: {}, I: ListRedemptionsRequest, O: ListRedemptionsResponse },
    { name: "GetOperatorRedemptionBuckets", options: {}, I: GetOperatorRedemptionBucketsRequest, O: GetOperatorRedemptionBucketsResponse },
    { name: "TvlHistory", options: {}, I: TvlHistoryRequest, O: TvlHistoryResponse },
    { name: "PnlHistory", options: {}, I: PnlHistoryRequest, O: PnlHistoryResponse }
]);
