import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class GetAccountTxsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetAccountTxsRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "before",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "after",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "module",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "from_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "to_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.before = 0n;
    message.after = 0n;
    message.limit = 0;
    message.skip = 0n;
    message.type = "";
    message.module = "";
    message.fromNumber = 0n;
    message.toNumber = 0n;
    message.startTime = 0n;
    message.endTime = 0n;
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* uint64 before */
        2:
          message.before = reader.uint64().toBigInt();
          break;
        case /* uint64 after */
        3:
          message.after = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* string type */
        6:
          message.type = reader.string();
          break;
        case /* string module */
        7:
          message.module = reader.string();
          break;
        case /* sint64 from_number */
        8:
          message.fromNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 to_number */
        9:
          message.toNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 start_time */
        10:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        11:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* string status */
        12:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.before !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.before);
    if (message.after !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.after);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.type !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.type);
    if (message.module !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.module);
    if (message.fromNumber !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.fromNumber);
    if (message.toNumber !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.toNumber);
    if (message.startTime !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.endTime);
    if (message.status !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetAccountTxsRequest = new GetAccountTxsRequest$Type();
class GetAccountTxsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetAccountTxsResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => TxDetailData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.TxDetailData data */
        2:
          message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetAccountTxsResponse = new GetAccountTxsResponse$Type();
class Paging$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Paging", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "from",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "to",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "count_by_subaccount",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total = 0n;
    message.from = 0;
    message.to = 0;
    message.countBySubaccount = 0n;
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 total */
        1:
          message.total = reader.sint64().toBigInt();
          break;
        case /* sint32 from */
        2:
          message.from = reader.sint32();
          break;
        case /* sint32 to */
        3:
          message.to = reader.sint32();
          break;
        case /* sint64 count_by_subaccount */
        4:
          message.countBySubaccount = reader.sint64().toBigInt();
          break;
        case /* repeated string next */
        5:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.total);
    if (message.from !== 0)
      writer.tag(2, WireType.Varint).sint32(message.from);
    if (message.to !== 0)
      writer.tag(3, WireType.Varint).sint32(message.to);
    if (message.countBySubaccount !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
    for (let i = 0; i < message.next.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Paging = new Paging$Type();
class TxDetailData$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.TxDetailData", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "block_timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "gas_wanted",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "gas_used",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 11, name: "gas_fee", kind: "message", T: () => GasFee },
      {
        no: 12,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 13, name: "events", kind: "message", repeat: 2, T: () => Event },
      {
        no: 14,
        name: "tx_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "messages",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 16, name: "signatures", kind: "message", repeat: 2, T: () => Signature },
      {
        no: 17,
        name: "memo",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 18,
        name: "tx_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 19,
        name: "block_unix_timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 20,
        name: "error_log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: "logs",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 22,
        name: "claim_ids",
        kind: "scalar",
        repeat: 1,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.blockNumber = 0n;
    message.blockTimestamp = "";
    message.hash = "";
    message.code = 0;
    message.data = new Uint8Array(0);
    message.info = "";
    message.gasWanted = 0n;
    message.gasUsed = 0n;
    message.codespace = "";
    message.events = [];
    message.txType = "";
    message.messages = new Uint8Array(0);
    message.signatures = [];
    message.memo = "";
    message.txNumber = 0n;
    message.blockUnixTimestamp = 0n;
    message.errorLog = "";
    message.logs = new Uint8Array(0);
    message.claimIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* uint64 block_number */
        2:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        case /* string block_timestamp */
        3:
          message.blockTimestamp = reader.string();
          break;
        case /* string hash */
        4:
          message.hash = reader.string();
          break;
        case /* uint32 code */
        5:
          message.code = reader.uint32();
          break;
        case /* bytes data */
        6:
          message.data = reader.bytes();
          break;
        case /* string info */
        8:
          message.info = reader.string();
          break;
        case /* sint64 gas_wanted */
        9:
          message.gasWanted = reader.sint64().toBigInt();
          break;
        case /* sint64 gas_used */
        10:
          message.gasUsed = reader.sint64().toBigInt();
          break;
        case /* injective_explorer_rpc.GasFee gas_fee */
        11:
          message.gasFee = GasFee.internalBinaryRead(reader, reader.uint32(), options, message.gasFee);
          break;
        case /* string codespace */
        12:
          message.codespace = reader.string();
          break;
        case /* repeated injective_explorer_rpc.Event events */
        13:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string tx_type */
        14:
          message.txType = reader.string();
          break;
        case /* bytes messages */
        15:
          message.messages = reader.bytes();
          break;
        case /* repeated injective_explorer_rpc.Signature signatures */
        16:
          message.signatures.push(Signature.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string memo */
        17:
          message.memo = reader.string();
          break;
        case /* uint64 tx_number */
        18:
          message.txNumber = reader.uint64().toBigInt();
          break;
        case /* uint64 block_unix_timestamp */
        19:
          message.blockUnixTimestamp = reader.uint64().toBigInt();
          break;
        case /* string error_log */
        20:
          message.errorLog = reader.string();
          break;
        case /* bytes logs */
        21:
          message.logs = reader.bytes();
          break;
        case /* repeated sint64 claim_ids */
        22:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.claimIds.push(reader.sint64().toBigInt());
          else
            message.claimIds.push(reader.sint64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.blockNumber !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.blockNumber);
    if (message.blockTimestamp !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
    if (message.hash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.hash);
    if (message.code !== 0)
      writer.tag(5, WireType.Varint).uint32(message.code);
    if (message.data.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.data);
    if (message.info !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.info);
    if (message.gasWanted !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.gasWanted);
    if (message.gasUsed !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.gasUsed);
    if (message.gasFee)
      GasFee.internalBinaryWrite(message.gasFee, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.codespace !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.codespace);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.txType !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.txType);
    if (message.messages.length)
      writer.tag(15, WireType.LengthDelimited).bytes(message.messages);
    for (let i = 0; i < message.signatures.length; i++)
      Signature.internalBinaryWrite(message.signatures[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.memo !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.memo);
    if (message.txNumber !== 0n)
      writer.tag(18, WireType.Varint).uint64(message.txNumber);
    if (message.blockUnixTimestamp !== 0n)
      writer.tag(19, WireType.Varint).uint64(message.blockUnixTimestamp);
    if (message.errorLog !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.errorLog);
    if (message.logs.length)
      writer.tag(21, WireType.LengthDelimited).bytes(message.logs);
    if (message.claimIds.length) {
      writer.tag(22, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.claimIds.length; i++)
        writer.sint64(message.claimIds[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxDetailData = new TxDetailData$Type();
class GasFee$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GasFee", [
      { no: 1, name: "amount", kind: "message", repeat: 2, T: () => CosmosCoin },
      {
        no: 2,
        name: "gas_limit",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "payer",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.amount = [];
    message.gasLimit = 0n;
    message.payer = "";
    message.granter = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_explorer_rpc.CosmosCoin amount */
        1:
          message.amount.push(CosmosCoin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 gas_limit */
        2:
          message.gasLimit = reader.uint64().toBigInt();
          break;
        case /* string payer */
        3:
          message.payer = reader.string();
          break;
        case /* string granter */
        4:
          message.granter = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.amount.length; i++)
      CosmosCoin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.gasLimit !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.gasLimit);
    if (message.payer !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.payer);
    if (message.granter !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.granter);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GasFee = new GasFee$Type();
class CosmosCoin$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.CosmosCoin", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CosmosCoin = new CosmosCoin$Type();
class Event$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Event", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "attributes", kind: "map", K: 9, V: {
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = "";
    message.attributes = {};
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */
        1:
          message.type = reader.string();
          break;
        case /* map<string, string> attributes */
        2:
          this.binaryReadMap2(message.attributes, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap2(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.string();
          break;
        default:
          throw new globalThis.Error("unknown map entry field for injective_explorer_rpc.Event.attributes");
      }
    }
    map[key ?? ""] = val ?? "";
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    for (let k of globalThis.Object.keys(message.attributes))
      writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.attributes[k]).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Event = new Event$Type();
class Signature$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Signature", [
      {
        no: 1,
        name: "pubkey",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "signature",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.pubkey = "";
    message.address = "";
    message.sequence = 0n;
    message.signature = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string pubkey */
        1:
          message.pubkey = reader.string();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        case /* uint64 sequence */
        3:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* string signature */
        4:
          message.signature = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.pubkey !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.pubkey);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    if (message.sequence !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.sequence);
    if (message.signature !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.signature);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Signature = new Signature$Type();
class GetAccountTxsV2Request$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetAccountTxsV2Request", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.type = "";
    message.startTime = 0n;
    message.endTime = 0n;
    message.perPage = 0;
    message.token = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string type */
        2:
          message.type = reader.string();
          break;
        case /* sint64 start_time */
        3:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        4:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* sint32 per_page */
        5:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        6:
          message.token = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.type !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.type);
    if (message.startTime !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.endTime);
    if (message.perPage !== 0)
      writer.tag(5, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.token);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetAccountTxsV2Request = new GetAccountTxsV2Request$Type();
class GetAccountTxsV2Response$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetAccountTxsV2Response", [
      { no: 1, name: "paging", kind: "message", T: () => Cursor },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => TxDetailData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Cursor paging */
        1:
          message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.TxDetailData data */
        2:
          message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetAccountTxsV2Response = new GetAccountTxsV2Response$Type();
class Cursor$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Cursor", [
      {
        no: 1,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string next */
        1:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.next.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Cursor = new Cursor$Type();
class GetContractTxsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetContractTxsRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "from_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "to_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.limit = 0;
    message.skip = 0n;
    message.fromNumber = 0n;
    message.toNumber = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* sint32 limit */
        2:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        3:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint64 from_number */
        4:
          message.fromNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 to_number */
        5:
          message.toNumber = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.limit !== 0)
      writer.tag(2, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.skip);
    if (message.fromNumber !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.fromNumber);
    if (message.toNumber !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.toNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetContractTxsRequest = new GetContractTxsRequest$Type();
class GetContractTxsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetContractTxsResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => TxDetailData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.TxDetailData data */
        2:
          message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetContractTxsResponse = new GetContractTxsResponse$Type();
class GetContractTxsV2Request$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetContractTxsV2Request", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "to",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.height = 0n;
    message.from = 0n;
    message.to = 0n;
    message.perPage = 0;
    message.token = "";
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* uint64 height */
        2:
          message.height = reader.uint64().toBigInt();
          break;
        case /* sint64 from */
        3:
          message.from = reader.sint64().toBigInt();
          break;
        case /* sint64 to */
        4:
          message.to = reader.sint64().toBigInt();
          break;
        case /* sint32 per_page */
        5:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        6:
          message.token = reader.string();
          break;
        case /* string status */
        7:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.height !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.height);
    if (message.from !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.from);
    if (message.to !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.to);
    if (message.perPage !== 0)
      writer.tag(5, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.token);
    if (message.status !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetContractTxsV2Request = new GetContractTxsV2Request$Type();
class GetContractTxsV2Response$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetContractTxsV2Response", [
      { no: 1, name: "paging", kind: "message", T: () => Cursor },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => TxDetailData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Cursor paging */
        1:
          message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.TxDetailData data */
        2:
          message.data.push(TxDetailData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      TxDetailData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetContractTxsV2Response = new GetContractTxsV2Response$Type();
class GetBlocksRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBlocksRequest", [
      {
        no: 1,
        name: "before",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "after",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "from",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "to",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.before = 0n;
    message.after = 0n;
    message.limit = 0;
    message.from = 0n;
    message.to = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 before */
        1:
          message.before = reader.uint64().toBigInt();
          break;
        case /* uint64 after */
        2:
          message.after = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* uint64 from */
        4:
          message.from = reader.uint64().toBigInt();
          break;
        case /* uint64 to */
        5:
          message.to = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.before !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.before);
    if (message.after !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.after);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.from !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.from);
    if (message.to !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.to);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBlocksRequest = new GetBlocksRequest$Type();
class GetBlocksResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBlocksResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => BlockInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.BlockInfo data */
        2:
          message.data.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      BlockInfo.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBlocksResponse = new GetBlocksResponse$Type();
class BlockInfo$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.BlockInfo", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "proposer",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "moniker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "block_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "parent_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "num_pre_commits",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "num_txs",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 8, name: "txs", kind: "message", repeat: 2, T: () => TxDataRPC },
      {
        no: 9,
        name: "timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "block_unix_timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.proposer = "";
    message.moniker = "";
    message.blockHash = "";
    message.parentHash = "";
    message.numPreCommits = 0n;
    message.numTxs = 0n;
    message.txs = [];
    message.timestamp = "";
    message.blockUnixTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 height */
        1:
          message.height = reader.uint64().toBigInt();
          break;
        case /* string proposer */
        2:
          message.proposer = reader.string();
          break;
        case /* string moniker */
        3:
          message.moniker = reader.string();
          break;
        case /* string block_hash */
        4:
          message.blockHash = reader.string();
          break;
        case /* string parent_hash */
        5:
          message.parentHash = reader.string();
          break;
        case /* sint64 num_pre_commits */
        6:
          message.numPreCommits = reader.sint64().toBigInt();
          break;
        case /* sint64 num_txs */
        7:
          message.numTxs = reader.sint64().toBigInt();
          break;
        case /* repeated injective_explorer_rpc.TxDataRPC txs */
        8:
          message.txs.push(TxDataRPC.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string timestamp */
        9:
          message.timestamp = reader.string();
          break;
        case /* uint64 block_unix_timestamp */
        10:
          message.blockUnixTimestamp = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.height);
    if (message.proposer !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.proposer);
    if (message.moniker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.moniker);
    if (message.blockHash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.blockHash);
    if (message.parentHash !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.parentHash);
    if (message.numPreCommits !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.numPreCommits);
    if (message.numTxs !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.numTxs);
    for (let i = 0; i < message.txs.length; i++)
      TxDataRPC.internalBinaryWrite(message.txs[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.timestamp);
    if (message.blockUnixTimestamp !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.blockUnixTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BlockInfo = new BlockInfo$Type();
class TxDataRPC$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.TxDataRPC", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "block_timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "messages",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "tx_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "error_log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 10,
        name: "claim_ids",
        kind: "scalar",
        repeat: 1,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.blockNumber = 0n;
    message.blockTimestamp = "";
    message.hash = "";
    message.codespace = "";
    message.messages = "";
    message.txNumber = 0n;
    message.errorLog = "";
    message.code = 0;
    message.claimIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* uint64 block_number */
        2:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        case /* string block_timestamp */
        3:
          message.blockTimestamp = reader.string();
          break;
        case /* string hash */
        4:
          message.hash = reader.string();
          break;
        case /* string codespace */
        5:
          message.codespace = reader.string();
          break;
        case /* string messages */
        6:
          message.messages = reader.string();
          break;
        case /* uint64 tx_number */
        7:
          message.txNumber = reader.uint64().toBigInt();
          break;
        case /* string error_log */
        8:
          message.errorLog = reader.string();
          break;
        case /* uint32 code */
        9:
          message.code = reader.uint32();
          break;
        case /* repeated sint64 claim_ids */
        10:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.claimIds.push(reader.sint64().toBigInt());
          else
            message.claimIds.push(reader.sint64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.blockNumber !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.blockNumber);
    if (message.blockTimestamp !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
    if (message.hash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.hash);
    if (message.codespace !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.codespace);
    if (message.messages !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.messages);
    if (message.txNumber !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.txNumber);
    if (message.errorLog !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.errorLog);
    if (message.code !== 0)
      writer.tag(9, WireType.Varint).uint32(message.code);
    if (message.claimIds.length) {
      writer.tag(10, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.claimIds.length; i++)
        writer.sint64(message.claimIds[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxDataRPC = new TxDataRPC$Type();
class GetBlocksV2Request$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBlocksV2Request", [
      {
        no: 1,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.perPage = 0;
    message.token = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint32 per_page */
        1:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        2:
          message.token = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.perPage !== 0)
      writer.tag(1, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.token);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBlocksV2Request = new GetBlocksV2Request$Type();
class GetBlocksV2Response$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBlocksV2Response", [
      { no: 1, name: "paging", kind: "message", T: () => Cursor },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => BlockInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Cursor paging */
        1:
          message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.BlockInfo data */
        2:
          message.data.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      BlockInfo.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBlocksV2Response = new GetBlocksV2Response$Type();
class GetBlockRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBlockRequest", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBlockRequest = new GetBlockRequest$Type();
class GetBlockResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBlockResponse", [
      {
        no: 1,
        name: "s",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "errmsg",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "data", kind: "message", T: () => BlockDetailInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.s = "";
    message.errmsg = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string s */
        1:
          message.s = reader.string();
          break;
        case /* string errmsg */
        2:
          message.errmsg = reader.string();
          break;
        case /* injective_explorer_rpc.BlockDetailInfo data */
        3:
          message.data = BlockDetailInfo.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.s !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.s);
    if (message.errmsg !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
    if (message.data)
      BlockDetailInfo.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBlockResponse = new GetBlockResponse$Type();
class BlockDetailInfo$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.BlockDetailInfo", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "proposer",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "moniker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "block_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "parent_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "num_pre_commits",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "num_txs",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "total_txs",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 9, name: "txs", kind: "message", repeat: 2, T: () => TxData },
      {
        no: 10,
        name: "timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "block_unix_timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.proposer = "";
    message.moniker = "";
    message.blockHash = "";
    message.parentHash = "";
    message.numPreCommits = 0n;
    message.numTxs = 0n;
    message.totalTxs = 0n;
    message.txs = [];
    message.timestamp = "";
    message.blockUnixTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 height */
        1:
          message.height = reader.uint64().toBigInt();
          break;
        case /* string proposer */
        2:
          message.proposer = reader.string();
          break;
        case /* string moniker */
        3:
          message.moniker = reader.string();
          break;
        case /* string block_hash */
        4:
          message.blockHash = reader.string();
          break;
        case /* string parent_hash */
        5:
          message.parentHash = reader.string();
          break;
        case /* sint64 num_pre_commits */
        6:
          message.numPreCommits = reader.sint64().toBigInt();
          break;
        case /* sint64 num_txs */
        7:
          message.numTxs = reader.sint64().toBigInt();
          break;
        case /* sint64 total_txs */
        8:
          message.totalTxs = reader.sint64().toBigInt();
          break;
        case /* repeated injective_explorer_rpc.TxData txs */
        9:
          message.txs.push(TxData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string timestamp */
        10:
          message.timestamp = reader.string();
          break;
        case /* uint64 block_unix_timestamp */
        11:
          message.blockUnixTimestamp = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.height);
    if (message.proposer !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.proposer);
    if (message.moniker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.moniker);
    if (message.blockHash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.blockHash);
    if (message.parentHash !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.parentHash);
    if (message.numPreCommits !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.numPreCommits);
    if (message.numTxs !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.numTxs);
    if (message.totalTxs !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.totalTxs);
    for (let i = 0; i < message.txs.length; i++)
      TxData.internalBinaryWrite(message.txs[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.timestamp);
    if (message.blockUnixTimestamp !== 0n)
      writer.tag(11, WireType.Varint).uint64(message.blockUnixTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BlockDetailInfo = new BlockDetailInfo$Type();
class TxData$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.TxData", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "block_timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "messages",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "tx_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "error_log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 10,
        name: "tx_msg_types",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 11,
        name: "logs",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 12,
        name: "claim_ids",
        kind: "scalar",
        repeat: 1,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 13, name: "signatures", kind: "message", repeat: 2, T: () => Signature },
      {
        no: 14,
        name: "block_unix_timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 15,
        name: "ethereum_tx_hash_hex",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.blockNumber = 0n;
    message.blockTimestamp = "";
    message.hash = "";
    message.codespace = "";
    message.messages = new Uint8Array(0);
    message.txNumber = 0n;
    message.errorLog = "";
    message.code = 0;
    message.txMsgTypes = new Uint8Array(0);
    message.logs = new Uint8Array(0);
    message.claimIds = [];
    message.signatures = [];
    message.blockUnixTimestamp = 0n;
    message.ethereumTxHashHex = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* uint64 block_number */
        2:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        case /* string block_timestamp */
        3:
          message.blockTimestamp = reader.string();
          break;
        case /* string hash */
        4:
          message.hash = reader.string();
          break;
        case /* string codespace */
        5:
          message.codespace = reader.string();
          break;
        case /* bytes messages */
        6:
          message.messages = reader.bytes();
          break;
        case /* uint64 tx_number */
        7:
          message.txNumber = reader.uint64().toBigInt();
          break;
        case /* string error_log */
        8:
          message.errorLog = reader.string();
          break;
        case /* uint32 code */
        9:
          message.code = reader.uint32();
          break;
        case /* bytes tx_msg_types */
        10:
          message.txMsgTypes = reader.bytes();
          break;
        case /* bytes logs */
        11:
          message.logs = reader.bytes();
          break;
        case /* repeated sint64 claim_ids */
        12:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.claimIds.push(reader.sint64().toBigInt());
          else
            message.claimIds.push(reader.sint64().toBigInt());
          break;
        case /* repeated injective_explorer_rpc.Signature signatures */
        13:
          message.signatures.push(Signature.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 block_unix_timestamp */
        14:
          message.blockUnixTimestamp = reader.uint64().toBigInt();
          break;
        case /* string ethereum_tx_hash_hex */
        15:
          message.ethereumTxHashHex = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.blockNumber !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.blockNumber);
    if (message.blockTimestamp !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
    if (message.hash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.hash);
    if (message.codespace !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.codespace);
    if (message.messages.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.messages);
    if (message.txNumber !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.txNumber);
    if (message.errorLog !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.errorLog);
    if (message.code !== 0)
      writer.tag(9, WireType.Varint).uint32(message.code);
    if (message.txMsgTypes.length)
      writer.tag(10, WireType.LengthDelimited).bytes(message.txMsgTypes);
    if (message.logs.length)
      writer.tag(11, WireType.LengthDelimited).bytes(message.logs);
    if (message.claimIds.length) {
      writer.tag(12, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.claimIds.length; i++)
        writer.sint64(message.claimIds[i]);
      writer.join();
    }
    for (let i = 0; i < message.signatures.length; i++)
      Signature.internalBinaryWrite(message.signatures[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.blockUnixTimestamp !== 0n)
      writer.tag(14, WireType.Varint).uint64(message.blockUnixTimestamp);
    if (message.ethereumTxHashHex !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.ethereumTxHashHex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxData = new TxData$Type();
class GetValidatorsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetValidatorsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetValidatorsRequest = new GetValidatorsRequest$Type();
class GetValidatorsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetValidatorsResponse", [
      {
        no: 1,
        name: "s",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "errmsg",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "data", kind: "message", repeat: 2, T: () => Validator }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.s = "";
    message.errmsg = "";
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string s */
        1:
          message.s = reader.string();
          break;
        case /* string errmsg */
        2:
          message.errmsg = reader.string();
          break;
        case /* repeated injective_explorer_rpc.Validator data */
        3:
          message.data.push(Validator.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.s !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.s);
    if (message.errmsg !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
    for (let i = 0; i < message.data.length; i++)
      Validator.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetValidatorsResponse = new GetValidatorsResponse$Type();
class Validator$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Validator", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "moniker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "operator_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "consensus_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "jailed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "status",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 7,
        name: "tokens",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "delegator_shares",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 9, name: "description", kind: "message", T: () => ValidatorDescription },
      {
        no: 10,
        name: "unbonding_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "unbonding_time",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "commission_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "commission_max_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "commission_max_change_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "commission_update_time",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "proposed",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 17,
        name: "signed",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 18,
        name: "missed",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 19,
        name: "timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 20, name: "uptimes", kind: "message", repeat: 2, T: () => ValidatorUptime },
      { no: 21, name: "slashing_events", kind: "message", repeat: 2, T: () => SlashingEvent },
      {
        no: 22,
        name: "uptime_percentage",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 23,
        name: "image_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.moniker = "";
    message.operatorAddress = "";
    message.consensusAddress = "";
    message.jailed = false;
    message.status = 0;
    message.tokens = "";
    message.delegatorShares = "";
    message.unbondingHeight = 0n;
    message.unbondingTime = "";
    message.commissionRate = "";
    message.commissionMaxRate = "";
    message.commissionMaxChangeRate = "";
    message.commissionUpdateTime = "";
    message.proposed = 0n;
    message.signed = 0n;
    message.missed = 0n;
    message.timestamp = "";
    message.uptimes = [];
    message.slashingEvents = [];
    message.uptimePercentage = 0;
    message.imageUrl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string moniker */
        2:
          message.moniker = reader.string();
          break;
        case /* string operator_address */
        3:
          message.operatorAddress = reader.string();
          break;
        case /* string consensus_address */
        4:
          message.consensusAddress = reader.string();
          break;
        case /* bool jailed */
        5:
          message.jailed = reader.bool();
          break;
        case /* sint32 status */
        6:
          message.status = reader.sint32();
          break;
        case /* string tokens */
        7:
          message.tokens = reader.string();
          break;
        case /* string delegator_shares */
        8:
          message.delegatorShares = reader.string();
          break;
        case /* injective_explorer_rpc.ValidatorDescription description */
        9:
          message.description = ValidatorDescription.internalBinaryRead(reader, reader.uint32(), options, message.description);
          break;
        case /* sint64 unbonding_height */
        10:
          message.unbondingHeight = reader.sint64().toBigInt();
          break;
        case /* string unbonding_time */
        11:
          message.unbondingTime = reader.string();
          break;
        case /* string commission_rate */
        12:
          message.commissionRate = reader.string();
          break;
        case /* string commission_max_rate */
        13:
          message.commissionMaxRate = reader.string();
          break;
        case /* string commission_max_change_rate */
        14:
          message.commissionMaxChangeRate = reader.string();
          break;
        case /* string commission_update_time */
        15:
          message.commissionUpdateTime = reader.string();
          break;
        case /* uint64 proposed */
        16:
          message.proposed = reader.uint64().toBigInt();
          break;
        case /* uint64 signed */
        17:
          message.signed = reader.uint64().toBigInt();
          break;
        case /* uint64 missed */
        18:
          message.missed = reader.uint64().toBigInt();
          break;
        case /* string timestamp */
        19:
          message.timestamp = reader.string();
          break;
        case /* repeated injective_explorer_rpc.ValidatorUptime uptimes */
        20:
          message.uptimes.push(ValidatorUptime.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective_explorer_rpc.SlashingEvent slashing_events */
        21:
          message.slashingEvents.push(SlashingEvent.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* double uptime_percentage */
        22:
          message.uptimePercentage = reader.double();
          break;
        case /* string image_url */
        23:
          message.imageUrl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.moniker !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.moniker);
    if (message.operatorAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.operatorAddress);
    if (message.consensusAddress !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.consensusAddress);
    if (message.jailed !== false)
      writer.tag(5, WireType.Varint).bool(message.jailed);
    if (message.status !== 0)
      writer.tag(6, WireType.Varint).sint32(message.status);
    if (message.tokens !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.tokens);
    if (message.delegatorShares !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.delegatorShares);
    if (message.description)
      ValidatorDescription.internalBinaryWrite(message.description, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.unbondingHeight !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.unbondingHeight);
    if (message.unbondingTime !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.unbondingTime);
    if (message.commissionRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.commissionRate);
    if (message.commissionMaxRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.commissionMaxRate);
    if (message.commissionMaxChangeRate !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.commissionMaxChangeRate);
    if (message.commissionUpdateTime !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.commissionUpdateTime);
    if (message.proposed !== 0n)
      writer.tag(16, WireType.Varint).uint64(message.proposed);
    if (message.signed !== 0n)
      writer.tag(17, WireType.Varint).uint64(message.signed);
    if (message.missed !== 0n)
      writer.tag(18, WireType.Varint).uint64(message.missed);
    if (message.timestamp !== "")
      writer.tag(19, WireType.LengthDelimited).string(message.timestamp);
    for (let i = 0; i < message.uptimes.length; i++)
      ValidatorUptime.internalBinaryWrite(message.uptimes[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.slashingEvents.length; i++)
      SlashingEvent.internalBinaryWrite(message.slashingEvents[i], writer.tag(21, WireType.LengthDelimited).fork(), options).join();
    if (message.uptimePercentage !== 0)
      writer.tag(22, WireType.Bit64).double(message.uptimePercentage);
    if (message.imageUrl !== "")
      writer.tag(23, WireType.LengthDelimited).string(message.imageUrl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Validator = new Validator$Type();
class ValidatorDescription$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.ValidatorDescription", [
      {
        no: 1,
        name: "moniker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "identity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "website",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "security_contact",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "details",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "image_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.moniker = "";
    message.identity = "";
    message.website = "";
    message.securityContact = "";
    message.details = "";
    message.imageUrl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string moniker */
        1:
          message.moniker = reader.string();
          break;
        case /* string identity */
        2:
          message.identity = reader.string();
          break;
        case /* string website */
        3:
          message.website = reader.string();
          break;
        case /* string security_contact */
        4:
          message.securityContact = reader.string();
          break;
        case /* string details */
        5:
          message.details = reader.string();
          break;
        case /* string image_url */
        6:
          message.imageUrl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.moniker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.moniker);
    if (message.identity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.identity);
    if (message.website !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.website);
    if (message.securityContact !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.securityContact);
    if (message.details !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.details);
    if (message.imageUrl !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.imageUrl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorDescription = new ValidatorDescription$Type();
class ValidatorUptime$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.ValidatorUptime", [
      {
        no: 1,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.blockNumber = 0n;
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 block_number */
        1:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        case /* string status */
        2:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.blockNumber !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.blockNumber);
    if (message.status !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorUptime = new ValidatorUptime$Type();
class SlashingEvent$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.SlashingEvent", [
      {
        no: 1,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "block_timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "power",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "jailed",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "missed_blocks",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.blockNumber = 0n;
    message.blockTimestamp = "";
    message.address = "";
    message.power = 0n;
    message.reason = "";
    message.jailed = "";
    message.missedBlocks = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 block_number */
        1:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        case /* string block_timestamp */
        2:
          message.blockTimestamp = reader.string();
          break;
        case /* string address */
        3:
          message.address = reader.string();
          break;
        case /* uint64 power */
        4:
          message.power = reader.uint64().toBigInt();
          break;
        case /* string reason */
        5:
          message.reason = reader.string();
          break;
        case /* string jailed */
        6:
          message.jailed = reader.string();
          break;
        case /* uint64 missed_blocks */
        7:
          message.missedBlocks = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.blockNumber !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.blockNumber);
    if (message.blockTimestamp !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.blockTimestamp);
    if (message.address !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.address);
    if (message.power !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.power);
    if (message.reason !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.reason);
    if (message.jailed !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.jailed);
    if (message.missedBlocks !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.missedBlocks);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SlashingEvent = new SlashingEvent$Type();
class GetValidatorRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetValidatorRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetValidatorRequest = new GetValidatorRequest$Type();
class GetValidatorResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetValidatorResponse", [
      {
        no: 1,
        name: "s",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "errmsg",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "data", kind: "message", T: () => Validator }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.s = "";
    message.errmsg = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string s */
        1:
          message.s = reader.string();
          break;
        case /* string errmsg */
        2:
          message.errmsg = reader.string();
          break;
        case /* injective_explorer_rpc.Validator data */
        3:
          message.data = Validator.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.s !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.s);
    if (message.errmsg !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
    if (message.data)
      Validator.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetValidatorResponse = new GetValidatorResponse$Type();
class GetValidatorUptimeRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetValidatorUptimeRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetValidatorUptimeRequest = new GetValidatorUptimeRequest$Type();
class GetValidatorUptimeResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetValidatorUptimeResponse", [
      {
        no: 1,
        name: "s",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "errmsg",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "data", kind: "message", repeat: 2, T: () => ValidatorUptime }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.s = "";
    message.errmsg = "";
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string s */
        1:
          message.s = reader.string();
          break;
        case /* string errmsg */
        2:
          message.errmsg = reader.string();
          break;
        case /* repeated injective_explorer_rpc.ValidatorUptime data */
        3:
          message.data.push(ValidatorUptime.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.s !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.s);
    if (message.errmsg !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
    for (let i = 0; i < message.data.length; i++)
      ValidatorUptime.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetValidatorUptimeResponse = new GetValidatorUptimeResponse$Type();
class GetTxsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetTxsRequest", [
      {
        no: 1,
        name: "before",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "after",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "module",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "from_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "to_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.before = 0n;
    message.after = 0n;
    message.limit = 0;
    message.skip = 0n;
    message.type = "";
    message.module = "";
    message.fromNumber = 0n;
    message.toNumber = 0n;
    message.startTime = 0n;
    message.endTime = 0n;
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 before */
        1:
          message.before = reader.uint64().toBigInt();
          break;
        case /* uint64 after */
        2:
          message.after = reader.uint64().toBigInt();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* string type */
        5:
          message.type = reader.string();
          break;
        case /* string module */
        6:
          message.module = reader.string();
          break;
        case /* sint64 from_number */
        7:
          message.fromNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 to_number */
        8:
          message.toNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 start_time */
        9:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        10:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* string status */
        11:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.before !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.before);
    if (message.after !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.after);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    if (message.type !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.type);
    if (message.module !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.module);
    if (message.fromNumber !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.fromNumber);
    if (message.toNumber !== 0n)
      writer.tag(8, WireType.Varint).sint64(message.toNumber);
    if (message.startTime !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.endTime);
    if (message.status !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxsRequest = new GetTxsRequest$Type();
class GetTxsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetTxsResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => TxData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.TxData data */
        2:
          message.data.push(TxData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      TxData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxsResponse = new GetTxsResponse$Type();
class GetTxsV2Request$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetTxsV2Request", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = "";
    message.startTime = 0n;
    message.endTime = 0n;
    message.perPage = 0;
    message.token = "";
    message.status = "";
    message.blockNumber = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */
        1:
          message.type = reader.string();
          break;
        case /* sint64 start_time */
        2:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        3:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* sint32 per_page */
        4:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        5:
          message.token = reader.string();
          break;
        case /* string status */
        6:
          message.status = reader.string();
          break;
        case /* uint64 block_number */
        7:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    if (message.startTime !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.endTime);
    if (message.perPage !== 0)
      writer.tag(4, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.token);
    if (message.status !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.status);
    if (message.blockNumber !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.blockNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxsV2Request = new GetTxsV2Request$Type();
class GetTxsV2Response$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetTxsV2Response", [
      { no: 1, name: "paging", kind: "message", T: () => Cursor },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => TxData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Cursor paging */
        1:
          message.paging = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.TxData data */
        2:
          message.data.push(TxData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Cursor.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      TxData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxsV2Response = new GetTxsV2Response$Type();
class GetTxByTxHashRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetTxByTxHashRequest", [
      {
        no: 1,
        name: "hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "is_evm_hash",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = "";
    message.isEvmHash = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string hash */
        1:
          message.hash = reader.string();
          break;
        case /* bool is_evm_hash */
        2:
          message.isEvmHash = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.hash);
    if (message.isEvmHash !== false)
      writer.tag(2, WireType.Varint).bool(message.isEvmHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxByTxHashRequest = new GetTxByTxHashRequest$Type();
class GetTxByTxHashResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetTxByTxHashResponse", [
      {
        no: 1,
        name: "s",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "errmsg",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "data", kind: "message", T: () => TxDetailData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.s = "";
    message.errmsg = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string s */
        1:
          message.s = reader.string();
          break;
        case /* string errmsg */
        2:
          message.errmsg = reader.string();
          break;
        case /* injective_explorer_rpc.TxDetailData data */
        3:
          message.data = TxDetailData.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.s !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.s);
    if (message.errmsg !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.errmsg);
    if (message.data)
      TxDetailData.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxByTxHashResponse = new GetTxByTxHashResponse$Type();
class GetPeggyDepositTxsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetPeggyDepositTxsRequest", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "receiver",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.receiver = "";
    message.limit = 0;
    message.skip = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string receiver */
        2:
          message.receiver = reader.string();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.receiver !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.receiver);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetPeggyDepositTxsRequest = new GetPeggyDepositTxsRequest$Type();
class GetPeggyDepositTxsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetPeggyDepositTxsResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => PeggyDepositTx }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_explorer_rpc.PeggyDepositTx field */
        1:
          message.field.push(PeggyDepositTx.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      PeggyDepositTx.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetPeggyDepositTxsResponse = new GetPeggyDepositTxsResponse$Type();
class PeggyDepositTx$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.PeggyDepositTx", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "receiver",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "event_nonce",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "event_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "orchestrator_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "claim_type",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 10,
        name: "tx_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.receiver = "";
    message.eventNonce = 0n;
    message.eventHeight = 0n;
    message.amount = "";
    message.denom = "";
    message.orchestratorAddress = "";
    message.state = "";
    message.claimType = 0;
    message.txHashes = [];
    message.createdAt = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string receiver */
        2:
          message.receiver = reader.string();
          break;
        case /* uint64 event_nonce */
        3:
          message.eventNonce = reader.uint64().toBigInt();
          break;
        case /* uint64 event_height */
        4:
          message.eventHeight = reader.uint64().toBigInt();
          break;
        case /* string amount */
        5:
          message.amount = reader.string();
          break;
        case /* string denom */
        6:
          message.denom = reader.string();
          break;
        case /* string orchestrator_address */
        7:
          message.orchestratorAddress = reader.string();
          break;
        case /* string state */
        8:
          message.state = reader.string();
          break;
        case /* sint32 claim_type */
        9:
          message.claimType = reader.sint32();
          break;
        case /* repeated string tx_hashes */
        10:
          message.txHashes.push(reader.string());
          break;
        case /* string created_at */
        11:
          message.createdAt = reader.string();
          break;
        case /* string updated_at */
        12:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.receiver !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.receiver);
    if (message.eventNonce !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.eventNonce);
    if (message.eventHeight !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.eventHeight);
    if (message.amount !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.amount);
    if (message.denom !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.denom);
    if (message.orchestratorAddress !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.orchestratorAddress);
    if (message.state !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.state);
    if (message.claimType !== 0)
      writer.tag(9, WireType.Varint).sint32(message.claimType);
    for (let i = 0; i < message.txHashes.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.txHashes[i]);
    if (message.createdAt !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.createdAt);
    if (message.updatedAt !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PeggyDepositTx = new PeggyDepositTx$Type();
class GetPeggyWithdrawalTxsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetPeggyWithdrawalTxsRequest", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "receiver",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.receiver = "";
    message.limit = 0;
    message.skip = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string receiver */
        2:
          message.receiver = reader.string();
          break;
        case /* sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        4:
          message.skip = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.receiver !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.receiver);
    if (message.limit !== 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.skip);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetPeggyWithdrawalTxsRequest = new GetPeggyWithdrawalTxsRequest$Type();
class GetPeggyWithdrawalTxsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetPeggyWithdrawalTxsResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => PeggyWithdrawalTx }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_explorer_rpc.PeggyWithdrawalTx field */
        1:
          message.field.push(PeggyWithdrawalTx.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      PeggyWithdrawalTx.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetPeggyWithdrawalTxsResponse = new GetPeggyWithdrawalTxsResponse$Type();
class PeggyWithdrawalTx$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.PeggyWithdrawalTx", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "receiver",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "bridge_fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "outgoing_tx_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "batch_timeout",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "batch_nonce",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "orchestrator_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "event_nonce",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "event_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "claim_type",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 14,
        name: "tx_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.receiver = "";
    message.amount = "";
    message.denom = "";
    message.bridgeFee = "";
    message.outgoingTxId = 0n;
    message.batchTimeout = 0n;
    message.batchNonce = 0n;
    message.orchestratorAddress = "";
    message.eventNonce = 0n;
    message.eventHeight = 0n;
    message.state = "";
    message.claimType = 0;
    message.txHashes = [];
    message.createdAt = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string receiver */
        2:
          message.receiver = reader.string();
          break;
        case /* string amount */
        3:
          message.amount = reader.string();
          break;
        case /* string denom */
        4:
          message.denom = reader.string();
          break;
        case /* string bridge_fee */
        5:
          message.bridgeFee = reader.string();
          break;
        case /* uint64 outgoing_tx_id */
        6:
          message.outgoingTxId = reader.uint64().toBigInt();
          break;
        case /* uint64 batch_timeout */
        7:
          message.batchTimeout = reader.uint64().toBigInt();
          break;
        case /* uint64 batch_nonce */
        8:
          message.batchNonce = reader.uint64().toBigInt();
          break;
        case /* string orchestrator_address */
        9:
          message.orchestratorAddress = reader.string();
          break;
        case /* uint64 event_nonce */
        10:
          message.eventNonce = reader.uint64().toBigInt();
          break;
        case /* uint64 event_height */
        11:
          message.eventHeight = reader.uint64().toBigInt();
          break;
        case /* string state */
        12:
          message.state = reader.string();
          break;
        case /* sint32 claim_type */
        13:
          message.claimType = reader.sint32();
          break;
        case /* repeated string tx_hashes */
        14:
          message.txHashes.push(reader.string());
          break;
        case /* string created_at */
        15:
          message.createdAt = reader.string();
          break;
        case /* string updated_at */
        16:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.receiver !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.receiver);
    if (message.amount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.amount);
    if (message.denom !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.denom);
    if (message.bridgeFee !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.bridgeFee);
    if (message.outgoingTxId !== 0n)
      writer.tag(6, WireType.Varint).uint64(message.outgoingTxId);
    if (message.batchTimeout !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.batchTimeout);
    if (message.batchNonce !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.batchNonce);
    if (message.orchestratorAddress !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.orchestratorAddress);
    if (message.eventNonce !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.eventNonce);
    if (message.eventHeight !== 0n)
      writer.tag(11, WireType.Varint).uint64(message.eventHeight);
    if (message.state !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.state);
    if (message.claimType !== 0)
      writer.tag(13, WireType.Varint).sint32(message.claimType);
    for (let i = 0; i < message.txHashes.length; i++)
      writer.tag(14, WireType.LengthDelimited).string(message.txHashes[i]);
    if (message.createdAt !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.createdAt);
    if (message.updatedAt !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PeggyWithdrawalTx = new PeggyWithdrawalTx$Type();
class GetIBCTransferTxsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetIBCTransferTxsRequest", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "receiver",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "src_channel",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "src_port",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "dest_channel",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "dest_port",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 8,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.receiver = "";
    message.srcChannel = "";
    message.srcPort = "";
    message.destChannel = "";
    message.destPort = "";
    message.limit = 0;
    message.skip = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string receiver */
        2:
          message.receiver = reader.string();
          break;
        case /* string src_channel */
        3:
          message.srcChannel = reader.string();
          break;
        case /* string src_port */
        4:
          message.srcPort = reader.string();
          break;
        case /* string dest_channel */
        5:
          message.destChannel = reader.string();
          break;
        case /* string dest_port */
        6:
          message.destPort = reader.string();
          break;
        case /* sint32 limit */
        7:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        8:
          message.skip = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.receiver !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.receiver);
    if (message.srcChannel !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.srcChannel);
    if (message.srcPort !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.srcPort);
    if (message.destChannel !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.destChannel);
    if (message.destPort !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.destPort);
    if (message.limit !== 0)
      writer.tag(7, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.skip);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIBCTransferTxsRequest = new GetIBCTransferTxsRequest$Type();
class GetIBCTransferTxsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetIBCTransferTxsResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => IBCTransferTx }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_explorer_rpc.IBCTransferTx field */
        1:
          message.field.push(IBCTransferTx.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      IBCTransferTx.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIBCTransferTxsResponse = new GetIBCTransferTxsResponse$Type();
class IBCTransferTx$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.IBCTransferTx", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "receiver",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "source_port",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "source_channel",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "destination_port",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "destination_channel",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "timeout_height",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "timeout_timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "packet_sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "data_hex",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 13,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "tx_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.receiver = "";
    message.sourcePort = "";
    message.sourceChannel = "";
    message.destinationPort = "";
    message.destinationChannel = "";
    message.amount = "";
    message.denom = "";
    message.timeoutHeight = "";
    message.timeoutTimestamp = 0n;
    message.packetSequence = 0n;
    message.dataHex = new Uint8Array(0);
    message.state = "";
    message.txHashes = [];
    message.createdAt = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string receiver */
        2:
          message.receiver = reader.string();
          break;
        case /* string source_port */
        3:
          message.sourcePort = reader.string();
          break;
        case /* string source_channel */
        4:
          message.sourceChannel = reader.string();
          break;
        case /* string destination_port */
        5:
          message.destinationPort = reader.string();
          break;
        case /* string destination_channel */
        6:
          message.destinationChannel = reader.string();
          break;
        case /* string amount */
        7:
          message.amount = reader.string();
          break;
        case /* string denom */
        8:
          message.denom = reader.string();
          break;
        case /* string timeout_height */
        9:
          message.timeoutHeight = reader.string();
          break;
        case /* uint64 timeout_timestamp */
        10:
          message.timeoutTimestamp = reader.uint64().toBigInt();
          break;
        case /* uint64 packet_sequence */
        11:
          message.packetSequence = reader.uint64().toBigInt();
          break;
        case /* bytes data_hex */
        12:
          message.dataHex = reader.bytes();
          break;
        case /* string state */
        13:
          message.state = reader.string();
          break;
        case /* repeated string tx_hashes */
        14:
          message.txHashes.push(reader.string());
          break;
        case /* string created_at */
        15:
          message.createdAt = reader.string();
          break;
        case /* string updated_at */
        16:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.receiver !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.receiver);
    if (message.sourcePort !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.sourcePort);
    if (message.sourceChannel !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.sourceChannel);
    if (message.destinationPort !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.destinationPort);
    if (message.destinationChannel !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.destinationChannel);
    if (message.amount !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.amount);
    if (message.denom !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.denom);
    if (message.timeoutHeight !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.timeoutHeight);
    if (message.timeoutTimestamp !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.timeoutTimestamp);
    if (message.packetSequence !== 0n)
      writer.tag(11, WireType.Varint).uint64(message.packetSequence);
    if (message.dataHex.length)
      writer.tag(12, WireType.LengthDelimited).bytes(message.dataHex);
    if (message.state !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.state);
    for (let i = 0; i < message.txHashes.length; i++)
      writer.tag(14, WireType.LengthDelimited).string(message.txHashes[i]);
    if (message.createdAt !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.createdAt);
    if (message.updatedAt !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IBCTransferTx = new IBCTransferTx$Type();
class GetWasmCodesRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmCodesRequest", [
      {
        no: 1,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "from_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "to_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.limit = 0;
    message.fromNumber = 0n;
    message.toNumber = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint32 limit */
        1:
          message.limit = reader.sint32();
          break;
        case /* sint64 from_number */
        2:
          message.fromNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 to_number */
        3:
          message.toNumber = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.limit !== 0)
      writer.tag(1, WireType.Varint).sint32(message.limit);
    if (message.fromNumber !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.fromNumber);
    if (message.toNumber !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.toNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmCodesRequest = new GetWasmCodesRequest$Type();
class GetWasmCodesResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmCodesResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => WasmCode }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.WasmCode data */
        2:
          message.data.push(WasmCode.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      WasmCode.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmCodesResponse = new GetWasmCodesResponse$Type();
class WasmCode$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.WasmCode", [
      {
        no: 1,
        name: "code_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "checksum", kind: "message", T: () => Checksum },
      {
        no: 4,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "contract_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "permission", kind: "message", T: () => ContractPermission },
      {
        no: 8,
        name: "code_schema",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "code_view",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "instantiates",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "creator",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "code_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "proposal_id",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.codeId = 0n;
    message.txHash = "";
    message.createdAt = 0n;
    message.contractType = "";
    message.version = "";
    message.codeSchema = "";
    message.codeView = "";
    message.instantiates = 0n;
    message.creator = "";
    message.codeNumber = 0n;
    message.proposalId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 code_id */
        1:
          message.codeId = reader.uint64().toBigInt();
          break;
        case /* string tx_hash */
        2:
          message.txHash = reader.string();
          break;
        case /* injective_explorer_rpc.Checksum checksum */
        3:
          message.checksum = Checksum.internalBinaryRead(reader, reader.uint32(), options, message.checksum);
          break;
        case /* uint64 created_at */
        4:
          message.createdAt = reader.uint64().toBigInt();
          break;
        case /* string contract_type */
        5:
          message.contractType = reader.string();
          break;
        case /* string version */
        6:
          message.version = reader.string();
          break;
        case /* injective_explorer_rpc.ContractPermission permission */
        7:
          message.permission = ContractPermission.internalBinaryRead(reader, reader.uint32(), options, message.permission);
          break;
        case /* string code_schema */
        8:
          message.codeSchema = reader.string();
          break;
        case /* string code_view */
        9:
          message.codeView = reader.string();
          break;
        case /* uint64 instantiates */
        10:
          message.instantiates = reader.uint64().toBigInt();
          break;
        case /* string creator */
        11:
          message.creator = reader.string();
          break;
        case /* sint64 code_number */
        12:
          message.codeNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 proposal_id */
        13:
          message.proposalId = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.codeId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.codeId);
    if (message.txHash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.txHash);
    if (message.checksum)
      Checksum.internalBinaryWrite(message.checksum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.createdAt !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.createdAt);
    if (message.contractType !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.contractType);
    if (message.version !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.version);
    if (message.permission)
      ContractPermission.internalBinaryWrite(message.permission, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.codeSchema !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.codeSchema);
    if (message.codeView !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.codeView);
    if (message.instantiates !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.instantiates);
    if (message.creator !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.creator);
    if (message.codeNumber !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.codeNumber);
    if (message.proposalId !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.proposalId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const WasmCode = new WasmCode$Type();
class Checksum$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Checksum", [
      {
        no: 1,
        name: "algorithm",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.algorithm = "";
    message.hash = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string algorithm */
        1:
          message.algorithm = reader.string();
          break;
        case /* string hash */
        2:
          message.hash = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.algorithm !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.algorithm);
    if (message.hash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.hash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Checksum = new Checksum$Type();
class ContractPermission$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.ContractPermission", [
      {
        no: 1,
        name: "access_type",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accessType = 0;
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint32 access_type */
        1:
          message.accessType = reader.sint32();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accessType !== 0)
      writer.tag(1, WireType.Varint).sint32(message.accessType);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ContractPermission = new ContractPermission$Type();
class GetWasmCodeByIDRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmCodeByIDRequest", [
      {
        no: 1,
        name: "code_id",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.codeId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 code_id */
        1:
          message.codeId = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.codeId !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.codeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmCodeByIDRequest = new GetWasmCodeByIDRequest$Type();
class GetWasmCodeByIDResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmCodeByIDResponse", [
      {
        no: 1,
        name: "code_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "checksum", kind: "message", T: () => Checksum },
      {
        no: 4,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "contract_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "permission", kind: "message", T: () => ContractPermission },
      {
        no: 8,
        name: "code_schema",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "code_view",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "instantiates",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "creator",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "code_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "proposal_id",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.codeId = 0n;
    message.txHash = "";
    message.createdAt = 0n;
    message.contractType = "";
    message.version = "";
    message.codeSchema = "";
    message.codeView = "";
    message.instantiates = 0n;
    message.creator = "";
    message.codeNumber = 0n;
    message.proposalId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 code_id */
        1:
          message.codeId = reader.uint64().toBigInt();
          break;
        case /* string tx_hash */
        2:
          message.txHash = reader.string();
          break;
        case /* injective_explorer_rpc.Checksum checksum */
        3:
          message.checksum = Checksum.internalBinaryRead(reader, reader.uint32(), options, message.checksum);
          break;
        case /* uint64 created_at */
        4:
          message.createdAt = reader.uint64().toBigInt();
          break;
        case /* string contract_type */
        5:
          message.contractType = reader.string();
          break;
        case /* string version */
        6:
          message.version = reader.string();
          break;
        case /* injective_explorer_rpc.ContractPermission permission */
        7:
          message.permission = ContractPermission.internalBinaryRead(reader, reader.uint32(), options, message.permission);
          break;
        case /* string code_schema */
        8:
          message.codeSchema = reader.string();
          break;
        case /* string code_view */
        9:
          message.codeView = reader.string();
          break;
        case /* uint64 instantiates */
        10:
          message.instantiates = reader.uint64().toBigInt();
          break;
        case /* string creator */
        11:
          message.creator = reader.string();
          break;
        case /* sint64 code_number */
        12:
          message.codeNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 proposal_id */
        13:
          message.proposalId = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.codeId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.codeId);
    if (message.txHash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.txHash);
    if (message.checksum)
      Checksum.internalBinaryWrite(message.checksum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.createdAt !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.createdAt);
    if (message.contractType !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.contractType);
    if (message.version !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.version);
    if (message.permission)
      ContractPermission.internalBinaryWrite(message.permission, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.codeSchema !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.codeSchema);
    if (message.codeView !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.codeView);
    if (message.instantiates !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.instantiates);
    if (message.creator !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.creator);
    if (message.codeNumber !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.codeNumber);
    if (message.proposalId !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.proposalId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmCodeByIDResponse = new GetWasmCodeByIDResponse$Type();
class GetWasmContractsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmContractsRequest", [
      {
        no: 1,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 2,
        name: "code_id",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "from_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "to_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "assets_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "skip",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "lookup",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.limit = 0;
    message.codeId = 0n;
    message.fromNumber = 0n;
    message.toNumber = 0n;
    message.assetsOnly = false;
    message.skip = 0n;
    message.label = "";
    message.token = "";
    message.lookup = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint32 limit */
        1:
          message.limit = reader.sint32();
          break;
        case /* sint64 code_id */
        2:
          message.codeId = reader.sint64().toBigInt();
          break;
        case /* sint64 from_number */
        3:
          message.fromNumber = reader.sint64().toBigInt();
          break;
        case /* sint64 to_number */
        4:
          message.toNumber = reader.sint64().toBigInt();
          break;
        case /* bool assets_only */
        5:
          message.assetsOnly = reader.bool();
          break;
        case /* sint64 skip */
        6:
          message.skip = reader.sint64().toBigInt();
          break;
        case /* string label */
        7:
          message.label = reader.string();
          break;
        case /* string token */
        8:
          message.token = reader.string();
          break;
        case /* string lookup */
        9:
          message.lookup = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.limit !== 0)
      writer.tag(1, WireType.Varint).sint32(message.limit);
    if (message.codeId !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.codeId);
    if (message.fromNumber !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.fromNumber);
    if (message.toNumber !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.toNumber);
    if (message.assetsOnly !== false)
      writer.tag(5, WireType.Varint).bool(message.assetsOnly);
    if (message.skip !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.skip);
    if (message.label !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.label);
    if (message.token !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.token);
    if (message.lookup !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.lookup);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmContractsRequest = new GetWasmContractsRequest$Type();
class GetWasmContractsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmContractsResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => WasmContract }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.WasmContract data */
        2:
          message.data.push(WasmContract.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      WasmContract.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmContractsResponse = new GetWasmContractsResponse$Type();
class WasmContract$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.WasmContract", [
      {
        no: 1,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "creator",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "executes",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "instantiated_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "init_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "last_executed_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 9, name: "funds", kind: "message", repeat: 2, T: () => ContractFund },
      {
        no: 10,
        name: "code_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "current_migrate_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "contract_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 16, name: "cw20_metadata", kind: "message", T: () => Cw20Metadata },
      {
        no: 17,
        name: "proposal_id",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.label = "";
    message.address = "";
    message.txHash = "";
    message.creator = "";
    message.executes = 0n;
    message.instantiatedAt = 0n;
    message.initMessage = "";
    message.lastExecutedAt = 0n;
    message.funds = [];
    message.codeId = 0n;
    message.admin = "";
    message.currentMigrateMessage = "";
    message.contractNumber = 0n;
    message.version = "";
    message.type = "";
    message.proposalId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string label */
        1:
          message.label = reader.string();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        case /* string tx_hash */
        3:
          message.txHash = reader.string();
          break;
        case /* string creator */
        4:
          message.creator = reader.string();
          break;
        case /* uint64 executes */
        5:
          message.executes = reader.uint64().toBigInt();
          break;
        case /* uint64 instantiated_at */
        6:
          message.instantiatedAt = reader.uint64().toBigInt();
          break;
        case /* string init_message */
        7:
          message.initMessage = reader.string();
          break;
        case /* uint64 last_executed_at */
        8:
          message.lastExecutedAt = reader.uint64().toBigInt();
          break;
        case /* repeated injective_explorer_rpc.ContractFund funds */
        9:
          message.funds.push(ContractFund.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 code_id */
        10:
          message.codeId = reader.uint64().toBigInt();
          break;
        case /* string admin */
        11:
          message.admin = reader.string();
          break;
        case /* string current_migrate_message */
        12:
          message.currentMigrateMessage = reader.string();
          break;
        case /* sint64 contract_number */
        13:
          message.contractNumber = reader.sint64().toBigInt();
          break;
        case /* string version */
        14:
          message.version = reader.string();
          break;
        case /* string type */
        15:
          message.type = reader.string();
          break;
        case /* injective_explorer_rpc.Cw20Metadata cw20_metadata */
        16:
          message.cw20Metadata = Cw20Metadata.internalBinaryRead(reader, reader.uint32(), options, message.cw20Metadata);
          break;
        case /* sint64 proposal_id */
        17:
          message.proposalId = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.label !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.label);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    if (message.txHash !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.txHash);
    if (message.creator !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.creator);
    if (message.executes !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.executes);
    if (message.instantiatedAt !== 0n)
      writer.tag(6, WireType.Varint).uint64(message.instantiatedAt);
    if (message.initMessage !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.initMessage);
    if (message.lastExecutedAt !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.lastExecutedAt);
    for (let i = 0; i < message.funds.length; i++)
      ContractFund.internalBinaryWrite(message.funds[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.codeId !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.codeId);
    if (message.admin !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.admin);
    if (message.currentMigrateMessage !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.currentMigrateMessage);
    if (message.contractNumber !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.contractNumber);
    if (message.version !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.version);
    if (message.type !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.type);
    if (message.cw20Metadata)
      Cw20Metadata.internalBinaryWrite(message.cw20Metadata, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.proposalId !== 0n)
      writer.tag(17, WireType.Varint).sint64(message.proposalId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const WasmContract = new WasmContract$Type();
class ContractFund$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.ContractFund", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ContractFund = new ContractFund$Type();
class Cw20Metadata$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Cw20Metadata", [
      { no: 1, name: "token_info", kind: "message", T: () => Cw20TokenInfo },
      { no: 2, name: "marketing_info", kind: "message", T: () => Cw20MarketingInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Cw20TokenInfo token_info */
        1:
          message.tokenInfo = Cw20TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
          break;
        case /* injective_explorer_rpc.Cw20MarketingInfo marketing_info */
        2:
          message.marketingInfo = Cw20MarketingInfo.internalBinaryRead(reader, reader.uint32(), options, message.marketingInfo);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tokenInfo)
      Cw20TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.marketingInfo)
      Cw20MarketingInfo.internalBinaryWrite(message.marketingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Cw20Metadata = new Cw20Metadata$Type();
class Cw20TokenInfo$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Cw20TokenInfo", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "decimals",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "total_supply",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.symbol = "";
    message.decimals = 0n;
    message.totalSupply = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string symbol */
        2:
          message.symbol = reader.string();
          break;
        case /* sint64 decimals */
        3:
          message.decimals = reader.sint64().toBigInt();
          break;
        case /* string total_supply */
        4:
          message.totalSupply = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.symbol !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.symbol);
    if (message.decimals !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.decimals);
    if (message.totalSupply !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.totalSupply);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Cw20TokenInfo = new Cw20TokenInfo$Type();
class Cw20MarketingInfo$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Cw20MarketingInfo", [
      {
        no: 1,
        name: "project",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "logo",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "marketing",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.project = "";
    message.description = "";
    message.logo = "";
    message.marketing = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string project */
        1:
          message.project = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string logo */
        3:
          message.logo = reader.string();
          break;
        case /* bytes marketing */
        4:
          message.marketing = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.project !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.project);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.logo !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.logo);
    if (message.marketing.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.marketing);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Cw20MarketingInfo = new Cw20MarketingInfo$Type();
class GetWasmContractByAddressRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmContractByAddressRequest", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmContractByAddressRequest = new GetWasmContractByAddressRequest$Type();
class GetWasmContractByAddressResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetWasmContractByAddressResponse", [
      {
        no: 1,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "creator",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "executes",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "instantiated_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "init_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "last_executed_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 9, name: "funds", kind: "message", repeat: 2, T: () => ContractFund },
      {
        no: 10,
        name: "code_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "current_migrate_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "contract_number",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 16, name: "cw20_metadata", kind: "message", T: () => Cw20Metadata },
      {
        no: 17,
        name: "proposal_id",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.label = "";
    message.address = "";
    message.txHash = "";
    message.creator = "";
    message.executes = 0n;
    message.instantiatedAt = 0n;
    message.initMessage = "";
    message.lastExecutedAt = 0n;
    message.funds = [];
    message.codeId = 0n;
    message.admin = "";
    message.currentMigrateMessage = "";
    message.contractNumber = 0n;
    message.version = "";
    message.type = "";
    message.proposalId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string label */
        1:
          message.label = reader.string();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        case /* string tx_hash */
        3:
          message.txHash = reader.string();
          break;
        case /* string creator */
        4:
          message.creator = reader.string();
          break;
        case /* uint64 executes */
        5:
          message.executes = reader.uint64().toBigInt();
          break;
        case /* uint64 instantiated_at */
        6:
          message.instantiatedAt = reader.uint64().toBigInt();
          break;
        case /* string init_message */
        7:
          message.initMessage = reader.string();
          break;
        case /* uint64 last_executed_at */
        8:
          message.lastExecutedAt = reader.uint64().toBigInt();
          break;
        case /* repeated injective_explorer_rpc.ContractFund funds */
        9:
          message.funds.push(ContractFund.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 code_id */
        10:
          message.codeId = reader.uint64().toBigInt();
          break;
        case /* string admin */
        11:
          message.admin = reader.string();
          break;
        case /* string current_migrate_message */
        12:
          message.currentMigrateMessage = reader.string();
          break;
        case /* sint64 contract_number */
        13:
          message.contractNumber = reader.sint64().toBigInt();
          break;
        case /* string version */
        14:
          message.version = reader.string();
          break;
        case /* string type */
        15:
          message.type = reader.string();
          break;
        case /* injective_explorer_rpc.Cw20Metadata cw20_metadata */
        16:
          message.cw20Metadata = Cw20Metadata.internalBinaryRead(reader, reader.uint32(), options, message.cw20Metadata);
          break;
        case /* sint64 proposal_id */
        17:
          message.proposalId = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.label !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.label);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    if (message.txHash !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.txHash);
    if (message.creator !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.creator);
    if (message.executes !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.executes);
    if (message.instantiatedAt !== 0n)
      writer.tag(6, WireType.Varint).uint64(message.instantiatedAt);
    if (message.initMessage !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.initMessage);
    if (message.lastExecutedAt !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.lastExecutedAt);
    for (let i = 0; i < message.funds.length; i++)
      ContractFund.internalBinaryWrite(message.funds[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.codeId !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.codeId);
    if (message.admin !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.admin);
    if (message.currentMigrateMessage !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.currentMigrateMessage);
    if (message.contractNumber !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.contractNumber);
    if (message.version !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.version);
    if (message.type !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.type);
    if (message.cw20Metadata)
      Cw20Metadata.internalBinaryWrite(message.cw20Metadata, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.proposalId !== 0n)
      writer.tag(17, WireType.Varint).sint64(message.proposalId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWasmContractByAddressResponse = new GetWasmContractByAddressResponse$Type();
class GetCw20BalanceRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetCw20BalanceRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* sint32 limit */
        2:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.limit !== 0)
      writer.tag(2, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCw20BalanceRequest = new GetCw20BalanceRequest$Type();
class GetCw20BalanceResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetCw20BalanceResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => WasmCw20Balance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_explorer_rpc.WasmCw20Balance field */
        1:
          message.field.push(WasmCw20Balance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      WasmCw20Balance.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCw20BalanceResponse = new GetCw20BalanceResponse$Type();
class WasmCw20Balance$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.WasmCw20Balance", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 5, name: "cw20_metadata", kind: "message", T: () => Cw20Metadata }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    message.account = "";
    message.balance = "";
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* string account */
        2:
          message.account = reader.string();
          break;
        case /* string balance */
        3:
          message.balance = reader.string();
          break;
        case /* sint64 updated_at */
        4:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* injective_explorer_rpc.Cw20Metadata cw20_metadata */
        5:
          message.cw20Metadata = Cw20Metadata.internalBinaryRead(reader, reader.uint32(), options, message.cw20Metadata);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.account !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.account);
    if (message.balance !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.balance);
    if (message.updatedAt !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.updatedAt);
    if (message.cw20Metadata)
      Cw20Metadata.internalBinaryWrite(message.cw20Metadata, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const WasmCw20Balance = new WasmCw20Balance$Type();
class RelayersRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.RelayersRequest", [
      {
        no: 1,
        name: "market_i_ds",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIDs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_i_ds */
        1:
          message.marketIDs.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIDs.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIDs[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RelayersRequest = new RelayersRequest$Type();
class RelayersResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.RelayersResponse", [
      { no: 1, name: "field", kind: "message", repeat: 2, T: () => RelayerMarkets }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_explorer_rpc.RelayerMarkets field */
        1:
          message.field.push(RelayerMarkets.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      RelayerMarkets.internalBinaryWrite(message.field[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RelayersResponse = new RelayersResponse$Type();
class RelayerMarkets$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.RelayerMarkets", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "relayers", kind: "message", repeat: 2, T: () => Relayer }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.relayers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective_explorer_rpc.Relayer relayers */
        2:
          message.relayers.push(Relayer.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.relayers.length; i++)
      Relayer.internalBinaryWrite(message.relayers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RelayerMarkets = new RelayerMarkets$Type();
class Relayer$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Relayer", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "cta",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.cta = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string cta */
        2:
          message.cta = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.cta !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cta);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Relayer = new Relayer$Type();
class GetBankTransfersRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBankTransfersRequest", [
      {
        no: 1,
        name: "senders",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "recipients",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_community_pool_related",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "address",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "per_page",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 10,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.senders = [];
    message.recipients = [];
    message.isCommunityPoolRelated = false;
    message.limit = 0;
    message.skip = 0n;
    message.startTime = 0n;
    message.endTime = 0n;
    message.address = [];
    message.perPage = 0;
    message.token = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string senders */
        1:
          message.senders.push(reader.string());
          break;
        case /* repeated string recipients */
        2:
          message.recipients.push(reader.string());
          break;
        case /* bool is_community_pool_related */
        3:
          message.isCommunityPoolRelated = reader.bool();
          break;
        case /* sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        5:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* sint64 start_time */
        6:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        7:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* repeated string address */
        8:
          message.address.push(reader.string());
          break;
        case /* sint32 per_page */
        9:
          message.perPage = reader.sint32();
          break;
        case /* string token */
        10:
          message.token = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.senders.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.senders[i]);
    for (let i = 0; i < message.recipients.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.recipients[i]);
    if (message.isCommunityPoolRelated !== false)
      writer.tag(3, WireType.Varint).bool(message.isCommunityPoolRelated);
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.skip);
    if (message.startTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.endTime);
    for (let i = 0; i < message.address.length; i++)
      writer.tag(8, WireType.LengthDelimited).string(message.address[i]);
    if (message.perPage !== 0)
      writer.tag(9, WireType.Varint).sint32(message.perPage);
    if (message.token !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.token);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBankTransfersRequest = new GetBankTransfersRequest$Type();
class GetBankTransfersResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetBankTransfersResponse", [
      { no: 1, name: "paging", kind: "message", T: () => Paging },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => BankTransfer }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_explorer_rpc.Paging paging */
        1:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        case /* repeated injective_explorer_rpc.BankTransfer data */
        2:
          message.data.push(BankTransfer.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.data.length; i++)
      BankTransfer.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBankTransfersResponse = new GetBankTransfersResponse$Type();
class BankTransfer$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.BankTransfer", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "amounts", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 4,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "block_timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.recipient = "";
    message.amounts = [];
    message.blockNumber = 0n;
    message.blockTimestamp = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string recipient */
        2:
          message.recipient = reader.string();
          break;
        case /* repeated injective_explorer_rpc.Coin amounts */
        3:
          message.amounts.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 block_number */
        4:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        case /* string block_timestamp */
        5:
          message.blockTimestamp = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.recipient !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.recipient);
    for (let i = 0; i < message.amounts.length; i++)
      Coin.internalBinaryWrite(message.amounts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.blockNumber !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.blockNumber);
    if (message.blockTimestamp !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.blockTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BankTransfer = new BankTransfer$Type();
class Coin$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.Coin", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "usd_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.amount = "";
    message.usdValue = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        case /* string usd_value */
        3:
          message.usdValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    if (message.usdValue !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Coin = new Coin$Type();
class StreamTxsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.StreamTxsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTxsRequest = new StreamTxsRequest$Type();
class StreamTxsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.StreamTxsResponse", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "block_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "block_timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "messages",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "tx_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "error_log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 10,
        name: "claim_ids",
        kind: "scalar",
        repeat: 1,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.blockNumber = 0n;
    message.blockTimestamp = "";
    message.hash = "";
    message.codespace = "";
    message.messages = "";
    message.txNumber = 0n;
    message.errorLog = "";
    message.code = 0;
    message.claimIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* uint64 block_number */
        2:
          message.blockNumber = reader.uint64().toBigInt();
          break;
        case /* string block_timestamp */
        3:
          message.blockTimestamp = reader.string();
          break;
        case /* string hash */
        4:
          message.hash = reader.string();
          break;
        case /* string codespace */
        5:
          message.codespace = reader.string();
          break;
        case /* string messages */
        6:
          message.messages = reader.string();
          break;
        case /* uint64 tx_number */
        7:
          message.txNumber = reader.uint64().toBigInt();
          break;
        case /* string error_log */
        8:
          message.errorLog = reader.string();
          break;
        case /* uint32 code */
        9:
          message.code = reader.uint32();
          break;
        case /* repeated sint64 claim_ids */
        10:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.claimIds.push(reader.sint64().toBigInt());
          else
            message.claimIds.push(reader.sint64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.blockNumber !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.blockNumber);
    if (message.blockTimestamp !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.blockTimestamp);
    if (message.hash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.hash);
    if (message.codespace !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.codespace);
    if (message.messages !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.messages);
    if (message.txNumber !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.txNumber);
    if (message.errorLog !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.errorLog);
    if (message.code !== 0)
      writer.tag(9, WireType.Varint).uint32(message.code);
    if (message.claimIds.length) {
      writer.tag(10, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.claimIds.length; i++)
        writer.sint64(message.claimIds[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTxsResponse = new StreamTxsResponse$Type();
class StreamBlocksRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.StreamBlocksRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamBlocksRequest = new StreamBlocksRequest$Type();
class StreamBlocksResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.StreamBlocksResponse", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "proposer",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "moniker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "block_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "parent_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "num_pre_commits",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "num_txs",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 8, name: "txs", kind: "message", repeat: 2, T: () => TxDataRPC },
      {
        no: 9,
        name: "timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "block_unix_timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.proposer = "";
    message.moniker = "";
    message.blockHash = "";
    message.parentHash = "";
    message.numPreCommits = 0n;
    message.numTxs = 0n;
    message.txs = [];
    message.timestamp = "";
    message.blockUnixTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 height */
        1:
          message.height = reader.uint64().toBigInt();
          break;
        case /* string proposer */
        2:
          message.proposer = reader.string();
          break;
        case /* string moniker */
        3:
          message.moniker = reader.string();
          break;
        case /* string block_hash */
        4:
          message.blockHash = reader.string();
          break;
        case /* string parent_hash */
        5:
          message.parentHash = reader.string();
          break;
        case /* sint64 num_pre_commits */
        6:
          message.numPreCommits = reader.sint64().toBigInt();
          break;
        case /* sint64 num_txs */
        7:
          message.numTxs = reader.sint64().toBigInt();
          break;
        case /* repeated injective_explorer_rpc.TxDataRPC txs */
        8:
          message.txs.push(TxDataRPC.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string timestamp */
        9:
          message.timestamp = reader.string();
          break;
        case /* uint64 block_unix_timestamp */
        10:
          message.blockUnixTimestamp = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.height);
    if (message.proposer !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.proposer);
    if (message.moniker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.moniker);
    if (message.blockHash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.blockHash);
    if (message.parentHash !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.parentHash);
    if (message.numPreCommits !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.numPreCommits);
    if (message.numTxs !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.numTxs);
    for (let i = 0; i < message.txs.length; i++)
      TxDataRPC.internalBinaryWrite(message.txs[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.timestamp);
    if (message.blockUnixTimestamp !== 0n)
      writer.tag(10, WireType.Varint).uint64(message.blockUnixTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamBlocksResponse = new StreamBlocksResponse$Type();
class GetStatsRequest$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetStatsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetStatsRequest = new GetStatsRequest$Type();
class GetStatsResponse$Type extends MessageType {
  constructor() {
    super("injective_explorer_rpc.GetStatsResponse", [
      {
        no: 1,
        name: "addresses",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "assets",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "inj_supply",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "txs_ps24_h",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "txs_ps100_b",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "txs_total",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "txs24_h",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "txs30_d",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "block_count24_h",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.addresses = 0n;
    message.assets = 0n;
    message.injSupply = 0n;
    message.txsPs24H = 0n;
    message.txsPs100B = 0n;
    message.txsTotal = 0n;
    message.txs24H = 0n;
    message.txs30D = 0n;
    message.blockCount24H = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 addresses */
        1:
          message.addresses = reader.uint64().toBigInt();
          break;
        case /* uint64 assets */
        2:
          message.assets = reader.uint64().toBigInt();
          break;
        case /* uint64 inj_supply */
        3:
          message.injSupply = reader.uint64().toBigInt();
          break;
        case /* uint64 txs_ps24_h */
        4:
          message.txsPs24H = reader.uint64().toBigInt();
          break;
        case /* uint64 txs_ps100_b */
        5:
          message.txsPs100B = reader.uint64().toBigInt();
          break;
        case /* uint64 txs_total */
        6:
          message.txsTotal = reader.uint64().toBigInt();
          break;
        case /* uint64 txs24_h */
        7:
          message.txs24H = reader.uint64().toBigInt();
          break;
        case /* uint64 txs30_d */
        8:
          message.txs30D = reader.uint64().toBigInt();
          break;
        case /* uint64 block_count24_h */
        9:
          message.blockCount24H = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.addresses !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.addresses);
    if (message.assets !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.assets);
    if (message.injSupply !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.injSupply);
    if (message.txsPs24H !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.txsPs24H);
    if (message.txsPs100B !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.txsPs100B);
    if (message.txsTotal !== 0n)
      writer.tag(6, WireType.Varint).uint64(message.txsTotal);
    if (message.txs24H !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.txs24H);
    if (message.txs30D !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.txs30D);
    if (message.blockCount24H !== 0n)
      writer.tag(9, WireType.Varint).uint64(message.blockCount24H);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetStatsResponse = new GetStatsResponse$Type();
const InjectiveExplorerRPC = new ServiceType("injective_explorer_rpc.InjectiveExplorerRPC", [
  { name: "GetAccountTxs", options: {}, I: GetAccountTxsRequest, O: GetAccountTxsResponse },
  { name: "GetAccountTxsV2", options: {}, I: GetAccountTxsV2Request, O: GetAccountTxsV2Response },
  { name: "GetContractTxs", options: {}, I: GetContractTxsRequest, O: GetContractTxsResponse },
  { name: "GetContractTxsV2", options: {}, I: GetContractTxsV2Request, O: GetContractTxsV2Response },
  { name: "GetBlocks", options: {}, I: GetBlocksRequest, O: GetBlocksResponse },
  { name: "GetBlocksV2", options: {}, I: GetBlocksV2Request, O: GetBlocksV2Response },
  { name: "GetBlock", options: {}, I: GetBlockRequest, O: GetBlockResponse },
  { name: "GetValidators", options: {}, I: GetValidatorsRequest, O: GetValidatorsResponse },
  { name: "GetValidator", options: {}, I: GetValidatorRequest, O: GetValidatorResponse },
  { name: "GetValidatorUptime", options: {}, I: GetValidatorUptimeRequest, O: GetValidatorUptimeResponse },
  { name: "GetTxs", options: {}, I: GetTxsRequest, O: GetTxsResponse },
  { name: "GetTxsV2", options: {}, I: GetTxsV2Request, O: GetTxsV2Response },
  { name: "GetTxByTxHash", options: {}, I: GetTxByTxHashRequest, O: GetTxByTxHashResponse },
  { name: "GetPeggyDepositTxs", options: {}, I: GetPeggyDepositTxsRequest, O: GetPeggyDepositTxsResponse },
  { name: "GetPeggyWithdrawalTxs", options: {}, I: GetPeggyWithdrawalTxsRequest, O: GetPeggyWithdrawalTxsResponse },
  { name: "GetIBCTransferTxs", options: {}, I: GetIBCTransferTxsRequest, O: GetIBCTransferTxsResponse },
  { name: "GetWasmCodes", options: {}, I: GetWasmCodesRequest, O: GetWasmCodesResponse },
  { name: "GetWasmCodeByID", options: {}, I: GetWasmCodeByIDRequest, O: GetWasmCodeByIDResponse },
  { name: "GetWasmContracts", options: {}, I: GetWasmContractsRequest, O: GetWasmContractsResponse },
  { name: "GetWasmContractByAddress", options: {}, I: GetWasmContractByAddressRequest, O: GetWasmContractByAddressResponse },
  { name: "GetCw20Balance", options: {}, I: GetCw20BalanceRequest, O: GetCw20BalanceResponse },
  { name: "Relayers", options: {}, I: RelayersRequest, O: RelayersResponse },
  { name: "GetBankTransfers", options: {}, I: GetBankTransfersRequest, O: GetBankTransfersResponse },
  { name: "StreamTxs", serverStreaming: true, options: {}, I: StreamTxsRequest, O: StreamTxsResponse },
  { name: "StreamBlocks", serverStreaming: true, options: {}, I: StreamBlocksRequest, O: StreamBlocksResponse },
  { name: "GetStats", options: {}, I: GetStatsRequest, O: GetStatsResponse }
]);
export {
  BankTransfer,
  BlockDetailInfo,
  BlockInfo,
  Checksum,
  Coin,
  ContractFund,
  ContractPermission,
  CosmosCoin,
  Cursor,
  Cw20MarketingInfo,
  Cw20Metadata,
  Cw20TokenInfo,
  Event,
  GasFee,
  GetAccountTxsRequest,
  GetAccountTxsResponse,
  GetAccountTxsV2Request,
  GetAccountTxsV2Response,
  GetBankTransfersRequest,
  GetBankTransfersResponse,
  GetBlockRequest,
  GetBlockResponse,
  GetBlocksRequest,
  GetBlocksResponse,
  GetBlocksV2Request,
  GetBlocksV2Response,
  GetContractTxsRequest,
  GetContractTxsResponse,
  GetContractTxsV2Request,
  GetContractTxsV2Response,
  GetCw20BalanceRequest,
  GetCw20BalanceResponse,
  GetIBCTransferTxsRequest,
  GetIBCTransferTxsResponse,
  GetPeggyDepositTxsRequest,
  GetPeggyDepositTxsResponse,
  GetPeggyWithdrawalTxsRequest,
  GetPeggyWithdrawalTxsResponse,
  GetStatsRequest,
  GetStatsResponse,
  GetTxByTxHashRequest,
  GetTxByTxHashResponse,
  GetTxsRequest,
  GetTxsResponse,
  GetTxsV2Request,
  GetTxsV2Response,
  GetValidatorRequest,
  GetValidatorResponse,
  GetValidatorUptimeRequest,
  GetValidatorUptimeResponse,
  GetValidatorsRequest,
  GetValidatorsResponse,
  GetWasmCodeByIDRequest,
  GetWasmCodeByIDResponse,
  GetWasmCodesRequest,
  GetWasmCodesResponse,
  GetWasmContractByAddressRequest,
  GetWasmContractByAddressResponse,
  GetWasmContractsRequest,
  GetWasmContractsResponse,
  IBCTransferTx,
  InjectiveExplorerRPC,
  Paging,
  PeggyDepositTx,
  PeggyWithdrawalTx,
  Relayer,
  RelayerMarkets,
  RelayersRequest,
  RelayersResponse,
  Signature,
  SlashingEvent,
  StreamBlocksRequest,
  StreamBlocksResponse,
  StreamTxsRequest,
  StreamTxsResponse,
  TxData,
  TxDataRPC,
  TxDetailData,
  Validator,
  ValidatorDescription,
  ValidatorUptime,
  WasmCode,
  WasmContract,
  WasmCw20Balance
};
