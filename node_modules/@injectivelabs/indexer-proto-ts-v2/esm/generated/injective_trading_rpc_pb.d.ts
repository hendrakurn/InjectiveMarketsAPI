// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_trading_rpc.proto" (package "injective_trading_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveTradingRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_trading_rpc.ListTradingStrategiesRequest
 */
export interface ListTradingStrategiesRequest {
    /**
     * @generated from protobuf field: string state = 1
     */
    state: string;
    /**
     * MarketId of the trading strategy
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * subaccount ID to filter by
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 4
     */
    accountAddress: string;
    /**
     * Indicates whether the trading strategy is pending execution
     *
     * @generated from protobuf field: bool pending_execution = 5
     */
    pendingExecution: boolean;
    /**
     * The starting timestamp in UNIX milliseconds for the creation time of the
     * trading strategy
     *
     * @generated from protobuf field: sint64 start_time = 6
     */
    startTime: bigint;
    /**
     * The ending timestamp in UNIX milliseconds for the creation time of the
     * trading strategy
     *
     * @generated from protobuf field: sint64 end_time = 7
     */
    endTime: bigint;
    /**
     * @generated from protobuf field: sint32 limit = 8
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 skip = 9
     */
    skip: bigint;
    /**
     * Filter by strategy type
     *
     * @generated from protobuf field: repeated string strategy_type = 10
     */
    strategyType: string[];
    /**
     * Filter by market type
     *
     * @generated from protobuf field: string market_type = 11
     */
    marketType: string;
    /**
     * The last executed timestamp in UNIX milliseconds for the last executed time
     * of the trading strategy
     *
     * @generated from protobuf field: sint64 last_executed_time = 12
     */
    lastExecutedTime: bigint;
    /**
     * Include TVL in the response
     *
     * @generated from protobuf field: bool with_tvl = 13
     */
    withTvl: boolean;
    /**
     * Indicates whether the trading strategy is a trailing strategy
     *
     * @generated from protobuf field: bool is_trailing_strategy = 14
     */
    isTrailingStrategy: boolean;
    /**
     * Indicates whether the trading strategy performance should be included in the
     * response
     *
     * @generated from protobuf field: bool with_performance = 15
     */
    withPerformance: boolean;
}
/**
 * @generated from protobuf message injective_trading_rpc.ListTradingStrategiesResponse
 */
export interface ListTradingStrategiesResponse {
    /**
     * The trading strategies
     *
     * @generated from protobuf field: repeated injective_trading_rpc.TradingStrategy strategies = 1
     */
    strategies: TradingStrategy[];
    /**
     * @generated from protobuf field: injective_trading_rpc.Paging paging = 2
     */
    paging?: Paging;
}
/**
 * @generated from protobuf message injective_trading_rpc.TradingStrategy
 */
export interface TradingStrategy {
    /**
     * @generated from protobuf field: string state = 1
     */
    state: string;
    /**
     * MarketId of the trading strategy
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * subaccount ID of the trading strategy
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 4
     */
    accountAddress: string;
    /**
     * Contract address
     *
     * @generated from protobuf field: string contract_address = 5
     */
    contractAddress: string;
    /**
     * Execution price of the trading strategy
     *
     * @generated from protobuf field: string execution_price = 6
     */
    executionPrice: string;
    /**
     * Base quantity of the trading strategy
     *
     * @generated from protobuf field: string base_quantity = 7
     */
    baseQuantity: string;
    /**
     * Quote quantity of the trading strategy
     *
     * @generated from protobuf field: string quote_quantity = 20
     */
    quoteQuantity: string;
    /**
     * Lower bound of the trading strategy
     *
     * @generated from protobuf field: string lower_bound = 8
     */
    lowerBound: string;
    /**
     * Upper bound of the trading strategy
     *
     * @generated from protobuf field: string upper_bound = 9
     */
    upperBound: string;
    /**
     * Stop loss limit of the trading strategy
     *
     * @generated from protobuf field: string stop_loss = 10
     */
    stopLoss: string;
    /**
     * Take profit limit of the trading strategy
     *
     * @generated from protobuf field: string take_profit = 11
     */
    takeProfit: string;
    /**
     * Swap fee of the trading strategy
     *
     * @generated from protobuf field: string swap_fee = 12
     */
    swapFee: string;
    /**
     * Base deposit at the time of closing the trading strategy
     *
     * @generated from protobuf field: string base_deposit = 17
     */
    baseDeposit: string;
    /**
     * Quote deposit at the time of closing the trading strategy
     *
     * @generated from protobuf field: string quote_deposit = 18
     */
    quoteDeposit: string;
    /**
     * Market mid price at the time of closing the trading strategy
     *
     * @generated from protobuf field: string market_mid_price = 19
     */
    marketMidPrice: string;
    /**
     * Subscription quote quantity of the trading strategy
     *
     * @generated from protobuf field: string subscription_quote_quantity = 21
     */
    subscriptionQuoteQuantity: string;
    /**
     * Subscription base quantity of the trading strategy
     *
     * @generated from protobuf field: string subscription_base_quantity = 22
     */
    subscriptionBaseQuantity: string;
    /**
     * Number of grid levels of the trading strategy
     *
     * @generated from protobuf field: string number_of_grid_levels = 23
     */
    numberOfGridLevels: string;
    /**
     * Indicates whether the trading strategy should exit with quote only
     *
     * @generated from protobuf field: bool should_exit_with_quote_only = 24
     */
    shouldExitWithQuoteOnly: boolean;
    /**
     * Indicates the reason for stopping the trading strategy
     *
     * @generated from protobuf field: string stop_reason = 25
     */
    stopReason: string;
    /**
     * Indicates whether the trading strategy is pending execution
     *
     * @generated from protobuf field: bool pending_execution = 26
     */
    pendingExecution: boolean;
    /**
     * Block height when the strategy was created.
     *
     * @generated from protobuf field: sint64 created_height = 13
     */
    createdHeight: bigint;
    /**
     * Block height when the strategy was removed.
     *
     * @generated from protobuf field: sint64 removed_height = 14
     */
    removedHeight: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 created_at = 15
     */
    createdAt: bigint;
    /**
     * UpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 updated_at = 16
     */
    updatedAt: bigint;
    /**
     * Indicate how bot will convert funds (into base or quote or keep as is) after
     * strategy ended
     *
     * @generated from protobuf field: string exit_type = 27
     */
    exitType: string;
    /**
     * Exit config for stop loss
     *
     * @generated from protobuf field: injective_trading_rpc.ExitConfig stop_loss_config = 28
     */
    stopLossConfig?: ExitConfig;
    /**
     * Exit config for take profit
     *
     * @generated from protobuf field: injective_trading_rpc.ExitConfig take_profit_config = 29
     */
    takeProfitConfig?: ExitConfig;
    /**
     * Strategy type: arithmetic, geometric...
     *
     * @generated from protobuf field: string strategy_type = 30
     */
    strategyType: string;
    /**
     * Version of the contract
     *
     * @generated from protobuf field: string contract_version = 31
     */
    contractVersion: string;
    /**
     * Name of the contract
     *
     * @generated from protobuf field: string contract_name = 32
     */
    contractName: string;
    /**
     * Type of the market
     *
     * @generated from protobuf field: string market_type = 33
     */
    marketType: string;
    /**
     * lastExecutedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 last_executed_at = 34
     */
    lastExecutedAt: bigint;
    /**
     * trailing up price
     *
     * @generated from protobuf field: string trail_up_price = 35
     */
    trailUpPrice: string;
    /**
     * trailing down price
     *
     * @generated from protobuf field: string trail_down_price = 36
     */
    trailDownPrice: string;
    /**
     * trailing up counter
     *
     * @generated from protobuf field: sint64 trail_up_counter = 37
     */
    trailUpCounter: bigint;
    /**
     * trailing down counter
     *
     * @generated from protobuf field: sint64 trail_down_counter = 38
     */
    trailDownCounter: bigint;
    /**
     * TVL of the trading strategy
     *
     * @generated from protobuf field: string tvl = 39
     */
    tvl: string;
    /**
     * PnL of the trading strategy
     *
     * @generated from protobuf field: string pnl = 40
     */
    pnl: string;
    /**
     * PnL percentage of the trading strategy
     *
     * @generated from protobuf field: string pnl_perc = 41
     */
    pnlPerc: string;
    /**
     * pnlUpdatedAt timestamp in UNIX millis.
     *
     * @generated from protobuf field: sint64 pnl_updated_at = 42
     */
    pnlUpdatedAt: bigint;
    /**
     * Indicates the performance of the trading strategy
     *
     * @generated from protobuf field: string performance = 43
     */
    performance: string;
    /**
     * Return on investment of the trading strategy
     *
     * @generated from protobuf field: string roi = 44
     */
    roi: string;
    /**
     * Initial base price of the trading strategy from asset price service
     * Use strategyFinalData if available to have more accurate data
     *
     * @generated from protobuf field: string initial_base_price = 45
     */
    initialBasePrice: string;
    /**
     * Initial quote price of the trading strategy from asset price service
     * Use strategyFinalData if available to have more accurate data
     *
     * @generated from protobuf field: string initial_quote_price = 46
     */
    initialQuotePrice: string;
    /**
     * Current base price of the trading strategy from asset price service
     * Use strategyFinalData if available to have more accurate data
     *
     * @generated from protobuf field: string current_base_price = 47
     */
    currentBasePrice: string;
    /**
     * Current quote price of the trading strategy from asset price service
     * Use strategyFinalData if available to have more accurate data
     *
     * @generated from protobuf field: string current_quote_price = 48
     */
    currentQuotePrice: string;
    /**
     * Final base price of the trading strategy from asset price service
     * Use strategyFinalData if available to have more accurate data
     *
     * @generated from protobuf field: string final_base_price = 49
     */
    finalBasePrice: string;
    /**
     * Final quote price of the trading strategy from asset price service
     * Use strategyFinalData if available to have more accurate data
     *
     * @generated from protobuf field: string final_quote_price = 50
     */
    finalQuotePrice: string;
    /**
     * Final data of the trading strategy. This is present from contract v0.8.4.
     *
     * @generated from protobuf field: injective_trading_rpc.StrategyFinalData final_data = 51
     */
    finalData?: StrategyFinalData;
    /**
     * Margin ratio of the trading strategy
     *
     * @generated from protobuf field: string margin_ratio = 52
     */
    marginRatio: string;
    /**
     * Lower trailing bound of the trading strategy
     *
     * @generated from protobuf field: string lower_trailing_bound = 53
     */
    lowerTrailingBound: string;
    /**
     * Upper trailing bound of the trading strategy
     *
     * @generated from protobuf field: string upper_trailing_bound = 54
     */
    upperTrailingBound: string;
    /**
     * New upper bound of the trading strategy
     *
     * @generated from protobuf field: string new_upper_bound = 55
     */
    newUpperBound: string;
    /**
     * New lower bound of the trading strategy
     *
     * @generated from protobuf field: string new_lower_bound = 56
     */
    newLowerBound: string;
}
/**
 * @generated from protobuf message injective_trading_rpc.ExitConfig
 */
export interface ExitConfig {
    /**
     * strategy exit type (stopLoss/takeProfit)
     *
     * @generated from protobuf field: string exit_type = 1
     */
    exitType: string;
    /**
     * strategy stopLoss/takeProfit price
     *
     * @generated from protobuf field: string exit_price = 2
     */
    exitPrice: string;
}
/**
 * @generated from protobuf message injective_trading_rpc.StrategyFinalData
 */
export interface StrategyFinalData {
    /**
     * Initial base amount
     *
     * @generated from protobuf field: string initial_base_amount = 1
     */
    initialBaseAmount: string;
    /**
     * Initial quote amount
     *
     * @generated from protobuf field: string initial_quote_amount = 2
     */
    initialQuoteAmount: string;
    /**
     * Final base amount
     *
     * @generated from protobuf field: string final_base_amount = 3
     */
    finalBaseAmount: string;
    /**
     * Final quote amount
     *
     * @generated from protobuf field: string final_quote_amount = 4
     */
    finalQuoteAmount: string;
    /**
     * Initial base price
     *
     * @generated from protobuf field: string initial_base_price = 5
     */
    initialBasePrice: string;
    /**
     * Initial quote price
     *
     * @generated from protobuf field: string initial_quote_price = 6
     */
    initialQuotePrice: string;
    /**
     * Final base price
     *
     * @generated from protobuf field: string final_base_price = 7
     */
    finalBasePrice: string;
    /**
     * Final quote price
     *
     * @generated from protobuf field: string final_quote_price = 8
     */
    finalQuotePrice: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_trading_rpc.Paging
 */
export interface Paging {
    /**
     * total number of txs saved in database
     *
     * @generated from protobuf field: sint64 total = 1
     */
    total: bigint;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 from = 2
     */
    from: number;
    /**
     * can be either block height or index num
     *
     * @generated from protobuf field: sint32 to = 3
     */
    to: number;
    /**
     * count entries by subaccount, serving some places on helix
     *
     * @generated from protobuf field: sint64 count_by_subaccount = 4
     */
    countBySubaccount: bigint;
    /**
     * array of tokens to navigate to the next pages
     *
     * @generated from protobuf field: repeated string next = 5
     */
    next: string[];
}
/**
 * @generated from protobuf message injective_trading_rpc.GetTradingStatsRequest
 */
export interface GetTradingStatsRequest {
}
/**
 * @generated from protobuf message injective_trading_rpc.GetTradingStatsResponse
 */
export interface GetTradingStatsResponse {
    /**
     * Total of unique active trading strategies
     *
     * @generated from protobuf field: uint64 active_trading_strategies = 1
     */
    activeTradingStrategies: bigint;
    /**
     * Total number of created trading strategies
     *
     * @generated from protobuf field: uint64 total_trading_strategies_created = 2
     */
    totalTradingStrategiesCreated: bigint;
    /**
     * Total TVL of all active trading strategies
     *
     * @generated from protobuf field: string total_tvl = 3
     */
    totalTvl: string;
    /**
     * Market stats
     *
     * @generated from protobuf field: repeated injective_trading_rpc.Market markets = 4
     */
    markets: Market[];
}
/**
 * @generated from protobuf message injective_trading_rpc.Market
 */
export interface Market {
    /**
     * MarketId of the trading strategy
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Total of unique active trading strategies
     *
     * @generated from protobuf field: uint64 active_trading_strategies = 2
     */
    activeTradingStrategies: bigint;
}
/**
 * @generated from protobuf message injective_trading_rpc.StreamStrategyRequest
 */
export interface StreamStrategyRequest {
    /**
     * Account addresses
     *
     * @generated from protobuf field: repeated string account_addresses = 1
     */
    accountAddresses: string[];
    /**
     * MarketId of the trading strategy
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective_trading_rpc.StreamStrategyResponse
 */
export interface StreamStrategyResponse {
    /**
     * The trading strategy
     *
     * @generated from protobuf field: injective_trading_rpc.TradingStrategy trading_strategy = 1
     */
    tradingStrategy?: TradingStrategy;
    /**
     * Timestamp in UNIX millis
     *
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class ListTradingStrategiesRequest$Type extends MessageType<ListTradingStrategiesRequest> {
    constructor() {
        super("injective_trading_rpc.ListTradingStrategiesRequest", [
            { no: 1, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "pending_execution", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "limit", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 9, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "strategy_type", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "market_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "last_executed_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "with_tvl", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "is_trailing_strategy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "with_performance", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListTradingStrategiesRequest>): ListTradingStrategiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = "";
        message.marketId = "";
        message.subaccountId = "";
        message.accountAddress = "";
        message.pendingExecution = false;
        message.startTime = 0n;
        message.endTime = 0n;
        message.limit = 0;
        message.skip = 0n;
        message.strategyType = [];
        message.marketType = "";
        message.lastExecutedTime = 0n;
        message.withTvl = false;
        message.isTrailingStrategy = false;
        message.withPerformance = false;
        if (value !== undefined)
            reflectionMergePartial<ListTradingStrategiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTradingStrategiesRequest): ListTradingStrategiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string state */ 1:
                    message.state = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string account_address */ 4:
                    message.accountAddress = reader.string();
                    break;
                case /* bool pending_execution */ 5:
                    message.pendingExecution = reader.bool();
                    break;
                case /* sint64 start_time */ 6:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 7:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* sint32 limit */ 8:
                    message.limit = reader.sint32();
                    break;
                case /* uint64 skip */ 9:
                    message.skip = reader.uint64().toBigInt();
                    break;
                case /* repeated string strategy_type */ 10:
                    message.strategyType.push(reader.string());
                    break;
                case /* string market_type */ 11:
                    message.marketType = reader.string();
                    break;
                case /* sint64 last_executed_time */ 12:
                    message.lastExecutedTime = reader.sint64().toBigInt();
                    break;
                case /* bool with_tvl */ 13:
                    message.withTvl = reader.bool();
                    break;
                case /* bool is_trailing_strategy */ 14:
                    message.isTrailingStrategy = reader.bool();
                    break;
                case /* bool with_performance */ 15:
                    message.withPerformance = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTradingStrategiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string state = 1; */
        if (message.state !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.state);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string account_address = 4; */
        if (message.accountAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accountAddress);
        /* bool pending_execution = 5; */
        if (message.pendingExecution !== false)
            writer.tag(5, WireType.Varint).bool(message.pendingExecution);
        /* sint64 start_time = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 7; */
        if (message.endTime !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.endTime);
        /* sint32 limit = 8; */
        if (message.limit !== 0)
            writer.tag(8, WireType.Varint).sint32(message.limit);
        /* uint64 skip = 9; */
        if (message.skip !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.skip);
        /* repeated string strategy_type = 10; */
        for (let i = 0; i < message.strategyType.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.strategyType[i]);
        /* string market_type = 11; */
        if (message.marketType !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.marketType);
        /* sint64 last_executed_time = 12; */
        if (message.lastExecutedTime !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.lastExecutedTime);
        /* bool with_tvl = 13; */
        if (message.withTvl !== false)
            writer.tag(13, WireType.Varint).bool(message.withTvl);
        /* bool is_trailing_strategy = 14; */
        if (message.isTrailingStrategy !== false)
            writer.tag(14, WireType.Varint).bool(message.isTrailingStrategy);
        /* bool with_performance = 15; */
        if (message.withPerformance !== false)
            writer.tag(15, WireType.Varint).bool(message.withPerformance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.ListTradingStrategiesRequest
 */
export const ListTradingStrategiesRequest = new ListTradingStrategiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTradingStrategiesResponse$Type extends MessageType<ListTradingStrategiesResponse> {
    constructor() {
        super("injective_trading_rpc.ListTradingStrategiesResponse", [
            { no: 1, name: "strategies", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradingStrategy },
            { no: 2, name: "paging", kind: "message", T: () => Paging }
        ]);
    }
    create(value?: PartialMessage<ListTradingStrategiesResponse>): ListTradingStrategiesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.strategies = [];
        if (value !== undefined)
            reflectionMergePartial<ListTradingStrategiesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTradingStrategiesResponse): ListTradingStrategiesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_trading_rpc.TradingStrategy strategies */ 1:
                    message.strategies.push(TradingStrategy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_trading_rpc.Paging paging */ 2:
                    message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTradingStrategiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_trading_rpc.TradingStrategy strategies = 1; */
        for (let i = 0; i < message.strategies.length; i++)
            TradingStrategy.internalBinaryWrite(message.strategies[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_trading_rpc.Paging paging = 2; */
        if (message.paging)
            Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.ListTradingStrategiesResponse
 */
export const ListTradingStrategiesResponse = new ListTradingStrategiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingStrategy$Type extends MessageType<TradingStrategy> {
    constructor() {
        super("injective_trading_rpc.TradingStrategy", [
            { no: 1, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "execution_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "base_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "quote_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "lower_bound", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "upper_bound", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "stop_loss", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "take_profit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "swap_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "base_deposit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "quote_deposit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "market_mid_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "subscription_quote_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "subscription_base_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "number_of_grid_levels", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "should_exit_with_quote_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "stop_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "pending_execution", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "created_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "removed_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 27, name: "exit_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "stop_loss_config", kind: "message", T: () => ExitConfig },
            { no: 29, name: "take_profit_config", kind: "message", T: () => ExitConfig },
            { no: 30, name: "strategy_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "contract_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "contract_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 33, name: "market_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "last_executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 35, name: "trail_up_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 36, name: "trail_down_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 37, name: "trail_up_counter", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 38, name: "trail_down_counter", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 39, name: "tvl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "pnl_perc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 42, name: "pnl_updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 43, name: "performance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 44, name: "roi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 45, name: "initial_base_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 46, name: "initial_quote_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 47, name: "current_base_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 48, name: "current_quote_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 49, name: "final_base_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 50, name: "final_quote_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 51, name: "final_data", kind: "message", T: () => StrategyFinalData },
            { no: 52, name: "margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 53, name: "lower_trailing_bound", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 54, name: "upper_trailing_bound", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 55, name: "new_upper_bound", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 56, name: "new_lower_bound", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradingStrategy>): TradingStrategy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = "";
        message.marketId = "";
        message.subaccountId = "";
        message.accountAddress = "";
        message.contractAddress = "";
        message.executionPrice = "";
        message.baseQuantity = "";
        message.quoteQuantity = "";
        message.lowerBound = "";
        message.upperBound = "";
        message.stopLoss = "";
        message.takeProfit = "";
        message.swapFee = "";
        message.baseDeposit = "";
        message.quoteDeposit = "";
        message.marketMidPrice = "";
        message.subscriptionQuoteQuantity = "";
        message.subscriptionBaseQuantity = "";
        message.numberOfGridLevels = "";
        message.shouldExitWithQuoteOnly = false;
        message.stopReason = "";
        message.pendingExecution = false;
        message.createdHeight = 0n;
        message.removedHeight = 0n;
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.exitType = "";
        message.strategyType = "";
        message.contractVersion = "";
        message.contractName = "";
        message.marketType = "";
        message.lastExecutedAt = 0n;
        message.trailUpPrice = "";
        message.trailDownPrice = "";
        message.trailUpCounter = 0n;
        message.trailDownCounter = 0n;
        message.tvl = "";
        message.pnl = "";
        message.pnlPerc = "";
        message.pnlUpdatedAt = 0n;
        message.performance = "";
        message.roi = "";
        message.initialBasePrice = "";
        message.initialQuotePrice = "";
        message.currentBasePrice = "";
        message.currentQuotePrice = "";
        message.finalBasePrice = "";
        message.finalQuotePrice = "";
        message.marginRatio = "";
        message.lowerTrailingBound = "";
        message.upperTrailingBound = "";
        message.newUpperBound = "";
        message.newLowerBound = "";
        if (value !== undefined)
            reflectionMergePartial<TradingStrategy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingStrategy): TradingStrategy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string state */ 1:
                    message.state = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string account_address */ 4:
                    message.accountAddress = reader.string();
                    break;
                case /* string contract_address */ 5:
                    message.contractAddress = reader.string();
                    break;
                case /* string execution_price */ 6:
                    message.executionPrice = reader.string();
                    break;
                case /* string base_quantity */ 7:
                    message.baseQuantity = reader.string();
                    break;
                case /* string quote_quantity */ 20:
                    message.quoteQuantity = reader.string();
                    break;
                case /* string lower_bound */ 8:
                    message.lowerBound = reader.string();
                    break;
                case /* string upper_bound */ 9:
                    message.upperBound = reader.string();
                    break;
                case /* string stop_loss */ 10:
                    message.stopLoss = reader.string();
                    break;
                case /* string take_profit */ 11:
                    message.takeProfit = reader.string();
                    break;
                case /* string swap_fee */ 12:
                    message.swapFee = reader.string();
                    break;
                case /* string base_deposit */ 17:
                    message.baseDeposit = reader.string();
                    break;
                case /* string quote_deposit */ 18:
                    message.quoteDeposit = reader.string();
                    break;
                case /* string market_mid_price */ 19:
                    message.marketMidPrice = reader.string();
                    break;
                case /* string subscription_quote_quantity */ 21:
                    message.subscriptionQuoteQuantity = reader.string();
                    break;
                case /* string subscription_base_quantity */ 22:
                    message.subscriptionBaseQuantity = reader.string();
                    break;
                case /* string number_of_grid_levels */ 23:
                    message.numberOfGridLevels = reader.string();
                    break;
                case /* bool should_exit_with_quote_only */ 24:
                    message.shouldExitWithQuoteOnly = reader.bool();
                    break;
                case /* string stop_reason */ 25:
                    message.stopReason = reader.string();
                    break;
                case /* bool pending_execution */ 26:
                    message.pendingExecution = reader.bool();
                    break;
                case /* sint64 created_height */ 13:
                    message.createdHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 removed_height */ 14:
                    message.removedHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 created_at */ 15:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 16:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string exit_type */ 27:
                    message.exitType = reader.string();
                    break;
                case /* injective_trading_rpc.ExitConfig stop_loss_config */ 28:
                    message.stopLossConfig = ExitConfig.internalBinaryRead(reader, reader.uint32(), options, message.stopLossConfig);
                    break;
                case /* injective_trading_rpc.ExitConfig take_profit_config */ 29:
                    message.takeProfitConfig = ExitConfig.internalBinaryRead(reader, reader.uint32(), options, message.takeProfitConfig);
                    break;
                case /* string strategy_type */ 30:
                    message.strategyType = reader.string();
                    break;
                case /* string contract_version */ 31:
                    message.contractVersion = reader.string();
                    break;
                case /* string contract_name */ 32:
                    message.contractName = reader.string();
                    break;
                case /* string market_type */ 33:
                    message.marketType = reader.string();
                    break;
                case /* sint64 last_executed_at */ 34:
                    message.lastExecutedAt = reader.sint64().toBigInt();
                    break;
                case /* string trail_up_price */ 35:
                    message.trailUpPrice = reader.string();
                    break;
                case /* string trail_down_price */ 36:
                    message.trailDownPrice = reader.string();
                    break;
                case /* sint64 trail_up_counter */ 37:
                    message.trailUpCounter = reader.sint64().toBigInt();
                    break;
                case /* sint64 trail_down_counter */ 38:
                    message.trailDownCounter = reader.sint64().toBigInt();
                    break;
                case /* string tvl */ 39:
                    message.tvl = reader.string();
                    break;
                case /* string pnl */ 40:
                    message.pnl = reader.string();
                    break;
                case /* string pnl_perc */ 41:
                    message.pnlPerc = reader.string();
                    break;
                case /* sint64 pnl_updated_at */ 42:
                    message.pnlUpdatedAt = reader.sint64().toBigInt();
                    break;
                case /* string performance */ 43:
                    message.performance = reader.string();
                    break;
                case /* string roi */ 44:
                    message.roi = reader.string();
                    break;
                case /* string initial_base_price */ 45:
                    message.initialBasePrice = reader.string();
                    break;
                case /* string initial_quote_price */ 46:
                    message.initialQuotePrice = reader.string();
                    break;
                case /* string current_base_price */ 47:
                    message.currentBasePrice = reader.string();
                    break;
                case /* string current_quote_price */ 48:
                    message.currentQuotePrice = reader.string();
                    break;
                case /* string final_base_price */ 49:
                    message.finalBasePrice = reader.string();
                    break;
                case /* string final_quote_price */ 50:
                    message.finalQuotePrice = reader.string();
                    break;
                case /* injective_trading_rpc.StrategyFinalData final_data */ 51:
                    message.finalData = StrategyFinalData.internalBinaryRead(reader, reader.uint32(), options, message.finalData);
                    break;
                case /* string margin_ratio */ 52:
                    message.marginRatio = reader.string();
                    break;
                case /* string lower_trailing_bound */ 53:
                    message.lowerTrailingBound = reader.string();
                    break;
                case /* string upper_trailing_bound */ 54:
                    message.upperTrailingBound = reader.string();
                    break;
                case /* string new_upper_bound */ 55:
                    message.newUpperBound = reader.string();
                    break;
                case /* string new_lower_bound */ 56:
                    message.newLowerBound = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingStrategy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string state = 1; */
        if (message.state !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.state);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string account_address = 4; */
        if (message.accountAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accountAddress);
        /* string contract_address = 5; */
        if (message.contractAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.contractAddress);
        /* string execution_price = 6; */
        if (message.executionPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.executionPrice);
        /* string base_quantity = 7; */
        if (message.baseQuantity !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.baseQuantity);
        /* string lower_bound = 8; */
        if (message.lowerBound !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lowerBound);
        /* string upper_bound = 9; */
        if (message.upperBound !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.upperBound);
        /* string stop_loss = 10; */
        if (message.stopLoss !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.stopLoss);
        /* string take_profit = 11; */
        if (message.takeProfit !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.takeProfit);
        /* string swap_fee = 12; */
        if (message.swapFee !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.swapFee);
        /* sint64 created_height = 13; */
        if (message.createdHeight !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.createdHeight);
        /* sint64 removed_height = 14; */
        if (message.removedHeight !== 0n)
            writer.tag(14, WireType.Varint).sint64(message.removedHeight);
        /* sint64 created_at = 15; */
        if (message.createdAt !== 0n)
            writer.tag(15, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 16; */
        if (message.updatedAt !== 0n)
            writer.tag(16, WireType.Varint).sint64(message.updatedAt);
        /* string base_deposit = 17; */
        if (message.baseDeposit !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.baseDeposit);
        /* string quote_deposit = 18; */
        if (message.quoteDeposit !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.quoteDeposit);
        /* string market_mid_price = 19; */
        if (message.marketMidPrice !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.marketMidPrice);
        /* string quote_quantity = 20; */
        if (message.quoteQuantity !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.quoteQuantity);
        /* string subscription_quote_quantity = 21; */
        if (message.subscriptionQuoteQuantity !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.subscriptionQuoteQuantity);
        /* string subscription_base_quantity = 22; */
        if (message.subscriptionBaseQuantity !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.subscriptionBaseQuantity);
        /* string number_of_grid_levels = 23; */
        if (message.numberOfGridLevels !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.numberOfGridLevels);
        /* bool should_exit_with_quote_only = 24; */
        if (message.shouldExitWithQuoteOnly !== false)
            writer.tag(24, WireType.Varint).bool(message.shouldExitWithQuoteOnly);
        /* string stop_reason = 25; */
        if (message.stopReason !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.stopReason);
        /* bool pending_execution = 26; */
        if (message.pendingExecution !== false)
            writer.tag(26, WireType.Varint).bool(message.pendingExecution);
        /* string exit_type = 27; */
        if (message.exitType !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.exitType);
        /* injective_trading_rpc.ExitConfig stop_loss_config = 28; */
        if (message.stopLossConfig)
            ExitConfig.internalBinaryWrite(message.stopLossConfig, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* injective_trading_rpc.ExitConfig take_profit_config = 29; */
        if (message.takeProfitConfig)
            ExitConfig.internalBinaryWrite(message.takeProfitConfig, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* string strategy_type = 30; */
        if (message.strategyType !== "")
            writer.tag(30, WireType.LengthDelimited).string(message.strategyType);
        /* string contract_version = 31; */
        if (message.contractVersion !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.contractVersion);
        /* string contract_name = 32; */
        if (message.contractName !== "")
            writer.tag(32, WireType.LengthDelimited).string(message.contractName);
        /* string market_type = 33; */
        if (message.marketType !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.marketType);
        /* sint64 last_executed_at = 34; */
        if (message.lastExecutedAt !== 0n)
            writer.tag(34, WireType.Varint).sint64(message.lastExecutedAt);
        /* string trail_up_price = 35; */
        if (message.trailUpPrice !== "")
            writer.tag(35, WireType.LengthDelimited).string(message.trailUpPrice);
        /* string trail_down_price = 36; */
        if (message.trailDownPrice !== "")
            writer.tag(36, WireType.LengthDelimited).string(message.trailDownPrice);
        /* sint64 trail_up_counter = 37; */
        if (message.trailUpCounter !== 0n)
            writer.tag(37, WireType.Varint).sint64(message.trailUpCounter);
        /* sint64 trail_down_counter = 38; */
        if (message.trailDownCounter !== 0n)
            writer.tag(38, WireType.Varint).sint64(message.trailDownCounter);
        /* string tvl = 39; */
        if (message.tvl !== "")
            writer.tag(39, WireType.LengthDelimited).string(message.tvl);
        /* string pnl = 40; */
        if (message.pnl !== "")
            writer.tag(40, WireType.LengthDelimited).string(message.pnl);
        /* string pnl_perc = 41; */
        if (message.pnlPerc !== "")
            writer.tag(41, WireType.LengthDelimited).string(message.pnlPerc);
        /* sint64 pnl_updated_at = 42; */
        if (message.pnlUpdatedAt !== 0n)
            writer.tag(42, WireType.Varint).sint64(message.pnlUpdatedAt);
        /* string performance = 43; */
        if (message.performance !== "")
            writer.tag(43, WireType.LengthDelimited).string(message.performance);
        /* string roi = 44; */
        if (message.roi !== "")
            writer.tag(44, WireType.LengthDelimited).string(message.roi);
        /* string initial_base_price = 45; */
        if (message.initialBasePrice !== "")
            writer.tag(45, WireType.LengthDelimited).string(message.initialBasePrice);
        /* string initial_quote_price = 46; */
        if (message.initialQuotePrice !== "")
            writer.tag(46, WireType.LengthDelimited).string(message.initialQuotePrice);
        /* string current_base_price = 47; */
        if (message.currentBasePrice !== "")
            writer.tag(47, WireType.LengthDelimited).string(message.currentBasePrice);
        /* string current_quote_price = 48; */
        if (message.currentQuotePrice !== "")
            writer.tag(48, WireType.LengthDelimited).string(message.currentQuotePrice);
        /* string final_base_price = 49; */
        if (message.finalBasePrice !== "")
            writer.tag(49, WireType.LengthDelimited).string(message.finalBasePrice);
        /* string final_quote_price = 50; */
        if (message.finalQuotePrice !== "")
            writer.tag(50, WireType.LengthDelimited).string(message.finalQuotePrice);
        /* injective_trading_rpc.StrategyFinalData final_data = 51; */
        if (message.finalData)
            StrategyFinalData.internalBinaryWrite(message.finalData, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* string margin_ratio = 52; */
        if (message.marginRatio !== "")
            writer.tag(52, WireType.LengthDelimited).string(message.marginRatio);
        /* string lower_trailing_bound = 53; */
        if (message.lowerTrailingBound !== "")
            writer.tag(53, WireType.LengthDelimited).string(message.lowerTrailingBound);
        /* string upper_trailing_bound = 54; */
        if (message.upperTrailingBound !== "")
            writer.tag(54, WireType.LengthDelimited).string(message.upperTrailingBound);
        /* string new_upper_bound = 55; */
        if (message.newUpperBound !== "")
            writer.tag(55, WireType.LengthDelimited).string(message.newUpperBound);
        /* string new_lower_bound = 56; */
        if (message.newLowerBound !== "")
            writer.tag(56, WireType.LengthDelimited).string(message.newLowerBound);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.TradingStrategy
 */
export const TradingStrategy = new TradingStrategy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExitConfig$Type extends MessageType<ExitConfig> {
    constructor() {
        super("injective_trading_rpc.ExitConfig", [
            { no: 1, name: "exit_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "exit_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExitConfig>): ExitConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.exitType = "";
        message.exitPrice = "";
        if (value !== undefined)
            reflectionMergePartial<ExitConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExitConfig): ExitConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string exit_type */ 1:
                    message.exitType = reader.string();
                    break;
                case /* string exit_price */ 2:
                    message.exitPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExitConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string exit_type = 1; */
        if (message.exitType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.exitType);
        /* string exit_price = 2; */
        if (message.exitPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.exitPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.ExitConfig
 */
export const ExitConfig = new ExitConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrategyFinalData$Type extends MessageType<StrategyFinalData> {
    constructor() {
        super("injective_trading_rpc.StrategyFinalData", [
            { no: 1, name: "initial_base_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "initial_quote_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "final_base_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "final_quote_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "initial_base_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "initial_quote_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "final_base_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "final_quote_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StrategyFinalData>): StrategyFinalData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.initialBaseAmount = "";
        message.initialQuoteAmount = "";
        message.finalBaseAmount = "";
        message.finalQuoteAmount = "";
        message.initialBasePrice = "";
        message.initialQuotePrice = "";
        message.finalBasePrice = "";
        message.finalQuotePrice = "";
        if (value !== undefined)
            reflectionMergePartial<StrategyFinalData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StrategyFinalData): StrategyFinalData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string initial_base_amount */ 1:
                    message.initialBaseAmount = reader.string();
                    break;
                case /* string initial_quote_amount */ 2:
                    message.initialQuoteAmount = reader.string();
                    break;
                case /* string final_base_amount */ 3:
                    message.finalBaseAmount = reader.string();
                    break;
                case /* string final_quote_amount */ 4:
                    message.finalQuoteAmount = reader.string();
                    break;
                case /* string initial_base_price */ 5:
                    message.initialBasePrice = reader.string();
                    break;
                case /* string initial_quote_price */ 6:
                    message.initialQuotePrice = reader.string();
                    break;
                case /* string final_base_price */ 7:
                    message.finalBasePrice = reader.string();
                    break;
                case /* string final_quote_price */ 8:
                    message.finalQuotePrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StrategyFinalData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string initial_base_amount = 1; */
        if (message.initialBaseAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.initialBaseAmount);
        /* string initial_quote_amount = 2; */
        if (message.initialQuoteAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.initialQuoteAmount);
        /* string final_base_amount = 3; */
        if (message.finalBaseAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.finalBaseAmount);
        /* string final_quote_amount = 4; */
        if (message.finalQuoteAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.finalQuoteAmount);
        /* string initial_base_price = 5; */
        if (message.initialBasePrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.initialBasePrice);
        /* string initial_quote_price = 6; */
        if (message.initialQuotePrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.initialQuotePrice);
        /* string final_base_price = 7; */
        if (message.finalBasePrice !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.finalBasePrice);
        /* string final_quote_price = 8; */
        if (message.finalQuotePrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.finalQuotePrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.StrategyFinalData
 */
export const StrategyFinalData = new StrategyFinalData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Paging$Type extends MessageType<Paging> {
    constructor() {
        super("injective_trading_rpc.Paging", [
            { no: 1, name: "total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "from", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "to", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "count_by_subaccount", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "next", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Paging>): Paging {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0n;
        message.from = 0;
        message.to = 0;
        message.countBySubaccount = 0n;
        message.next = [];
        if (value !== undefined)
            reflectionMergePartial<Paging>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Paging): Paging {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 total */ 1:
                    message.total = reader.sint64().toBigInt();
                    break;
                case /* sint32 from */ 2:
                    message.from = reader.sint32();
                    break;
                case /* sint32 to */ 3:
                    message.to = reader.sint32();
                    break;
                case /* sint64 count_by_subaccount */ 4:
                    message.countBySubaccount = reader.sint64().toBigInt();
                    break;
                case /* repeated string next */ 5:
                    message.next.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Paging, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 total = 1; */
        if (message.total !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.total);
        /* sint32 from = 2; */
        if (message.from !== 0)
            writer.tag(2, WireType.Varint).sint32(message.from);
        /* sint32 to = 3; */
        if (message.to !== 0)
            writer.tag(3, WireType.Varint).sint32(message.to);
        /* sint64 count_by_subaccount = 4; */
        if (message.countBySubaccount !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
        /* repeated string next = 5; */
        for (let i = 0; i < message.next.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.Paging
 */
export const Paging = new Paging$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTradingStatsRequest$Type extends MessageType<GetTradingStatsRequest> {
    constructor() {
        super("injective_trading_rpc.GetTradingStatsRequest", []);
    }
    create(value?: PartialMessage<GetTradingStatsRequest>): GetTradingStatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTradingStatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTradingStatsRequest): GetTradingStatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTradingStatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.GetTradingStatsRequest
 */
export const GetTradingStatsRequest = new GetTradingStatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTradingStatsResponse$Type extends MessageType<GetTradingStatsResponse> {
    constructor() {
        super("injective_trading_rpc.GetTradingStatsResponse", [
            { no: 1, name: "active_trading_strategies", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "total_trading_strategies_created", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "total_tvl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Market }
        ]);
    }
    create(value?: PartialMessage<GetTradingStatsResponse>): GetTradingStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activeTradingStrategies = 0n;
        message.totalTradingStrategiesCreated = 0n;
        message.totalTvl = "";
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<GetTradingStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTradingStatsResponse): GetTradingStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 active_trading_strategies */ 1:
                    message.activeTradingStrategies = reader.uint64().toBigInt();
                    break;
                case /* uint64 total_trading_strategies_created */ 2:
                    message.totalTradingStrategiesCreated = reader.uint64().toBigInt();
                    break;
                case /* string total_tvl */ 3:
                    message.totalTvl = reader.string();
                    break;
                case /* repeated injective_trading_rpc.Market markets */ 4:
                    message.markets.push(Market.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTradingStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 active_trading_strategies = 1; */
        if (message.activeTradingStrategies !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.activeTradingStrategies);
        /* uint64 total_trading_strategies_created = 2; */
        if (message.totalTradingStrategiesCreated !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.totalTradingStrategiesCreated);
        /* string total_tvl = 3; */
        if (message.totalTvl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.totalTvl);
        /* repeated injective_trading_rpc.Market markets = 4; */
        for (let i = 0; i < message.markets.length; i++)
            Market.internalBinaryWrite(message.markets[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.GetTradingStatsResponse
 */
export const GetTradingStatsResponse = new GetTradingStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Market$Type extends MessageType<Market> {
    constructor() {
        super("injective_trading_rpc.Market", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active_trading_strategies", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Market>): Market {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.activeTradingStrategies = 0n;
        if (value !== undefined)
            reflectionMergePartial<Market>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Market): Market {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* uint64 active_trading_strategies */ 2:
                    message.activeTradingStrategies = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Market, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* uint64 active_trading_strategies = 2; */
        if (message.activeTradingStrategies !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.activeTradingStrategies);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.Market
 */
export const Market = new Market$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamStrategyRequest$Type extends MessageType<StreamStrategyRequest> {
    constructor() {
        super("injective_trading_rpc.StreamStrategyRequest", [
            { no: 1, name: "account_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamStrategyRequest>): StreamStrategyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddresses = [];
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<StreamStrategyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamStrategyRequest): StreamStrategyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string account_addresses */ 1:
                    message.accountAddresses.push(reader.string());
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamStrategyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string account_addresses = 1; */
        for (let i = 0; i < message.accountAddresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddresses[i]);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.StreamStrategyRequest
 */
export const StreamStrategyRequest = new StreamStrategyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamStrategyResponse$Type extends MessageType<StreamStrategyResponse> {
    constructor() {
        super("injective_trading_rpc.StreamStrategyResponse", [
            { no: 1, name: "trading_strategy", kind: "message", T: () => TradingStrategy },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamStrategyResponse>): StreamStrategyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamStrategyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamStrategyResponse): StreamStrategyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_trading_rpc.TradingStrategy trading_strategy */ 1:
                    message.tradingStrategy = TradingStrategy.internalBinaryRead(reader, reader.uint32(), options, message.tradingStrategy);
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamStrategyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_trading_rpc.TradingStrategy trading_strategy = 1; */
        if (message.tradingStrategy)
            TradingStrategy.internalBinaryWrite(message.tradingStrategy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.StreamStrategyResponse
 */
export const StreamStrategyResponse = new StreamStrategyResponse$Type();
/**
 * @generated ServiceType for protobuf service injective_trading_rpc.InjectiveTradingRPC
 */
export const InjectiveTradingRPC = new ServiceType("injective_trading_rpc.InjectiveTradingRPC", [
    { name: "ListTradingStrategies", options: {}, I: ListTradingStrategiesRequest, O: ListTradingStrategiesResponse },
    { name: "GetTradingStats", options: {}, I: GetTradingStatsRequest, O: GetTradingStatsResponse },
    { name: "StreamStrategy", serverStreaming: true, options: {}, I: StreamStrategyRequest, O: StreamStrategyResponse }
]);
