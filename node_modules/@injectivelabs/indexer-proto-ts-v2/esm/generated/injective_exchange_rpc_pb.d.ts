// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_exchange_rpc.proto" (package "injective_exchange_rpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveExchangeRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_exchange_rpc.GetTxRequest
 */
export interface GetTxRequest {
    /**
     * Transaction hash in hex without 0x prefix (Cosmos-like).
     *
     * @generated from protobuf field: string hash = 1
     */
    hash: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.GetTxResponse
 */
export interface GetTxResponse {
    /**
     * Hex-encoded Tendermint transaction hash
     *
     * @generated from protobuf field: string tx_hash = 1
     */
    txHash: string;
    /**
     * The block height
     *
     * @generated from protobuf field: sint64 height = 2
     */
    height: bigint;
    /**
     * Tx index in the block
     *
     * @generated from protobuf field: uint32 index = 3
     */
    index: number;
    /**
     * Namespace for the resp code
     *
     * @generated from protobuf field: string codespace = 4
     */
    codespace: string;
    /**
     * Response code
     *
     * @generated from protobuf field: uint32 code = 5
     */
    code: number;
    /**
     * Result bytes, if any
     *
     * @generated from protobuf field: bytes data = 6
     */
    data: Uint8Array;
    /**
     * The output of the application's logger (raw string). May be
     * non-deterministic.
     *
     * @generated from protobuf field: string raw_log = 7
     */
    rawLog: string;
    /**
     * Time of the previous block.
     *
     * @generated from protobuf field: string timestamp = 8
     */
    timestamp: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareTxRequest
 */
export interface PrepareTxRequest {
    /**
     * Specify chainID for the target tx
     *
     * @generated from protobuf field: uint64 chain_id = 1
     */
    chainId: bigint;
    /**
     * Specify Ethereum address of a signer
     *
     * @generated from protobuf field: string signer_address = 2
     */
    signerAddress: string;
    /**
     * Deprecated: this field is ignored
     *
     * @generated from protobuf field: uint64 sequence = 3
     */
    sequence: bigint;
    /**
     * Textual memo information to attach with tx
     *
     * @generated from protobuf field: string memo = 4
     */
    memo: string;
    /**
     * Block height until which the transaction is valid.
     *
     * @generated from protobuf field: uint64 timeout_height = 5
     */
    timeoutHeight: bigint;
    /**
     * Transaction fee details.
     *
     * @generated from protobuf field: injective_exchange_rpc.CosmosTxFee fee = 6
     */
    fee?: CosmosTxFee;
    /**
     * List of Cosmos proto3-encoded Msgs to include in a single tx
     *
     * @generated from protobuf field: repeated bytes msgs = 7
     */
    msgs: Uint8Array[];
    /**
     * The wrapper of the EIP712 message, 'v1'/'v2' or 'V1'/'V2'
     *
     * @generated from protobuf field: string eip712_wrapper = 8
     */
    eip712Wrapper: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.CosmosTxFee
 */
export interface CosmosTxFee {
    /**
     * Transaction gas price
     *
     * @generated from protobuf field: repeated injective_exchange_rpc.CosmosCoin price = 1
     */
    price: CosmosCoin[];
    /**
     * Transaction gas limit
     *
     * @generated from protobuf field: uint64 gas = 2
     */
    gas: bigint;
    /**
     * Explicitly require fee delegation when set to true. Or don't care = false.
     * Will be replaced by other flag in the next version.
     *
     * @generated from protobuf field: bool delegate_fee = 3
     */
    delegateFee: boolean;
}
/**
 * @generated from protobuf message injective_exchange_rpc.CosmosCoin
 */
export interface CosmosCoin {
    /**
     * Coin denominator
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * Coin amount (big int)
     *
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareTxResponse
 */
export interface PrepareTxResponse {
    /**
     * EIP712-compatible message suitable for signing with eth_signTypedData_v4
     *
     * @generated from protobuf field: string data = 1
     */
    data: string;
    /**
     * Account tx sequence (nonce)
     *
     * @generated from protobuf field: uint64 sequence = 2
     */
    sequence: bigint;
    /**
     * Sign mode for the resulting tx
     *
     * @generated from protobuf field: string sign_mode = 3
     */
    signMode: string;
    /**
     * Specify proto-URL of a public key, which defines the signature format
     *
     * @generated from protobuf field: string pub_key_type = 4
     */
    pubKeyType: string;
    /**
     * Fee payer address provided by service
     *
     * @generated from protobuf field: string fee_payer = 5
     */
    feePayer: string;
    /**
     * Hex-encoded ethsecp256k1 signature bytes from fee payer
     *
     * @generated from protobuf field: string fee_payer_sig = 6
     */
    feePayerSig: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareEip712Request
 */
export interface PrepareEip712Request {
    /**
     * Specify chainID for the target tx
     *
     * @generated from protobuf field: uint64 chain_id = 1
     */
    chainId: bigint;
    /**
     * Specify Ethereum address of a signer
     *
     * @generated from protobuf field: string signer_address = 2
     */
    signerAddress: string;
    /**
     * Sequence number of the transaction signer
     *
     * @generated from protobuf field: uint64 sequence = 3
     */
    sequence: bigint;
    /**
     * Account number of the transaction signer
     *
     * @generated from protobuf field: uint64 account_number = 4
     */
    accountNumber: bigint;
    /**
     * Textual memo information to attach with tx
     *
     * @generated from protobuf field: string memo = 5
     */
    memo: string;
    /**
     * Block height until which the transaction is valid.
     *
     * @generated from protobuf field: uint64 timeout_height = 6
     */
    timeoutHeight: bigint;
    /**
     * Transaction fee details.
     *
     * @generated from protobuf field: injective_exchange_rpc.CosmosTxFee fee = 7
     */
    fee?: CosmosTxFee;
    /**
     * List of Cosmos proto3-encoded Msgs to include in a single tx
     *
     * @generated from protobuf field: repeated bytes msgs = 8
     */
    msgs: Uint8Array[];
    /**
     * The wrapper of the EIP712 message, 'v1'/'v2' or 'V1'/'V2'
     *
     * @generated from protobuf field: string eip712_wrapper = 9
     */
    eip712Wrapper: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareEip712Response
 */
export interface PrepareEip712Response {
    /**
     * EIP712-compatible message suitable for signing with eth_signTypedData_v4
     *
     * @generated from protobuf field: string data = 1
     */
    data: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.BroadcastTxRequest
 */
export interface BroadcastTxRequest {
    /**
     * Specify Web3 chainID (from prepateTx) for the target Tx
     *
     * @generated from protobuf field: uint64 chain_id = 1
     */
    chainId: bigint;
    /**
     * Amino-encoded Tx JSON data (except Msgs)
     *
     * @generated from protobuf field: bytes tx = 2
     */
    tx: Uint8Array;
    /**
     * List of Cosmos proto3-encoded Msgs from tx
     *
     * @generated from protobuf field: repeated bytes msgs = 3
     */
    msgs: Uint8Array[];
    /**
     * Specify ethsecp256k1 pubkey of the signer
     *
     * @generated from protobuf field: injective_exchange_rpc.CosmosPubKey pub_key = 4
     */
    pubKey?: CosmosPubKey;
    /**
     * Hex-encoded ethsecp256k1 signature bytes
     *
     * @generated from protobuf field: string signature = 5
     */
    signature: string;
    /**
     * Fee payer address provided by service
     *
     * @generated from protobuf field: string fee_payer = 6
     */
    feePayer: string;
    /**
     * Hex-encoded ethsecp256k1 signature bytes from fee payer
     *
     * @generated from protobuf field: string fee_payer_sig = 7
     */
    feePayerSig: string;
    /**
     * Broadcast mode
     *
     * @generated from protobuf field: string mode = 8
     */
    mode: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.CosmosPubKey
 */
export interface CosmosPubKey {
    /**
     * Pubkey type URL
     *
     * @generated from protobuf field: string type = 1
     */
    type: string;
    /**
     * Hex-encoded string of the public key
     *
     * @generated from protobuf field: string key = 2
     */
    key: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.BroadcastTxResponse
 */
export interface BroadcastTxResponse {
    /**
     * Hex-encoded Tendermint transaction hash
     *
     * @generated from protobuf field: string tx_hash = 1
     */
    txHash: string;
    /**
     * The block height
     *
     * @generated from protobuf field: sint64 height = 2
     */
    height: bigint;
    /**
     * Tx index in the block
     *
     * @generated from protobuf field: uint32 index = 3
     */
    index: number;
    /**
     * Namespace for the resp code
     *
     * @generated from protobuf field: string codespace = 4
     */
    codespace: string;
    /**
     * Response code
     *
     * @generated from protobuf field: uint32 code = 5
     */
    code: number;
    /**
     * Result bytes, if any
     *
     * @generated from protobuf field: bytes data = 6
     */
    data: Uint8Array;
    /**
     * The output of the application's logger (raw string). May be
     * non-deterministic.
     *
     * @generated from protobuf field: string raw_log = 7
     */
    rawLog: string;
    /**
     * Time of the previous block.
     *
     * @generated from protobuf field: string timestamp = 8
     */
    timestamp: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareCosmosTxRequest
 */
export interface PrepareCosmosTxRequest {
    /**
     * Specify chainID for the target tx
     *
     * @generated from protobuf field: uint64 chain_id = 1
     */
    chainId: bigint;
    /**
     * sender address provided
     *
     * @generated from protobuf field: string sender_address = 2
     */
    senderAddress: string;
    /**
     * Textual memo information to attach with tx
     *
     * @generated from protobuf field: string memo = 3
     */
    memo: string;
    /**
     * Block height until which the transaction is valid.
     *
     * @generated from protobuf field: uint64 timeout_height = 4
     */
    timeoutHeight: bigint;
    /**
     * Transaction fee details.
     *
     * @generated from protobuf field: injective_exchange_rpc.CosmosTxFee fee = 5
     */
    fee?: CosmosTxFee;
    /**
     * List of Cosmos proto3-encoded Msgs to include in a single tx
     *
     * @generated from protobuf field: repeated bytes msgs = 6
     */
    msgs: Uint8Array[];
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareCosmosTxResponse
 */
export interface PrepareCosmosTxResponse {
    /**
     * proto encoded tx
     *
     * @generated from protobuf field: bytes tx = 1
     */
    tx: Uint8Array;
    /**
     * Sign mode for the resulting tx
     *
     * @generated from protobuf field: string sign_mode = 2
     */
    signMode: string;
    /**
     * Specify proto-URL of a public key, which defines the signature format
     *
     * @generated from protobuf field: string pub_key_type = 3
     */
    pubKeyType: string;
    /**
     * Fee payer address provided by service
     *
     * @generated from protobuf field: string fee_payer = 4
     */
    feePayer: string;
    /**
     * Hex-encoded ethsecp256k1 signature bytes from fee payer
     *
     * @generated from protobuf field: string fee_payer_sig = 5
     */
    feePayerSig: string;
    /**
     * ethsecp256k1 feePayer pubkey
     *
     * @generated from protobuf field: injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 6
     */
    feePayerPubKey?: CosmosPubKey;
}
/**
 * @generated from protobuf message injective_exchange_rpc.BroadcastCosmosTxRequest
 */
export interface BroadcastCosmosTxRequest {
    /**
     * proto encoded tx
     *
     * @generated from protobuf field: bytes tx = 1
     */
    tx: Uint8Array;
    /**
     * Specify ethsecp256k1 sender pubkey
     *
     * @generated from protobuf field: injective_exchange_rpc.CosmosPubKey pub_key = 2
     */
    pubKey?: CosmosPubKey;
    /**
     * Hex-encoded ethsecp256k1 sender signature bytes
     *
     * @generated from protobuf field: string signature = 3
     */
    signature: string;
    /**
     * sender address
     *
     * @generated from protobuf field: string sender_address = 4
     */
    senderAddress: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.BroadcastCosmosTxResponse
 */
export interface BroadcastCosmosTxResponse {
    /**
     * Hex-encoded Tendermint transaction hash
     *
     * @generated from protobuf field: string tx_hash = 1
     */
    txHash: string;
    /**
     * The block height
     *
     * @generated from protobuf field: sint64 height = 2
     */
    height: bigint;
    /**
     * Tx index in the block
     *
     * @generated from protobuf field: uint32 index = 3
     */
    index: number;
    /**
     * Namespace for the resp code
     *
     * @generated from protobuf field: string codespace = 4
     */
    codespace: string;
    /**
     * Response code
     *
     * @generated from protobuf field: uint32 code = 5
     */
    code: number;
    /**
     * Result bytes, if any
     *
     * @generated from protobuf field: bytes data = 6
     */
    data: Uint8Array;
    /**
     * The output of the application's logger (raw string). May be
     * non-deterministic.
     *
     * @generated from protobuf field: string raw_log = 7
     */
    rawLog: string;
    /**
     * Time of the previous block.
     *
     * @generated from protobuf field: string timestamp = 8
     */
    timestamp: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.GetFeePayerRequest
 */
export interface GetFeePayerRequest {
}
/**
 * @generated from protobuf message injective_exchange_rpc.GetFeePayerResponse
 */
export interface GetFeePayerResponse {
    /**
     * Fee payer address provided by service
     *
     * @generated from protobuf field: string fee_payer = 1
     */
    feePayer: string;
    /**
     * ethsecp256k1 feePayer pubkey
     *
     * @generated from protobuf field: injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 2
     */
    feePayerPubKey?: CosmosPubKey;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetTxRequest$Type extends MessageType<GetTxRequest> {
    constructor() {
        super("injective_exchange_rpc.GetTxRequest", [
            { no: 1, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTxRequest>): GetTxRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = "";
        if (value !== undefined)
            reflectionMergePartial<GetTxRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxRequest): GetTxRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash */ 1:
                    message.hash = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash = 1; */
        if (message.hash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.GetTxRequest
 */
export const GetTxRequest = new GetTxRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxResponse$Type extends MessageType<GetTxResponse> {
    constructor() {
        super("injective_exchange_rpc.GetTxResponse", [
            { no: 1, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "raw_log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTxResponse>): GetTxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txHash = "";
        message.height = 0n;
        message.index = 0;
        message.codespace = "";
        message.code = 0;
        message.data = new Uint8Array(0);
        message.rawLog = "";
        message.timestamp = "";
        if (value !== undefined)
            reflectionMergePartial<GetTxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxResponse): GetTxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tx_hash */ 1:
                    message.txHash = reader.string();
                    break;
                case /* sint64 height */ 2:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* uint32 index */ 3:
                    message.index = reader.uint32();
                    break;
                case /* string codespace */ 4:
                    message.codespace = reader.string();
                    break;
                case /* uint32 code */ 5:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 6:
                    message.data = reader.bytes();
                    break;
                case /* string raw_log */ 7:
                    message.rawLog = reader.string();
                    break;
                case /* string timestamp */ 8:
                    message.timestamp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tx_hash = 1; */
        if (message.txHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txHash);
        /* sint64 height = 2; */
        if (message.height !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.height);
        /* uint32 index = 3; */
        if (message.index !== 0)
            writer.tag(3, WireType.Varint).uint32(message.index);
        /* string codespace = 4; */
        if (message.codespace !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.codespace);
        /* uint32 code = 5; */
        if (message.code !== 0)
            writer.tag(5, WireType.Varint).uint32(message.code);
        /* bytes data = 6; */
        if (message.data.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.data);
        /* string raw_log = 7; */
        if (message.rawLog !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.rawLog);
        /* string timestamp = 8; */
        if (message.timestamp !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.GetTxResponse
 */
export const GetTxResponse = new GetTxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareTxRequest$Type extends MessageType<PrepareTxRequest> {
    constructor() {
        super("injective_exchange_rpc.PrepareTxRequest", [
            { no: 1, name: "chain_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "signer_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "memo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "timeout_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "fee", kind: "message", T: () => CosmosTxFee },
            { no: 7, name: "msgs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "eip712_wrapper", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareTxRequest>): PrepareTxRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = 0n;
        message.signerAddress = "";
        message.sequence = 0n;
        message.memo = "";
        message.timeoutHeight = 0n;
        message.msgs = [];
        message.eip712Wrapper = "";
        if (value !== undefined)
            reflectionMergePartial<PrepareTxRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareTxRequest): PrepareTxRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chain_id */ 1:
                    message.chainId = reader.uint64().toBigInt();
                    break;
                case /* string signer_address */ 2:
                    message.signerAddress = reader.string();
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* string memo */ 4:
                    message.memo = reader.string();
                    break;
                case /* uint64 timeout_height */ 5:
                    message.timeoutHeight = reader.uint64().toBigInt();
                    break;
                case /* injective_exchange_rpc.CosmosTxFee fee */ 6:
                    message.fee = CosmosTxFee.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* repeated bytes msgs */ 7:
                    message.msgs.push(reader.bytes());
                    break;
                case /* string eip712_wrapper */ 8:
                    message.eip712Wrapper = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareTxRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chain_id = 1; */
        if (message.chainId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.chainId);
        /* string signer_address = 2; */
        if (message.signerAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signerAddress);
        /* uint64 sequence = 3; */
        if (message.sequence !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        /* string memo = 4; */
        if (message.memo !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.memo);
        /* uint64 timeout_height = 5; */
        if (message.timeoutHeight !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.timeoutHeight);
        /* injective_exchange_rpc.CosmosTxFee fee = 6; */
        if (message.fee)
            CosmosTxFee.internalBinaryWrite(message.fee, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes msgs = 7; */
        for (let i = 0; i < message.msgs.length; i++)
            writer.tag(7, WireType.LengthDelimited).bytes(message.msgs[i]);
        /* string eip712_wrapper = 8; */
        if (message.eip712Wrapper !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.eip712Wrapper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareTxRequest
 */
export const PrepareTxRequest = new PrepareTxRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CosmosTxFee$Type extends MessageType<CosmosTxFee> {
    constructor() {
        super("injective_exchange_rpc.CosmosTxFee", [
            { no: 1, name: "price", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CosmosCoin },
            { no: 2, name: "gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "delegate_fee", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CosmosTxFee>): CosmosTxFee {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = [];
        message.gas = 0n;
        message.delegateFee = false;
        if (value !== undefined)
            reflectionMergePartial<CosmosTxFee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CosmosTxFee): CosmosTxFee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_exchange_rpc.CosmosCoin price */ 1:
                    message.price.push(CosmosCoin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 gas */ 2:
                    message.gas = reader.uint64().toBigInt();
                    break;
                case /* bool delegate_fee */ 3:
                    message.delegateFee = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CosmosTxFee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_exchange_rpc.CosmosCoin price = 1; */
        for (let i = 0; i < message.price.length; i++)
            CosmosCoin.internalBinaryWrite(message.price[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 gas = 2; */
        if (message.gas !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.gas);
        /* bool delegate_fee = 3; */
        if (message.delegateFee !== false)
            writer.tag(3, WireType.Varint).bool(message.delegateFee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.CosmosTxFee
 */
export const CosmosTxFee = new CosmosTxFee$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CosmosCoin$Type extends MessageType<CosmosCoin> {
    constructor() {
        super("injective_exchange_rpc.CosmosCoin", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CosmosCoin>): CosmosCoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<CosmosCoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CosmosCoin): CosmosCoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CosmosCoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.CosmosCoin
 */
export const CosmosCoin = new CosmosCoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareTxResponse$Type extends MessageType<PrepareTxResponse> {
    constructor() {
        super("injective_exchange_rpc.PrepareTxResponse", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sign_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pub_key_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "fee_payer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fee_payer_sig", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareTxResponse>): PrepareTxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = "";
        message.sequence = 0n;
        message.signMode = "";
        message.pubKeyType = "";
        message.feePayer = "";
        message.feePayerSig = "";
        if (value !== undefined)
            reflectionMergePartial<PrepareTxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareTxResponse): PrepareTxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                case /* uint64 sequence */ 2:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* string sign_mode */ 3:
                    message.signMode = reader.string();
                    break;
                case /* string pub_key_type */ 4:
                    message.pubKeyType = reader.string();
                    break;
                case /* string fee_payer */ 5:
                    message.feePayer = reader.string();
                    break;
                case /* string fee_payer_sig */ 6:
                    message.feePayerSig = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareTxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        /* uint64 sequence = 2; */
        if (message.sequence !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.sequence);
        /* string sign_mode = 3; */
        if (message.signMode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.signMode);
        /* string pub_key_type = 4; */
        if (message.pubKeyType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pubKeyType);
        /* string fee_payer = 5; */
        if (message.feePayer !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.feePayer);
        /* string fee_payer_sig = 6; */
        if (message.feePayerSig !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.feePayerSig);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareTxResponse
 */
export const PrepareTxResponse = new PrepareTxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareEip712Request$Type extends MessageType<PrepareEip712Request> {
    constructor() {
        super("injective_exchange_rpc.PrepareEip712Request", [
            { no: 1, name: "chain_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "signer_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "account_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "memo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "timeout_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "fee", kind: "message", T: () => CosmosTxFee },
            { no: 8, name: "msgs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "eip712_wrapper", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareEip712Request>): PrepareEip712Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = 0n;
        message.signerAddress = "";
        message.sequence = 0n;
        message.accountNumber = 0n;
        message.memo = "";
        message.timeoutHeight = 0n;
        message.msgs = [];
        message.eip712Wrapper = "";
        if (value !== undefined)
            reflectionMergePartial<PrepareEip712Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareEip712Request): PrepareEip712Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chain_id */ 1:
                    message.chainId = reader.uint64().toBigInt();
                    break;
                case /* string signer_address */ 2:
                    message.signerAddress = reader.string();
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* uint64 account_number */ 4:
                    message.accountNumber = reader.uint64().toBigInt();
                    break;
                case /* string memo */ 5:
                    message.memo = reader.string();
                    break;
                case /* uint64 timeout_height */ 6:
                    message.timeoutHeight = reader.uint64().toBigInt();
                    break;
                case /* injective_exchange_rpc.CosmosTxFee fee */ 7:
                    message.fee = CosmosTxFee.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* repeated bytes msgs */ 8:
                    message.msgs.push(reader.bytes());
                    break;
                case /* string eip712_wrapper */ 9:
                    message.eip712Wrapper = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareEip712Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chain_id = 1; */
        if (message.chainId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.chainId);
        /* string signer_address = 2; */
        if (message.signerAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signerAddress);
        /* uint64 sequence = 3; */
        if (message.sequence !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        /* uint64 account_number = 4; */
        if (message.accountNumber !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.accountNumber);
        /* string memo = 5; */
        if (message.memo !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.memo);
        /* uint64 timeout_height = 6; */
        if (message.timeoutHeight !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.timeoutHeight);
        /* injective_exchange_rpc.CosmosTxFee fee = 7; */
        if (message.fee)
            CosmosTxFee.internalBinaryWrite(message.fee, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes msgs = 8; */
        for (let i = 0; i < message.msgs.length; i++)
            writer.tag(8, WireType.LengthDelimited).bytes(message.msgs[i]);
        /* string eip712_wrapper = 9; */
        if (message.eip712Wrapper !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.eip712Wrapper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareEip712Request
 */
export const PrepareEip712Request = new PrepareEip712Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareEip712Response$Type extends MessageType<PrepareEip712Response> {
    constructor() {
        super("injective_exchange_rpc.PrepareEip712Response", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareEip712Response>): PrepareEip712Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<PrepareEip712Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareEip712Response): PrepareEip712Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareEip712Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareEip712Response
 */
export const PrepareEip712Response = new PrepareEip712Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BroadcastTxRequest$Type extends MessageType<BroadcastTxRequest> {
    constructor() {
        super("injective_exchange_rpc.BroadcastTxRequest", [
            { no: 1, name: "chain_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "msgs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "pub_key", kind: "message", T: () => CosmosPubKey },
            { no: 5, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fee_payer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "fee_payer_sig", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BroadcastTxRequest>): BroadcastTxRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = 0n;
        message.tx = new Uint8Array(0);
        message.msgs = [];
        message.signature = "";
        message.feePayer = "";
        message.feePayerSig = "";
        message.mode = "";
        if (value !== undefined)
            reflectionMergePartial<BroadcastTxRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BroadcastTxRequest): BroadcastTxRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chain_id */ 1:
                    message.chainId = reader.uint64().toBigInt();
                    break;
                case /* bytes tx */ 2:
                    message.tx = reader.bytes();
                    break;
                case /* repeated bytes msgs */ 3:
                    message.msgs.push(reader.bytes());
                    break;
                case /* injective_exchange_rpc.CosmosPubKey pub_key */ 4:
                    message.pubKey = CosmosPubKey.internalBinaryRead(reader, reader.uint32(), options, message.pubKey);
                    break;
                case /* string signature */ 5:
                    message.signature = reader.string();
                    break;
                case /* string fee_payer */ 6:
                    message.feePayer = reader.string();
                    break;
                case /* string fee_payer_sig */ 7:
                    message.feePayerSig = reader.string();
                    break;
                case /* string mode */ 8:
                    message.mode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BroadcastTxRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chain_id = 1; */
        if (message.chainId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.chainId);
        /* bytes tx = 2; */
        if (message.tx.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.tx);
        /* repeated bytes msgs = 3; */
        for (let i = 0; i < message.msgs.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.msgs[i]);
        /* injective_exchange_rpc.CosmosPubKey pub_key = 4; */
        if (message.pubKey)
            CosmosPubKey.internalBinaryWrite(message.pubKey, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string signature = 5; */
        if (message.signature !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.signature);
        /* string fee_payer = 6; */
        if (message.feePayer !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.feePayer);
        /* string fee_payer_sig = 7; */
        if (message.feePayerSig !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.feePayerSig);
        /* string mode = 8; */
        if (message.mode !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.BroadcastTxRequest
 */
export const BroadcastTxRequest = new BroadcastTxRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CosmosPubKey$Type extends MessageType<CosmosPubKey> {
    constructor() {
        super("injective_exchange_rpc.CosmosPubKey", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CosmosPubKey>): CosmosPubKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<CosmosPubKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CosmosPubKey): CosmosPubKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CosmosPubKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.CosmosPubKey
 */
export const CosmosPubKey = new CosmosPubKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BroadcastTxResponse$Type extends MessageType<BroadcastTxResponse> {
    constructor() {
        super("injective_exchange_rpc.BroadcastTxResponse", [
            { no: 1, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "raw_log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BroadcastTxResponse>): BroadcastTxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txHash = "";
        message.height = 0n;
        message.index = 0;
        message.codespace = "";
        message.code = 0;
        message.data = new Uint8Array(0);
        message.rawLog = "";
        message.timestamp = "";
        if (value !== undefined)
            reflectionMergePartial<BroadcastTxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BroadcastTxResponse): BroadcastTxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tx_hash */ 1:
                    message.txHash = reader.string();
                    break;
                case /* sint64 height */ 2:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* uint32 index */ 3:
                    message.index = reader.uint32();
                    break;
                case /* string codespace */ 4:
                    message.codespace = reader.string();
                    break;
                case /* uint32 code */ 5:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 6:
                    message.data = reader.bytes();
                    break;
                case /* string raw_log */ 7:
                    message.rawLog = reader.string();
                    break;
                case /* string timestamp */ 8:
                    message.timestamp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BroadcastTxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tx_hash = 1; */
        if (message.txHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txHash);
        /* sint64 height = 2; */
        if (message.height !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.height);
        /* uint32 index = 3; */
        if (message.index !== 0)
            writer.tag(3, WireType.Varint).uint32(message.index);
        /* string codespace = 4; */
        if (message.codespace !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.codespace);
        /* uint32 code = 5; */
        if (message.code !== 0)
            writer.tag(5, WireType.Varint).uint32(message.code);
        /* bytes data = 6; */
        if (message.data.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.data);
        /* string raw_log = 7; */
        if (message.rawLog !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.rawLog);
        /* string timestamp = 8; */
        if (message.timestamp !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.BroadcastTxResponse
 */
export const BroadcastTxResponse = new BroadcastTxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareCosmosTxRequest$Type extends MessageType<PrepareCosmosTxRequest> {
    constructor() {
        super("injective_exchange_rpc.PrepareCosmosTxRequest", [
            { no: 1, name: "chain_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sender_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "memo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timeout_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "fee", kind: "message", T: () => CosmosTxFee },
            { no: 6, name: "msgs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareCosmosTxRequest>): PrepareCosmosTxRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = 0n;
        message.senderAddress = "";
        message.memo = "";
        message.timeoutHeight = 0n;
        message.msgs = [];
        if (value !== undefined)
            reflectionMergePartial<PrepareCosmosTxRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareCosmosTxRequest): PrepareCosmosTxRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chain_id */ 1:
                    message.chainId = reader.uint64().toBigInt();
                    break;
                case /* string sender_address */ 2:
                    message.senderAddress = reader.string();
                    break;
                case /* string memo */ 3:
                    message.memo = reader.string();
                    break;
                case /* uint64 timeout_height */ 4:
                    message.timeoutHeight = reader.uint64().toBigInt();
                    break;
                case /* injective_exchange_rpc.CosmosTxFee fee */ 5:
                    message.fee = CosmosTxFee.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* repeated bytes msgs */ 6:
                    message.msgs.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareCosmosTxRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chain_id = 1; */
        if (message.chainId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.chainId);
        /* string sender_address = 2; */
        if (message.senderAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.senderAddress);
        /* string memo = 3; */
        if (message.memo !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.memo);
        /* uint64 timeout_height = 4; */
        if (message.timeoutHeight !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.timeoutHeight);
        /* injective_exchange_rpc.CosmosTxFee fee = 5; */
        if (message.fee)
            CosmosTxFee.internalBinaryWrite(message.fee, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes msgs = 6; */
        for (let i = 0; i < message.msgs.length; i++)
            writer.tag(6, WireType.LengthDelimited).bytes(message.msgs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareCosmosTxRequest
 */
export const PrepareCosmosTxRequest = new PrepareCosmosTxRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareCosmosTxResponse$Type extends MessageType<PrepareCosmosTxResponse> {
    constructor() {
        super("injective_exchange_rpc.PrepareCosmosTxResponse", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sign_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pub_key_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "fee_payer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "fee_payer_sig", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fee_payer_pub_key", kind: "message", T: () => CosmosPubKey }
        ]);
    }
    create(value?: PartialMessage<PrepareCosmosTxResponse>): PrepareCosmosTxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tx = new Uint8Array(0);
        message.signMode = "";
        message.pubKeyType = "";
        message.feePayer = "";
        message.feePayerSig = "";
        if (value !== undefined)
            reflectionMergePartial<PrepareCosmosTxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareCosmosTxResponse): PrepareCosmosTxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                case /* string sign_mode */ 2:
                    message.signMode = reader.string();
                    break;
                case /* string pub_key_type */ 3:
                    message.pubKeyType = reader.string();
                    break;
                case /* string fee_payer */ 4:
                    message.feePayer = reader.string();
                    break;
                case /* string fee_payer_sig */ 5:
                    message.feePayerSig = reader.string();
                    break;
                case /* injective_exchange_rpc.CosmosPubKey fee_payer_pub_key */ 6:
                    message.feePayerPubKey = CosmosPubKey.internalBinaryRead(reader, reader.uint32(), options, message.feePayerPubKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareCosmosTxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        /* string sign_mode = 2; */
        if (message.signMode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signMode);
        /* string pub_key_type = 3; */
        if (message.pubKeyType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pubKeyType);
        /* string fee_payer = 4; */
        if (message.feePayer !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.feePayer);
        /* string fee_payer_sig = 5; */
        if (message.feePayerSig !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.feePayerSig);
        /* injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 6; */
        if (message.feePayerPubKey)
            CosmosPubKey.internalBinaryWrite(message.feePayerPubKey, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareCosmosTxResponse
 */
export const PrepareCosmosTxResponse = new PrepareCosmosTxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BroadcastCosmosTxRequest$Type extends MessageType<BroadcastCosmosTxRequest> {
    constructor() {
        super("injective_exchange_rpc.BroadcastCosmosTxRequest", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "pub_key", kind: "message", T: () => CosmosPubKey },
            { no: 3, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sender_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BroadcastCosmosTxRequest>): BroadcastCosmosTxRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tx = new Uint8Array(0);
        message.signature = "";
        message.senderAddress = "";
        if (value !== undefined)
            reflectionMergePartial<BroadcastCosmosTxRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BroadcastCosmosTxRequest): BroadcastCosmosTxRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                case /* injective_exchange_rpc.CosmosPubKey pub_key */ 2:
                    message.pubKey = CosmosPubKey.internalBinaryRead(reader, reader.uint32(), options, message.pubKey);
                    break;
                case /* string signature */ 3:
                    message.signature = reader.string();
                    break;
                case /* string sender_address */ 4:
                    message.senderAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BroadcastCosmosTxRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        /* injective_exchange_rpc.CosmosPubKey pub_key = 2; */
        if (message.pubKey)
            CosmosPubKey.internalBinaryWrite(message.pubKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string signature = 3; */
        if (message.signature !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.signature);
        /* string sender_address = 4; */
        if (message.senderAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.senderAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.BroadcastCosmosTxRequest
 */
export const BroadcastCosmosTxRequest = new BroadcastCosmosTxRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BroadcastCosmosTxResponse$Type extends MessageType<BroadcastCosmosTxResponse> {
    constructor() {
        super("injective_exchange_rpc.BroadcastCosmosTxResponse", [
            { no: 1, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "raw_log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BroadcastCosmosTxResponse>): BroadcastCosmosTxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txHash = "";
        message.height = 0n;
        message.index = 0;
        message.codespace = "";
        message.code = 0;
        message.data = new Uint8Array(0);
        message.rawLog = "";
        message.timestamp = "";
        if (value !== undefined)
            reflectionMergePartial<BroadcastCosmosTxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BroadcastCosmosTxResponse): BroadcastCosmosTxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tx_hash */ 1:
                    message.txHash = reader.string();
                    break;
                case /* sint64 height */ 2:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* uint32 index */ 3:
                    message.index = reader.uint32();
                    break;
                case /* string codespace */ 4:
                    message.codespace = reader.string();
                    break;
                case /* uint32 code */ 5:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 6:
                    message.data = reader.bytes();
                    break;
                case /* string raw_log */ 7:
                    message.rawLog = reader.string();
                    break;
                case /* string timestamp */ 8:
                    message.timestamp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BroadcastCosmosTxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tx_hash = 1; */
        if (message.txHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txHash);
        /* sint64 height = 2; */
        if (message.height !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.height);
        /* uint32 index = 3; */
        if (message.index !== 0)
            writer.tag(3, WireType.Varint).uint32(message.index);
        /* string codespace = 4; */
        if (message.codespace !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.codespace);
        /* uint32 code = 5; */
        if (message.code !== 0)
            writer.tag(5, WireType.Varint).uint32(message.code);
        /* bytes data = 6; */
        if (message.data.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.data);
        /* string raw_log = 7; */
        if (message.rawLog !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.rawLog);
        /* string timestamp = 8; */
        if (message.timestamp !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.BroadcastCosmosTxResponse
 */
export const BroadcastCosmosTxResponse = new BroadcastCosmosTxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeePayerRequest$Type extends MessageType<GetFeePayerRequest> {
    constructor() {
        super("injective_exchange_rpc.GetFeePayerRequest", []);
    }
    create(value?: PartialMessage<GetFeePayerRequest>): GetFeePayerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFeePayerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeePayerRequest): GetFeePayerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeePayerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.GetFeePayerRequest
 */
export const GetFeePayerRequest = new GetFeePayerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeePayerResponse$Type extends MessageType<GetFeePayerResponse> {
    constructor() {
        super("injective_exchange_rpc.GetFeePayerResponse", [
            { no: 1, name: "fee_payer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fee_payer_pub_key", kind: "message", T: () => CosmosPubKey }
        ]);
    }
    create(value?: PartialMessage<GetFeePayerResponse>): GetFeePayerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feePayer = "";
        if (value !== undefined)
            reflectionMergePartial<GetFeePayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeePayerResponse): GetFeePayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fee_payer */ 1:
                    message.feePayer = reader.string();
                    break;
                case /* injective_exchange_rpc.CosmosPubKey fee_payer_pub_key */ 2:
                    message.feePayerPubKey = CosmosPubKey.internalBinaryRead(reader, reader.uint32(), options, message.feePayerPubKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeePayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fee_payer = 1; */
        if (message.feePayer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feePayer);
        /* injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 2; */
        if (message.feePayerPubKey)
            CosmosPubKey.internalBinaryWrite(message.feePayerPubKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.GetFeePayerResponse
 */
export const GetFeePayerResponse = new GetFeePayerResponse$Type();
/**
 * @generated ServiceType for protobuf service injective_exchange_rpc.InjectiveExchangeRPC
 */
export const InjectiveExchangeRPC = new ServiceType("injective_exchange_rpc.InjectiveExchangeRPC", [
    { name: "GetTx", options: {}, I: GetTxRequest, O: GetTxResponse },
    { name: "PrepareTx", options: {}, I: PrepareTxRequest, O: PrepareTxResponse },
    { name: "PrepareEip712", options: {}, I: PrepareEip712Request, O: PrepareEip712Response },
    { name: "BroadcastTx", options: {}, I: BroadcastTxRequest, O: BroadcastTxResponse },
    { name: "PrepareCosmosTx", options: {}, I: PrepareCosmosTxRequest, O: PrepareCosmosTxResponse },
    { name: "BroadcastCosmosTx", options: {}, I: BroadcastCosmosTxRequest, O: BroadcastCosmosTxResponse },
    { name: "GetFeePayer", options: {}, I: GetFeePayerRequest, O: GetFeePayerResponse }
]);
