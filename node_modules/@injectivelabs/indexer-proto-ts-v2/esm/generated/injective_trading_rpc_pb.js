import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class ListTradingStrategiesRequest$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.ListTradingStrategiesRequest", [
      {
        no: 1,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "pending_execution",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "limit",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 9,
        name: "skip",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "strategy_type",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "market_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "last_executed_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "with_tvl",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 14,
        name: "is_trailing_strategy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 15,
        name: "with_performance",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.state = "";
    message.marketId = "";
    message.subaccountId = "";
    message.accountAddress = "";
    message.pendingExecution = false;
    message.startTime = 0n;
    message.endTime = 0n;
    message.limit = 0;
    message.skip = 0n;
    message.strategyType = [];
    message.marketType = "";
    message.lastExecutedTime = 0n;
    message.withTvl = false;
    message.isTrailingStrategy = false;
    message.withPerformance = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string state */
        1:
          message.state = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string account_address */
        4:
          message.accountAddress = reader.string();
          break;
        case /* bool pending_execution */
        5:
          message.pendingExecution = reader.bool();
          break;
        case /* sint64 start_time */
        6:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        7:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* sint32 limit */
        8:
          message.limit = reader.sint32();
          break;
        case /* uint64 skip */
        9:
          message.skip = reader.uint64().toBigInt();
          break;
        case /* repeated string strategy_type */
        10:
          message.strategyType.push(reader.string());
          break;
        case /* string market_type */
        11:
          message.marketType = reader.string();
          break;
        case /* sint64 last_executed_time */
        12:
          message.lastExecutedTime = reader.sint64().toBigInt();
          break;
        case /* bool with_tvl */
        13:
          message.withTvl = reader.bool();
          break;
        case /* bool is_trailing_strategy */
        14:
          message.isTrailingStrategy = reader.bool();
          break;
        case /* bool with_performance */
        15:
          message.withPerformance = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.state);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.accountAddress !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.accountAddress);
    if (message.pendingExecution !== false)
      writer.tag(5, WireType.Varint).bool(message.pendingExecution);
    if (message.startTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.endTime);
    if (message.limit !== 0)
      writer.tag(8, WireType.Varint).sint32(message.limit);
    if (message.skip !== 0n)
      writer.tag(9, WireType.Varint).uint64(message.skip);
    for (let i = 0; i < message.strategyType.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.strategyType[i]);
    if (message.marketType !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.marketType);
    if (message.lastExecutedTime !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.lastExecutedTime);
    if (message.withTvl !== false)
      writer.tag(13, WireType.Varint).bool(message.withTvl);
    if (message.isTrailingStrategy !== false)
      writer.tag(14, WireType.Varint).bool(message.isTrailingStrategy);
    if (message.withPerformance !== false)
      writer.tag(15, WireType.Varint).bool(message.withPerformance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListTradingStrategiesRequest = new ListTradingStrategiesRequest$Type();
class ListTradingStrategiesResponse$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.ListTradingStrategiesResponse", [
      { no: 1, name: "strategies", kind: "message", repeat: 2, T: () => TradingStrategy },
      { no: 2, name: "paging", kind: "message", T: () => Paging }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.strategies = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_trading_rpc.TradingStrategy strategies */
        1:
          message.strategies.push(TradingStrategy.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective_trading_rpc.Paging paging */
        2:
          message.paging = Paging.internalBinaryRead(reader, reader.uint32(), options, message.paging);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.strategies.length; i++)
      TradingStrategy.internalBinaryWrite(message.strategies[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.paging)
      Paging.internalBinaryWrite(message.paging, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListTradingStrategiesResponse = new ListTradingStrategiesResponse$Type();
class TradingStrategy$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.TradingStrategy", [
      {
        no: 1,
        name: "state",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "execution_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "base_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 20,
        name: "quote_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "lower_bound",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "upper_bound",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "stop_loss",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "take_profit",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "swap_fee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 17,
        name: "base_deposit",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 18,
        name: "quote_deposit",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 19,
        name: "market_mid_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: "subscription_quote_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 22,
        name: "subscription_base_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 23,
        name: "number_of_grid_levels",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 24,
        name: "should_exit_with_quote_only",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 25,
        name: "stop_reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 26,
        name: "pending_execution",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "created_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "removed_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 15,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 16,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 27,
        name: "exit_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 28, name: "stop_loss_config", kind: "message", T: () => ExitConfig },
      { no: 29, name: "take_profit_config", kind: "message", T: () => ExitConfig },
      {
        no: 30,
        name: "strategy_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 31,
        name: "contract_version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 32,
        name: "contract_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 33,
        name: "market_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 34,
        name: "last_executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 35,
        name: "trail_up_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 36,
        name: "trail_down_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 37,
        name: "trail_up_counter",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 38,
        name: "trail_down_counter",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 39,
        name: "tvl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 40,
        name: "pnl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 41,
        name: "pnl_perc",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 42,
        name: "pnl_updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 43,
        name: "performance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 44,
        name: "roi",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 45,
        name: "initial_base_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 46,
        name: "initial_quote_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 47,
        name: "current_base_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 48,
        name: "current_quote_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 49,
        name: "final_base_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 50,
        name: "final_quote_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 51, name: "final_data", kind: "message", T: () => StrategyFinalData },
      {
        no: 52,
        name: "margin_ratio",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 53,
        name: "lower_trailing_bound",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 54,
        name: "upper_trailing_bound",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 55,
        name: "new_upper_bound",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 56,
        name: "new_lower_bound",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.state = "";
    message.marketId = "";
    message.subaccountId = "";
    message.accountAddress = "";
    message.contractAddress = "";
    message.executionPrice = "";
    message.baseQuantity = "";
    message.quoteQuantity = "";
    message.lowerBound = "";
    message.upperBound = "";
    message.stopLoss = "";
    message.takeProfit = "";
    message.swapFee = "";
    message.baseDeposit = "";
    message.quoteDeposit = "";
    message.marketMidPrice = "";
    message.subscriptionQuoteQuantity = "";
    message.subscriptionBaseQuantity = "";
    message.numberOfGridLevels = "";
    message.shouldExitWithQuoteOnly = false;
    message.stopReason = "";
    message.pendingExecution = false;
    message.createdHeight = 0n;
    message.removedHeight = 0n;
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.exitType = "";
    message.strategyType = "";
    message.contractVersion = "";
    message.contractName = "";
    message.marketType = "";
    message.lastExecutedAt = 0n;
    message.trailUpPrice = "";
    message.trailDownPrice = "";
    message.trailUpCounter = 0n;
    message.trailDownCounter = 0n;
    message.tvl = "";
    message.pnl = "";
    message.pnlPerc = "";
    message.pnlUpdatedAt = 0n;
    message.performance = "";
    message.roi = "";
    message.initialBasePrice = "";
    message.initialQuotePrice = "";
    message.currentBasePrice = "";
    message.currentQuotePrice = "";
    message.finalBasePrice = "";
    message.finalQuotePrice = "";
    message.marginRatio = "";
    message.lowerTrailingBound = "";
    message.upperTrailingBound = "";
    message.newUpperBound = "";
    message.newLowerBound = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string state */
        1:
          message.state = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string account_address */
        4:
          message.accountAddress = reader.string();
          break;
        case /* string contract_address */
        5:
          message.contractAddress = reader.string();
          break;
        case /* string execution_price */
        6:
          message.executionPrice = reader.string();
          break;
        case /* string base_quantity */
        7:
          message.baseQuantity = reader.string();
          break;
        case /* string quote_quantity */
        20:
          message.quoteQuantity = reader.string();
          break;
        case /* string lower_bound */
        8:
          message.lowerBound = reader.string();
          break;
        case /* string upper_bound */
        9:
          message.upperBound = reader.string();
          break;
        case /* string stop_loss */
        10:
          message.stopLoss = reader.string();
          break;
        case /* string take_profit */
        11:
          message.takeProfit = reader.string();
          break;
        case /* string swap_fee */
        12:
          message.swapFee = reader.string();
          break;
        case /* string base_deposit */
        17:
          message.baseDeposit = reader.string();
          break;
        case /* string quote_deposit */
        18:
          message.quoteDeposit = reader.string();
          break;
        case /* string market_mid_price */
        19:
          message.marketMidPrice = reader.string();
          break;
        case /* string subscription_quote_quantity */
        21:
          message.subscriptionQuoteQuantity = reader.string();
          break;
        case /* string subscription_base_quantity */
        22:
          message.subscriptionBaseQuantity = reader.string();
          break;
        case /* string number_of_grid_levels */
        23:
          message.numberOfGridLevels = reader.string();
          break;
        case /* bool should_exit_with_quote_only */
        24:
          message.shouldExitWithQuoteOnly = reader.bool();
          break;
        case /* string stop_reason */
        25:
          message.stopReason = reader.string();
          break;
        case /* bool pending_execution */
        26:
          message.pendingExecution = reader.bool();
          break;
        case /* sint64 created_height */
        13:
          message.createdHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 removed_height */
        14:
          message.removedHeight = reader.sint64().toBigInt();
          break;
        case /* sint64 created_at */
        15:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        16:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string exit_type */
        27:
          message.exitType = reader.string();
          break;
        case /* injective_trading_rpc.ExitConfig stop_loss_config */
        28:
          message.stopLossConfig = ExitConfig.internalBinaryRead(reader, reader.uint32(), options, message.stopLossConfig);
          break;
        case /* injective_trading_rpc.ExitConfig take_profit_config */
        29:
          message.takeProfitConfig = ExitConfig.internalBinaryRead(reader, reader.uint32(), options, message.takeProfitConfig);
          break;
        case /* string strategy_type */
        30:
          message.strategyType = reader.string();
          break;
        case /* string contract_version */
        31:
          message.contractVersion = reader.string();
          break;
        case /* string contract_name */
        32:
          message.contractName = reader.string();
          break;
        case /* string market_type */
        33:
          message.marketType = reader.string();
          break;
        case /* sint64 last_executed_at */
        34:
          message.lastExecutedAt = reader.sint64().toBigInt();
          break;
        case /* string trail_up_price */
        35:
          message.trailUpPrice = reader.string();
          break;
        case /* string trail_down_price */
        36:
          message.trailDownPrice = reader.string();
          break;
        case /* sint64 trail_up_counter */
        37:
          message.trailUpCounter = reader.sint64().toBigInt();
          break;
        case /* sint64 trail_down_counter */
        38:
          message.trailDownCounter = reader.sint64().toBigInt();
          break;
        case /* string tvl */
        39:
          message.tvl = reader.string();
          break;
        case /* string pnl */
        40:
          message.pnl = reader.string();
          break;
        case /* string pnl_perc */
        41:
          message.pnlPerc = reader.string();
          break;
        case /* sint64 pnl_updated_at */
        42:
          message.pnlUpdatedAt = reader.sint64().toBigInt();
          break;
        case /* string performance */
        43:
          message.performance = reader.string();
          break;
        case /* string roi */
        44:
          message.roi = reader.string();
          break;
        case /* string initial_base_price */
        45:
          message.initialBasePrice = reader.string();
          break;
        case /* string initial_quote_price */
        46:
          message.initialQuotePrice = reader.string();
          break;
        case /* string current_base_price */
        47:
          message.currentBasePrice = reader.string();
          break;
        case /* string current_quote_price */
        48:
          message.currentQuotePrice = reader.string();
          break;
        case /* string final_base_price */
        49:
          message.finalBasePrice = reader.string();
          break;
        case /* string final_quote_price */
        50:
          message.finalQuotePrice = reader.string();
          break;
        case /* injective_trading_rpc.StrategyFinalData final_data */
        51:
          message.finalData = StrategyFinalData.internalBinaryRead(reader, reader.uint32(), options, message.finalData);
          break;
        case /* string margin_ratio */
        52:
          message.marginRatio = reader.string();
          break;
        case /* string lower_trailing_bound */
        53:
          message.lowerTrailingBound = reader.string();
          break;
        case /* string upper_trailing_bound */
        54:
          message.upperTrailingBound = reader.string();
          break;
        case /* string new_upper_bound */
        55:
          message.newUpperBound = reader.string();
          break;
        case /* string new_lower_bound */
        56:
          message.newLowerBound = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.state);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.accountAddress !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.accountAddress);
    if (message.contractAddress !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.contractAddress);
    if (message.executionPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.executionPrice);
    if (message.baseQuantity !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.baseQuantity);
    if (message.lowerBound !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.lowerBound);
    if (message.upperBound !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.upperBound);
    if (message.stopLoss !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.stopLoss);
    if (message.takeProfit !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.takeProfit);
    if (message.swapFee !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.swapFee);
    if (message.createdHeight !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.createdHeight);
    if (message.removedHeight !== 0n)
      writer.tag(14, WireType.Varint).sint64(message.removedHeight);
    if (message.createdAt !== 0n)
      writer.tag(15, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(16, WireType.Varint).sint64(message.updatedAt);
    if (message.baseDeposit !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.baseDeposit);
    if (message.quoteDeposit !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.quoteDeposit);
    if (message.marketMidPrice !== "")
      writer.tag(19, WireType.LengthDelimited).string(message.marketMidPrice);
    if (message.quoteQuantity !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.quoteQuantity);
    if (message.subscriptionQuoteQuantity !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.subscriptionQuoteQuantity);
    if (message.subscriptionBaseQuantity !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.subscriptionBaseQuantity);
    if (message.numberOfGridLevels !== "")
      writer.tag(23, WireType.LengthDelimited).string(message.numberOfGridLevels);
    if (message.shouldExitWithQuoteOnly !== false)
      writer.tag(24, WireType.Varint).bool(message.shouldExitWithQuoteOnly);
    if (message.stopReason !== "")
      writer.tag(25, WireType.LengthDelimited).string(message.stopReason);
    if (message.pendingExecution !== false)
      writer.tag(26, WireType.Varint).bool(message.pendingExecution);
    if (message.exitType !== "")
      writer.tag(27, WireType.LengthDelimited).string(message.exitType);
    if (message.stopLossConfig)
      ExitConfig.internalBinaryWrite(message.stopLossConfig, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
    if (message.takeProfitConfig)
      ExitConfig.internalBinaryWrite(message.takeProfitConfig, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
    if (message.strategyType !== "")
      writer.tag(30, WireType.LengthDelimited).string(message.strategyType);
    if (message.contractVersion !== "")
      writer.tag(31, WireType.LengthDelimited).string(message.contractVersion);
    if (message.contractName !== "")
      writer.tag(32, WireType.LengthDelimited).string(message.contractName);
    if (message.marketType !== "")
      writer.tag(33, WireType.LengthDelimited).string(message.marketType);
    if (message.lastExecutedAt !== 0n)
      writer.tag(34, WireType.Varint).sint64(message.lastExecutedAt);
    if (message.trailUpPrice !== "")
      writer.tag(35, WireType.LengthDelimited).string(message.trailUpPrice);
    if (message.trailDownPrice !== "")
      writer.tag(36, WireType.LengthDelimited).string(message.trailDownPrice);
    if (message.trailUpCounter !== 0n)
      writer.tag(37, WireType.Varint).sint64(message.trailUpCounter);
    if (message.trailDownCounter !== 0n)
      writer.tag(38, WireType.Varint).sint64(message.trailDownCounter);
    if (message.tvl !== "")
      writer.tag(39, WireType.LengthDelimited).string(message.tvl);
    if (message.pnl !== "")
      writer.tag(40, WireType.LengthDelimited).string(message.pnl);
    if (message.pnlPerc !== "")
      writer.tag(41, WireType.LengthDelimited).string(message.pnlPerc);
    if (message.pnlUpdatedAt !== 0n)
      writer.tag(42, WireType.Varint).sint64(message.pnlUpdatedAt);
    if (message.performance !== "")
      writer.tag(43, WireType.LengthDelimited).string(message.performance);
    if (message.roi !== "")
      writer.tag(44, WireType.LengthDelimited).string(message.roi);
    if (message.initialBasePrice !== "")
      writer.tag(45, WireType.LengthDelimited).string(message.initialBasePrice);
    if (message.initialQuotePrice !== "")
      writer.tag(46, WireType.LengthDelimited).string(message.initialQuotePrice);
    if (message.currentBasePrice !== "")
      writer.tag(47, WireType.LengthDelimited).string(message.currentBasePrice);
    if (message.currentQuotePrice !== "")
      writer.tag(48, WireType.LengthDelimited).string(message.currentQuotePrice);
    if (message.finalBasePrice !== "")
      writer.tag(49, WireType.LengthDelimited).string(message.finalBasePrice);
    if (message.finalQuotePrice !== "")
      writer.tag(50, WireType.LengthDelimited).string(message.finalQuotePrice);
    if (message.finalData)
      StrategyFinalData.internalBinaryWrite(message.finalData, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
    if (message.marginRatio !== "")
      writer.tag(52, WireType.LengthDelimited).string(message.marginRatio);
    if (message.lowerTrailingBound !== "")
      writer.tag(53, WireType.LengthDelimited).string(message.lowerTrailingBound);
    if (message.upperTrailingBound !== "")
      writer.tag(54, WireType.LengthDelimited).string(message.upperTrailingBound);
    if (message.newUpperBound !== "")
      writer.tag(55, WireType.LengthDelimited).string(message.newUpperBound);
    if (message.newLowerBound !== "")
      writer.tag(56, WireType.LengthDelimited).string(message.newLowerBound);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingStrategy = new TradingStrategy$Type();
class ExitConfig$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.ExitConfig", [
      {
        no: 1,
        name: "exit_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "exit_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.exitType = "";
    message.exitPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string exit_type */
        1:
          message.exitType = reader.string();
          break;
        case /* string exit_price */
        2:
          message.exitPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.exitType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.exitType);
    if (message.exitPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.exitPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExitConfig = new ExitConfig$Type();
class StrategyFinalData$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.StrategyFinalData", [
      {
        no: 1,
        name: "initial_base_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "initial_quote_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "final_base_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "final_quote_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "initial_base_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "initial_quote_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "final_base_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "final_quote_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.initialBaseAmount = "";
    message.initialQuoteAmount = "";
    message.finalBaseAmount = "";
    message.finalQuoteAmount = "";
    message.initialBasePrice = "";
    message.initialQuotePrice = "";
    message.finalBasePrice = "";
    message.finalQuotePrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string initial_base_amount */
        1:
          message.initialBaseAmount = reader.string();
          break;
        case /* string initial_quote_amount */
        2:
          message.initialQuoteAmount = reader.string();
          break;
        case /* string final_base_amount */
        3:
          message.finalBaseAmount = reader.string();
          break;
        case /* string final_quote_amount */
        4:
          message.finalQuoteAmount = reader.string();
          break;
        case /* string initial_base_price */
        5:
          message.initialBasePrice = reader.string();
          break;
        case /* string initial_quote_price */
        6:
          message.initialQuotePrice = reader.string();
          break;
        case /* string final_base_price */
        7:
          message.finalBasePrice = reader.string();
          break;
        case /* string final_quote_price */
        8:
          message.finalQuotePrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.initialBaseAmount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.initialBaseAmount);
    if (message.initialQuoteAmount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.initialQuoteAmount);
    if (message.finalBaseAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.finalBaseAmount);
    if (message.finalQuoteAmount !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.finalQuoteAmount);
    if (message.initialBasePrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.initialBasePrice);
    if (message.initialQuotePrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.initialQuotePrice);
    if (message.finalBasePrice !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.finalBasePrice);
    if (message.finalQuotePrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.finalQuotePrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StrategyFinalData = new StrategyFinalData$Type();
class Paging$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.Paging", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "from",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "to",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "count_by_subaccount",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "next",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total = 0n;
    message.from = 0;
    message.to = 0;
    message.countBySubaccount = 0n;
    message.next = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 total */
        1:
          message.total = reader.sint64().toBigInt();
          break;
        case /* sint32 from */
        2:
          message.from = reader.sint32();
          break;
        case /* sint32 to */
        3:
          message.to = reader.sint32();
          break;
        case /* sint64 count_by_subaccount */
        4:
          message.countBySubaccount = reader.sint64().toBigInt();
          break;
        case /* repeated string next */
        5:
          message.next.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.total);
    if (message.from !== 0)
      writer.tag(2, WireType.Varint).sint32(message.from);
    if (message.to !== 0)
      writer.tag(3, WireType.Varint).sint32(message.to);
    if (message.countBySubaccount !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.countBySubaccount);
    for (let i = 0; i < message.next.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.next[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Paging = new Paging$Type();
class GetTradingStatsRequest$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.GetTradingStatsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTradingStatsRequest = new GetTradingStatsRequest$Type();
class GetTradingStatsResponse$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.GetTradingStatsResponse", [
      {
        no: 1,
        name: "active_trading_strategies",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "total_trading_strategies_created",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "total_tvl",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "markets", kind: "message", repeat: 2, T: () => Market }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.activeTradingStrategies = 0n;
    message.totalTradingStrategiesCreated = 0n;
    message.totalTvl = "";
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 active_trading_strategies */
        1:
          message.activeTradingStrategies = reader.uint64().toBigInt();
          break;
        case /* uint64 total_trading_strategies_created */
        2:
          message.totalTradingStrategiesCreated = reader.uint64().toBigInt();
          break;
        case /* string total_tvl */
        3:
          message.totalTvl = reader.string();
          break;
        case /* repeated injective_trading_rpc.Market markets */
        4:
          message.markets.push(Market.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.activeTradingStrategies !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.activeTradingStrategies);
    if (message.totalTradingStrategiesCreated !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.totalTradingStrategiesCreated);
    if (message.totalTvl !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.totalTvl);
    for (let i = 0; i < message.markets.length; i++)
      Market.internalBinaryWrite(message.markets[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTradingStatsResponse = new GetTradingStatsResponse$Type();
class Market$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.Market", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "active_trading_strategies",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.activeTradingStrategies = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* uint64 active_trading_strategies */
        2:
          message.activeTradingStrategies = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.activeTradingStrategies !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.activeTradingStrategies);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Market = new Market$Type();
class StreamStrategyRequest$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.StreamStrategyRequest", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddresses = [];
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string account_addresses */
        1:
          message.accountAddresses.push(reader.string());
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accountAddresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddresses[i]);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamStrategyRequest = new StreamStrategyRequest$Type();
class StreamStrategyResponse$Type extends MessageType {
  constructor() {
    super("injective_trading_rpc.StreamStrategyResponse", [
      { no: 1, name: "trading_strategy", kind: "message", T: () => TradingStrategy },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_trading_rpc.TradingStrategy trading_strategy */
        1:
          message.tradingStrategy = TradingStrategy.internalBinaryRead(reader, reader.uint32(), options, message.tradingStrategy);
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tradingStrategy)
      TradingStrategy.internalBinaryWrite(message.tradingStrategy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamStrategyResponse = new StreamStrategyResponse$Type();
const InjectiveTradingRPC = new ServiceType("injective_trading_rpc.InjectiveTradingRPC", [
  { name: "ListTradingStrategies", options: {}, I: ListTradingStrategiesRequest, O: ListTradingStrategiesResponse },
  { name: "GetTradingStats", options: {}, I: GetTradingStatsRequest, O: GetTradingStatsResponse },
  { name: "StreamStrategy", serverStreaming: true, options: {}, I: StreamStrategyRequest, O: StreamStrategyResponse }
]);
export {
  ExitConfig,
  GetTradingStatsRequest,
  GetTradingStatsResponse,
  InjectiveTradingRPC,
  ListTradingStrategiesRequest,
  ListTradingStrategiesResponse,
  Market,
  Paging,
  StrategyFinalData,
  StreamStrategyRequest,
  StreamStrategyResponse,
  TradingStrategy
};
