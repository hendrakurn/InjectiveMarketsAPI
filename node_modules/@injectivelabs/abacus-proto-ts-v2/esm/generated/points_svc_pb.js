import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class PointsLatestForAccountRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsLatestForAccountRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsLatestForAccountRequest = new PointsLatestForAccountRequest$Type();
class PointsLatestForAccountResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsLatestForAccountResponse", [
      {
        no: 1,
        name: "rank",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "total_points",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "total_points_precise",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "league",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "points_season1",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "points_bonus",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rank = 0n;
    message.totalPoints = 0n;
    message.totalPointsPrecise = 0;
    message.league = "";
    message.updatedAt = "";
    message.pointsSeason1 = 0;
    message.pointsBonus = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 rank */
        1:
          message.rank = reader.uint64().toBigInt();
          break;
        case /* uint64 total_points */
        2:
          message.totalPoints = reader.uint64().toBigInt();
          break;
        case /* double total_points_precise */
        3:
          message.totalPointsPrecise = reader.double();
          break;
        case /* string league */
        4:
          message.league = reader.string();
          break;
        case /* string updated_at */
        5:
          message.updatedAt = reader.string();
          break;
        case /* double points_season1 */
        6:
          message.pointsSeason1 = reader.double();
          break;
        case /* double points_bonus */
        7:
          message.pointsBonus = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rank !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.rank);
    if (message.totalPoints !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.totalPoints);
    if (message.totalPointsPrecise !== 0)
      writer.tag(3, WireType.Bit64).double(message.totalPointsPrecise);
    if (message.league !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.league);
    if (message.updatedAt !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.updatedAt);
    if (message.pointsSeason1 !== 0)
      writer.tag(6, WireType.Bit64).double(message.pointsSeason1);
    if (message.pointsBonus !== 0)
      writer.tag(7, WireType.Bit64).double(message.pointsBonus);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsLatestForAccountResponse = new PointsLatestForAccountResponse$Type();
class PointsStatsDailyForAccountRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsStatsDailyForAccountRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "days_limit",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* optional uint64 days_limit */
        2:
          message.daysLimit = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.daysLimit !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.daysLimit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsStatsDailyForAccountRequest = new PointsStatsDailyForAccountRequest$Type();
class HistoricalPointsStatsRowCollection$Type extends MessageType {
  constructor() {
    super("points_svc.HistoricalPointsStatsRowCollection", [
      { no: 1, name: "rows", kind: "message", repeat: 2, T: () => HistoricalPointsStatsRow }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rows = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated points_svc.HistoricalPointsStatsRow rows */
        1:
          message.rows.push(HistoricalPointsStatsRow.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.rows.length; i++)
      HistoricalPointsStatsRow.internalBinaryWrite(message.rows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalPointsStatsRowCollection = new HistoricalPointsStatsRowCollection$Type();
class HistoricalPointsStatsRow$Type extends MessageType {
  constructor() {
    super("points_svc.HistoricalPointsStatsRow", [
      {
        no: 1,
        name: "week",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "day",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "points",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "points_precise",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.week = "";
    message.points = 0n;
    message.pointsPrecise = 0;
    message.volume = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string week */
        1:
          message.week = reader.string();
          break;
        case /* optional string day */
        2:
          message.day = reader.string();
          break;
        case /* uint64 points */
        3:
          message.points = reader.uint64().toBigInt();
          break;
        case /* double points_precise */
        4:
          message.pointsPrecise = reader.double();
          break;
        case /* double volume */
        5:
          message.volume = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.week !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.week);
    if (message.day !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.day);
    if (message.points !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.points);
    if (message.pointsPrecise !== 0)
      writer.tag(4, WireType.Bit64).double(message.pointsPrecise);
    if (message.volume !== 0)
      writer.tag(5, WireType.Bit64).double(message.volume);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HistoricalPointsStatsRow = new HistoricalPointsStatsRow$Type();
class PointsStatsWeeklyForAccountRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsStatsWeeklyForAccountRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "weeks_limit",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* optional uint64 weeks_limit */
        2:
          message.weeksLimit = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.weeksLimit !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.weeksLimit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsStatsWeeklyForAccountRequest = new PointsStatsWeeklyForAccountRequest$Type();
class PointsLeaderboardRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsLeaderboardRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsLeaderboardRequest = new PointsLeaderboardRequest$Type();
class LeaderboardPointsRowCollection$Type extends MessageType {
  constructor() {
    super("points_svc.LeaderboardPointsRowCollection", [
      { no: 1, name: "rows", kind: "message", repeat: 2, T: () => LeaderboardPointsRow }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rows = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated points_svc.LeaderboardPointsRow rows */
        1:
          message.rows.push(LeaderboardPointsRow.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.rows.length; i++)
      LeaderboardPointsRow.internalBinaryWrite(message.rows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardPointsRowCollection = new LeaderboardPointsRowCollection$Type();
class LeaderboardPointsRow$Type extends MessageType {
  constructor() {
    super("points_svc.LeaderboardPointsRow", [
      {
        no: 1,
        name: "rank",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "total_rank",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "points",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "league",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rank = 0n;
    message.totalRank = 0n;
    message.accountAddress = "";
    message.points = 0;
    message.league = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 rank */
        1:
          message.rank = reader.uint64().toBigInt();
          break;
        case /* uint64 total_rank */
        2:
          message.totalRank = reader.uint64().toBigInt();
          break;
        case /* string account_address */
        3:
          message.accountAddress = reader.string();
          break;
        case /* double points */
        4:
          message.points = reader.double();
          break;
        case /* string league */
        5:
          message.league = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rank !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.rank);
    if (message.totalRank !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.totalRank);
    if (message.accountAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
    if (message.points !== 0)
      writer.tag(4, WireType.Bit64).double(message.points);
    if (message.league !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.league);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardPointsRow = new LeaderboardPointsRow$Type();
class PointsSimulateAllocationRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsSimulateAllocationRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "trade_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "execution_side",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "usd_value",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "flags",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "market_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "prior_daily_volume",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.marketId = "";
    message.tradeDirection = "";
    message.executionSide = "";
    message.usdValue = 0;
    message.flags = [];
    message.marketType = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string trade_direction */
        3:
          message.tradeDirection = reader.string();
          break;
        case /* string execution_side */
        4:
          message.executionSide = reader.string();
          break;
        case /* double usd_value */
        5:
          message.usdValue = reader.double();
          break;
        case /* repeated string flags */
        6:
          message.flags.push(reader.string());
          break;
        case /* string market_type */
        7:
          message.marketType = reader.string();
          break;
        case /* uint64 timestamp */
        8:
          message.timestamp = reader.uint64().toBigInt();
          break;
        case /* optional double prior_daily_volume */
        9:
          message.priorDailyVolume = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.tradeDirection !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.tradeDirection);
    if (message.executionSide !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.executionSide);
    if (message.usdValue !== 0)
      writer.tag(5, WireType.Bit64).double(message.usdValue);
    for (let i = 0; i < message.flags.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.flags[i]);
    if (message.marketType !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.marketType);
    if (message.timestamp !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.timestamp);
    if (message.priorDailyVolume !== void 0)
      writer.tag(9, WireType.Bit64).double(message.priorDailyVolume);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsSimulateAllocationRequest = new PointsSimulateAllocationRequest$Type();
class PointsSimulateAllocationResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsSimulateAllocationResponse", [
      {
        no: 1,
        name: "points_emitted",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "points_breakdown",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "prior_daily_volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 4, name: "effective_volume_tiers", kind: "message", repeat: 2, T: () => ModelEffectiveVolumeTier },
      { no: 5, name: "effective_multipliers", kind: "message", repeat: 2, T: () => ModelPointsMultiplier }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.pointsEmitted = 0;
    message.pointsBreakdown = "";
    message.priorDailyVolume = 0;
    message.effectiveVolumeTiers = [];
    message.effectiveMultipliers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double points_emitted */
        1:
          message.pointsEmitted = reader.double();
          break;
        case /* string points_breakdown */
        2:
          message.pointsBreakdown = reader.string();
          break;
        case /* double prior_daily_volume */
        3:
          message.priorDailyVolume = reader.double();
          break;
        case /* repeated points_svc.ModelEffectiveVolumeTier effective_volume_tiers */
        4:
          message.effectiveVolumeTiers.push(ModelEffectiveVolumeTier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated points_svc.ModelPointsMultiplier effective_multipliers */
        5:
          message.effectiveMultipliers.push(ModelPointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.pointsEmitted !== 0)
      writer.tag(1, WireType.Bit64).double(message.pointsEmitted);
    if (message.pointsBreakdown !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.pointsBreakdown);
    if (message.priorDailyVolume !== 0)
      writer.tag(3, WireType.Bit64).double(message.priorDailyVolume);
    for (let i = 0; i < message.effectiveVolumeTiers.length; i++)
      ModelEffectiveVolumeTier.internalBinaryWrite(message.effectiveVolumeTiers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.effectiveMultipliers.length; i++)
      ModelPointsMultiplier.internalBinaryWrite(message.effectiveMultipliers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsSimulateAllocationResponse = new PointsSimulateAllocationResponse$Type();
class ModelEffectiveVolumeTier$Type extends MessageType {
  constructor() {
    super("points_svc.ModelEffectiveVolumeTier", [
      {
        no: 1,
        name: "tier_number",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "upper_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "taker_rate",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "maker_rate",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "effective_volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "effective_rate",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tierNumber = 0;
    message.upperThreshold = 0;
    message.takerRate = 0;
    message.makerRate = 0;
    message.effectiveVolume = 0;
    message.effectiveRate = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 tier_number */
        1:
          message.tierNumber = reader.uint32();
          break;
        case /* double upper_threshold */
        2:
          message.upperThreshold = reader.double();
          break;
        case /* double taker_rate */
        3:
          message.takerRate = reader.double();
          break;
        case /* double maker_rate */
        4:
          message.makerRate = reader.double();
          break;
        case /* double effective_volume */
        5:
          message.effectiveVolume = reader.double();
          break;
        case /* double effective_rate */
        6:
          message.effectiveRate = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tierNumber !== 0)
      writer.tag(1, WireType.Varint).uint32(message.tierNumber);
    if (message.upperThreshold !== 0)
      writer.tag(2, WireType.Bit64).double(message.upperThreshold);
    if (message.takerRate !== 0)
      writer.tag(3, WireType.Bit64).double(message.takerRate);
    if (message.makerRate !== 0)
      writer.tag(4, WireType.Bit64).double(message.makerRate);
    if (message.effectiveVolume !== 0)
      writer.tag(5, WireType.Bit64).double(message.effectiveVolume);
    if (message.effectiveRate !== 0)
      writer.tag(6, WireType.Bit64).double(message.effectiveRate);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ModelEffectiveVolumeTier = new ModelEffectiveVolumeTier$Type();
class ModelPointsMultiplier$Type extends MessageType {
  constructor() {
    super("points_svc.ModelPointsMultiplier", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "multiplier",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "affected_users",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "affected_markets",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "all_markets_except",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "effective_date_start",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "effective_date_end",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "effective_flags",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.label = "";
    message.multiplier = 0;
    message.affectedUsers = [];
    message.affectedMarkets = [];
    message.allMarketsExcept = [];
    message.effectiveFlags = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string label */
        2:
          message.label = reader.string();
          break;
        case /* double multiplier */
        3:
          message.multiplier = reader.double();
          break;
        case /* repeated string affected_users */
        4:
          message.affectedUsers.push(reader.string());
          break;
        case /* repeated string affected_markets */
        5:
          message.affectedMarkets.push(reader.string());
          break;
        case /* repeated string all_markets_except */
        6:
          message.allMarketsExcept.push(reader.string());
          break;
        case /* optional string effective_date_start */
        7:
          message.effectiveDateStart = reader.string();
          break;
        case /* optional string effective_date_end */
        8:
          message.effectiveDateEnd = reader.string();
          break;
        case /* repeated string effective_flags */
        9:
          message.effectiveFlags.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    if (message.multiplier !== 0)
      writer.tag(3, WireType.Bit64).double(message.multiplier);
    for (let i = 0; i < message.affectedUsers.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.affectedUsers[i]);
    for (let i = 0; i < message.affectedMarkets.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.affectedMarkets[i]);
    for (let i = 0; i < message.allMarketsExcept.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
    if (message.effectiveDateStart !== void 0)
      writer.tag(7, WireType.LengthDelimited).string(message.effectiveDateStart);
    if (message.effectiveDateEnd !== void 0)
      writer.tag(8, WireType.LengthDelimited).string(message.effectiveDateEnd);
    for (let i = 0; i < message.effectiveFlags.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.effectiveFlags[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ModelPointsMultiplier = new ModelPointsMultiplier$Type();
class PointsGetLeagueConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsGetLeagueConfigRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsGetLeagueConfigRequest = new PointsGetLeagueConfigRequest$Type();
class PointsGetLeagueConfigResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsGetLeagueConfigResponse", [
      {
        no: 1,
        name: "white_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "orange_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "blue_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "purple_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "black_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "updated_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.whiteThreshold = 0;
    message.orangeThreshold = 0;
    message.blueThreshold = 0;
    message.purpleThreshold = 0;
    message.blackThreshold = 0;
    message.updatedBy = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double white_threshold */
        1:
          message.whiteThreshold = reader.double();
          break;
        case /* double orange_threshold */
        2:
          message.orangeThreshold = reader.double();
          break;
        case /* double blue_threshold */
        3:
          message.blueThreshold = reader.double();
          break;
        case /* double purple_threshold */
        4:
          message.purpleThreshold = reader.double();
          break;
        case /* double black_threshold */
        5:
          message.blackThreshold = reader.double();
          break;
        case /* string updated_by */
        6:
          message.updatedBy = reader.string();
          break;
        case /* string updated_at */
        7:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.whiteThreshold !== 0)
      writer.tag(1, WireType.Bit64).double(message.whiteThreshold);
    if (message.orangeThreshold !== 0)
      writer.tag(2, WireType.Bit64).double(message.orangeThreshold);
    if (message.blueThreshold !== 0)
      writer.tag(3, WireType.Bit64).double(message.blueThreshold);
    if (message.purpleThreshold !== 0)
      writer.tag(4, WireType.Bit64).double(message.purpleThreshold);
    if (message.blackThreshold !== 0)
      writer.tag(5, WireType.Bit64).double(message.blackThreshold);
    if (message.updatedBy !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.updatedBy);
    if (message.updatedAt !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsGetLeagueConfigResponse = new PointsGetLeagueConfigResponse$Type();
class PointsSetLeagueConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsSetLeagueConfigRequest", [
      {
        no: 1,
        name: "white_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "orange_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "blue_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "purple_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "black_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.whiteThreshold = 0;
    message.orangeThreshold = 0;
    message.blueThreshold = 0;
    message.purpleThreshold = 0;
    message.blackThreshold = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double white_threshold */
        1:
          message.whiteThreshold = reader.double();
          break;
        case /* double orange_threshold */
        2:
          message.orangeThreshold = reader.double();
          break;
        case /* double blue_threshold */
        3:
          message.blueThreshold = reader.double();
          break;
        case /* double purple_threshold */
        4:
          message.purpleThreshold = reader.double();
          break;
        case /* double black_threshold */
        5:
          message.blackThreshold = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.whiteThreshold !== 0)
      writer.tag(1, WireType.Bit64).double(message.whiteThreshold);
    if (message.orangeThreshold !== 0)
      writer.tag(2, WireType.Bit64).double(message.orangeThreshold);
    if (message.blueThreshold !== 0)
      writer.tag(3, WireType.Bit64).double(message.blueThreshold);
    if (message.purpleThreshold !== 0)
      writer.tag(4, WireType.Bit64).double(message.purpleThreshold);
    if (message.blackThreshold !== 0)
      writer.tag(5, WireType.Bit64).double(message.blackThreshold);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsSetLeagueConfigRequest = new PointsSetLeagueConfigRequest$Type();
class PointsSetLeagueConfigResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsSetLeagueConfigResponse", [
      {
        no: 1,
        name: "white_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "orange_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "blue_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "purple_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "black_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "updated_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.whiteThreshold = 0;
    message.orangeThreshold = 0;
    message.blueThreshold = 0;
    message.purpleThreshold = 0;
    message.blackThreshold = 0;
    message.updatedBy = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double white_threshold */
        1:
          message.whiteThreshold = reader.double();
          break;
        case /* double orange_threshold */
        2:
          message.orangeThreshold = reader.double();
          break;
        case /* double blue_threshold */
        3:
          message.blueThreshold = reader.double();
          break;
        case /* double purple_threshold */
        4:
          message.purpleThreshold = reader.double();
          break;
        case /* double black_threshold */
        5:
          message.blackThreshold = reader.double();
          break;
        case /* string updated_by */
        6:
          message.updatedBy = reader.string();
          break;
        case /* string updated_at */
        7:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.whiteThreshold !== 0)
      writer.tag(1, WireType.Bit64).double(message.whiteThreshold);
    if (message.orangeThreshold !== 0)
      writer.tag(2, WireType.Bit64).double(message.orangeThreshold);
    if (message.blueThreshold !== 0)
      writer.tag(3, WireType.Bit64).double(message.blueThreshold);
    if (message.purpleThreshold !== 0)
      writer.tag(4, WireType.Bit64).double(message.purpleThreshold);
    if (message.blackThreshold !== 0)
      writer.tag(5, WireType.Bit64).double(message.blackThreshold);
    if (message.updatedBy !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.updatedBy);
    if (message.updatedAt !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsSetLeagueConfigResponse = new PointsSetLeagueConfigResponse$Type();
class PointsGetEmissionConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsGetEmissionConfigRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsGetEmissionConfigRequest = new PointsGetEmissionConfigRequest$Type();
class PointsGetEmissionConfigResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsGetEmissionConfigResponse", [
      {
        no: 1,
        name: "unit_volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 2, name: "volume_tiers", kind: "message", repeat: 2, T: () => ModelVolumeTierConfig },
      {
        no: 3,
        name: "updated_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.unitVolume = 0;
    message.volumeTiers = [];
    message.updatedBy = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double unit_volume */
        1:
          message.unitVolume = reader.double();
          break;
        case /* repeated points_svc.ModelVolumeTierConfig volume_tiers */
        2:
          message.volumeTiers.push(ModelVolumeTierConfig.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string updated_by */
        3:
          message.updatedBy = reader.string();
          break;
        case /* string updated_at */
        4:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.unitVolume !== 0)
      writer.tag(1, WireType.Bit64).double(message.unitVolume);
    for (let i = 0; i < message.volumeTiers.length; i++)
      ModelVolumeTierConfig.internalBinaryWrite(message.volumeTiers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedBy !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.updatedBy);
    if (message.updatedAt !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsGetEmissionConfigResponse = new PointsGetEmissionConfigResponse$Type();
class ModelVolumeTierConfig$Type extends MessageType {
  constructor() {
    super("points_svc.ModelVolumeTierConfig", [
      {
        no: 1,
        name: "upper_threshold",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "taker_rate",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "maker_rate",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.upperThreshold = 0;
    message.takerRate = 0;
    message.makerRate = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double upper_threshold */
        1:
          message.upperThreshold = reader.double();
          break;
        case /* double taker_rate */
        2:
          message.takerRate = reader.double();
          break;
        case /* double maker_rate */
        3:
          message.makerRate = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.upperThreshold !== 0)
      writer.tag(1, WireType.Bit64).double(message.upperThreshold);
    if (message.takerRate !== 0)
      writer.tag(2, WireType.Bit64).double(message.takerRate);
    if (message.makerRate !== 0)
      writer.tag(3, WireType.Bit64).double(message.makerRate);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ModelVolumeTierConfig = new ModelVolumeTierConfig$Type();
class PointsSetEmissionConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsSetEmissionConfigRequest", [
      {
        no: 1,
        name: "unit_volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 2, name: "volume_tiers", kind: "message", repeat: 2, T: () => ModelVolumeTierConfig }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.unitVolume = 0;
    message.volumeTiers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double unit_volume */
        1:
          message.unitVolume = reader.double();
          break;
        case /* repeated points_svc.ModelVolumeTierConfig volume_tiers */
        2:
          message.volumeTiers.push(ModelVolumeTierConfig.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.unitVolume !== 0)
      writer.tag(1, WireType.Bit64).double(message.unitVolume);
    for (let i = 0; i < message.volumeTiers.length; i++)
      ModelVolumeTierConfig.internalBinaryWrite(message.volumeTiers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsSetEmissionConfigRequest = new PointsSetEmissionConfigRequest$Type();
class PointsSetEmissionConfigResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsSetEmissionConfigResponse", [
      {
        no: 1,
        name: "unit_volume",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 2, name: "volume_tiers", kind: "message", repeat: 2, T: () => ModelVolumeTierConfig },
      {
        no: 3,
        name: "updated_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.unitVolume = 0;
    message.volumeTiers = [];
    message.updatedBy = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double unit_volume */
        1:
          message.unitVolume = reader.double();
          break;
        case /* repeated points_svc.ModelVolumeTierConfig volume_tiers */
        2:
          message.volumeTiers.push(ModelVolumeTierConfig.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string updated_by */
        3:
          message.updatedBy = reader.string();
          break;
        case /* string updated_at */
        4:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.unitVolume !== 0)
      writer.tag(1, WireType.Bit64).double(message.unitVolume);
    for (let i = 0; i < message.volumeTiers.length; i++)
      ModelVolumeTierConfig.internalBinaryWrite(message.volumeTiers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedBy !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.updatedBy);
    if (message.updatedAt !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsSetEmissionConfigResponse = new PointsSetEmissionConfigResponse$Type();
class PointsListBanConfigsRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsListBanConfigsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsListBanConfigsRequest = new PointsListBanConfigsRequest$Type();
class BanConfigCollection$Type extends MessageType {
  constructor() {
    super("points_svc.BanConfigCollection", [
      { no: 1, name: "bans", kind: "message", repeat: 2, T: () => BanConfig }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bans = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated points_svc.BanConfig bans */
        1:
          message.bans.push(BanConfig.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.bans.length; i++)
      BanConfig.internalBinaryWrite(message.bans[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BanConfigCollection = new BanConfigCollection$Type();
class BanConfig$Type extends MessageType {
  constructor() {
    super("points_svc.BanConfig", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "eth_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "created_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.label = "";
    message.accountAddress = "";
    message.ethAddress = "";
    message.createdBy = "";
    message.createdAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string label */
        2:
          message.label = reader.string();
          break;
        case /* string account_address */
        3:
          message.accountAddress = reader.string();
          break;
        case /* string eth_address */
        4:
          message.ethAddress = reader.string();
          break;
        case /* string created_by */
        5:
          message.createdBy = reader.string();
          break;
        case /* string created_at */
        6:
          message.createdAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    if (message.accountAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
    if (message.ethAddress !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.ethAddress);
    if (message.createdBy !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.createdBy);
    if (message.createdAt !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.createdAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BanConfig = new BanConfig$Type();
class PointsCreateBanConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCreateBanConfigRequest", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "eth_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "effective_from",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddresses = [];
    message.ethAddresses = [];
    message.label = "";
    message.effectiveFrom = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string account_addresses */
        1:
          message.accountAddresses.push(reader.string());
          break;
        case /* repeated string eth_addresses */
        2:
          message.ethAddresses.push(reader.string());
          break;
        case /* string label */
        3:
          message.label = reader.string();
          break;
        case /* uint64 effective_from */
        4:
          message.effectiveFrom = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accountAddresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddresses[i]);
    for (let i = 0; i < message.ethAddresses.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.ethAddresses[i]);
    if (message.label !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.label);
    if (message.effectiveFrom !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.effectiveFrom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCreateBanConfigRequest = new PointsCreateBanConfigRequest$Type();
class PointsDeleteBanConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsDeleteBanConfigRequest", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsDeleteBanConfigRequest = new PointsDeleteBanConfigRequest$Type();
class PointsDeleteBanConfigResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsDeleteBanConfigResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsDeleteBanConfigResponse = new PointsDeleteBanConfigResponse$Type();
class PointsListMultiplierConfigsRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsListMultiplierConfigsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsListMultiplierConfigsRequest = new PointsListMultiplierConfigsRequest$Type();
class PointsMultiplierConfigCollection$Type extends MessageType {
  constructor() {
    super("points_svc.PointsMultiplierConfigCollection", [
      { no: 1, name: "multipliers", kind: "message", repeat: 2, T: () => PointsMultiplierConfig }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.multipliers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated points_svc.PointsMultiplierConfig multipliers */
        1:
          message.multipliers.push(PointsMultiplierConfig.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.multipliers.length; i++)
      PointsMultiplierConfig.internalBinaryWrite(message.multipliers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsMultiplierConfigCollection = new PointsMultiplierConfigCollection$Type();
class PointsMultiplierConfig$Type extends MessageType {
  constructor() {
    super("points_svc.PointsMultiplierConfig", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "multiplier",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "affected_users",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "affected_markets",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "all_markets_except",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "effective_date_start",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "effective_date_end",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "effective_flags",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "enforce_recalculate",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "created_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "updated_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.label = "";
    message.multiplier = 0;
    message.affectedUsers = [];
    message.affectedMarkets = [];
    message.allMarketsExcept = [];
    message.effectiveFlags = [];
    message.enforceRecalculate = false;
    message.createdBy = "";
    message.createdAt = "";
    message.updatedBy = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string label */
        2:
          message.label = reader.string();
          break;
        case /* double multiplier */
        3:
          message.multiplier = reader.double();
          break;
        case /* repeated string affected_users */
        4:
          message.affectedUsers.push(reader.string());
          break;
        case /* repeated string affected_markets */
        5:
          message.affectedMarkets.push(reader.string());
          break;
        case /* repeated string all_markets_except */
        6:
          message.allMarketsExcept.push(reader.string());
          break;
        case /* optional uint64 effective_date_start */
        7:
          message.effectiveDateStart = reader.uint64().toBigInt();
          break;
        case /* optional uint64 effective_date_end */
        8:
          message.effectiveDateEnd = reader.uint64().toBigInt();
          break;
        case /* repeated string effective_flags */
        9:
          message.effectiveFlags.push(reader.string());
          break;
        case /* bool enforce_recalculate */
        10:
          message.enforceRecalculate = reader.bool();
          break;
        case /* string created_by */
        11:
          message.createdBy = reader.string();
          break;
        case /* string created_at */
        12:
          message.createdAt = reader.string();
          break;
        case /* string updated_by */
        13:
          message.updatedBy = reader.string();
          break;
        case /* string updated_at */
        14:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    if (message.multiplier !== 0)
      writer.tag(3, WireType.Bit64).double(message.multiplier);
    for (let i = 0; i < message.affectedUsers.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.affectedUsers[i]);
    for (let i = 0; i < message.affectedMarkets.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.affectedMarkets[i]);
    for (let i = 0; i < message.allMarketsExcept.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
    if (message.effectiveDateStart !== void 0)
      writer.tag(7, WireType.Varint).uint64(message.effectiveDateStart);
    if (message.effectiveDateEnd !== void 0)
      writer.tag(8, WireType.Varint).uint64(message.effectiveDateEnd);
    for (let i = 0; i < message.effectiveFlags.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.effectiveFlags[i]);
    if (message.enforceRecalculate !== false)
      writer.tag(10, WireType.Varint).bool(message.enforceRecalculate);
    if (message.createdBy !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.createdBy);
    if (message.createdAt !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.createdAt);
    if (message.updatedBy !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.updatedBy);
    if (message.updatedAt !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsMultiplierConfig = new PointsMultiplierConfig$Type();
class PointsCreateMultiplierConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCreateMultiplierConfigRequest", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "all_markets_except",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "account_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "flags",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "multiplier",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "effective_from",
        kind: "scalar",
        opt: true,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "effective_until",
        kind: "scalar",
        opt: true,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "enforce_recalculate",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    message.allMarketsExcept = [];
    message.accountAddresses = [];
    message.flags = [];
    message.multiplier = 0;
    message.label = "";
    message.enforceRecalculate = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        case /* repeated string all_markets_except */
        2:
          message.allMarketsExcept.push(reader.string());
          break;
        case /* repeated string account_addresses */
        3:
          message.accountAddresses.push(reader.string());
          break;
        case /* repeated string flags */
        4:
          message.flags.push(reader.string());
          break;
        case /* double multiplier */
        5:
          message.multiplier = reader.double();
          break;
        case /* string label */
        6:
          message.label = reader.string();
          break;
        case /* optional sint64 effective_from */
        7:
          message.effectiveFrom = reader.sint64().toBigInt();
          break;
        case /* optional sint64 effective_until */
        8:
          message.effectiveUntil = reader.sint64().toBigInt();
          break;
        case /* bool enforce_recalculate */
        9:
          message.enforceRecalculate = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    for (let i = 0; i < message.allMarketsExcept.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
    for (let i = 0; i < message.accountAddresses.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.accountAddresses[i]);
    for (let i = 0; i < message.flags.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.flags[i]);
    if (message.multiplier !== 0)
      writer.tag(5, WireType.Bit64).double(message.multiplier);
    if (message.label !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.label);
    if (message.effectiveFrom !== void 0)
      writer.tag(7, WireType.Varint).sint64(message.effectiveFrom);
    if (message.effectiveUntil !== void 0)
      writer.tag(8, WireType.Varint).sint64(message.effectiveUntil);
    if (message.enforceRecalculate !== false)
      writer.tag(9, WireType.Varint).bool(message.enforceRecalculate);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCreateMultiplierConfigRequest = new PointsCreateMultiplierConfigRequest$Type();
class PointsCreateMultiplierConfigResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCreateMultiplierConfigResponse", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "multiplier",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "affected_users",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "affected_markets",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "all_markets_except",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "effective_date_start",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "effective_date_end",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "effective_flags",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "enforce_recalculate",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "created_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "updated_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "updated_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.label = "";
    message.multiplier = 0;
    message.affectedUsers = [];
    message.affectedMarkets = [];
    message.allMarketsExcept = [];
    message.effectiveFlags = [];
    message.enforceRecalculate = false;
    message.createdBy = "";
    message.createdAt = "";
    message.updatedBy = "";
    message.updatedAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string label */
        2:
          message.label = reader.string();
          break;
        case /* double multiplier */
        3:
          message.multiplier = reader.double();
          break;
        case /* repeated string affected_users */
        4:
          message.affectedUsers.push(reader.string());
          break;
        case /* repeated string affected_markets */
        5:
          message.affectedMarkets.push(reader.string());
          break;
        case /* repeated string all_markets_except */
        6:
          message.allMarketsExcept.push(reader.string());
          break;
        case /* optional uint64 effective_date_start */
        7:
          message.effectiveDateStart = reader.uint64().toBigInt();
          break;
        case /* optional uint64 effective_date_end */
        8:
          message.effectiveDateEnd = reader.uint64().toBigInt();
          break;
        case /* repeated string effective_flags */
        9:
          message.effectiveFlags.push(reader.string());
          break;
        case /* bool enforce_recalculate */
        10:
          message.enforceRecalculate = reader.bool();
          break;
        case /* string created_by */
        11:
          message.createdBy = reader.string();
          break;
        case /* string created_at */
        12:
          message.createdAt = reader.string();
          break;
        case /* string updated_by */
        13:
          message.updatedBy = reader.string();
          break;
        case /* string updated_at */
        14:
          message.updatedAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    if (message.multiplier !== 0)
      writer.tag(3, WireType.Bit64).double(message.multiplier);
    for (let i = 0; i < message.affectedUsers.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.affectedUsers[i]);
    for (let i = 0; i < message.affectedMarkets.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.affectedMarkets[i]);
    for (let i = 0; i < message.allMarketsExcept.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
    if (message.effectiveDateStart !== void 0)
      writer.tag(7, WireType.Varint).uint64(message.effectiveDateStart);
    if (message.effectiveDateEnd !== void 0)
      writer.tag(8, WireType.Varint).uint64(message.effectiveDateEnd);
    for (let i = 0; i < message.effectiveFlags.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.effectiveFlags[i]);
    if (message.enforceRecalculate !== false)
      writer.tag(10, WireType.Varint).bool(message.enforceRecalculate);
    if (message.createdBy !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.createdBy);
    if (message.createdAt !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.createdAt);
    if (message.updatedBy !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.updatedBy);
    if (message.updatedAt !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCreateMultiplierConfigResponse = new PointsCreateMultiplierConfigResponse$Type();
class PointsDeleteMultiplierConfigRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsDeleteMultiplierConfigRequest", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsDeleteMultiplierConfigRequest = new PointsDeleteMultiplierConfigRequest$Type();
class PointsDeleteMultiplierConfigResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsDeleteMultiplierConfigResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsDeleteMultiplierConfigResponse = new PointsDeleteMultiplierConfigResponse$Type();
class PointsListAdminCorrectionsRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsListAdminCorrectionsRequest", [
      {
        no: 1,
        name: "correction_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string correction_type */
        1:
          message.correctionType = reader.string();
          break;
        case /* optional string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.correctionType !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.correctionType);
    if (message.accountAddress !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsListAdminCorrectionsRequest = new PointsListAdminCorrectionsRequest$Type();
class AdminPointsCorrectionCollection$Type extends MessageType {
  constructor() {
    super("points_svc.AdminPointsCorrectionCollection", [
      { no: 1, name: "corrections", kind: "message", repeat: 2, T: () => AdminPointsCorrection }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.corrections = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated points_svc.AdminPointsCorrection corrections */
        1:
          message.corrections.push(AdminPointsCorrection.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.corrections.length; i++)
      AdminPointsCorrection.internalBinaryWrite(message.corrections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AdminPointsCorrectionCollection = new AdminPointsCorrectionCollection$Type();
class AdminPointsCorrection$Type extends MessageType {
  constructor() {
    super("points_svc.AdminPointsCorrection", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "correction_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "value",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "effective_from",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "created_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.label = "";
    message.accountAddress = "";
    message.correctionType = "";
    message.value = 0;
    message.effectiveFrom = "";
    message.createdBy = "";
    message.createdAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string label */
        2:
          message.label = reader.string();
          break;
        case /* string account_address */
        3:
          message.accountAddress = reader.string();
          break;
        case /* string correction_type */
        4:
          message.correctionType = reader.string();
          break;
        case /* double value */
        5:
          message.value = reader.double();
          break;
        case /* string effective_from */
        6:
          message.effectiveFrom = reader.string();
          break;
        case /* string created_by */
        7:
          message.createdBy = reader.string();
          break;
        case /* string created_at */
        8:
          message.createdAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    if (message.accountAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
    if (message.correctionType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.correctionType);
    if (message.value !== 0)
      writer.tag(5, WireType.Bit64).double(message.value);
    if (message.effectiveFrom !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.effectiveFrom);
    if (message.createdBy !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.createdBy);
    if (message.createdAt !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.createdAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AdminPointsCorrection = new AdminPointsCorrection$Type();
class PointsCreateAdminCorrectionRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCreateAdminCorrectionRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "correction_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "value",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "effective_from",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.correctionType = "";
    message.value = 0;
    message.label = "";
    message.effectiveFrom = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* string correction_type */
        2:
          message.correctionType = reader.string();
          break;
        case /* double value */
        3:
          message.value = reader.double();
          break;
        case /* string label */
        4:
          message.label = reader.string();
          break;
        case /* sint64 effective_from */
        5:
          message.effectiveFrom = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.correctionType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.correctionType);
    if (message.value !== 0)
      writer.tag(3, WireType.Bit64).double(message.value);
    if (message.label !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.label);
    if (message.effectiveFrom !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.effectiveFrom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCreateAdminCorrectionRequest = new PointsCreateAdminCorrectionRequest$Type();
class PointsCreateAdminCorrectionResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCreateAdminCorrectionResponse", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "correction_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "value",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "effective_from",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "created_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "created_at",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.label = "";
    message.accountAddress = "";
    message.correctionType = "";
    message.value = 0;
    message.effectiveFrom = "";
    message.createdBy = "";
    message.createdAt = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string label */
        2:
          message.label = reader.string();
          break;
        case /* string account_address */
        3:
          message.accountAddress = reader.string();
          break;
        case /* string correction_type */
        4:
          message.correctionType = reader.string();
          break;
        case /* double value */
        5:
          message.value = reader.double();
          break;
        case /* string effective_from */
        6:
          message.effectiveFrom = reader.string();
          break;
        case /* string created_by */
        7:
          message.createdBy = reader.string();
          break;
        case /* string created_at */
        8:
          message.createdAt = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    if (message.accountAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
    if (message.correctionType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.correctionType);
    if (message.value !== 0)
      writer.tag(5, WireType.Bit64).double(message.value);
    if (message.effectiveFrom !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.effectiveFrom);
    if (message.createdBy !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.createdBy);
    if (message.createdAt !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.createdAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCreateAdminCorrectionResponse = new PointsCreateAdminCorrectionResponse$Type();
class PointsCreateAdminCorrectionsBatchRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCreateAdminCorrectionsBatchRequest", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "correction_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "values",
        kind: "scalar",
        repeat: 1,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "effective_from",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddresses = [];
    message.correctionType = "";
    message.values = [];
    message.label = "";
    message.effectiveFrom = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string account_addresses */
        1:
          message.accountAddresses.push(reader.string());
          break;
        case /* string correction_type */
        2:
          message.correctionType = reader.string();
          break;
        case /* repeated double values */
        3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.values.push(reader.double());
          else
            message.values.push(reader.double());
          break;
        case /* string label */
        4:
          message.label = reader.string();
          break;
        case /* sint64 effective_from */
        5:
          message.effectiveFrom = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accountAddresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddresses[i]);
    if (message.correctionType !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.correctionType);
    if (message.values.length) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.values.length; i++)
        writer.double(message.values[i]);
      writer.join();
    }
    if (message.label !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.label);
    if (message.effectiveFrom !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.effectiveFrom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCreateAdminCorrectionsBatchRequest = new PointsCreateAdminCorrectionsBatchRequest$Type();
class PointsDeleteAdminCorrectionRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsDeleteAdminCorrectionRequest", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsDeleteAdminCorrectionRequest = new PointsDeleteAdminCorrectionRequest$Type();
class PointsDeleteAdminCorrectionResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsDeleteAdminCorrectionResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsDeleteAdminCorrectionResponse = new PointsDeleteAdminCorrectionResponse$Type();
class PointsReprocessTradesAfterDateRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsReprocessTradesAfterDateRequest", [
      {
        no: 1,
        name: "after_date",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.afterDate = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 after_date */
        1:
          message.afterDate = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.afterDate !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.afterDate);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsReprocessTradesAfterDateRequest = new PointsReprocessTradesAfterDateRequest$Type();
class PointsReprocessTradesAfterDateResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsReprocessTradesAfterDateResponse", [
      {
        no: 1,
        name: "affected_count",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.affectedCount = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 affected_count */
        1:
          message.affectedCount = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.affectedCount !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.affectedCount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsReprocessTradesAfterDateResponse = new PointsReprocessTradesAfterDateResponse$Type();
class PointsCaptureSeasonOneSnapshotAndBonusRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCaptureSeasonOneSnapshotAndBonusRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCaptureSeasonOneSnapshotAndBonusRequest = new PointsCaptureSeasonOneSnapshotAndBonusRequest$Type();
class PointsCaptureSeasonOneSnapshotAndBonusResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsCaptureSeasonOneSnapshotAndBonusResponse", [
      {
        no: 1,
        name: "accounts_processed",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountsProcessed = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 accounts_processed */
        1:
          message.accountsProcessed = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountsProcessed !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.accountsProcessed);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsCaptureSeasonOneSnapshotAndBonusResponse = new PointsCaptureSeasonOneSnapshotAndBonusResponse$Type();
class PointsRecomputeDailyPointsSnapshotsRequest$Type extends MessageType {
  constructor() {
    super("points_svc.PointsRecomputeDailyPointsSnapshotsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsRecomputeDailyPointsSnapshotsRequest = new PointsRecomputeDailyPointsSnapshotsRequest$Type();
class PointsRecomputeDailyPointsSnapshotsResponse$Type extends MessageType {
  constructor() {
    super("points_svc.PointsRecomputeDailyPointsSnapshotsResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsRecomputeDailyPointsSnapshotsResponse = new PointsRecomputeDailyPointsSnapshotsResponse$Type();
const PointsSvc = new ServiceType("points_svc.PointsSvc", [
  { name: "PointsLatestForAccount", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsLatestForAccountRequest, O: PointsLatestForAccountResponse },
  { name: "PointsStatsDailyForAccount", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsStatsDailyForAccountRequest, O: HistoricalPointsStatsRowCollection },
  { name: "PointsStatsWeeklyForAccount", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsStatsWeeklyForAccountRequest, O: HistoricalPointsStatsRowCollection },
  { name: "PointsLeaderboard", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsLeaderboardRequest, O: LeaderboardPointsRowCollection },
  { name: "PointsSimulateAllocation", options: {}, I: PointsSimulateAllocationRequest, O: PointsSimulateAllocationResponse },
  { name: "PointsGetLeagueConfig", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsGetLeagueConfigRequest, O: PointsGetLeagueConfigResponse },
  { name: "PointsSetLeagueConfig", options: {}, I: PointsSetLeagueConfigRequest, O: PointsSetLeagueConfigResponse },
  { name: "PointsGetEmissionConfig", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsGetEmissionConfigRequest, O: PointsGetEmissionConfigResponse },
  { name: "PointsSetEmissionConfig", options: {}, I: PointsSetEmissionConfigRequest, O: PointsSetEmissionConfigResponse },
  { name: "PointsListBanConfigs", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsListBanConfigsRequest, O: BanConfigCollection },
  { name: "PointsCreateBanConfig", options: {}, I: PointsCreateBanConfigRequest, O: BanConfigCollection },
  { name: "PointsDeleteBanConfig", options: {}, I: PointsDeleteBanConfigRequest, O: PointsDeleteBanConfigResponse },
  { name: "PointsListMultiplierConfigs", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsListMultiplierConfigsRequest, O: PointsMultiplierConfigCollection },
  { name: "PointsCreateMultiplierConfig", options: {}, I: PointsCreateMultiplierConfigRequest, O: PointsCreateMultiplierConfigResponse },
  { name: "PointsDeleteMultiplierConfig", options: {}, I: PointsDeleteMultiplierConfigRequest, O: PointsDeleteMultiplierConfigResponse },
  { name: "PointsListAdminCorrections", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsListAdminCorrectionsRequest, O: AdminPointsCorrectionCollection },
  { name: "PointsCreateAdminCorrection", options: {}, I: PointsCreateAdminCorrectionRequest, O: PointsCreateAdminCorrectionResponse },
  { name: "PointsCreateAdminCorrectionsBatch", options: {}, I: PointsCreateAdminCorrectionsBatchRequest, O: AdminPointsCorrectionCollection },
  { name: "PointsDeleteAdminCorrection", options: {}, I: PointsDeleteAdminCorrectionRequest, O: PointsDeleteAdminCorrectionResponse },
  { name: "PointsReprocessTradesAfterDate", options: {}, I: PointsReprocessTradesAfterDateRequest, O: PointsReprocessTradesAfterDateResponse },
  { name: "PointsCaptureSeasonOneSnapshotAndBonus", options: {}, I: PointsCaptureSeasonOneSnapshotAndBonusRequest, O: PointsCaptureSeasonOneSnapshotAndBonusResponse },
  { name: "PointsRecomputeDailyPointsSnapshots", options: {}, I: PointsRecomputeDailyPointsSnapshotsRequest, O: PointsRecomputeDailyPointsSnapshotsResponse }
]);
export {
  AdminPointsCorrection,
  AdminPointsCorrectionCollection,
  BanConfig,
  BanConfigCollection,
  HistoricalPointsStatsRow,
  HistoricalPointsStatsRowCollection,
  LeaderboardPointsRow,
  LeaderboardPointsRowCollection,
  ModelEffectiveVolumeTier,
  ModelPointsMultiplier,
  ModelVolumeTierConfig,
  PointsCaptureSeasonOneSnapshotAndBonusRequest,
  PointsCaptureSeasonOneSnapshotAndBonusResponse,
  PointsCreateAdminCorrectionRequest,
  PointsCreateAdminCorrectionResponse,
  PointsCreateAdminCorrectionsBatchRequest,
  PointsCreateBanConfigRequest,
  PointsCreateMultiplierConfigRequest,
  PointsCreateMultiplierConfigResponse,
  PointsDeleteAdminCorrectionRequest,
  PointsDeleteAdminCorrectionResponse,
  PointsDeleteBanConfigRequest,
  PointsDeleteBanConfigResponse,
  PointsDeleteMultiplierConfigRequest,
  PointsDeleteMultiplierConfigResponse,
  PointsGetEmissionConfigRequest,
  PointsGetEmissionConfigResponse,
  PointsGetLeagueConfigRequest,
  PointsGetLeagueConfigResponse,
  PointsLatestForAccountRequest,
  PointsLatestForAccountResponse,
  PointsLeaderboardRequest,
  PointsListAdminCorrectionsRequest,
  PointsListBanConfigsRequest,
  PointsListMultiplierConfigsRequest,
  PointsMultiplierConfig,
  PointsMultiplierConfigCollection,
  PointsRecomputeDailyPointsSnapshotsRequest,
  PointsRecomputeDailyPointsSnapshotsResponse,
  PointsReprocessTradesAfterDateRequest,
  PointsReprocessTradesAfterDateResponse,
  PointsSetEmissionConfigRequest,
  PointsSetEmissionConfigResponse,
  PointsSetLeagueConfigRequest,
  PointsSetLeagueConfigResponse,
  PointsSimulateAllocationRequest,
  PointsSimulateAllocationResponse,
  PointsStatsDailyForAccountRequest,
  PointsStatsWeeklyForAccountRequest,
  PointsSvc
};
