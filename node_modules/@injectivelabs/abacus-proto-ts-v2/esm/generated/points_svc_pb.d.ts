// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "points_svc.proto" (package "points_svc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.15.2, DO NOT EDIT.
//
// PointsSvc protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-abacus/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message points_svc.PointsLatestForAccountRequest
 */
export interface PointsLatestForAccountRequest {
    /**
     * Account address to get stats for.
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message points_svc.PointsLatestForAccountResponse
 */
export interface PointsLatestForAccountResponse {
    /**
     * Global rank of an account address based on total points.
     *
     * @generated from protobuf field: uint64 rank = 1
     */
    rank: bigint;
    /**
     * Total amount of points allocated for an account address.
     *
     * @generated from protobuf field: uint64 total_points = 2
     */
    totalPoints: bigint;
    /**
     * Total amount of points allocated for an account address. With float part.
     *
     * @generated from protobuf field: double total_points_precise = 3
     */
    totalPointsPrecise: number;
    /**
     * League assigned based on the rank among total participants.
     *
     * @generated from protobuf field: string league = 4
     */
    league: string;
    /**
     * Latest computation timestamp of the rank and total points.
     *
     * @generated from protobuf field: string updated_at = 5
     */
    updatedAt: string;
    /**
     * Points allocated for an account address during season 1.
     *
     * @generated from protobuf field: double points_season1 = 6
     */
    pointsSeason1: number;
    /**
     * Bonus points allocated for an account address (on top of S1).
     *
     * @generated from protobuf field: double points_bonus = 7
     */
    pointsBonus: number;
}
/**
 * @generated from protobuf message points_svc.PointsStatsDailyForAccountRequest
 */
export interface PointsStatsDailyForAccountRequest {
    /**
     * Account address to get stats for.
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Limit amount of days of historical look back.
     *
     * @generated from protobuf field: optional uint64 days_limit = 2
     */
    daysLimit?: bigint;
}
/**
 * @generated from protobuf message points_svc.HistoricalPointsStatsRowCollection
 */
export interface HistoricalPointsStatsRowCollection {
    /**
     * @generated from protobuf field: repeated points_svc.HistoricalPointsStatsRow rows = 1
     */
    rows: HistoricalPointsStatsRow[];
}
/**
 * @generated from protobuf message points_svc.HistoricalPointsStatsRow
 */
export interface HistoricalPointsStatsRow {
    /**
     * Week number in ISO format.
     *
     * @generated from protobuf field: string week = 1
     */
    week: string;
    /**
     * Day in ISO format.
     *
     * @generated from protobuf field: optional string day = 2
     */
    day?: string;
    /**
     * Amount of points allocated for an account address during time window.
     *
     * @generated from protobuf field: uint64 points = 3
     */
    points: bigint;
    /**
     * Amount of points allocated for an account address during time window. With
     * float part.
     *
     * @generated from protobuf field: double points_precise = 4
     */
    pointsPrecise: number;
    /**
     * Notional volume traded account address during time window.
     *
     * @generated from protobuf field: double volume = 5
     */
    volume: number;
}
/**
 * @generated from protobuf message points_svc.PointsStatsWeeklyForAccountRequest
 */
export interface PointsStatsWeeklyForAccountRequest {
    /**
     * Account address to get stats for.
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Limit amount of days of historical look back.
     *
     * @generated from protobuf field: optional uint64 weeks_limit = 2
     */
    weeksLimit?: bigint;
}
/**
 * @generated from protobuf message points_svc.PointsLeaderboardRequest
 */
export interface PointsLeaderboardRequest {
}
/**
 * @generated from protobuf message points_svc.LeaderboardPointsRowCollection
 */
export interface LeaderboardPointsRowCollection {
    /**
     * @generated from protobuf field: repeated points_svc.LeaderboardPointsRow rows = 1
     */
    rows: LeaderboardPointsRow[];
}
/**
 * @generated from protobuf message points_svc.LeaderboardPointsRow
 */
export interface LeaderboardPointsRow {
    /**
     * Rank of an account address.
     *
     * @generated from protobuf field: uint64 rank = 1
     */
    rank: bigint;
    /**
     * Total count of ranked participants.
     *
     * @generated from protobuf field: uint64 total_rank = 2
     */
    totalRank: bigint;
    /**
     * Account address.
     *
     * @generated from protobuf field: string account_address = 3
     */
    accountAddress: string;
    /**
     * Points allocated for an account address.
     *
     * @generated from protobuf field: double points = 4
     */
    points: number;
    /**
     * League assigned based on the rank among total participants.
     *
     * @generated from protobuf field: string league = 5
     */
    league: string;
}
/**
 * @generated from protobuf message points_svc.PointsSimulateAllocationRequest
 */
export interface PointsSimulateAllocationRequest {
    /**
     * Account address
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * The ID of the market that this trade is in
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * The direction the trade
     *
     * @generated from protobuf field: string trade_direction = 3
     */
    tradeDirection: string;
    /**
     * Trade's execution side, maker/taker
     *
     * @generated from protobuf field: string execution_side = 4
     */
    executionSide: string;
    /**
     * USD value of the trade at the time of execution
     *
     * @generated from protobuf field: double usd_value = 5
     */
    usdValue: number;
    /**
     * A list of flag assigned to the trade
     *
     * @generated from protobuf field: repeated string flags = 6
     */
    flags: string[];
    /**
     * Type of market
     *
     * @generated from protobuf field: string market_type = 7
     */
    marketType: string;
    /**
     * Target UNIX timestamp in seconds of trade execution.
     *
     * @generated from protobuf field: uint64 timestamp = 8
     */
    timestamp: bigint;
    /**
     * Prior daily volume (in USD) of the account address before processing the
     * trade.
     *
     * @generated from protobuf field: optional double prior_daily_volume = 9
     */
    priorDailyVolume?: number;
}
/**
 * @generated from protobuf message points_svc.PointsSimulateAllocationResponse
 */
export interface PointsSimulateAllocationResponse {
    /**
     * Points that would be emitted for this trade
     *
     * @generated from protobuf field: double points_emitted = 1
     */
    pointsEmitted: number;
    /**
     * Breakdown of how points were calculated
     *
     * @generated from protobuf field: string points_breakdown = 2
     */
    pointsBreakdown: string;
    /**
     * Trading volume prior to this trade in the same day
     *
     * @generated from protobuf field: double prior_daily_volume = 3
     */
    priorDailyVolume: number;
    /**
     * Volume tiers that apply
     *
     * @generated from protobuf field: repeated points_svc.ModelEffectiveVolumeTier effective_volume_tiers = 4
     */
    effectiveVolumeTiers: ModelEffectiveVolumeTier[];
    /**
     * Multipliers that would apply
     *
     * @generated from protobuf field: repeated points_svc.ModelPointsMultiplier effective_multipliers = 5
     */
    effectiveMultipliers: ModelPointsMultiplier[];
}
/**
 * @generated from protobuf message points_svc.ModelEffectiveVolumeTier
 */
export interface ModelEffectiveVolumeTier {
    /**
     * Tier config number. Starts from 1.
     *
     * @generated from protobuf field: uint32 tier_number = 1
     */
    tierNumber: number;
    /**
     * Maximum USD notional volume for the tier.
     *
     * @generated from protobuf field: double upper_threshold = 2
     */
    upperThreshold: number;
    /**
     * Points per unit volume for taker trades.
     *
     * @generated from protobuf field: double taker_rate = 3
     */
    takerRate: number;
    /**
     * Points per unit volume for maker trades.
     *
     * @generated from protobuf field: double maker_rate = 4
     */
    makerRate: number;
    /**
     * Volume allocated to this tier.
     *
     * @generated from protobuf field: double effective_volume = 5
     */
    effectiveVolume: number;
    /**
     * Points rate applied for this tier
     *
     * @generated from protobuf field: double effective_rate = 6
     */
    effectiveRate: number;
}
/**
 * @generated from protobuf message points_svc.ModelPointsMultiplier
 */
export interface ModelPointsMultiplier {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Human readable label
     *
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * Points multiplier value
     *
     * @generated from protobuf field: double multiplier = 3
     */
    multiplier: number;
    /**
     * List of affected user addresses
     *
     * @generated from protobuf field: repeated string affected_users = 4
     */
    affectedUsers: string[];
    /**
     * List of affected market IDs
     *
     * @generated from protobuf field: repeated string affected_markets = 5
     */
    affectedMarkets: string[];
    /**
     * List of not-affected market IDs, all other markets will be affected. Cannot
     * be used together with affected_markets.
     *
     * @generated from protobuf field: repeated string all_markets_except = 6
     */
    allMarketsExcept: string[];
    /**
     * Start date when multiplier becomes effective
     *
     * @generated from protobuf field: optional string effective_date_start = 7
     */
    effectiveDateStart?: string;
    /**
     * End date when multiplier expires
     *
     * @generated from protobuf field: optional string effective_date_end = 8
     */
    effectiveDateEnd?: string;
    /**
     * List of trade flags this multiplier applies to
     *
     * @generated from protobuf field: repeated string effective_flags = 9
     */
    effectiveFlags: string[];
}
/**
 * @generated from protobuf message points_svc.PointsGetLeagueConfigRequest
 */
export interface PointsGetLeagueConfigRequest {
}
/**
 * @generated from protobuf message points_svc.PointsGetLeagueConfigResponse
 */
export interface PointsGetLeagueConfigResponse {
    /**
     * Percentile threshold for white league
     *
     * @generated from protobuf field: double white_threshold = 1
     */
    whiteThreshold: number;
    /**
     * Percentile threshold for orange league
     *
     * @generated from protobuf field: double orange_threshold = 2
     */
    orangeThreshold: number;
    /**
     * Percentile threshold for blue league
     *
     * @generated from protobuf field: double blue_threshold = 3
     */
    blueThreshold: number;
    /**
     * Percentile threshold for purple league
     *
     * @generated from protobuf field: double purple_threshold = 4
     */
    purpleThreshold: number;
    /**
     * Percentile threshold for black league
     *
     * @generated from protobuf field: double black_threshold = 5
     */
    blackThreshold: number;
    /**
     * ID of the admin who last updated the config
     *
     * @generated from protobuf field: string updated_by = 6
     */
    updatedBy: string;
    /**
     * Timestamp of the last update
     *
     * @generated from protobuf field: string updated_at = 7
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsSetLeagueConfigRequest
 */
export interface PointsSetLeagueConfigRequest {
    /**
     * Percentile threshold for white league
     *
     * @generated from protobuf field: double white_threshold = 1
     */
    whiteThreshold: number;
    /**
     * Percentile threshold for orange league
     *
     * @generated from protobuf field: double orange_threshold = 2
     */
    orangeThreshold: number;
    /**
     * Percentile threshold for blue league
     *
     * @generated from protobuf field: double blue_threshold = 3
     */
    blueThreshold: number;
    /**
     * Percentile threshold for purple league
     *
     * @generated from protobuf field: double purple_threshold = 4
     */
    purpleThreshold: number;
    /**
     * Percentile threshold for black league
     *
     * @generated from protobuf field: double black_threshold = 5
     */
    blackThreshold: number;
}
/**
 * @generated from protobuf message points_svc.PointsSetLeagueConfigResponse
 */
export interface PointsSetLeagueConfigResponse {
    /**
     * Percentile threshold for white league
     *
     * @generated from protobuf field: double white_threshold = 1
     */
    whiteThreshold: number;
    /**
     * Percentile threshold for orange league
     *
     * @generated from protobuf field: double orange_threshold = 2
     */
    orangeThreshold: number;
    /**
     * Percentile threshold for blue league
     *
     * @generated from protobuf field: double blue_threshold = 3
     */
    blueThreshold: number;
    /**
     * Percentile threshold for purple league
     *
     * @generated from protobuf field: double purple_threshold = 4
     */
    purpleThreshold: number;
    /**
     * Percentile threshold for black league
     *
     * @generated from protobuf field: double black_threshold = 5
     */
    blackThreshold: number;
    /**
     * ID of the admin who last updated the config
     *
     * @generated from protobuf field: string updated_by = 6
     */
    updatedBy: string;
    /**
     * Timestamp of the last update
     *
     * @generated from protobuf field: string updated_at = 7
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsGetEmissionConfigRequest
 */
export interface PointsGetEmissionConfigRequest {
}
/**
 * @generated from protobuf message points_svc.PointsGetEmissionConfigResponse
 */
export interface PointsGetEmissionConfigResponse {
    /**
     * Base unit volume for points calculation
     *
     * @generated from protobuf field: double unit_volume = 1
     */
    unitVolume: number;
    /**
     * List of volume tiers configuration
     *
     * @generated from protobuf field: repeated points_svc.ModelVolumeTierConfig volume_tiers = 2
     */
    volumeTiers: ModelVolumeTierConfig[];
    /**
     * ID of the admin who last updated the config
     *
     * @generated from protobuf field: string updated_by = 3
     */
    updatedBy: string;
    /**
     * Timestamp of the last update
     *
     * @generated from protobuf field: string updated_at = 4
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message points_svc.ModelVolumeTierConfig
 */
export interface ModelVolumeTierConfig {
    /**
     * Maximum USD notional volume for the tier.
     *
     * @generated from protobuf field: double upper_threshold = 1
     */
    upperThreshold: number;
    /**
     * Points per unit volume for taker trades.
     *
     * @generated from protobuf field: double taker_rate = 2
     */
    takerRate: number;
    /**
     * Points per unit volume for maker trades.
     *
     * @generated from protobuf field: double maker_rate = 3
     */
    makerRate: number;
}
/**
 * @generated from protobuf message points_svc.PointsSetEmissionConfigRequest
 */
export interface PointsSetEmissionConfigRequest {
    /**
     * Base unit volume for points calculation
     *
     * @generated from protobuf field: double unit_volume = 1
     */
    unitVolume: number;
    /**
     * List of volume tiers configuration
     *
     * @generated from protobuf field: repeated points_svc.ModelVolumeTierConfig volume_tiers = 2
     */
    volumeTiers: ModelVolumeTierConfig[];
}
/**
 * @generated from protobuf message points_svc.PointsSetEmissionConfigResponse
 */
export interface PointsSetEmissionConfigResponse {
    /**
     * Base unit volume for points calculation
     *
     * @generated from protobuf field: double unit_volume = 1
     */
    unitVolume: number;
    /**
     * List of volume tiers configuration
     *
     * @generated from protobuf field: repeated points_svc.ModelVolumeTierConfig volume_tiers = 2
     */
    volumeTiers: ModelVolumeTierConfig[];
    /**
     * ID of the admin who last updated the config
     *
     * @generated from protobuf field: string updated_by = 3
     */
    updatedBy: string;
    /**
     * Timestamp of the last update
     *
     * @generated from protobuf field: string updated_at = 4
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsListBanConfigsRequest
 */
export interface PointsListBanConfigsRequest {
}
/**
 * @generated from protobuf message points_svc.BanConfigCollection
 */
export interface BanConfigCollection {
    /**
     * @generated from protobuf field: repeated points_svc.BanConfig bans = 1
     */
    bans: BanConfig[];
}
/**
 * @generated from protobuf message points_svc.BanConfig
 */
export interface BanConfig {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Human readable label for the ban
     *
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * Account address that is banned
     *
     * @generated from protobuf field: string account_address = 3
     */
    accountAddress: string;
    /**
     * Eth address that is banned
     *
     * @generated from protobuf field: string eth_address = 4
     */
    ethAddress: string;
    /**
     * ID of the admin who created the ban
     *
     * @generated from protobuf field: string created_by = 5
     */
    createdBy: string;
    /**
     * Timestamp when the ban was created
     *
     * @generated from protobuf field: string created_at = 6
     */
    createdAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsCreateBanConfigRequest
 */
export interface PointsCreateBanConfigRequest {
    /**
     * Account addresses to create ban config for.
     *
     * @generated from protobuf field: repeated string account_addresses = 1
     */
    accountAddresses: string[];
    /**
     * Eth addresses to create ban config for (optional).
     *
     * @generated from protobuf field: repeated string eth_addresses = 2
     */
    ethAddresses: string[];
    /**
     * Provides a reason for the ban configuration.
     *
     * @generated from protobuf field: string label = 3
     */
    label: string;
    /**
     * UNIX timestamp in seconds when the ban becomes effective.
     *
     * @generated from protobuf field: uint64 effective_from = 4
     */
    effectiveFrom: bigint;
}
/**
 * @generated from protobuf message points_svc.PointsDeleteBanConfigRequest
 */
export interface PointsDeleteBanConfigRequest {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message points_svc.PointsDeleteBanConfigResponse
 */
export interface PointsDeleteBanConfigResponse {
}
/**
 * @generated from protobuf message points_svc.PointsListMultiplierConfigsRequest
 */
export interface PointsListMultiplierConfigsRequest {
}
/**
 * @generated from protobuf message points_svc.PointsMultiplierConfigCollection
 */
export interface PointsMultiplierConfigCollection {
    /**
     * @generated from protobuf field: repeated points_svc.PointsMultiplierConfig multipliers = 1
     */
    multipliers: PointsMultiplierConfig[];
}
/**
 * @generated from protobuf message points_svc.PointsMultiplierConfig
 */
export interface PointsMultiplierConfig {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Human readable label
     *
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * Points multiplier value
     *
     * @generated from protobuf field: double multiplier = 3
     */
    multiplier: number;
    /**
     * List of affected user addresses
     *
     * @generated from protobuf field: repeated string affected_users = 4
     */
    affectedUsers: string[];
    /**
     * List of affected market IDs
     *
     * @generated from protobuf field: repeated string affected_markets = 5
     */
    affectedMarkets: string[];
    /**
     * List of not-affected market IDs, all other markets will be affected. Cannot
     * be used together with affected_markets.
     *
     * @generated from protobuf field: repeated string all_markets_except = 6
     */
    allMarketsExcept: string[];
    /**
     * Start date when multiplier becomes effective (UNIX seconds)
     *
     * @generated from protobuf field: optional uint64 effective_date_start = 7
     */
    effectiveDateStart?: bigint;
    /**
     * End date when multiplier expires (UNIX seconds)
     *
     * @generated from protobuf field: optional uint64 effective_date_end = 8
     */
    effectiveDateEnd?: bigint;
    /**
     * List of trade flags this multiplier applies to
     *
     * @generated from protobuf field: repeated string effective_flags = 9
     */
    effectiveFlags: string[];
    /**
     * Whether to force recalculation of points
     *
     * @generated from protobuf field: bool enforce_recalculate = 10
     */
    enforceRecalculate: boolean;
    /**
     * ID of the admin who created the config
     *
     * @generated from protobuf field: string created_by = 11
     */
    createdBy: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 12
     */
    createdAt: string;
    /**
     * ID of the admin who last updated the config
     *
     * @generated from protobuf field: string updated_by = 13
     */
    updatedBy: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 14
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsCreateMultiplierConfigRequest
 */
export interface PointsCreateMultiplierConfigRequest {
    /**
     * List of market IDs to apply multiplier to. Empty list means all markets.
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
    /**
     * Multiplier will apply to all markets except the ones in this list. Cannot be
     * used together with market_ids.
     *
     * @generated from protobuf field: repeated string all_markets_except = 2
     */
    allMarketsExcept: string[];
    /**
     * List of account addresses to apply multiplier to.
     *
     * @generated from protobuf field: repeated string account_addresses = 3
     */
    accountAddresses: string[];
    /**
     * List of feature flags to apply multiplier to. Empty list means all flags.
     *
     * @generated from protobuf field: repeated string flags = 4
     */
    flags: string[];
    /**
     * Points multiplier value. 1.0 means normal points, 2.0 means double points,
     * etc.
     *
     * @generated from protobuf field: double multiplier = 5
     */
    multiplier: number;
    /**
     * Description of the multiplier configuration.
     *
     * @generated from protobuf field: string label = 6
     */
    label: string;
    /**
     * UNIX timestamp in seconds when the multiplier becomes effective.
     *
     * @generated from protobuf field: optional sint64 effective_from = 7
     */
    effectiveFrom?: bigint;
    /**
     * UNIX timestamp in seconds when the multiplier expires. 0 means no expiration.
     *
     * @generated from protobuf field: optional sint64 effective_until = 8
     */
    effectiveUntil?: bigint;
    /**
     * If true, recalculate points for affected users and markets after the
     * multiplier is set.
     *
     * @generated from protobuf field: bool enforce_recalculate = 9
     */
    enforceRecalculate: boolean;
}
/**
 * @generated from protobuf message points_svc.PointsCreateMultiplierConfigResponse
 */
export interface PointsCreateMultiplierConfigResponse {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Human readable label
     *
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * Points multiplier value
     *
     * @generated from protobuf field: double multiplier = 3
     */
    multiplier: number;
    /**
     * List of affected user addresses
     *
     * @generated from protobuf field: repeated string affected_users = 4
     */
    affectedUsers: string[];
    /**
     * List of affected market IDs
     *
     * @generated from protobuf field: repeated string affected_markets = 5
     */
    affectedMarkets: string[];
    /**
     * List of not-affected market IDs, all other markets will be affected. Cannot
     * be used together with affected_markets.
     *
     * @generated from protobuf field: repeated string all_markets_except = 6
     */
    allMarketsExcept: string[];
    /**
     * Start date when multiplier becomes effective (UNIX seconds)
     *
     * @generated from protobuf field: optional uint64 effective_date_start = 7
     */
    effectiveDateStart?: bigint;
    /**
     * End date when multiplier expires (UNIX seconds)
     *
     * @generated from protobuf field: optional uint64 effective_date_end = 8
     */
    effectiveDateEnd?: bigint;
    /**
     * List of trade flags this multiplier applies to
     *
     * @generated from protobuf field: repeated string effective_flags = 9
     */
    effectiveFlags: string[];
    /**
     * Whether to force recalculation of points
     *
     * @generated from protobuf field: bool enforce_recalculate = 10
     */
    enforceRecalculate: boolean;
    /**
     * ID of the admin who created the config
     *
     * @generated from protobuf field: string created_by = 11
     */
    createdBy: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 12
     */
    createdAt: string;
    /**
     * ID of the admin who last updated the config
     *
     * @generated from protobuf field: string updated_by = 13
     */
    updatedBy: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 14
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsDeleteMultiplierConfigRequest
 */
export interface PointsDeleteMultiplierConfigRequest {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message points_svc.PointsDeleteMultiplierConfigResponse
 */
export interface PointsDeleteMultiplierConfigResponse {
}
/**
 * @generated from protobuf message points_svc.PointsListAdminCorrectionsRequest
 */
export interface PointsListAdminCorrectionsRequest {
    /**
     * Filter corrections by type (absolute or relative)
     *
     * @generated from protobuf field: optional string correction_type = 1
     */
    correctionType?: string;
    /**
     * Filter corrections by account address
     *
     * @generated from protobuf field: optional string account_address = 2
     */
    accountAddress?: string;
}
/**
 * @generated from protobuf message points_svc.AdminPointsCorrectionCollection
 */
export interface AdminPointsCorrectionCollection {
    /**
     * @generated from protobuf field: repeated points_svc.AdminPointsCorrection corrections = 1
     */
    corrections: AdminPointsCorrection[];
}
/**
 * @generated from protobuf message points_svc.AdminPointsCorrection
 */
export interface AdminPointsCorrection {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Human readable label for the correction
     *
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * Account address for which points are being corrected
     *
     * @generated from protobuf field: string account_address = 3
     */
    accountAddress: string;
    /**
     * Type of correction (absolute or relative)
     *
     * @generated from protobuf field: string correction_type = 4
     */
    correctionType: string;
    /**
     * Correction value (can be negative if relative)
     *
     * @generated from protobuf field: double value = 5
     */
    value: number;
    /**
     * Timestamp from which the correction is effective
     *
     * @generated from protobuf field: string effective_from = 6
     */
    effectiveFrom: string;
    /**
     * ID of the admin who created the correction
     *
     * @generated from protobuf field: string created_by = 7
     */
    createdBy: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 8
     */
    createdAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsCreateAdminCorrectionRequest
 */
export interface PointsCreateAdminCorrectionRequest {
    /**
     * Account address to create correction for.
     *
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * Type of correction (absolute or relative)
     *
     * @generated from protobuf field: string correction_type = 2
     */
    correctionType: string;
    /**
     * Points value to set (absolute) or add/subtract (relative)
     *
     * @generated from protobuf field: double value = 3
     */
    value: number;
    /**
     * Provides a reason for the correction.
     *
     * @generated from protobuf field: string label = 4
     */
    label: string;
    /**
     * UNIX timestamp in seconds when the correction becomes effective.
     *
     * @generated from protobuf field: sint64 effective_from = 5
     */
    effectiveFrom: bigint;
}
/**
 * @generated from protobuf message points_svc.PointsCreateAdminCorrectionResponse
 */
export interface PointsCreateAdminCorrectionResponse {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Human readable label for the correction
     *
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * Account address for which points are being corrected
     *
     * @generated from protobuf field: string account_address = 3
     */
    accountAddress: string;
    /**
     * Type of correction (absolute or relative)
     *
     * @generated from protobuf field: string correction_type = 4
     */
    correctionType: string;
    /**
     * Correction value (can be negative if relative)
     *
     * @generated from protobuf field: double value = 5
     */
    value: number;
    /**
     * Timestamp from which the correction is effective
     *
     * @generated from protobuf field: string effective_from = 6
     */
    effectiveFrom: string;
    /**
     * ID of the admin who created the correction
     *
     * @generated from protobuf field: string created_by = 7
     */
    createdBy: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 8
     */
    createdAt: string;
}
/**
 * @generated from protobuf message points_svc.PointsCreateAdminCorrectionsBatchRequest
 */
export interface PointsCreateAdminCorrectionsBatchRequest {
    /**
     * Account addresses to create corrections for.
     *
     * @generated from protobuf field: repeated string account_addresses = 1
     */
    accountAddresses: string[];
    /**
     * Type of correction (absolute or relative)
     *
     * @generated from protobuf field: string correction_type = 2
     */
    correctionType: string;
    /**
     * Points values to set (absolute) or add/subtract (relative)
     *
     * @generated from protobuf field: repeated double values = 3
     */
    values: number[];
    /**
     * Provides a reason for the correction.
     *
     * @generated from protobuf field: string label = 4
     */
    label: string;
    /**
     * UNIX timestamp in seconds when the correction becomes effective.
     *
     * @generated from protobuf field: sint64 effective_from = 5
     */
    effectiveFrom: bigint;
}
/**
 * @generated from protobuf message points_svc.PointsDeleteAdminCorrectionRequest
 */
export interface PointsDeleteAdminCorrectionRequest {
    /**
     * Unique identifier
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message points_svc.PointsDeleteAdminCorrectionResponse
 */
export interface PointsDeleteAdminCorrectionResponse {
}
/**
 * @generated from protobuf message points_svc.PointsReprocessTradesAfterDateRequest
 */
export interface PointsReprocessTradesAfterDateRequest {
    /**
     * UNIX timestamp in seconds after which trades will be reprocessed.
     *
     * @generated from protobuf field: sint64 after_date = 1
     */
    afterDate: bigint;
}
/**
 * @generated from protobuf message points_svc.PointsReprocessTradesAfterDateResponse
 */
export interface PointsReprocessTradesAfterDateResponse {
    /**
     * Number of trades scheduled to be reprocessed.
     *
     * @generated from protobuf field: sint64 affected_count = 1
     */
    affectedCount: bigint;
}
/**
 * @generated from protobuf message points_svc.PointsCaptureSeasonOneSnapshotAndBonusRequest
 */
export interface PointsCaptureSeasonOneSnapshotAndBonusRequest {
}
/**
 * @generated from protobuf message points_svc.PointsCaptureSeasonOneSnapshotAndBonusResponse
 */
export interface PointsCaptureSeasonOneSnapshotAndBonusResponse {
    /**
     * Number of accounts processed.
     *
     * @generated from protobuf field: sint64 accounts_processed = 1
     */
    accountsProcessed: bigint;
}
/**
 * @generated from protobuf message points_svc.PointsRecomputeDailyPointsSnapshotsRequest
 */
export interface PointsRecomputeDailyPointsSnapshotsRequest {
}
/**
 * @generated from protobuf message points_svc.PointsRecomputeDailyPointsSnapshotsResponse
 */
export interface PointsRecomputeDailyPointsSnapshotsResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class PointsLatestForAccountRequest$Type extends MessageType<PointsLatestForAccountRequest> {
    constructor() {
        super("points_svc.PointsLatestForAccountRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsLatestForAccountRequest>): PointsLatestForAccountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<PointsLatestForAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsLatestForAccountRequest): PointsLatestForAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsLatestForAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsLatestForAccountRequest
 */
export const PointsLatestForAccountRequest = new PointsLatestForAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsLatestForAccountResponse$Type extends MessageType<PointsLatestForAccountResponse> {
    constructor() {
        super("points_svc.PointsLatestForAccountResponse", [
            { no: 1, name: "rank", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "total_points", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "total_points_precise", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "league", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "points_season1", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "points_bonus", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<PointsLatestForAccountResponse>): PointsLatestForAccountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rank = 0n;
        message.totalPoints = 0n;
        message.totalPointsPrecise = 0;
        message.league = "";
        message.updatedAt = "";
        message.pointsSeason1 = 0;
        message.pointsBonus = 0;
        if (value !== undefined)
            reflectionMergePartial<PointsLatestForAccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsLatestForAccountResponse): PointsLatestForAccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rank */ 1:
                    message.rank = reader.uint64().toBigInt();
                    break;
                case /* uint64 total_points */ 2:
                    message.totalPoints = reader.uint64().toBigInt();
                    break;
                case /* double total_points_precise */ 3:
                    message.totalPointsPrecise = reader.double();
                    break;
                case /* string league */ 4:
                    message.league = reader.string();
                    break;
                case /* string updated_at */ 5:
                    message.updatedAt = reader.string();
                    break;
                case /* double points_season1 */ 6:
                    message.pointsSeason1 = reader.double();
                    break;
                case /* double points_bonus */ 7:
                    message.pointsBonus = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsLatestForAccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rank = 1; */
        if (message.rank !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rank);
        /* uint64 total_points = 2; */
        if (message.totalPoints !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.totalPoints);
        /* double total_points_precise = 3; */
        if (message.totalPointsPrecise !== 0)
            writer.tag(3, WireType.Bit64).double(message.totalPointsPrecise);
        /* string league = 4; */
        if (message.league !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.league);
        /* string updated_at = 5; */
        if (message.updatedAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.updatedAt);
        /* double points_season1 = 6; */
        if (message.pointsSeason1 !== 0)
            writer.tag(6, WireType.Bit64).double(message.pointsSeason1);
        /* double points_bonus = 7; */
        if (message.pointsBonus !== 0)
            writer.tag(7, WireType.Bit64).double(message.pointsBonus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsLatestForAccountResponse
 */
export const PointsLatestForAccountResponse = new PointsLatestForAccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsStatsDailyForAccountRequest$Type extends MessageType<PointsStatsDailyForAccountRequest> {
    constructor() {
        super("points_svc.PointsStatsDailyForAccountRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "days_limit", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsStatsDailyForAccountRequest>): PointsStatsDailyForAccountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<PointsStatsDailyForAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsStatsDailyForAccountRequest): PointsStatsDailyForAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* optional uint64 days_limit */ 2:
                    message.daysLimit = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsStatsDailyForAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* optional uint64 days_limit = 2; */
        if (message.daysLimit !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.daysLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsStatsDailyForAccountRequest
 */
export const PointsStatsDailyForAccountRequest = new PointsStatsDailyForAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalPointsStatsRowCollection$Type extends MessageType<HistoricalPointsStatsRowCollection> {
    constructor() {
        super("points_svc.HistoricalPointsStatsRowCollection", [
            { no: 1, name: "rows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HistoricalPointsStatsRow }
        ]);
    }
    create(value?: PartialMessage<HistoricalPointsStatsRowCollection>): HistoricalPointsStatsRowCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rows = [];
        if (value !== undefined)
            reflectionMergePartial<HistoricalPointsStatsRowCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalPointsStatsRowCollection): HistoricalPointsStatsRowCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated points_svc.HistoricalPointsStatsRow rows */ 1:
                    message.rows.push(HistoricalPointsStatsRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalPointsStatsRowCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated points_svc.HistoricalPointsStatsRow rows = 1; */
        for (let i = 0; i < message.rows.length; i++)
            HistoricalPointsStatsRow.internalBinaryWrite(message.rows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.HistoricalPointsStatsRowCollection
 */
export const HistoricalPointsStatsRowCollection = new HistoricalPointsStatsRowCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricalPointsStatsRow$Type extends MessageType<HistoricalPointsStatsRow> {
    constructor() {
        super("points_svc.HistoricalPointsStatsRow", [
            { no: 1, name: "week", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "day", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "points", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "points_precise", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricalPointsStatsRow>): HistoricalPointsStatsRow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.week = "";
        message.points = 0n;
        message.pointsPrecise = 0;
        message.volume = 0;
        if (value !== undefined)
            reflectionMergePartial<HistoricalPointsStatsRow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricalPointsStatsRow): HistoricalPointsStatsRow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string week */ 1:
                    message.week = reader.string();
                    break;
                case /* optional string day */ 2:
                    message.day = reader.string();
                    break;
                case /* uint64 points */ 3:
                    message.points = reader.uint64().toBigInt();
                    break;
                case /* double points_precise */ 4:
                    message.pointsPrecise = reader.double();
                    break;
                case /* double volume */ 5:
                    message.volume = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricalPointsStatsRow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string week = 1; */
        if (message.week !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.week);
        /* optional string day = 2; */
        if (message.day !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.day);
        /* uint64 points = 3; */
        if (message.points !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.points);
        /* double points_precise = 4; */
        if (message.pointsPrecise !== 0)
            writer.tag(4, WireType.Bit64).double(message.pointsPrecise);
        /* double volume = 5; */
        if (message.volume !== 0)
            writer.tag(5, WireType.Bit64).double(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.HistoricalPointsStatsRow
 */
export const HistoricalPointsStatsRow = new HistoricalPointsStatsRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsStatsWeeklyForAccountRequest$Type extends MessageType<PointsStatsWeeklyForAccountRequest> {
    constructor() {
        super("points_svc.PointsStatsWeeklyForAccountRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "weeks_limit", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsStatsWeeklyForAccountRequest>): PointsStatsWeeklyForAccountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<PointsStatsWeeklyForAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsStatsWeeklyForAccountRequest): PointsStatsWeeklyForAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* optional uint64 weeks_limit */ 2:
                    message.weeksLimit = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsStatsWeeklyForAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* optional uint64 weeks_limit = 2; */
        if (message.weeksLimit !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.weeksLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsStatsWeeklyForAccountRequest
 */
export const PointsStatsWeeklyForAccountRequest = new PointsStatsWeeklyForAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsLeaderboardRequest$Type extends MessageType<PointsLeaderboardRequest> {
    constructor() {
        super("points_svc.PointsLeaderboardRequest", []);
    }
    create(value?: PartialMessage<PointsLeaderboardRequest>): PointsLeaderboardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsLeaderboardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsLeaderboardRequest): PointsLeaderboardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsLeaderboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsLeaderboardRequest
 */
export const PointsLeaderboardRequest = new PointsLeaderboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardPointsRowCollection$Type extends MessageType<LeaderboardPointsRowCollection> {
    constructor() {
        super("points_svc.LeaderboardPointsRowCollection", [
            { no: 1, name: "rows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardPointsRow }
        ]);
    }
    create(value?: PartialMessage<LeaderboardPointsRowCollection>): LeaderboardPointsRowCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rows = [];
        if (value !== undefined)
            reflectionMergePartial<LeaderboardPointsRowCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardPointsRowCollection): LeaderboardPointsRowCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated points_svc.LeaderboardPointsRow rows */ 1:
                    message.rows.push(LeaderboardPointsRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardPointsRowCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated points_svc.LeaderboardPointsRow rows = 1; */
        for (let i = 0; i < message.rows.length; i++)
            LeaderboardPointsRow.internalBinaryWrite(message.rows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.LeaderboardPointsRowCollection
 */
export const LeaderboardPointsRowCollection = new LeaderboardPointsRowCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardPointsRow$Type extends MessageType<LeaderboardPointsRow> {
    constructor() {
        super("points_svc.LeaderboardPointsRow", [
            { no: 1, name: "rank", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "total_rank", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "points", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "league", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardPointsRow>): LeaderboardPointsRow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rank = 0n;
        message.totalRank = 0n;
        message.accountAddress = "";
        message.points = 0;
        message.league = "";
        if (value !== undefined)
            reflectionMergePartial<LeaderboardPointsRow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardPointsRow): LeaderboardPointsRow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rank */ 1:
                    message.rank = reader.uint64().toBigInt();
                    break;
                case /* uint64 total_rank */ 2:
                    message.totalRank = reader.uint64().toBigInt();
                    break;
                case /* string account_address */ 3:
                    message.accountAddress = reader.string();
                    break;
                case /* double points */ 4:
                    message.points = reader.double();
                    break;
                case /* string league */ 5:
                    message.league = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardPointsRow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rank = 1; */
        if (message.rank !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rank);
        /* uint64 total_rank = 2; */
        if (message.totalRank !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.totalRank);
        /* string account_address = 3; */
        if (message.accountAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
        /* double points = 4; */
        if (message.points !== 0)
            writer.tag(4, WireType.Bit64).double(message.points);
        /* string league = 5; */
        if (message.league !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.league);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.LeaderboardPointsRow
 */
export const LeaderboardPointsRow = new LeaderboardPointsRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsSimulateAllocationRequest$Type extends MessageType<PointsSimulateAllocationRequest> {
    constructor() {
        super("points_svc.PointsSimulateAllocationRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "trade_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "execution_side", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "usd_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "market_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "prior_daily_volume", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<PointsSimulateAllocationRequest>): PointsSimulateAllocationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.marketId = "";
        message.tradeDirection = "";
        message.executionSide = "";
        message.usdValue = 0;
        message.flags = [];
        message.marketType = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PointsSimulateAllocationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsSimulateAllocationRequest): PointsSimulateAllocationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string trade_direction */ 3:
                    message.tradeDirection = reader.string();
                    break;
                case /* string execution_side */ 4:
                    message.executionSide = reader.string();
                    break;
                case /* double usd_value */ 5:
                    message.usdValue = reader.double();
                    break;
                case /* repeated string flags */ 6:
                    message.flags.push(reader.string());
                    break;
                case /* string market_type */ 7:
                    message.marketType = reader.string();
                    break;
                case /* uint64 timestamp */ 8:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional double prior_daily_volume */ 9:
                    message.priorDailyVolume = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsSimulateAllocationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string trade_direction = 3; */
        if (message.tradeDirection !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tradeDirection);
        /* string execution_side = 4; */
        if (message.executionSide !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.executionSide);
        /* double usd_value = 5; */
        if (message.usdValue !== 0)
            writer.tag(5, WireType.Bit64).double(message.usdValue);
        /* repeated string flags = 6; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.flags[i]);
        /* string market_type = 7; */
        if (message.marketType !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.marketType);
        /* uint64 timestamp = 8; */
        if (message.timestamp !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.timestamp);
        /* optional double prior_daily_volume = 9; */
        if (message.priorDailyVolume !== undefined)
            writer.tag(9, WireType.Bit64).double(message.priorDailyVolume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsSimulateAllocationRequest
 */
export const PointsSimulateAllocationRequest = new PointsSimulateAllocationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsSimulateAllocationResponse$Type extends MessageType<PointsSimulateAllocationResponse> {
    constructor() {
        super("points_svc.PointsSimulateAllocationResponse", [
            { no: 1, name: "points_emitted", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "points_breakdown", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "prior_daily_volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "effective_volume_tiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelEffectiveVolumeTier },
            { no: 5, name: "effective_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelPointsMultiplier }
        ]);
    }
    create(value?: PartialMessage<PointsSimulateAllocationResponse>): PointsSimulateAllocationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pointsEmitted = 0;
        message.pointsBreakdown = "";
        message.priorDailyVolume = 0;
        message.effectiveVolumeTiers = [];
        message.effectiveMultipliers = [];
        if (value !== undefined)
            reflectionMergePartial<PointsSimulateAllocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsSimulateAllocationResponse): PointsSimulateAllocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double points_emitted */ 1:
                    message.pointsEmitted = reader.double();
                    break;
                case /* string points_breakdown */ 2:
                    message.pointsBreakdown = reader.string();
                    break;
                case /* double prior_daily_volume */ 3:
                    message.priorDailyVolume = reader.double();
                    break;
                case /* repeated points_svc.ModelEffectiveVolumeTier effective_volume_tiers */ 4:
                    message.effectiveVolumeTiers.push(ModelEffectiveVolumeTier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated points_svc.ModelPointsMultiplier effective_multipliers */ 5:
                    message.effectiveMultipliers.push(ModelPointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsSimulateAllocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double points_emitted = 1; */
        if (message.pointsEmitted !== 0)
            writer.tag(1, WireType.Bit64).double(message.pointsEmitted);
        /* string points_breakdown = 2; */
        if (message.pointsBreakdown !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pointsBreakdown);
        /* double prior_daily_volume = 3; */
        if (message.priorDailyVolume !== 0)
            writer.tag(3, WireType.Bit64).double(message.priorDailyVolume);
        /* repeated points_svc.ModelEffectiveVolumeTier effective_volume_tiers = 4; */
        for (let i = 0; i < message.effectiveVolumeTiers.length; i++)
            ModelEffectiveVolumeTier.internalBinaryWrite(message.effectiveVolumeTiers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated points_svc.ModelPointsMultiplier effective_multipliers = 5; */
        for (let i = 0; i < message.effectiveMultipliers.length; i++)
            ModelPointsMultiplier.internalBinaryWrite(message.effectiveMultipliers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsSimulateAllocationResponse
 */
export const PointsSimulateAllocationResponse = new PointsSimulateAllocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelEffectiveVolumeTier$Type extends MessageType<ModelEffectiveVolumeTier> {
    constructor() {
        super("points_svc.ModelEffectiveVolumeTier", [
            { no: 1, name: "tier_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "upper_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "taker_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "maker_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "effective_volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "effective_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ModelEffectiveVolumeTier>): ModelEffectiveVolumeTier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tierNumber = 0;
        message.upperThreshold = 0;
        message.takerRate = 0;
        message.makerRate = 0;
        message.effectiveVolume = 0;
        message.effectiveRate = 0;
        if (value !== undefined)
            reflectionMergePartial<ModelEffectiveVolumeTier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModelEffectiveVolumeTier): ModelEffectiveVolumeTier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tier_number */ 1:
                    message.tierNumber = reader.uint32();
                    break;
                case /* double upper_threshold */ 2:
                    message.upperThreshold = reader.double();
                    break;
                case /* double taker_rate */ 3:
                    message.takerRate = reader.double();
                    break;
                case /* double maker_rate */ 4:
                    message.makerRate = reader.double();
                    break;
                case /* double effective_volume */ 5:
                    message.effectiveVolume = reader.double();
                    break;
                case /* double effective_rate */ 6:
                    message.effectiveRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModelEffectiveVolumeTier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 tier_number = 1; */
        if (message.tierNumber !== 0)
            writer.tag(1, WireType.Varint).uint32(message.tierNumber);
        /* double upper_threshold = 2; */
        if (message.upperThreshold !== 0)
            writer.tag(2, WireType.Bit64).double(message.upperThreshold);
        /* double taker_rate = 3; */
        if (message.takerRate !== 0)
            writer.tag(3, WireType.Bit64).double(message.takerRate);
        /* double maker_rate = 4; */
        if (message.makerRate !== 0)
            writer.tag(4, WireType.Bit64).double(message.makerRate);
        /* double effective_volume = 5; */
        if (message.effectiveVolume !== 0)
            writer.tag(5, WireType.Bit64).double(message.effectiveVolume);
        /* double effective_rate = 6; */
        if (message.effectiveRate !== 0)
            writer.tag(6, WireType.Bit64).double(message.effectiveRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.ModelEffectiveVolumeTier
 */
export const ModelEffectiveVolumeTier = new ModelEffectiveVolumeTier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelPointsMultiplier$Type extends MessageType<ModelPointsMultiplier> {
    constructor() {
        super("points_svc.ModelPointsMultiplier", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "multiplier", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "affected_users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "affected_markets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "all_markets_except", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "effective_date_start", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "effective_date_end", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "effective_flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ModelPointsMultiplier>): ModelPointsMultiplier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.label = "";
        message.multiplier = 0;
        message.affectedUsers = [];
        message.affectedMarkets = [];
        message.allMarketsExcept = [];
        message.effectiveFlags = [];
        if (value !== undefined)
            reflectionMergePartial<ModelPointsMultiplier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModelPointsMultiplier): ModelPointsMultiplier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* double multiplier */ 3:
                    message.multiplier = reader.double();
                    break;
                case /* repeated string affected_users */ 4:
                    message.affectedUsers.push(reader.string());
                    break;
                case /* repeated string affected_markets */ 5:
                    message.affectedMarkets.push(reader.string());
                    break;
                case /* repeated string all_markets_except */ 6:
                    message.allMarketsExcept.push(reader.string());
                    break;
                case /* optional string effective_date_start */ 7:
                    message.effectiveDateStart = reader.string();
                    break;
                case /* optional string effective_date_end */ 8:
                    message.effectiveDateEnd = reader.string();
                    break;
                case /* repeated string effective_flags */ 9:
                    message.effectiveFlags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModelPointsMultiplier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* double multiplier = 3; */
        if (message.multiplier !== 0)
            writer.tag(3, WireType.Bit64).double(message.multiplier);
        /* repeated string affected_users = 4; */
        for (let i = 0; i < message.affectedUsers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.affectedUsers[i]);
        /* repeated string affected_markets = 5; */
        for (let i = 0; i < message.affectedMarkets.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.affectedMarkets[i]);
        /* repeated string all_markets_except = 6; */
        for (let i = 0; i < message.allMarketsExcept.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
        /* optional string effective_date_start = 7; */
        if (message.effectiveDateStart !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.effectiveDateStart);
        /* optional string effective_date_end = 8; */
        if (message.effectiveDateEnd !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.effectiveDateEnd);
        /* repeated string effective_flags = 9; */
        for (let i = 0; i < message.effectiveFlags.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.effectiveFlags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.ModelPointsMultiplier
 */
export const ModelPointsMultiplier = new ModelPointsMultiplier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsGetLeagueConfigRequest$Type extends MessageType<PointsGetLeagueConfigRequest> {
    constructor() {
        super("points_svc.PointsGetLeagueConfigRequest", []);
    }
    create(value?: PartialMessage<PointsGetLeagueConfigRequest>): PointsGetLeagueConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsGetLeagueConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsGetLeagueConfigRequest): PointsGetLeagueConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsGetLeagueConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsGetLeagueConfigRequest
 */
export const PointsGetLeagueConfigRequest = new PointsGetLeagueConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsGetLeagueConfigResponse$Type extends MessageType<PointsGetLeagueConfigResponse> {
    constructor() {
        super("points_svc.PointsGetLeagueConfigResponse", [
            { no: 1, name: "white_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "orange_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "blue_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "purple_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "black_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsGetLeagueConfigResponse>): PointsGetLeagueConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.whiteThreshold = 0;
        message.orangeThreshold = 0;
        message.blueThreshold = 0;
        message.purpleThreshold = 0;
        message.blackThreshold = 0;
        message.updatedBy = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PointsGetLeagueConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsGetLeagueConfigResponse): PointsGetLeagueConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double white_threshold */ 1:
                    message.whiteThreshold = reader.double();
                    break;
                case /* double orange_threshold */ 2:
                    message.orangeThreshold = reader.double();
                    break;
                case /* double blue_threshold */ 3:
                    message.blueThreshold = reader.double();
                    break;
                case /* double purple_threshold */ 4:
                    message.purpleThreshold = reader.double();
                    break;
                case /* double black_threshold */ 5:
                    message.blackThreshold = reader.double();
                    break;
                case /* string updated_by */ 6:
                    message.updatedBy = reader.string();
                    break;
                case /* string updated_at */ 7:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsGetLeagueConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double white_threshold = 1; */
        if (message.whiteThreshold !== 0)
            writer.tag(1, WireType.Bit64).double(message.whiteThreshold);
        /* double orange_threshold = 2; */
        if (message.orangeThreshold !== 0)
            writer.tag(2, WireType.Bit64).double(message.orangeThreshold);
        /* double blue_threshold = 3; */
        if (message.blueThreshold !== 0)
            writer.tag(3, WireType.Bit64).double(message.blueThreshold);
        /* double purple_threshold = 4; */
        if (message.purpleThreshold !== 0)
            writer.tag(4, WireType.Bit64).double(message.purpleThreshold);
        /* double black_threshold = 5; */
        if (message.blackThreshold !== 0)
            writer.tag(5, WireType.Bit64).double(message.blackThreshold);
        /* string updated_by = 6; */
        if (message.updatedBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.updatedBy);
        /* string updated_at = 7; */
        if (message.updatedAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsGetLeagueConfigResponse
 */
export const PointsGetLeagueConfigResponse = new PointsGetLeagueConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsSetLeagueConfigRequest$Type extends MessageType<PointsSetLeagueConfigRequest> {
    constructor() {
        super("points_svc.PointsSetLeagueConfigRequest", [
            { no: 1, name: "white_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "orange_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "blue_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "purple_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "black_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<PointsSetLeagueConfigRequest>): PointsSetLeagueConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.whiteThreshold = 0;
        message.orangeThreshold = 0;
        message.blueThreshold = 0;
        message.purpleThreshold = 0;
        message.blackThreshold = 0;
        if (value !== undefined)
            reflectionMergePartial<PointsSetLeagueConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsSetLeagueConfigRequest): PointsSetLeagueConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double white_threshold */ 1:
                    message.whiteThreshold = reader.double();
                    break;
                case /* double orange_threshold */ 2:
                    message.orangeThreshold = reader.double();
                    break;
                case /* double blue_threshold */ 3:
                    message.blueThreshold = reader.double();
                    break;
                case /* double purple_threshold */ 4:
                    message.purpleThreshold = reader.double();
                    break;
                case /* double black_threshold */ 5:
                    message.blackThreshold = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsSetLeagueConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double white_threshold = 1; */
        if (message.whiteThreshold !== 0)
            writer.tag(1, WireType.Bit64).double(message.whiteThreshold);
        /* double orange_threshold = 2; */
        if (message.orangeThreshold !== 0)
            writer.tag(2, WireType.Bit64).double(message.orangeThreshold);
        /* double blue_threshold = 3; */
        if (message.blueThreshold !== 0)
            writer.tag(3, WireType.Bit64).double(message.blueThreshold);
        /* double purple_threshold = 4; */
        if (message.purpleThreshold !== 0)
            writer.tag(4, WireType.Bit64).double(message.purpleThreshold);
        /* double black_threshold = 5; */
        if (message.blackThreshold !== 0)
            writer.tag(5, WireType.Bit64).double(message.blackThreshold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsSetLeagueConfigRequest
 */
export const PointsSetLeagueConfigRequest = new PointsSetLeagueConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsSetLeagueConfigResponse$Type extends MessageType<PointsSetLeagueConfigResponse> {
    constructor() {
        super("points_svc.PointsSetLeagueConfigResponse", [
            { no: 1, name: "white_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "orange_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "blue_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "purple_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "black_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsSetLeagueConfigResponse>): PointsSetLeagueConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.whiteThreshold = 0;
        message.orangeThreshold = 0;
        message.blueThreshold = 0;
        message.purpleThreshold = 0;
        message.blackThreshold = 0;
        message.updatedBy = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PointsSetLeagueConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsSetLeagueConfigResponse): PointsSetLeagueConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double white_threshold */ 1:
                    message.whiteThreshold = reader.double();
                    break;
                case /* double orange_threshold */ 2:
                    message.orangeThreshold = reader.double();
                    break;
                case /* double blue_threshold */ 3:
                    message.blueThreshold = reader.double();
                    break;
                case /* double purple_threshold */ 4:
                    message.purpleThreshold = reader.double();
                    break;
                case /* double black_threshold */ 5:
                    message.blackThreshold = reader.double();
                    break;
                case /* string updated_by */ 6:
                    message.updatedBy = reader.string();
                    break;
                case /* string updated_at */ 7:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsSetLeagueConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double white_threshold = 1; */
        if (message.whiteThreshold !== 0)
            writer.tag(1, WireType.Bit64).double(message.whiteThreshold);
        /* double orange_threshold = 2; */
        if (message.orangeThreshold !== 0)
            writer.tag(2, WireType.Bit64).double(message.orangeThreshold);
        /* double blue_threshold = 3; */
        if (message.blueThreshold !== 0)
            writer.tag(3, WireType.Bit64).double(message.blueThreshold);
        /* double purple_threshold = 4; */
        if (message.purpleThreshold !== 0)
            writer.tag(4, WireType.Bit64).double(message.purpleThreshold);
        /* double black_threshold = 5; */
        if (message.blackThreshold !== 0)
            writer.tag(5, WireType.Bit64).double(message.blackThreshold);
        /* string updated_by = 6; */
        if (message.updatedBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.updatedBy);
        /* string updated_at = 7; */
        if (message.updatedAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsSetLeagueConfigResponse
 */
export const PointsSetLeagueConfigResponse = new PointsSetLeagueConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsGetEmissionConfigRequest$Type extends MessageType<PointsGetEmissionConfigRequest> {
    constructor() {
        super("points_svc.PointsGetEmissionConfigRequest", []);
    }
    create(value?: PartialMessage<PointsGetEmissionConfigRequest>): PointsGetEmissionConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsGetEmissionConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsGetEmissionConfigRequest): PointsGetEmissionConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsGetEmissionConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsGetEmissionConfigRequest
 */
export const PointsGetEmissionConfigRequest = new PointsGetEmissionConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsGetEmissionConfigResponse$Type extends MessageType<PointsGetEmissionConfigResponse> {
    constructor() {
        super("points_svc.PointsGetEmissionConfigResponse", [
            { no: 1, name: "unit_volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "volume_tiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelVolumeTierConfig },
            { no: 3, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsGetEmissionConfigResponse>): PointsGetEmissionConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unitVolume = 0;
        message.volumeTiers = [];
        message.updatedBy = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PointsGetEmissionConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsGetEmissionConfigResponse): PointsGetEmissionConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double unit_volume */ 1:
                    message.unitVolume = reader.double();
                    break;
                case /* repeated points_svc.ModelVolumeTierConfig volume_tiers */ 2:
                    message.volumeTiers.push(ModelVolumeTierConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string updated_by */ 3:
                    message.updatedBy = reader.string();
                    break;
                case /* string updated_at */ 4:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsGetEmissionConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double unit_volume = 1; */
        if (message.unitVolume !== 0)
            writer.tag(1, WireType.Bit64).double(message.unitVolume);
        /* repeated points_svc.ModelVolumeTierConfig volume_tiers = 2; */
        for (let i = 0; i < message.volumeTiers.length; i++)
            ModelVolumeTierConfig.internalBinaryWrite(message.volumeTiers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string updated_by = 3; */
        if (message.updatedBy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updatedBy);
        /* string updated_at = 4; */
        if (message.updatedAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsGetEmissionConfigResponse
 */
export const PointsGetEmissionConfigResponse = new PointsGetEmissionConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelVolumeTierConfig$Type extends MessageType<ModelVolumeTierConfig> {
    constructor() {
        super("points_svc.ModelVolumeTierConfig", [
            { no: 1, name: "upper_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "taker_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "maker_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ModelVolumeTierConfig>): ModelVolumeTierConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upperThreshold = 0;
        message.takerRate = 0;
        message.makerRate = 0;
        if (value !== undefined)
            reflectionMergePartial<ModelVolumeTierConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModelVolumeTierConfig): ModelVolumeTierConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double upper_threshold */ 1:
                    message.upperThreshold = reader.double();
                    break;
                case /* double taker_rate */ 2:
                    message.takerRate = reader.double();
                    break;
                case /* double maker_rate */ 3:
                    message.makerRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModelVolumeTierConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double upper_threshold = 1; */
        if (message.upperThreshold !== 0)
            writer.tag(1, WireType.Bit64).double(message.upperThreshold);
        /* double taker_rate = 2; */
        if (message.takerRate !== 0)
            writer.tag(2, WireType.Bit64).double(message.takerRate);
        /* double maker_rate = 3; */
        if (message.makerRate !== 0)
            writer.tag(3, WireType.Bit64).double(message.makerRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.ModelVolumeTierConfig
 */
export const ModelVolumeTierConfig = new ModelVolumeTierConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsSetEmissionConfigRequest$Type extends MessageType<PointsSetEmissionConfigRequest> {
    constructor() {
        super("points_svc.PointsSetEmissionConfigRequest", [
            { no: 1, name: "unit_volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "volume_tiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelVolumeTierConfig }
        ]);
    }
    create(value?: PartialMessage<PointsSetEmissionConfigRequest>): PointsSetEmissionConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unitVolume = 0;
        message.volumeTiers = [];
        if (value !== undefined)
            reflectionMergePartial<PointsSetEmissionConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsSetEmissionConfigRequest): PointsSetEmissionConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double unit_volume */ 1:
                    message.unitVolume = reader.double();
                    break;
                case /* repeated points_svc.ModelVolumeTierConfig volume_tiers */ 2:
                    message.volumeTiers.push(ModelVolumeTierConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsSetEmissionConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double unit_volume = 1; */
        if (message.unitVolume !== 0)
            writer.tag(1, WireType.Bit64).double(message.unitVolume);
        /* repeated points_svc.ModelVolumeTierConfig volume_tiers = 2; */
        for (let i = 0; i < message.volumeTiers.length; i++)
            ModelVolumeTierConfig.internalBinaryWrite(message.volumeTiers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsSetEmissionConfigRequest
 */
export const PointsSetEmissionConfigRequest = new PointsSetEmissionConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsSetEmissionConfigResponse$Type extends MessageType<PointsSetEmissionConfigResponse> {
    constructor() {
        super("points_svc.PointsSetEmissionConfigResponse", [
            { no: 1, name: "unit_volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "volume_tiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelVolumeTierConfig },
            { no: 3, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsSetEmissionConfigResponse>): PointsSetEmissionConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unitVolume = 0;
        message.volumeTiers = [];
        message.updatedBy = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PointsSetEmissionConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsSetEmissionConfigResponse): PointsSetEmissionConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double unit_volume */ 1:
                    message.unitVolume = reader.double();
                    break;
                case /* repeated points_svc.ModelVolumeTierConfig volume_tiers */ 2:
                    message.volumeTiers.push(ModelVolumeTierConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string updated_by */ 3:
                    message.updatedBy = reader.string();
                    break;
                case /* string updated_at */ 4:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsSetEmissionConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double unit_volume = 1; */
        if (message.unitVolume !== 0)
            writer.tag(1, WireType.Bit64).double(message.unitVolume);
        /* repeated points_svc.ModelVolumeTierConfig volume_tiers = 2; */
        for (let i = 0; i < message.volumeTiers.length; i++)
            ModelVolumeTierConfig.internalBinaryWrite(message.volumeTiers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string updated_by = 3; */
        if (message.updatedBy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updatedBy);
        /* string updated_at = 4; */
        if (message.updatedAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsSetEmissionConfigResponse
 */
export const PointsSetEmissionConfigResponse = new PointsSetEmissionConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsListBanConfigsRequest$Type extends MessageType<PointsListBanConfigsRequest> {
    constructor() {
        super("points_svc.PointsListBanConfigsRequest", []);
    }
    create(value?: PartialMessage<PointsListBanConfigsRequest>): PointsListBanConfigsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsListBanConfigsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsListBanConfigsRequest): PointsListBanConfigsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsListBanConfigsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsListBanConfigsRequest
 */
export const PointsListBanConfigsRequest = new PointsListBanConfigsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BanConfigCollection$Type extends MessageType<BanConfigCollection> {
    constructor() {
        super("points_svc.BanConfigCollection", [
            { no: 1, name: "bans", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BanConfig }
        ]);
    }
    create(value?: PartialMessage<BanConfigCollection>): BanConfigCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bans = [];
        if (value !== undefined)
            reflectionMergePartial<BanConfigCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BanConfigCollection): BanConfigCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated points_svc.BanConfig bans */ 1:
                    message.bans.push(BanConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BanConfigCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated points_svc.BanConfig bans = 1; */
        for (let i = 0; i < message.bans.length; i++)
            BanConfig.internalBinaryWrite(message.bans[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.BanConfigCollection
 */
export const BanConfigCollection = new BanConfigCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BanConfig$Type extends MessageType<BanConfig> {
    constructor() {
        super("points_svc.BanConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "eth_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BanConfig>): BanConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.label = "";
        message.accountAddress = "";
        message.ethAddress = "";
        message.createdBy = "";
        message.createdAt = "";
        if (value !== undefined)
            reflectionMergePartial<BanConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BanConfig): BanConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string account_address */ 3:
                    message.accountAddress = reader.string();
                    break;
                case /* string eth_address */ 4:
                    message.ethAddress = reader.string();
                    break;
                case /* string created_by */ 5:
                    message.createdBy = reader.string();
                    break;
                case /* string created_at */ 6:
                    message.createdAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BanConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string account_address = 3; */
        if (message.accountAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
        /* string eth_address = 4; */
        if (message.ethAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ethAddress);
        /* string created_by = 5; */
        if (message.createdBy !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.createdBy);
        /* string created_at = 6; */
        if (message.createdAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.BanConfig
 */
export const BanConfig = new BanConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCreateBanConfigRequest$Type extends MessageType<PointsCreateBanConfigRequest> {
    constructor() {
        super("points_svc.PointsCreateBanConfigRequest", [
            { no: 1, name: "account_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eth_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "effective_from", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsCreateBanConfigRequest>): PointsCreateBanConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddresses = [];
        message.ethAddresses = [];
        message.label = "";
        message.effectiveFrom = 0n;
        if (value !== undefined)
            reflectionMergePartial<PointsCreateBanConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCreateBanConfigRequest): PointsCreateBanConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string account_addresses */ 1:
                    message.accountAddresses.push(reader.string());
                    break;
                case /* repeated string eth_addresses */ 2:
                    message.ethAddresses.push(reader.string());
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                case /* uint64 effective_from */ 4:
                    message.effectiveFrom = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCreateBanConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string account_addresses = 1; */
        for (let i = 0; i < message.accountAddresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddresses[i]);
        /* repeated string eth_addresses = 2; */
        for (let i = 0; i < message.ethAddresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.ethAddresses[i]);
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        /* uint64 effective_from = 4; */
        if (message.effectiveFrom !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.effectiveFrom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCreateBanConfigRequest
 */
export const PointsCreateBanConfigRequest = new PointsCreateBanConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsDeleteBanConfigRequest$Type extends MessageType<PointsDeleteBanConfigRequest> {
    constructor() {
        super("points_svc.PointsDeleteBanConfigRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsDeleteBanConfigRequest>): PointsDeleteBanConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<PointsDeleteBanConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsDeleteBanConfigRequest): PointsDeleteBanConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsDeleteBanConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsDeleteBanConfigRequest
 */
export const PointsDeleteBanConfigRequest = new PointsDeleteBanConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsDeleteBanConfigResponse$Type extends MessageType<PointsDeleteBanConfigResponse> {
    constructor() {
        super("points_svc.PointsDeleteBanConfigResponse", []);
    }
    create(value?: PartialMessage<PointsDeleteBanConfigResponse>): PointsDeleteBanConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsDeleteBanConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsDeleteBanConfigResponse): PointsDeleteBanConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsDeleteBanConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsDeleteBanConfigResponse
 */
export const PointsDeleteBanConfigResponse = new PointsDeleteBanConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsListMultiplierConfigsRequest$Type extends MessageType<PointsListMultiplierConfigsRequest> {
    constructor() {
        super("points_svc.PointsListMultiplierConfigsRequest", []);
    }
    create(value?: PartialMessage<PointsListMultiplierConfigsRequest>): PointsListMultiplierConfigsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsListMultiplierConfigsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsListMultiplierConfigsRequest): PointsListMultiplierConfigsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsListMultiplierConfigsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsListMultiplierConfigsRequest
 */
export const PointsListMultiplierConfigsRequest = new PointsListMultiplierConfigsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsMultiplierConfigCollection$Type extends MessageType<PointsMultiplierConfigCollection> {
    constructor() {
        super("points_svc.PointsMultiplierConfigCollection", [
            { no: 1, name: "multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PointsMultiplierConfig }
        ]);
    }
    create(value?: PartialMessage<PointsMultiplierConfigCollection>): PointsMultiplierConfigCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.multipliers = [];
        if (value !== undefined)
            reflectionMergePartial<PointsMultiplierConfigCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsMultiplierConfigCollection): PointsMultiplierConfigCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated points_svc.PointsMultiplierConfig multipliers */ 1:
                    message.multipliers.push(PointsMultiplierConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsMultiplierConfigCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated points_svc.PointsMultiplierConfig multipliers = 1; */
        for (let i = 0; i < message.multipliers.length; i++)
            PointsMultiplierConfig.internalBinaryWrite(message.multipliers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsMultiplierConfigCollection
 */
export const PointsMultiplierConfigCollection = new PointsMultiplierConfigCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsMultiplierConfig$Type extends MessageType<PointsMultiplierConfig> {
    constructor() {
        super("points_svc.PointsMultiplierConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "multiplier", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "affected_users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "affected_markets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "all_markets_except", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "effective_date_start", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "effective_date_end", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "effective_flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "enforce_recalculate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsMultiplierConfig>): PointsMultiplierConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.label = "";
        message.multiplier = 0;
        message.affectedUsers = [];
        message.affectedMarkets = [];
        message.allMarketsExcept = [];
        message.effectiveFlags = [];
        message.enforceRecalculate = false;
        message.createdBy = "";
        message.createdAt = "";
        message.updatedBy = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PointsMultiplierConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsMultiplierConfig): PointsMultiplierConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* double multiplier */ 3:
                    message.multiplier = reader.double();
                    break;
                case /* repeated string affected_users */ 4:
                    message.affectedUsers.push(reader.string());
                    break;
                case /* repeated string affected_markets */ 5:
                    message.affectedMarkets.push(reader.string());
                    break;
                case /* repeated string all_markets_except */ 6:
                    message.allMarketsExcept.push(reader.string());
                    break;
                case /* optional uint64 effective_date_start */ 7:
                    message.effectiveDateStart = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 effective_date_end */ 8:
                    message.effectiveDateEnd = reader.uint64().toBigInt();
                    break;
                case /* repeated string effective_flags */ 9:
                    message.effectiveFlags.push(reader.string());
                    break;
                case /* bool enforce_recalculate */ 10:
                    message.enforceRecalculate = reader.bool();
                    break;
                case /* string created_by */ 11:
                    message.createdBy = reader.string();
                    break;
                case /* string created_at */ 12:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_by */ 13:
                    message.updatedBy = reader.string();
                    break;
                case /* string updated_at */ 14:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsMultiplierConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* double multiplier = 3; */
        if (message.multiplier !== 0)
            writer.tag(3, WireType.Bit64).double(message.multiplier);
        /* repeated string affected_users = 4; */
        for (let i = 0; i < message.affectedUsers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.affectedUsers[i]);
        /* repeated string affected_markets = 5; */
        for (let i = 0; i < message.affectedMarkets.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.affectedMarkets[i]);
        /* repeated string all_markets_except = 6; */
        for (let i = 0; i < message.allMarketsExcept.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
        /* optional uint64 effective_date_start = 7; */
        if (message.effectiveDateStart !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.effectiveDateStart);
        /* optional uint64 effective_date_end = 8; */
        if (message.effectiveDateEnd !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.effectiveDateEnd);
        /* repeated string effective_flags = 9; */
        for (let i = 0; i < message.effectiveFlags.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.effectiveFlags[i]);
        /* bool enforce_recalculate = 10; */
        if (message.enforceRecalculate !== false)
            writer.tag(10, WireType.Varint).bool(message.enforceRecalculate);
        /* string created_by = 11; */
        if (message.createdBy !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.createdBy);
        /* string created_at = 12; */
        if (message.createdAt !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_by = 13; */
        if (message.updatedBy !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.updatedBy);
        /* string updated_at = 14; */
        if (message.updatedAt !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsMultiplierConfig
 */
export const PointsMultiplierConfig = new PointsMultiplierConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCreateMultiplierConfigRequest$Type extends MessageType<PointsCreateMultiplierConfigRequest> {
    constructor() {
        super("points_svc.PointsCreateMultiplierConfigRequest", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "all_markets_except", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "multiplier", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "effective_from", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "effective_until", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "enforce_recalculate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PointsCreateMultiplierConfigRequest>): PointsCreateMultiplierConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        message.allMarketsExcept = [];
        message.accountAddresses = [];
        message.flags = [];
        message.multiplier = 0;
        message.label = "";
        message.enforceRecalculate = false;
        if (value !== undefined)
            reflectionMergePartial<PointsCreateMultiplierConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCreateMultiplierConfigRequest): PointsCreateMultiplierConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                case /* repeated string all_markets_except */ 2:
                    message.allMarketsExcept.push(reader.string());
                    break;
                case /* repeated string account_addresses */ 3:
                    message.accountAddresses.push(reader.string());
                    break;
                case /* repeated string flags */ 4:
                    message.flags.push(reader.string());
                    break;
                case /* double multiplier */ 5:
                    message.multiplier = reader.double();
                    break;
                case /* string label */ 6:
                    message.label = reader.string();
                    break;
                case /* optional sint64 effective_from */ 7:
                    message.effectiveFrom = reader.sint64().toBigInt();
                    break;
                case /* optional sint64 effective_until */ 8:
                    message.effectiveUntil = reader.sint64().toBigInt();
                    break;
                case /* bool enforce_recalculate */ 9:
                    message.enforceRecalculate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCreateMultiplierConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        /* repeated string all_markets_except = 2; */
        for (let i = 0; i < message.allMarketsExcept.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
        /* repeated string account_addresses = 3; */
        for (let i = 0; i < message.accountAddresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.accountAddresses[i]);
        /* repeated string flags = 4; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.flags[i]);
        /* double multiplier = 5; */
        if (message.multiplier !== 0)
            writer.tag(5, WireType.Bit64).double(message.multiplier);
        /* string label = 6; */
        if (message.label !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.label);
        /* optional sint64 effective_from = 7; */
        if (message.effectiveFrom !== undefined)
            writer.tag(7, WireType.Varint).sint64(message.effectiveFrom);
        /* optional sint64 effective_until = 8; */
        if (message.effectiveUntil !== undefined)
            writer.tag(8, WireType.Varint).sint64(message.effectiveUntil);
        /* bool enforce_recalculate = 9; */
        if (message.enforceRecalculate !== false)
            writer.tag(9, WireType.Varint).bool(message.enforceRecalculate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCreateMultiplierConfigRequest
 */
export const PointsCreateMultiplierConfigRequest = new PointsCreateMultiplierConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCreateMultiplierConfigResponse$Type extends MessageType<PointsCreateMultiplierConfigResponse> {
    constructor() {
        super("points_svc.PointsCreateMultiplierConfigResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "multiplier", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "affected_users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "affected_markets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "all_markets_except", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "effective_date_start", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "effective_date_end", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "effective_flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "enforce_recalculate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsCreateMultiplierConfigResponse>): PointsCreateMultiplierConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.label = "";
        message.multiplier = 0;
        message.affectedUsers = [];
        message.affectedMarkets = [];
        message.allMarketsExcept = [];
        message.effectiveFlags = [];
        message.enforceRecalculate = false;
        message.createdBy = "";
        message.createdAt = "";
        message.updatedBy = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PointsCreateMultiplierConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCreateMultiplierConfigResponse): PointsCreateMultiplierConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* double multiplier */ 3:
                    message.multiplier = reader.double();
                    break;
                case /* repeated string affected_users */ 4:
                    message.affectedUsers.push(reader.string());
                    break;
                case /* repeated string affected_markets */ 5:
                    message.affectedMarkets.push(reader.string());
                    break;
                case /* repeated string all_markets_except */ 6:
                    message.allMarketsExcept.push(reader.string());
                    break;
                case /* optional uint64 effective_date_start */ 7:
                    message.effectiveDateStart = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 effective_date_end */ 8:
                    message.effectiveDateEnd = reader.uint64().toBigInt();
                    break;
                case /* repeated string effective_flags */ 9:
                    message.effectiveFlags.push(reader.string());
                    break;
                case /* bool enforce_recalculate */ 10:
                    message.enforceRecalculate = reader.bool();
                    break;
                case /* string created_by */ 11:
                    message.createdBy = reader.string();
                    break;
                case /* string created_at */ 12:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_by */ 13:
                    message.updatedBy = reader.string();
                    break;
                case /* string updated_at */ 14:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCreateMultiplierConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* double multiplier = 3; */
        if (message.multiplier !== 0)
            writer.tag(3, WireType.Bit64).double(message.multiplier);
        /* repeated string affected_users = 4; */
        for (let i = 0; i < message.affectedUsers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.affectedUsers[i]);
        /* repeated string affected_markets = 5; */
        for (let i = 0; i < message.affectedMarkets.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.affectedMarkets[i]);
        /* repeated string all_markets_except = 6; */
        for (let i = 0; i < message.allMarketsExcept.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.allMarketsExcept[i]);
        /* optional uint64 effective_date_start = 7; */
        if (message.effectiveDateStart !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.effectiveDateStart);
        /* optional uint64 effective_date_end = 8; */
        if (message.effectiveDateEnd !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.effectiveDateEnd);
        /* repeated string effective_flags = 9; */
        for (let i = 0; i < message.effectiveFlags.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.effectiveFlags[i]);
        /* bool enforce_recalculate = 10; */
        if (message.enforceRecalculate !== false)
            writer.tag(10, WireType.Varint).bool(message.enforceRecalculate);
        /* string created_by = 11; */
        if (message.createdBy !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.createdBy);
        /* string created_at = 12; */
        if (message.createdAt !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_by = 13; */
        if (message.updatedBy !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.updatedBy);
        /* string updated_at = 14; */
        if (message.updatedAt !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCreateMultiplierConfigResponse
 */
export const PointsCreateMultiplierConfigResponse = new PointsCreateMultiplierConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsDeleteMultiplierConfigRequest$Type extends MessageType<PointsDeleteMultiplierConfigRequest> {
    constructor() {
        super("points_svc.PointsDeleteMultiplierConfigRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsDeleteMultiplierConfigRequest>): PointsDeleteMultiplierConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<PointsDeleteMultiplierConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsDeleteMultiplierConfigRequest): PointsDeleteMultiplierConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsDeleteMultiplierConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsDeleteMultiplierConfigRequest
 */
export const PointsDeleteMultiplierConfigRequest = new PointsDeleteMultiplierConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsDeleteMultiplierConfigResponse$Type extends MessageType<PointsDeleteMultiplierConfigResponse> {
    constructor() {
        super("points_svc.PointsDeleteMultiplierConfigResponse", []);
    }
    create(value?: PartialMessage<PointsDeleteMultiplierConfigResponse>): PointsDeleteMultiplierConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsDeleteMultiplierConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsDeleteMultiplierConfigResponse): PointsDeleteMultiplierConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsDeleteMultiplierConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsDeleteMultiplierConfigResponse
 */
export const PointsDeleteMultiplierConfigResponse = new PointsDeleteMultiplierConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsListAdminCorrectionsRequest$Type extends MessageType<PointsListAdminCorrectionsRequest> {
    constructor() {
        super("points_svc.PointsListAdminCorrectionsRequest", [
            { no: 1, name: "correction_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsListAdminCorrectionsRequest>): PointsListAdminCorrectionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsListAdminCorrectionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsListAdminCorrectionsRequest): PointsListAdminCorrectionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string correction_type */ 1:
                    message.correctionType = reader.string();
                    break;
                case /* optional string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsListAdminCorrectionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string correction_type = 1; */
        if (message.correctionType !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.correctionType);
        /* optional string account_address = 2; */
        if (message.accountAddress !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsListAdminCorrectionsRequest
 */
export const PointsListAdminCorrectionsRequest = new PointsListAdminCorrectionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdminPointsCorrectionCollection$Type extends MessageType<AdminPointsCorrectionCollection> {
    constructor() {
        super("points_svc.AdminPointsCorrectionCollection", [
            { no: 1, name: "corrections", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdminPointsCorrection }
        ]);
    }
    create(value?: PartialMessage<AdminPointsCorrectionCollection>): AdminPointsCorrectionCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.corrections = [];
        if (value !== undefined)
            reflectionMergePartial<AdminPointsCorrectionCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdminPointsCorrectionCollection): AdminPointsCorrectionCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated points_svc.AdminPointsCorrection corrections */ 1:
                    message.corrections.push(AdminPointsCorrection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdminPointsCorrectionCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated points_svc.AdminPointsCorrection corrections = 1; */
        for (let i = 0; i < message.corrections.length; i++)
            AdminPointsCorrection.internalBinaryWrite(message.corrections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.AdminPointsCorrectionCollection
 */
export const AdminPointsCorrectionCollection = new AdminPointsCorrectionCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdminPointsCorrection$Type extends MessageType<AdminPointsCorrection> {
    constructor() {
        super("points_svc.AdminPointsCorrection", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "correction_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "effective_from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AdminPointsCorrection>): AdminPointsCorrection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.label = "";
        message.accountAddress = "";
        message.correctionType = "";
        message.value = 0;
        message.effectiveFrom = "";
        message.createdBy = "";
        message.createdAt = "";
        if (value !== undefined)
            reflectionMergePartial<AdminPointsCorrection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdminPointsCorrection): AdminPointsCorrection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string account_address */ 3:
                    message.accountAddress = reader.string();
                    break;
                case /* string correction_type */ 4:
                    message.correctionType = reader.string();
                    break;
                case /* double value */ 5:
                    message.value = reader.double();
                    break;
                case /* string effective_from */ 6:
                    message.effectiveFrom = reader.string();
                    break;
                case /* string created_by */ 7:
                    message.createdBy = reader.string();
                    break;
                case /* string created_at */ 8:
                    message.createdAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdminPointsCorrection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string account_address = 3; */
        if (message.accountAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
        /* string correction_type = 4; */
        if (message.correctionType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.correctionType);
        /* double value = 5; */
        if (message.value !== 0)
            writer.tag(5, WireType.Bit64).double(message.value);
        /* string effective_from = 6; */
        if (message.effectiveFrom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.effectiveFrom);
        /* string created_by = 7; */
        if (message.createdBy !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdBy);
        /* string created_at = 8; */
        if (message.createdAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.AdminPointsCorrection
 */
export const AdminPointsCorrection = new AdminPointsCorrection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCreateAdminCorrectionRequest$Type extends MessageType<PointsCreateAdminCorrectionRequest> {
    constructor() {
        super("points_svc.PointsCreateAdminCorrectionRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "correction_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "effective_from", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsCreateAdminCorrectionRequest>): PointsCreateAdminCorrectionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.correctionType = "";
        message.value = 0;
        message.label = "";
        message.effectiveFrom = 0n;
        if (value !== undefined)
            reflectionMergePartial<PointsCreateAdminCorrectionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCreateAdminCorrectionRequest): PointsCreateAdminCorrectionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* string correction_type */ 2:
                    message.correctionType = reader.string();
                    break;
                case /* double value */ 3:
                    message.value = reader.double();
                    break;
                case /* string label */ 4:
                    message.label = reader.string();
                    break;
                case /* sint64 effective_from */ 5:
                    message.effectiveFrom = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCreateAdminCorrectionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* string correction_type = 2; */
        if (message.correctionType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.correctionType);
        /* double value = 3; */
        if (message.value !== 0)
            writer.tag(3, WireType.Bit64).double(message.value);
        /* string label = 4; */
        if (message.label !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.label);
        /* sint64 effective_from = 5; */
        if (message.effectiveFrom !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.effectiveFrom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCreateAdminCorrectionRequest
 */
export const PointsCreateAdminCorrectionRequest = new PointsCreateAdminCorrectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCreateAdminCorrectionResponse$Type extends MessageType<PointsCreateAdminCorrectionResponse> {
    constructor() {
        super("points_svc.PointsCreateAdminCorrectionResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "correction_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "effective_from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsCreateAdminCorrectionResponse>): PointsCreateAdminCorrectionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.label = "";
        message.accountAddress = "";
        message.correctionType = "";
        message.value = 0;
        message.effectiveFrom = "";
        message.createdBy = "";
        message.createdAt = "";
        if (value !== undefined)
            reflectionMergePartial<PointsCreateAdminCorrectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCreateAdminCorrectionResponse): PointsCreateAdminCorrectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string account_address */ 3:
                    message.accountAddress = reader.string();
                    break;
                case /* string correction_type */ 4:
                    message.correctionType = reader.string();
                    break;
                case /* double value */ 5:
                    message.value = reader.double();
                    break;
                case /* string effective_from */ 6:
                    message.effectiveFrom = reader.string();
                    break;
                case /* string created_by */ 7:
                    message.createdBy = reader.string();
                    break;
                case /* string created_at */ 8:
                    message.createdAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCreateAdminCorrectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string account_address = 3; */
        if (message.accountAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
        /* string correction_type = 4; */
        if (message.correctionType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.correctionType);
        /* double value = 5; */
        if (message.value !== 0)
            writer.tag(5, WireType.Bit64).double(message.value);
        /* string effective_from = 6; */
        if (message.effectiveFrom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.effectiveFrom);
        /* string created_by = 7; */
        if (message.createdBy !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdBy);
        /* string created_at = 8; */
        if (message.createdAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCreateAdminCorrectionResponse
 */
export const PointsCreateAdminCorrectionResponse = new PointsCreateAdminCorrectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCreateAdminCorrectionsBatchRequest$Type extends MessageType<PointsCreateAdminCorrectionsBatchRequest> {
    constructor() {
        super("points_svc.PointsCreateAdminCorrectionsBatchRequest", [
            { no: 1, name: "account_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "correction_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "values", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "effective_from", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsCreateAdminCorrectionsBatchRequest>): PointsCreateAdminCorrectionsBatchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddresses = [];
        message.correctionType = "";
        message.values = [];
        message.label = "";
        message.effectiveFrom = 0n;
        if (value !== undefined)
            reflectionMergePartial<PointsCreateAdminCorrectionsBatchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCreateAdminCorrectionsBatchRequest): PointsCreateAdminCorrectionsBatchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string account_addresses */ 1:
                    message.accountAddresses.push(reader.string());
                    break;
                case /* string correction_type */ 2:
                    message.correctionType = reader.string();
                    break;
                case /* repeated double values */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.values.push(reader.double());
                    else
                        message.values.push(reader.double());
                    break;
                case /* string label */ 4:
                    message.label = reader.string();
                    break;
                case /* sint64 effective_from */ 5:
                    message.effectiveFrom = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCreateAdminCorrectionsBatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string account_addresses = 1; */
        for (let i = 0; i < message.accountAddresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddresses[i]);
        /* string correction_type = 2; */
        if (message.correctionType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.correctionType);
        /* repeated double values = 3; */
        if (message.values.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.values.length; i++)
                writer.double(message.values[i]);
            writer.join();
        }
        /* string label = 4; */
        if (message.label !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.label);
        /* sint64 effective_from = 5; */
        if (message.effectiveFrom !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.effectiveFrom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCreateAdminCorrectionsBatchRequest
 */
export const PointsCreateAdminCorrectionsBatchRequest = new PointsCreateAdminCorrectionsBatchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsDeleteAdminCorrectionRequest$Type extends MessageType<PointsDeleteAdminCorrectionRequest> {
    constructor() {
        super("points_svc.PointsDeleteAdminCorrectionRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PointsDeleteAdminCorrectionRequest>): PointsDeleteAdminCorrectionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<PointsDeleteAdminCorrectionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsDeleteAdminCorrectionRequest): PointsDeleteAdminCorrectionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsDeleteAdminCorrectionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsDeleteAdminCorrectionRequest
 */
export const PointsDeleteAdminCorrectionRequest = new PointsDeleteAdminCorrectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsDeleteAdminCorrectionResponse$Type extends MessageType<PointsDeleteAdminCorrectionResponse> {
    constructor() {
        super("points_svc.PointsDeleteAdminCorrectionResponse", []);
    }
    create(value?: PartialMessage<PointsDeleteAdminCorrectionResponse>): PointsDeleteAdminCorrectionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsDeleteAdminCorrectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsDeleteAdminCorrectionResponse): PointsDeleteAdminCorrectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsDeleteAdminCorrectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsDeleteAdminCorrectionResponse
 */
export const PointsDeleteAdminCorrectionResponse = new PointsDeleteAdminCorrectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsReprocessTradesAfterDateRequest$Type extends MessageType<PointsReprocessTradesAfterDateRequest> {
    constructor() {
        super("points_svc.PointsReprocessTradesAfterDateRequest", [
            { no: 1, name: "after_date", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsReprocessTradesAfterDateRequest>): PointsReprocessTradesAfterDateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.afterDate = 0n;
        if (value !== undefined)
            reflectionMergePartial<PointsReprocessTradesAfterDateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsReprocessTradesAfterDateRequest): PointsReprocessTradesAfterDateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 after_date */ 1:
                    message.afterDate = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsReprocessTradesAfterDateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 after_date = 1; */
        if (message.afterDate !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.afterDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsReprocessTradesAfterDateRequest
 */
export const PointsReprocessTradesAfterDateRequest = new PointsReprocessTradesAfterDateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsReprocessTradesAfterDateResponse$Type extends MessageType<PointsReprocessTradesAfterDateResponse> {
    constructor() {
        super("points_svc.PointsReprocessTradesAfterDateResponse", [
            { no: 1, name: "affected_count", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsReprocessTradesAfterDateResponse>): PointsReprocessTradesAfterDateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.affectedCount = 0n;
        if (value !== undefined)
            reflectionMergePartial<PointsReprocessTradesAfterDateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsReprocessTradesAfterDateResponse): PointsReprocessTradesAfterDateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 affected_count */ 1:
                    message.affectedCount = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsReprocessTradesAfterDateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 affected_count = 1; */
        if (message.affectedCount !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.affectedCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsReprocessTradesAfterDateResponse
 */
export const PointsReprocessTradesAfterDateResponse = new PointsReprocessTradesAfterDateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCaptureSeasonOneSnapshotAndBonusRequest$Type extends MessageType<PointsCaptureSeasonOneSnapshotAndBonusRequest> {
    constructor() {
        super("points_svc.PointsCaptureSeasonOneSnapshotAndBonusRequest", []);
    }
    create(value?: PartialMessage<PointsCaptureSeasonOneSnapshotAndBonusRequest>): PointsCaptureSeasonOneSnapshotAndBonusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsCaptureSeasonOneSnapshotAndBonusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCaptureSeasonOneSnapshotAndBonusRequest): PointsCaptureSeasonOneSnapshotAndBonusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCaptureSeasonOneSnapshotAndBonusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCaptureSeasonOneSnapshotAndBonusRequest
 */
export const PointsCaptureSeasonOneSnapshotAndBonusRequest = new PointsCaptureSeasonOneSnapshotAndBonusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsCaptureSeasonOneSnapshotAndBonusResponse$Type extends MessageType<PointsCaptureSeasonOneSnapshotAndBonusResponse> {
    constructor() {
        super("points_svc.PointsCaptureSeasonOneSnapshotAndBonusResponse", [
            { no: 1, name: "accounts_processed", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PointsCaptureSeasonOneSnapshotAndBonusResponse>): PointsCaptureSeasonOneSnapshotAndBonusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountsProcessed = 0n;
        if (value !== undefined)
            reflectionMergePartial<PointsCaptureSeasonOneSnapshotAndBonusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsCaptureSeasonOneSnapshotAndBonusResponse): PointsCaptureSeasonOneSnapshotAndBonusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 accounts_processed */ 1:
                    message.accountsProcessed = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsCaptureSeasonOneSnapshotAndBonusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 accounts_processed = 1; */
        if (message.accountsProcessed !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.accountsProcessed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsCaptureSeasonOneSnapshotAndBonusResponse
 */
export const PointsCaptureSeasonOneSnapshotAndBonusResponse = new PointsCaptureSeasonOneSnapshotAndBonusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsRecomputeDailyPointsSnapshotsRequest$Type extends MessageType<PointsRecomputeDailyPointsSnapshotsRequest> {
    constructor() {
        super("points_svc.PointsRecomputeDailyPointsSnapshotsRequest", []);
    }
    create(value?: PartialMessage<PointsRecomputeDailyPointsSnapshotsRequest>): PointsRecomputeDailyPointsSnapshotsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsRecomputeDailyPointsSnapshotsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsRecomputeDailyPointsSnapshotsRequest): PointsRecomputeDailyPointsSnapshotsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsRecomputeDailyPointsSnapshotsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsRecomputeDailyPointsSnapshotsRequest
 */
export const PointsRecomputeDailyPointsSnapshotsRequest = new PointsRecomputeDailyPointsSnapshotsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsRecomputeDailyPointsSnapshotsResponse$Type extends MessageType<PointsRecomputeDailyPointsSnapshotsResponse> {
    constructor() {
        super("points_svc.PointsRecomputeDailyPointsSnapshotsResponse", []);
    }
    create(value?: PartialMessage<PointsRecomputeDailyPointsSnapshotsResponse>): PointsRecomputeDailyPointsSnapshotsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PointsRecomputeDailyPointsSnapshotsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsRecomputeDailyPointsSnapshotsResponse): PointsRecomputeDailyPointsSnapshotsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsRecomputeDailyPointsSnapshotsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message points_svc.PointsRecomputeDailyPointsSnapshotsResponse
 */
export const PointsRecomputeDailyPointsSnapshotsResponse = new PointsRecomputeDailyPointsSnapshotsResponse$Type();
/**
 * @generated ServiceType for protobuf service points_svc.PointsSvc
 */
export const PointsSvc = new ServiceType("points_svc.PointsSvc", [
    { name: "PointsLatestForAccount", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsLatestForAccountRequest, O: PointsLatestForAccountResponse },
    { name: "PointsStatsDailyForAccount", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsStatsDailyForAccountRequest, O: HistoricalPointsStatsRowCollection },
    { name: "PointsStatsWeeklyForAccount", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsStatsWeeklyForAccountRequest, O: HistoricalPointsStatsRowCollection },
    { name: "PointsLeaderboard", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsLeaderboardRequest, O: LeaderboardPointsRowCollection },
    { name: "PointsSimulateAllocation", options: {}, I: PointsSimulateAllocationRequest, O: PointsSimulateAllocationResponse },
    { name: "PointsGetLeagueConfig", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsGetLeagueConfigRequest, O: PointsGetLeagueConfigResponse },
    { name: "PointsSetLeagueConfig", options: {}, I: PointsSetLeagueConfigRequest, O: PointsSetLeagueConfigResponse },
    { name: "PointsGetEmissionConfig", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsGetEmissionConfigRequest, O: PointsGetEmissionConfigResponse },
    { name: "PointsSetEmissionConfig", options: {}, I: PointsSetEmissionConfigRequest, O: PointsSetEmissionConfigResponse },
    { name: "PointsListBanConfigs", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsListBanConfigsRequest, O: BanConfigCollection },
    { name: "PointsCreateBanConfig", options: {}, I: PointsCreateBanConfigRequest, O: BanConfigCollection },
    { name: "PointsDeleteBanConfig", options: {}, I: PointsDeleteBanConfigRequest, O: PointsDeleteBanConfigResponse },
    { name: "PointsListMultiplierConfigs", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsListMultiplierConfigsRequest, O: PointsMultiplierConfigCollection },
    { name: "PointsCreateMultiplierConfig", options: {}, I: PointsCreateMultiplierConfigRequest, O: PointsCreateMultiplierConfigResponse },
    { name: "PointsDeleteMultiplierConfig", options: {}, I: PointsDeleteMultiplierConfigRequest, O: PointsDeleteMultiplierConfigResponse },
    { name: "PointsListAdminCorrections", options: { "danielvladco.protobuf.graphql.rpc": { type: "QUERY" } }, I: PointsListAdminCorrectionsRequest, O: AdminPointsCorrectionCollection },
    { name: "PointsCreateAdminCorrection", options: {}, I: PointsCreateAdminCorrectionRequest, O: PointsCreateAdminCorrectionResponse },
    { name: "PointsCreateAdminCorrectionsBatch", options: {}, I: PointsCreateAdminCorrectionsBatchRequest, O: AdminPointsCorrectionCollection },
    { name: "PointsDeleteAdminCorrection", options: {}, I: PointsDeleteAdminCorrectionRequest, O: PointsDeleteAdminCorrectionResponse },
    { name: "PointsReprocessTradesAfterDate", options: {}, I: PointsReprocessTradesAfterDateRequest, O: PointsReprocessTradesAfterDateResponse },
    { name: "PointsCaptureSeasonOneSnapshotAndBonus", options: {}, I: PointsCaptureSeasonOneSnapshotAndBonusRequest, O: PointsCaptureSeasonOneSnapshotAndBonusResponse },
    { name: "PointsRecomputeDailyPointsSnapshots", options: {}, I: PointsRecomputeDailyPointsSnapshotsRequest, O: PointsRecomputeDailyPointsSnapshotsResponse }
]);
