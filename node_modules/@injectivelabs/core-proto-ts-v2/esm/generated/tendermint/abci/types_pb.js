import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BlockIDFlag } from "../types/validator_pb.js";
import { PublicKey } from "../crypto/keys_pb.js";
import { ProofOps } from "../crypto/proof_pb.js";
import { ConsensusParams } from "../types/params_pb.js";
import { Timestamp } from "../../google/protobuf/timestamp_pb.js";
var ResponseOfferSnapshot_Result = /* @__PURE__ */ ((ResponseOfferSnapshot_Result2) => {
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
  return ResponseOfferSnapshot_Result2;
})(ResponseOfferSnapshot_Result || {});
var ResponseApplySnapshotChunk_Result = /* @__PURE__ */ ((ResponseApplySnapshotChunk_Result2) => {
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
  return ResponseApplySnapshotChunk_Result2;
})(ResponseApplySnapshotChunk_Result || {});
var ResponseProcessProposal_ProposalStatus = /* @__PURE__ */ ((ResponseProcessProposal_ProposalStatus2) => {
  ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNKNOWN"] = 0] = "UNKNOWN";
  ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["ACCEPT"] = 1] = "ACCEPT";
  ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["REJECT"] = 2] = "REJECT";
  return ResponseProcessProposal_ProposalStatus2;
})(ResponseProcessProposal_ProposalStatus || {});
var ResponseVerifyVoteExtension_VerifyStatus = /* @__PURE__ */ ((ResponseVerifyVoteExtension_VerifyStatus2) => {
  ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["UNKNOWN"] = 0] = "UNKNOWN";
  ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["ACCEPT"] = 1] = "ACCEPT";
  ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["REJECT"] = 2] = "REJECT";
  return ResponseVerifyVoteExtension_VerifyStatus2;
})(ResponseVerifyVoteExtension_VerifyStatus || {});
var CheckTxType = /* @__PURE__ */ ((CheckTxType2) => {
  CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
  CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
  return CheckTxType2;
})(CheckTxType || {});
var MisbehaviorType = /* @__PURE__ */ ((MisbehaviorType2) => {
  MisbehaviorType2[MisbehaviorType2["UNKNOWN"] = 0] = "UNKNOWN";
  MisbehaviorType2[MisbehaviorType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
  MisbehaviorType2[MisbehaviorType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
  return MisbehaviorType2;
})(MisbehaviorType || {});
class Request$Type extends MessageType {
  constructor() {
    super("tendermint.abci.Request", [
      { no: 1, name: "echo", kind: "message", oneof: "value", T: () => RequestEcho },
      { no: 2, name: "flush", kind: "message", oneof: "value", T: () => RequestFlush },
      { no: 3, name: "info", kind: "message", oneof: "value", T: () => RequestInfo },
      { no: 5, name: "init_chain", kind: "message", oneof: "value", T: () => RequestInitChain },
      { no: 6, name: "query", kind: "message", oneof: "value", T: () => RequestQuery },
      { no: 8, name: "check_tx", kind: "message", oneof: "value", T: () => RequestCheckTx },
      { no: 11, name: "commit", kind: "message", oneof: "value", T: () => RequestCommit },
      { no: 12, name: "list_snapshots", kind: "message", oneof: "value", T: () => RequestListSnapshots },
      { no: 13, name: "offer_snapshot", kind: "message", oneof: "value", T: () => RequestOfferSnapshot },
      { no: 14, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestLoadSnapshotChunk },
      { no: 15, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestApplySnapshotChunk },
      { no: 16, name: "prepare_proposal", kind: "message", oneof: "value", T: () => RequestPrepareProposal },
      { no: 17, name: "process_proposal", kind: "message", oneof: "value", T: () => RequestProcessProposal },
      { no: 18, name: "extend_vote", kind: "message", oneof: "value", T: () => RequestExtendVote },
      { no: 19, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => RequestVerifyVoteExtension },
      { no: 20, name: "finalize_block", kind: "message", oneof: "value", T: () => RequestFinalizeBlock }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.RequestEcho echo */
        1:
          message.value = {
            oneofKind: "echo",
            echo: RequestEcho.internalBinaryRead(reader, reader.uint32(), options, message.value.echo)
          };
          break;
        case /* tendermint.abci.RequestFlush flush */
        2:
          message.value = {
            oneofKind: "flush",
            flush: RequestFlush.internalBinaryRead(reader, reader.uint32(), options, message.value.flush)
          };
          break;
        case /* tendermint.abci.RequestInfo info */
        3:
          message.value = {
            oneofKind: "info",
            info: RequestInfo.internalBinaryRead(reader, reader.uint32(), options, message.value.info)
          };
          break;
        case /* tendermint.abci.RequestInitChain init_chain */
        5:
          message.value = {
            oneofKind: "initChain",
            initChain: RequestInitChain.internalBinaryRead(reader, reader.uint32(), options, message.value.initChain)
          };
          break;
        case /* tendermint.abci.RequestQuery query */
        6:
          message.value = {
            oneofKind: "query",
            query: RequestQuery.internalBinaryRead(reader, reader.uint32(), options, message.value.query)
          };
          break;
        case /* tendermint.abci.RequestCheckTx check_tx */
        8:
          message.value = {
            oneofKind: "checkTx",
            checkTx: RequestCheckTx.internalBinaryRead(reader, reader.uint32(), options, message.value.checkTx)
          };
          break;
        case /* tendermint.abci.RequestCommit commit */
        11:
          message.value = {
            oneofKind: "commit",
            commit: RequestCommit.internalBinaryRead(reader, reader.uint32(), options, message.value.commit)
          };
          break;
        case /* tendermint.abci.RequestListSnapshots list_snapshots */
        12:
          message.value = {
            oneofKind: "listSnapshots",
            listSnapshots: RequestListSnapshots.internalBinaryRead(reader, reader.uint32(), options, message.value.listSnapshots)
          };
          break;
        case /* tendermint.abci.RequestOfferSnapshot offer_snapshot */
        13:
          message.value = {
            oneofKind: "offerSnapshot",
            offerSnapshot: RequestOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, message.value.offerSnapshot)
          };
          break;
        case /* tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk */
        14:
          message.value = {
            oneofKind: "loadSnapshotChunk",
            loadSnapshotChunk: RequestLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.loadSnapshotChunk)
          };
          break;
        case /* tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk */
        15:
          message.value = {
            oneofKind: "applySnapshotChunk",
            applySnapshotChunk: RequestApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.applySnapshotChunk)
          };
          break;
        case /* tendermint.abci.RequestPrepareProposal prepare_proposal */
        16:
          message.value = {
            oneofKind: "prepareProposal",
            prepareProposal: RequestPrepareProposal.internalBinaryRead(reader, reader.uint32(), options, message.value.prepareProposal)
          };
          break;
        case /* tendermint.abci.RequestProcessProposal process_proposal */
        17:
          message.value = {
            oneofKind: "processProposal",
            processProposal: RequestProcessProposal.internalBinaryRead(reader, reader.uint32(), options, message.value.processProposal)
          };
          break;
        case /* tendermint.abci.RequestExtendVote extend_vote */
        18:
          message.value = {
            oneofKind: "extendVote",
            extendVote: RequestExtendVote.internalBinaryRead(reader, reader.uint32(), options, message.value.extendVote)
          };
          break;
        case /* tendermint.abci.RequestVerifyVoteExtension verify_vote_extension */
        19:
          message.value = {
            oneofKind: "verifyVoteExtension",
            verifyVoteExtension: RequestVerifyVoteExtension.internalBinaryRead(reader, reader.uint32(), options, message.value.verifyVoteExtension)
          };
          break;
        case /* tendermint.abci.RequestFinalizeBlock finalize_block */
        20:
          message.value = {
            oneofKind: "finalizeBlock",
            finalizeBlock: RequestFinalizeBlock.internalBinaryRead(reader, reader.uint32(), options, message.value.finalizeBlock)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value.oneofKind === "echo")
      RequestEcho.internalBinaryWrite(message.value.echo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "flush")
      RequestFlush.internalBinaryWrite(message.value.flush, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "info")
      RequestInfo.internalBinaryWrite(message.value.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "initChain")
      RequestInitChain.internalBinaryWrite(message.value.initChain, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "query")
      RequestQuery.internalBinaryWrite(message.value.query, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "checkTx")
      RequestCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "commit")
      RequestCommit.internalBinaryWrite(message.value.commit, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "listSnapshots")
      RequestListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "offerSnapshot")
      RequestOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "loadSnapshotChunk")
      RequestLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "applySnapshotChunk")
      RequestApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "prepareProposal")
      RequestPrepareProposal.internalBinaryWrite(message.value.prepareProposal, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "processProposal")
      RequestProcessProposal.internalBinaryWrite(message.value.processProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "extendVote")
      RequestExtendVote.internalBinaryWrite(message.value.extendVote, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "verifyVoteExtension")
      RequestVerifyVoteExtension.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "finalizeBlock")
      RequestFinalizeBlock.internalBinaryWrite(message.value.finalizeBlock, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Request = new Request$Type();
class RequestEcho$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestEcho", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.message = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestEcho = new RequestEcho$Type();
class RequestFlush$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestFlush", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestFlush = new RequestFlush$Type();
class RequestInfo$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestInfo", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "block_version",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "p2p_version",
        kind: "scalar",
        jsonName: "p2pVersion",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "abci_version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.version = "";
    message.blockVersion = 0n;
    message.p2PVersion = 0n;
    message.abciVersion = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string version */
        1:
          message.version = reader.string();
          break;
        case /* uint64 block_version */
        2:
          message.blockVersion = reader.uint64().toBigInt();
          break;
        case /* uint64 p2p_version */
        3:
          message.p2PVersion = reader.uint64().toBigInt();
          break;
        case /* string abci_version */
        4:
          message.abciVersion = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.version !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.version);
    if (message.blockVersion !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.blockVersion);
    if (message.p2PVersion !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.p2PVersion);
    if (message.abciVersion !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.abciVersion);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestInfo = new RequestInfo$Type();
class RequestInitChain$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestInitChain", [
      { no: 1, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 2,
        name: "chain_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "consensus_params", kind: "message", T: () => ConsensusParams },
      { no: 4, name: "validators", kind: "message", repeat: 2, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
      {
        no: 5,
        name: "app_state_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "initial_height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.chainId = "";
    message.validators = [];
    message.appStateBytes = new Uint8Array(0);
    message.initialHeight = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Timestamp time */
        1:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* string chain_id */
        2:
          message.chainId = reader.string();
          break;
        case /* tendermint.types.ConsensusParams consensus_params */
        3:
          message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
          break;
        case /* repeated tendermint.abci.ValidatorUpdate validators */
        4:
          message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes app_state_bytes */
        5:
          message.appStateBytes = reader.bytes();
          break;
        case /* int64 initial_height */
        6:
          message.initialHeight = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.chainId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.chainId);
    if (message.consensusParams)
      ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.validators.length; i++)
      ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.appStateBytes.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.appStateBytes);
    if (message.initialHeight !== 0n)
      writer.tag(6, WireType.Varint).int64(message.initialHeight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestInitChain = new RequestInitChain$Type();
class RequestQuery$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestQuery", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "path",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "prove",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    message.path = "";
    message.height = 0n;
    message.prove = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */
        1:
          message.data = reader.bytes();
          break;
        case /* string path */
        2:
          message.path = reader.string();
          break;
        case /* int64 height */
        3:
          message.height = reader.int64().toBigInt();
          break;
        case /* bool prove */
        4:
          message.prove = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    if (message.path !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.path);
    if (message.height !== 0n)
      writer.tag(3, WireType.Varint).int64(message.height);
    if (message.prove !== false)
      writer.tag(4, WireType.Varint).bool(message.prove);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestQuery = new RequestQuery$Type();
class RequestCheckTx$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestCheckTx", [
      {
        no: 1,
        name: "tx",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "type", kind: "enum", T: () => ["tendermint.abci.CheckTxType", CheckTxType] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tx = new Uint8Array(0);
    message.type = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes tx */
        1:
          message.tx = reader.bytes();
          break;
        case /* tendermint.abci.CheckTxType type */
        2:
          message.type = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tx.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
    if (message.type !== 0)
      writer.tag(2, WireType.Varint).int32(message.type);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestCheckTx = new RequestCheckTx$Type();
class RequestCommit$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestCommit", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestCommit = new RequestCommit$Type();
class RequestListSnapshots$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestListSnapshots", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestListSnapshots = new RequestListSnapshots$Type();
class RequestOfferSnapshot$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestOfferSnapshot", [
      { no: 1, name: "snapshot", kind: "message", T: () => Snapshot },
      {
        no: 2,
        name: "app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.appHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.Snapshot snapshot */
        1:
          message.snapshot = Snapshot.internalBinaryRead(reader, reader.uint32(), options, message.snapshot);
          break;
        case /* bytes app_hash */
        2:
          message.appHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.snapshot)
      Snapshot.internalBinaryWrite(message.snapshot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.appHash.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.appHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestOfferSnapshot = new RequestOfferSnapshot$Type();
class RequestLoadSnapshotChunk$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestLoadSnapshotChunk", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "format",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "chunk",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.format = 0;
    message.chunk = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 height */
        1:
          message.height = reader.uint64().toBigInt();
          break;
        case /* uint32 format */
        2:
          message.format = reader.uint32();
          break;
        case /* uint32 chunk */
        3:
          message.chunk = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.height);
    if (message.format !== 0)
      writer.tag(2, WireType.Varint).uint32(message.format);
    if (message.chunk !== 0)
      writer.tag(3, WireType.Varint).uint32(message.chunk);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestLoadSnapshotChunk = new RequestLoadSnapshotChunk$Type();
class RequestApplySnapshotChunk$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestApplySnapshotChunk", [
      {
        no: 1,
        name: "index",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "chunk",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.index = 0;
    message.chunk = new Uint8Array(0);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 index */
        1:
          message.index = reader.uint32();
          break;
        case /* bytes chunk */
        2:
          message.chunk = reader.bytes();
          break;
        case /* string sender */
        3:
          message.sender = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.index !== 0)
      writer.tag(1, WireType.Varint).uint32(message.index);
    if (message.chunk.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.chunk);
    if (message.sender !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.sender);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestApplySnapshotChunk = new RequestApplySnapshotChunk$Type();
class RequestPrepareProposal$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestPrepareProposal", [
      {
        no: 1,
        name: "max_tx_bytes",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "local_last_commit", kind: "message", T: () => ExtendedCommitInfo, options: { "gogoproto.nullable": false } },
      { no: 4, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.maxTxBytes = 0n;
    message.txs = [];
    message.misbehavior = [];
    message.height = 0n;
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 max_tx_bytes */
        1:
          message.maxTxBytes = reader.int64().toBigInt();
          break;
        case /* repeated bytes txs */
        2:
          message.txs.push(reader.bytes());
          break;
        case /* tendermint.abci.ExtendedCommitInfo local_last_commit */
        3:
          message.localLastCommit = ExtendedCommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.localLastCommit);
          break;
        case /* repeated tendermint.abci.Misbehavior misbehavior */
        4:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* int64 height */
        5:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        6:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.maxTxBytes !== 0n)
      writer.tag(1, WireType.Varint).int64(message.maxTxBytes);
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.localLastCommit)
      ExtendedCommitInfo.internalBinaryWrite(message.localLastCommit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestPrepareProposal = new RequestPrepareProposal$Type();
class RequestProcessProposal$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestProcessProposal", [
      {
        no: 1,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.txs = [];
    message.misbehavior = [];
    message.hash = new Uint8Array(0);
    message.height = 0n;
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes txs */
        1:
          message.txs.push(reader.bytes());
          break;
        case /* tendermint.abci.CommitInfo proposed_last_commit */
        2:
          message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
          break;
        case /* repeated tendermint.abci.Misbehavior misbehavior */
        3:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes hash */
        4:
          message.hash = reader.bytes();
          break;
        case /* int64 height */
        5:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        6:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.proposedLastCommit)
      CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.hash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestProcessProposal = new RequestProcessProposal$Type();
class RequestExtendVote$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestExtendVote", [
      {
        no: 1,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 4,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 5, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
      { no: 6, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = new Uint8Array(0);
    message.height = 0n;
    message.txs = [];
    message.misbehavior = [];
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hash */
        1:
          message.hash = reader.bytes();
          break;
        case /* int64 height */
        2:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        3:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* repeated bytes txs */
        4:
          message.txs.push(reader.bytes());
          break;
        case /* tendermint.abci.CommitInfo proposed_last_commit */
        5:
          message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
          break;
        case /* repeated tendermint.abci.Misbehavior misbehavior */
        6:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
    if (message.height !== 0n)
      writer.tag(2, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(4, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.proposedLastCommit)
      CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestExtendVote = new RequestExtendVote$Type();
class RequestVerifyVoteExtension$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestVerifyVoteExtension", [
      {
        no: 1,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "validator_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "vote_extension",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = new Uint8Array(0);
    message.validatorAddress = new Uint8Array(0);
    message.height = 0n;
    message.voteExtension = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hash */
        1:
          message.hash = reader.bytes();
          break;
        case /* bytes validator_address */
        2:
          message.validatorAddress = reader.bytes();
          break;
        case /* int64 height */
        3:
          message.height = reader.int64().toBigInt();
          break;
        case /* bytes vote_extension */
        4:
          message.voteExtension = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
    if (message.validatorAddress.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.validatorAddress);
    if (message.height !== 0n)
      writer.tag(3, WireType.Varint).int64(message.height);
    if (message.voteExtension.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.voteExtension);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestVerifyVoteExtension = new RequestVerifyVoteExtension$Type();
class RequestFinalizeBlock$Type extends MessageType {
  constructor() {
    super("tendermint.abci.RequestFinalizeBlock", [
      {
        no: 1,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "decided_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.txs = [];
    message.misbehavior = [];
    message.hash = new Uint8Array(0);
    message.height = 0n;
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes txs */
        1:
          message.txs.push(reader.bytes());
          break;
        case /* tendermint.abci.CommitInfo decided_last_commit */
        2:
          message.decidedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.decidedLastCommit);
          break;
        case /* repeated tendermint.abci.Misbehavior misbehavior */
        3:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes hash */
        4:
          message.hash = reader.bytes();
          break;
        case /* int64 height */
        5:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        6:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.decidedLastCommit)
      CommitInfo.internalBinaryWrite(message.decidedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.hash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestFinalizeBlock = new RequestFinalizeBlock$Type();
class Response$Type extends MessageType {
  constructor() {
    super("tendermint.abci.Response", [
      { no: 1, name: "exception", kind: "message", oneof: "value", T: () => ResponseException },
      { no: 2, name: "echo", kind: "message", oneof: "value", T: () => ResponseEcho },
      { no: 3, name: "flush", kind: "message", oneof: "value", T: () => ResponseFlush },
      { no: 4, name: "info", kind: "message", oneof: "value", T: () => ResponseInfo },
      { no: 6, name: "init_chain", kind: "message", oneof: "value", T: () => ResponseInitChain },
      { no: 7, name: "query", kind: "message", oneof: "value", T: () => ResponseQuery },
      { no: 9, name: "check_tx", kind: "message", oneof: "value", T: () => ResponseCheckTx },
      { no: 12, name: "commit", kind: "message", oneof: "value", T: () => ResponseCommit },
      { no: 13, name: "list_snapshots", kind: "message", oneof: "value", T: () => ResponseListSnapshots },
      { no: 14, name: "offer_snapshot", kind: "message", oneof: "value", T: () => ResponseOfferSnapshot },
      { no: 15, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseLoadSnapshotChunk },
      { no: 16, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseApplySnapshotChunk },
      { no: 17, name: "prepare_proposal", kind: "message", oneof: "value", T: () => ResponsePrepareProposal },
      { no: 18, name: "process_proposal", kind: "message", oneof: "value", T: () => ResponseProcessProposal },
      { no: 19, name: "extend_vote", kind: "message", oneof: "value", T: () => ResponseExtendVote },
      { no: 20, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => ResponseVerifyVoteExtension },
      { no: 21, name: "finalize_block", kind: "message", oneof: "value", T: () => ResponseFinalizeBlock }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.ResponseException exception */
        1:
          message.value = {
            oneofKind: "exception",
            exception: ResponseException.internalBinaryRead(reader, reader.uint32(), options, message.value.exception)
          };
          break;
        case /* tendermint.abci.ResponseEcho echo */
        2:
          message.value = {
            oneofKind: "echo",
            echo: ResponseEcho.internalBinaryRead(reader, reader.uint32(), options, message.value.echo)
          };
          break;
        case /* tendermint.abci.ResponseFlush flush */
        3:
          message.value = {
            oneofKind: "flush",
            flush: ResponseFlush.internalBinaryRead(reader, reader.uint32(), options, message.value.flush)
          };
          break;
        case /* tendermint.abci.ResponseInfo info */
        4:
          message.value = {
            oneofKind: "info",
            info: ResponseInfo.internalBinaryRead(reader, reader.uint32(), options, message.value.info)
          };
          break;
        case /* tendermint.abci.ResponseInitChain init_chain */
        6:
          message.value = {
            oneofKind: "initChain",
            initChain: ResponseInitChain.internalBinaryRead(reader, reader.uint32(), options, message.value.initChain)
          };
          break;
        case /* tendermint.abci.ResponseQuery query */
        7:
          message.value = {
            oneofKind: "query",
            query: ResponseQuery.internalBinaryRead(reader, reader.uint32(), options, message.value.query)
          };
          break;
        case /* tendermint.abci.ResponseCheckTx check_tx */
        9:
          message.value = {
            oneofKind: "checkTx",
            checkTx: ResponseCheckTx.internalBinaryRead(reader, reader.uint32(), options, message.value.checkTx)
          };
          break;
        case /* tendermint.abci.ResponseCommit commit */
        12:
          message.value = {
            oneofKind: "commit",
            commit: ResponseCommit.internalBinaryRead(reader, reader.uint32(), options, message.value.commit)
          };
          break;
        case /* tendermint.abci.ResponseListSnapshots list_snapshots */
        13:
          message.value = {
            oneofKind: "listSnapshots",
            listSnapshots: ResponseListSnapshots.internalBinaryRead(reader, reader.uint32(), options, message.value.listSnapshots)
          };
          break;
        case /* tendermint.abci.ResponseOfferSnapshot offer_snapshot */
        14:
          message.value = {
            oneofKind: "offerSnapshot",
            offerSnapshot: ResponseOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, message.value.offerSnapshot)
          };
          break;
        case /* tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk */
        15:
          message.value = {
            oneofKind: "loadSnapshotChunk",
            loadSnapshotChunk: ResponseLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.loadSnapshotChunk)
          };
          break;
        case /* tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk */
        16:
          message.value = {
            oneofKind: "applySnapshotChunk",
            applySnapshotChunk: ResponseApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.applySnapshotChunk)
          };
          break;
        case /* tendermint.abci.ResponsePrepareProposal prepare_proposal */
        17:
          message.value = {
            oneofKind: "prepareProposal",
            prepareProposal: ResponsePrepareProposal.internalBinaryRead(reader, reader.uint32(), options, message.value.prepareProposal)
          };
          break;
        case /* tendermint.abci.ResponseProcessProposal process_proposal */
        18:
          message.value = {
            oneofKind: "processProposal",
            processProposal: ResponseProcessProposal.internalBinaryRead(reader, reader.uint32(), options, message.value.processProposal)
          };
          break;
        case /* tendermint.abci.ResponseExtendVote extend_vote */
        19:
          message.value = {
            oneofKind: "extendVote",
            extendVote: ResponseExtendVote.internalBinaryRead(reader, reader.uint32(), options, message.value.extendVote)
          };
          break;
        case /* tendermint.abci.ResponseVerifyVoteExtension verify_vote_extension */
        20:
          message.value = {
            oneofKind: "verifyVoteExtension",
            verifyVoteExtension: ResponseVerifyVoteExtension.internalBinaryRead(reader, reader.uint32(), options, message.value.verifyVoteExtension)
          };
          break;
        case /* tendermint.abci.ResponseFinalizeBlock finalize_block */
        21:
          message.value = {
            oneofKind: "finalizeBlock",
            finalizeBlock: ResponseFinalizeBlock.internalBinaryRead(reader, reader.uint32(), options, message.value.finalizeBlock)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value.oneofKind === "exception")
      ResponseException.internalBinaryWrite(message.value.exception, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "echo")
      ResponseEcho.internalBinaryWrite(message.value.echo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "flush")
      ResponseFlush.internalBinaryWrite(message.value.flush, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "info")
      ResponseInfo.internalBinaryWrite(message.value.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "initChain")
      ResponseInitChain.internalBinaryWrite(message.value.initChain, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "query")
      ResponseQuery.internalBinaryWrite(message.value.query, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "checkTx")
      ResponseCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "commit")
      ResponseCommit.internalBinaryWrite(message.value.commit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "listSnapshots")
      ResponseListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "offerSnapshot")
      ResponseOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "loadSnapshotChunk")
      ResponseLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "applySnapshotChunk")
      ResponseApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "prepareProposal")
      ResponsePrepareProposal.internalBinaryWrite(message.value.prepareProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "processProposal")
      ResponseProcessProposal.internalBinaryWrite(message.value.processProposal, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "extendVote")
      ResponseExtendVote.internalBinaryWrite(message.value.extendVote, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "verifyVoteExtension")
      ResponseVerifyVoteExtension.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "finalizeBlock")
      ResponseFinalizeBlock.internalBinaryWrite(message.value.finalizeBlock, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Response = new Response$Type();
class ResponseException$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseException", [
      {
        no: 1,
        name: "error",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.error = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string error */
        1:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.error !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseException = new ResponseException$Type();
class ResponseEcho$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseEcho", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.message = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseEcho = new ResponseEcho$Type();
class ResponseFlush$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseFlush", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseFlush = new ResponseFlush$Type();
class ResponseInfo$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseInfo", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "app_version",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "last_block_height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "last_block_app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = "";
    message.version = "";
    message.appVersion = 0n;
    message.lastBlockHeight = 0n;
    message.lastBlockAppHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string data */
        1:
          message.data = reader.string();
          break;
        case /* string version */
        2:
          message.version = reader.string();
          break;
        case /* uint64 app_version */
        3:
          message.appVersion = reader.uint64().toBigInt();
          break;
        case /* int64 last_block_height */
        4:
          message.lastBlockHeight = reader.int64().toBigInt();
          break;
        case /* bytes last_block_app_hash */
        5:
          message.lastBlockAppHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.data);
    if (message.version !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.version);
    if (message.appVersion !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.appVersion);
    if (message.lastBlockHeight !== 0n)
      writer.tag(4, WireType.Varint).int64(message.lastBlockHeight);
    if (message.lastBlockAppHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.lastBlockAppHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseInfo = new ResponseInfo$Type();
class ResponseInitChain$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseInitChain", [
      { no: 1, name: "consensus_params", kind: "message", T: () => ConsensusParams },
      { no: 2, name: "validators", kind: "message", repeat: 2, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validators = [];
    message.appHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.types.ConsensusParams consensus_params */
        1:
          message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
          break;
        case /* repeated tendermint.abci.ValidatorUpdate validators */
        2:
          message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes app_hash */
        3:
          message.appHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.consensusParams)
      ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.validators.length; i++)
      ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.appHash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.appHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseInitChain = new ResponseInitChain$Type();
class ResponseQuery$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseQuery", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "index",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "key",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "value",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 8, name: "proof_ops", kind: "message", T: () => ProofOps },
      {
        no: 9,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = 0;
    message.log = "";
    message.info = "";
    message.index = 0n;
    message.key = new Uint8Array(0);
    message.value = new Uint8Array(0);
    message.height = 0n;
    message.codespace = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 code */
        1:
          message.code = reader.uint32();
          break;
        case /* string log */
        3:
          message.log = reader.string();
          break;
        case /* string info */
        4:
          message.info = reader.string();
          break;
        case /* int64 index */
        5:
          message.index = reader.int64().toBigInt();
          break;
        case /* bytes key */
        6:
          message.key = reader.bytes();
          break;
        case /* bytes value */
        7:
          message.value = reader.bytes();
          break;
        case /* tendermint.crypto.ProofOps proof_ops */
        8:
          message.proofOps = ProofOps.internalBinaryRead(reader, reader.uint32(), options, message.proofOps);
          break;
        case /* int64 height */
        9:
          message.height = reader.int64().toBigInt();
          break;
        case /* string codespace */
        10:
          message.codespace = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code !== 0)
      writer.tag(1, WireType.Varint).uint32(message.code);
    if (message.log !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.log);
    if (message.info !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.info);
    if (message.index !== 0n)
      writer.tag(5, WireType.Varint).int64(message.index);
    if (message.key.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.key);
    if (message.value.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.value);
    if (message.proofOps)
      ProofOps.internalBinaryWrite(message.proofOps, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.height !== 0n)
      writer.tag(9, WireType.Varint).int64(message.height);
    if (message.codespace !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.codespace);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseQuery = new ResponseQuery$Type();
class ResponseCheckTx$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseCheckTx", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "gas_wanted",
        kind: "scalar",
        jsonName: "gas_wanted",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "gas_used",
        kind: "scalar",
        jsonName: "gas_used",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 7, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
      {
        no: 8,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = 0;
    message.data = new Uint8Array(0);
    message.log = "";
    message.info = "";
    message.gasWanted = 0n;
    message.gasUsed = 0n;
    message.events = [];
    message.codespace = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 code */
        1:
          message.code = reader.uint32();
          break;
        case /* bytes data */
        2:
          message.data = reader.bytes();
          break;
        case /* string log */
        3:
          message.log = reader.string();
          break;
        case /* string info */
        4:
          message.info = reader.string();
          break;
        case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */
        5:
          message.gasWanted = reader.int64().toBigInt();
          break;
        case /* int64 gas_used = 6 [json_name = "gas_used"] */
        6:
          message.gasUsed = reader.int64().toBigInt();
          break;
        case /* repeated tendermint.abci.Event events */
        7:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string codespace */
        8:
          message.codespace = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code !== 0)
      writer.tag(1, WireType.Varint).uint32(message.code);
    if (message.data.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    if (message.log !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.log);
    if (message.info !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.info);
    if (message.gasWanted !== 0n)
      writer.tag(5, WireType.Varint).int64(message.gasWanted);
    if (message.gasUsed !== 0n)
      writer.tag(6, WireType.Varint).int64(message.gasUsed);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.codespace !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.codespace);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseCheckTx = new ResponseCheckTx$Type();
class ResponseCommit$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseCommit", [
      {
        no: 3,
        name: "retain_height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.retainHeight = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 retain_height */
        3:
          message.retainHeight = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.retainHeight !== 0n)
      writer.tag(3, WireType.Varint).int64(message.retainHeight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseCommit = new ResponseCommit$Type();
class ResponseListSnapshots$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseListSnapshots", [
      { no: 1, name: "snapshots", kind: "message", repeat: 2, T: () => Snapshot }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.snapshots = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated tendermint.abci.Snapshot snapshots */
        1:
          message.snapshots.push(Snapshot.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.snapshots.length; i++)
      Snapshot.internalBinaryWrite(message.snapshots[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseListSnapshots = new ResponseListSnapshots$Type();
class ResponseOfferSnapshot$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseOfferSnapshot", [
      { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseOfferSnapshot.Result", ResponseOfferSnapshot_Result] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.ResponseOfferSnapshot.Result result */
        1:
          message.result = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result !== 0)
      writer.tag(1, WireType.Varint).int32(message.result);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseOfferSnapshot = new ResponseOfferSnapshot$Type();
class ResponseLoadSnapshotChunk$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseLoadSnapshotChunk", [
      {
        no: 1,
        name: "chunk",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.chunk = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes chunk */
        1:
          message.chunk = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.chunk.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.chunk);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseLoadSnapshotChunk = new ResponseLoadSnapshotChunk$Type();
class ResponseApplySnapshotChunk$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseApplySnapshotChunk", [
      { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseApplySnapshotChunk.Result", ResponseApplySnapshotChunk_Result] },
      {
        no: 2,
        name: "refetch_chunks",
        kind: "scalar",
        repeat: 1,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "reject_senders",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = 0;
    message.refetchChunks = [];
    message.rejectSenders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.ResponseApplySnapshotChunk.Result result */
        1:
          message.result = reader.int32();
          break;
        case /* repeated uint32 refetch_chunks */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.refetchChunks.push(reader.uint32());
          else
            message.refetchChunks.push(reader.uint32());
          break;
        case /* repeated string reject_senders */
        3:
          message.rejectSenders.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result !== 0)
      writer.tag(1, WireType.Varint).int32(message.result);
    if (message.refetchChunks.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.refetchChunks.length; i++)
        writer.uint32(message.refetchChunks[i]);
      writer.join();
    }
    for (let i = 0; i < message.rejectSenders.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.rejectSenders[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseApplySnapshotChunk = new ResponseApplySnapshotChunk$Type();
class ResponsePrepareProposal$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponsePrepareProposal", [
      {
        no: 1,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.txs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes txs */
        1:
          message.txs.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponsePrepareProposal = new ResponsePrepareProposal$Type();
class ResponseProcessProposal$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseProcessProposal", [
      { no: 1, name: "status", kind: "enum", T: () => ["tendermint.abci.ResponseProcessProposal.ProposalStatus", ResponseProcessProposal_ProposalStatus] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.ResponseProcessProposal.ProposalStatus status */
        1:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== 0)
      writer.tag(1, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseProcessProposal = new ResponseProcessProposal$Type();
class ResponseExtendVote$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseExtendVote", [
      {
        no: 1,
        name: "vote_extension",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.voteExtension = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes vote_extension */
        1:
          message.voteExtension = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.voteExtension.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.voteExtension);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseExtendVote = new ResponseExtendVote$Type();
class ResponseVerifyVoteExtension$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseVerifyVoteExtension", [
      { no: 1, name: "status", kind: "enum", T: () => ["tendermint.abci.ResponseVerifyVoteExtension.VerifyStatus", ResponseVerifyVoteExtension_VerifyStatus] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.ResponseVerifyVoteExtension.VerifyStatus status */
        1:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== 0)
      writer.tag(1, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseVerifyVoteExtension = new ResponseVerifyVoteExtension$Type();
class ResponseFinalizeBlock$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ResponseFinalizeBlock", [
      { no: 1, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
      { no: 2, name: "tx_results", kind: "message", repeat: 2, T: () => ExecTxResult },
      { no: 3, name: "validator_updates", kind: "message", repeat: 2, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
      { no: 4, name: "consensus_param_updates", kind: "message", T: () => ConsensusParams },
      {
        no: 5,
        name: "app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.events = [];
    message.txResults = [];
    message.validatorUpdates = [];
    message.appHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated tendermint.abci.Event events */
        1:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated tendermint.abci.ExecTxResult tx_results */
        2:
          message.txResults.push(ExecTxResult.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated tendermint.abci.ValidatorUpdate validator_updates */
        3:
          message.validatorUpdates.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* tendermint.types.ConsensusParams consensus_param_updates */
        4:
          message.consensusParamUpdates = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParamUpdates);
          break;
        case /* bytes app_hash */
        5:
          message.appHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.txResults.length; i++)
      ExecTxResult.internalBinaryWrite(message.txResults[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.validatorUpdates.length; i++)
      ValidatorUpdate.internalBinaryWrite(message.validatorUpdates[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.consensusParamUpdates)
      ConsensusParams.internalBinaryWrite(message.consensusParamUpdates, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.appHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.appHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ResponseFinalizeBlock = new ResponseFinalizeBlock$Type();
class CommitInfo$Type extends MessageType {
  constructor() {
    super("tendermint.abci.CommitInfo", [
      {
        no: 1,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 2, name: "votes", kind: "message", repeat: 2, T: () => VoteInfo, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.round = 0;
    message.votes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 round */
        1:
          message.round = reader.int32();
          break;
        case /* repeated tendermint.abci.VoteInfo votes */
        2:
          message.votes.push(VoteInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.round !== 0)
      writer.tag(1, WireType.Varint).int32(message.round);
    for (let i = 0; i < message.votes.length; i++)
      VoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommitInfo = new CommitInfo$Type();
class ExtendedCommitInfo$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ExtendedCommitInfo", [
      {
        no: 1,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 2, name: "votes", kind: "message", repeat: 2, T: () => ExtendedVoteInfo, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.round = 0;
    message.votes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 round */
        1:
          message.round = reader.int32();
          break;
        case /* repeated tendermint.abci.ExtendedVoteInfo votes */
        2:
          message.votes.push(ExtendedVoteInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.round !== 0)
      writer.tag(1, WireType.Varint).int32(message.round);
    for (let i = 0; i < message.votes.length; i++)
      ExtendedVoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExtendedCommitInfo = new ExtendedCommitInfo$Type();
class Event$Type extends MessageType {
  constructor() {
    super("tendermint.abci.Event", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "attributes", kind: "message", repeat: 2, T: () => EventAttribute, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "attributes,omitempty" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = "";
    message.attributes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */
        1:
          message.type = reader.string();
          break;
        case /* repeated tendermint.abci.EventAttribute attributes */
        2:
          message.attributes.push(EventAttribute.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    for (let i = 0; i < message.attributes.length; i++)
      EventAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Event = new Event$Type();
class EventAttribute$Type extends MessageType {
  constructor() {
    super("tendermint.abci.EventAttribute", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "index",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = "";
    message.value = "";
    message.index = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */
        1:
          message.key = reader.string();
          break;
        case /* string value */
        2:
          message.value = reader.string();
          break;
        case /* bool index */
        3:
          message.index = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    if (message.value !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.value);
    if (message.index !== false)
      writer.tag(3, WireType.Varint).bool(message.index);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventAttribute = new EventAttribute$Type();
class ExecTxResult$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ExecTxResult", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "gas_wanted",
        kind: "scalar",
        jsonName: "gas_wanted",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "gas_used",
        kind: "scalar",
        jsonName: "gas_used",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 7, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
      {
        no: 8,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = 0;
    message.data = new Uint8Array(0);
    message.log = "";
    message.info = "";
    message.gasWanted = 0n;
    message.gasUsed = 0n;
    message.events = [];
    message.codespace = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 code */
        1:
          message.code = reader.uint32();
          break;
        case /* bytes data */
        2:
          message.data = reader.bytes();
          break;
        case /* string log */
        3:
          message.log = reader.string();
          break;
        case /* string info */
        4:
          message.info = reader.string();
          break;
        case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */
        5:
          message.gasWanted = reader.int64().toBigInt();
          break;
        case /* int64 gas_used = 6 [json_name = "gas_used"] */
        6:
          message.gasUsed = reader.int64().toBigInt();
          break;
        case /* repeated tendermint.abci.Event events */
        7:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string codespace */
        8:
          message.codespace = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code !== 0)
      writer.tag(1, WireType.Varint).uint32(message.code);
    if (message.data.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    if (message.log !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.log);
    if (message.info !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.info);
    if (message.gasWanted !== 0n)
      writer.tag(5, WireType.Varint).int64(message.gasWanted);
    if (message.gasUsed !== 0n)
      writer.tag(6, WireType.Varint).int64(message.gasUsed);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.codespace !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.codespace);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecTxResult = new ExecTxResult$Type();
class TxResult$Type extends MessageType {
  constructor() {
    super("tendermint.abci.TxResult", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "index",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "tx",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "result", kind: "message", T: () => ExecTxResult, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.index = 0;
    message.tx = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* uint32 index */
        2:
          message.index = reader.uint32();
          break;
        case /* bytes tx */
        3:
          message.tx = reader.bytes();
          break;
        case /* tendermint.abci.ExecTxResult result */
        4:
          message.result = ExecTxResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.index !== 0)
      writer.tag(2, WireType.Varint).uint32(message.index);
    if (message.tx.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.tx);
    if (message.result)
      ExecTxResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxResult = new TxResult$Type();
class Validator$Type extends MessageType {
  constructor() {
    super("tendermint.abci.Validator", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "power",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = new Uint8Array(0);
    message.power = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes address */
        1:
          message.address = reader.bytes();
          break;
        case /* int64 power */
        3:
          message.power = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.address);
    if (message.power !== 0n)
      writer.tag(3, WireType.Varint).int64(message.power);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Validator = new Validator$Type();
class ValidatorUpdate$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ValidatorUpdate", [
      { no: 1, name: "pub_key", kind: "message", T: () => PublicKey, options: { "gogoproto.nullable": false } },
      {
        no: 2,
        name: "power",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.power = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.crypto.PublicKey pub_key */
        1:
          message.pubKey = PublicKey.internalBinaryRead(reader, reader.uint32(), options, message.pubKey);
          break;
        case /* int64 power */
        2:
          message.power = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.pubKey)
      PublicKey.internalBinaryWrite(message.pubKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.power !== 0n)
      writer.tag(2, WireType.Varint).int64(message.power);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorUpdate = new ValidatorUpdate$Type();
class VoteInfo$Type extends MessageType {
  constructor() {
    super("tendermint.abci.VoteInfo", [
      { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
      { no: 3, name: "block_id_flag", kind: "enum", T: () => ["tendermint.types.BlockIDFlag", BlockIDFlag] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.blockIdFlag = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.Validator validator */
        1:
          message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
          break;
        case /* tendermint.types.BlockIDFlag block_id_flag */
        3:
          message.blockIdFlag = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validator)
      Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.blockIdFlag !== 0)
      writer.tag(3, WireType.Varint).int32(message.blockIdFlag);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VoteInfo = new VoteInfo$Type();
class ExtendedVoteInfo$Type extends MessageType {
  constructor() {
    super("tendermint.abci.ExtendedVoteInfo", [
      { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "vote_extension",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "extension_signature",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 5, name: "block_id_flag", kind: "enum", T: () => ["tendermint.types.BlockIDFlag", BlockIDFlag] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.voteExtension = new Uint8Array(0);
    message.extensionSignature = new Uint8Array(0);
    message.blockIdFlag = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.Validator validator */
        1:
          message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
          break;
        case /* bytes vote_extension */
        3:
          message.voteExtension = reader.bytes();
          break;
        case /* bytes extension_signature */
        4:
          message.extensionSignature = reader.bytes();
          break;
        case /* tendermint.types.BlockIDFlag block_id_flag */
        5:
          message.blockIdFlag = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validator)
      Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.voteExtension.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.voteExtension);
    if (message.extensionSignature.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.extensionSignature);
    if (message.blockIdFlag !== 0)
      writer.tag(5, WireType.Varint).int32(message.blockIdFlag);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExtendedVoteInfo = new ExtendedVoteInfo$Type();
class Misbehavior$Type extends MessageType {
  constructor() {
    super("tendermint.abci.Misbehavior", [
      { no: 1, name: "type", kind: "enum", T: () => ["tendermint.abci.MisbehaviorType", MisbehaviorType] },
      { no: 2, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 5,
        name: "total_voting_power",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = 0;
    message.height = 0n;
    message.totalVotingPower = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.abci.MisbehaviorType type */
        1:
          message.type = reader.int32();
          break;
        case /* tendermint.abci.Validator validator */
        2:
          message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
          break;
        case /* int64 height */
        3:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        4:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* int64 total_voting_power */
        5:
          message.totalVotingPower = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== 0)
      writer.tag(1, WireType.Varint).int32(message.type);
    if (message.validator)
      Validator.internalBinaryWrite(message.validator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.height !== 0n)
      writer.tag(3, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.totalVotingPower !== 0n)
      writer.tag(5, WireType.Varint).int64(message.totalVotingPower);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Misbehavior = new Misbehavior$Type();
class Snapshot$Type extends MessageType {
  constructor() {
    super("tendermint.abci.Snapshot", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "format",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "chunks",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.format = 0;
    message.chunks = 0;
    message.hash = new Uint8Array(0);
    message.metadata = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 height */
        1:
          message.height = reader.uint64().toBigInt();
          break;
        case /* uint32 format */
        2:
          message.format = reader.uint32();
          break;
        case /* uint32 chunks */
        3:
          message.chunks = reader.uint32();
          break;
        case /* bytes hash */
        4:
          message.hash = reader.bytes();
          break;
        case /* bytes metadata */
        5:
          message.metadata = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.height);
    if (message.format !== 0)
      writer.tag(2, WireType.Varint).uint32(message.format);
    if (message.chunks !== 0)
      writer.tag(3, WireType.Varint).uint32(message.chunks);
    if (message.hash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
    if (message.metadata.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.metadata);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Snapshot = new Snapshot$Type();
const ABCI = new ServiceType("tendermint.abci.ABCI", [
  { name: "Echo", options: {}, I: RequestEcho, O: ResponseEcho },
  { name: "Flush", options: {}, I: RequestFlush, O: ResponseFlush },
  { name: "Info", options: {}, I: RequestInfo, O: ResponseInfo },
  { name: "CheckTx", options: {}, I: RequestCheckTx, O: ResponseCheckTx },
  { name: "Query", options: {}, I: RequestQuery, O: ResponseQuery },
  { name: "Commit", options: {}, I: RequestCommit, O: ResponseCommit },
  { name: "InitChain", options: {}, I: RequestInitChain, O: ResponseInitChain },
  { name: "ListSnapshots", options: {}, I: RequestListSnapshots, O: ResponseListSnapshots },
  { name: "OfferSnapshot", options: {}, I: RequestOfferSnapshot, O: ResponseOfferSnapshot },
  { name: "LoadSnapshotChunk", options: {}, I: RequestLoadSnapshotChunk, O: ResponseLoadSnapshotChunk },
  { name: "ApplySnapshotChunk", options: {}, I: RequestApplySnapshotChunk, O: ResponseApplySnapshotChunk },
  { name: "PrepareProposal", options: {}, I: RequestPrepareProposal, O: ResponsePrepareProposal },
  { name: "ProcessProposal", options: {}, I: RequestProcessProposal, O: ResponseProcessProposal },
  { name: "ExtendVote", options: {}, I: RequestExtendVote, O: ResponseExtendVote },
  { name: "VerifyVoteExtension", options: {}, I: RequestVerifyVoteExtension, O: ResponseVerifyVoteExtension },
  { name: "FinalizeBlock", options: {}, I: RequestFinalizeBlock, O: ResponseFinalizeBlock }
]);
export {
  ABCI,
  CheckTxType,
  CommitInfo,
  Event,
  EventAttribute,
  ExecTxResult,
  ExtendedCommitInfo,
  ExtendedVoteInfo,
  Misbehavior,
  MisbehaviorType,
  Request,
  RequestApplySnapshotChunk,
  RequestCheckTx,
  RequestCommit,
  RequestEcho,
  RequestExtendVote,
  RequestFinalizeBlock,
  RequestFlush,
  RequestInfo,
  RequestInitChain,
  RequestListSnapshots,
  RequestLoadSnapshotChunk,
  RequestOfferSnapshot,
  RequestPrepareProposal,
  RequestProcessProposal,
  RequestQuery,
  RequestVerifyVoteExtension,
  Response,
  ResponseApplySnapshotChunk,
  ResponseApplySnapshotChunk_Result,
  ResponseCheckTx,
  ResponseCommit,
  ResponseEcho,
  ResponseException,
  ResponseExtendVote,
  ResponseFinalizeBlock,
  ResponseFlush,
  ResponseInfo,
  ResponseInitChain,
  ResponseListSnapshots,
  ResponseLoadSnapshotChunk,
  ResponseOfferSnapshot,
  ResponseOfferSnapshot_Result,
  ResponsePrepareProposal,
  ResponseProcessProposal,
  ResponseProcessProposal_ProposalStatus,
  ResponseQuery,
  ResponseVerifyVoteExtension,
  ResponseVerifyVoteExtension_VerifyStatus,
  Snapshot,
  TxResult,
  Validator,
  ValidatorUpdate,
  VoteInfo
};
