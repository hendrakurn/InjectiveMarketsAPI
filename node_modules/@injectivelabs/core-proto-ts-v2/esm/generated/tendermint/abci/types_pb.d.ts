// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "tendermint/abci/types.proto" (package "tendermint.abci", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BlockIDFlag } from "../types/validator_pb";
import { PublicKey } from "../crypto/keys_pb";
import { ProofOps } from "../crypto/proof_pb";
import { ConsensusParams } from "../types/params_pb";
import { Timestamp } from "../../google/protobuf/timestamp_pb";
// ----------------------------------------
// Request types

/**
 * @generated from protobuf message tendermint.abci.Request
 */
export interface Request {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "echo";
        /**
         * @generated from protobuf field: tendermint.abci.RequestEcho echo = 1
         */
        echo: RequestEcho;
    } | {
        oneofKind: "flush";
        /**
         * @generated from protobuf field: tendermint.abci.RequestFlush flush = 2
         */
        flush: RequestFlush;
    } | {
        oneofKind: "info";
        /**
         * @generated from protobuf field: tendermint.abci.RequestInfo info = 3
         */
        info: RequestInfo;
    } | {
        oneofKind: "initChain";
        /**
         * @generated from protobuf field: tendermint.abci.RequestInitChain init_chain = 5
         */
        initChain: RequestInitChain;
    } | {
        oneofKind: "query";
        /**
         * @generated from protobuf field: tendermint.abci.RequestQuery query = 6
         */
        query: RequestQuery;
    } | {
        oneofKind: "checkTx";
        /**
         * @generated from protobuf field: tendermint.abci.RequestCheckTx check_tx = 8
         */
        checkTx: RequestCheckTx;
    } | {
        oneofKind: "commit";
        /**
         * @generated from protobuf field: tendermint.abci.RequestCommit commit = 11
         */
        commit: RequestCommit;
    } | {
        oneofKind: "listSnapshots";
        /**
         * @generated from protobuf field: tendermint.abci.RequestListSnapshots list_snapshots = 12
         */
        listSnapshots: RequestListSnapshots;
    } | {
        oneofKind: "offerSnapshot";
        /**
         * @generated from protobuf field: tendermint.abci.RequestOfferSnapshot offer_snapshot = 13
         */
        offerSnapshot: RequestOfferSnapshot;
    } | {
        oneofKind: "loadSnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14
         */
        loadSnapshotChunk: RequestLoadSnapshotChunk;
    } | {
        oneofKind: "applySnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15
         */
        applySnapshotChunk: RequestApplySnapshotChunk;
    } | {
        oneofKind: "prepareProposal";
        /**
         * @generated from protobuf field: tendermint.abci.RequestPrepareProposal prepare_proposal = 16
         */
        prepareProposal: RequestPrepareProposal;
    } | {
        oneofKind: "processProposal";
        /**
         * @generated from protobuf field: tendermint.abci.RequestProcessProposal process_proposal = 17
         */
        processProposal: RequestProcessProposal;
    } | {
        oneofKind: "extendVote";
        /**
         * @generated from protobuf field: tendermint.abci.RequestExtendVote extend_vote = 18
         */
        extendVote: RequestExtendVote;
    } | {
        oneofKind: "verifyVoteExtension";
        /**
         * @generated from protobuf field: tendermint.abci.RequestVerifyVoteExtension verify_vote_extension = 19
         */
        verifyVoteExtension: RequestVerifyVoteExtension;
    } | {
        oneofKind: "finalizeBlock";
        /**
         * @generated from protobuf field: tendermint.abci.RequestFinalizeBlock finalize_block = 20
         */
        finalizeBlock: RequestFinalizeBlock;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message tendermint.abci.RequestEcho
 */
export interface RequestEcho {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message tendermint.abci.RequestFlush
 */
export interface RequestFlush {
}
/**
 * @generated from protobuf message tendermint.abci.RequestInfo
 */
export interface RequestInfo {
    /**
     * @generated from protobuf field: string version = 1
     */
    version: string;
    /**
     * @generated from protobuf field: uint64 block_version = 2
     */
    blockVersion: bigint;
    /**
     * @generated from protobuf field: uint64 p2p_version = 3
     */
    p2PVersion: bigint;
    /**
     * @generated from protobuf field: string abci_version = 4
     */
    abciVersion: string;
}
/**
 * @generated from protobuf message tendermint.abci.RequestInitChain
 */
export interface RequestInitChain {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 1
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: string chain_id = 2
     */
    chainId: string;
    /**
     * @generated from protobuf field: tendermint.types.ConsensusParams consensus_params = 3
     */
    consensusParams?: ConsensusParams;
    /**
     * @generated from protobuf field: repeated tendermint.abci.ValidatorUpdate validators = 4
     */
    validators: ValidatorUpdate[];
    /**
     * @generated from protobuf field: bytes app_state_bytes = 5
     */
    appStateBytes: Uint8Array;
    /**
     * @generated from protobuf field: int64 initial_height = 6
     */
    initialHeight: bigint;
}
/**
 * @generated from protobuf message tendermint.abci.RequestQuery
 */
export interface RequestQuery {
    /**
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: int64 height = 3
     */
    height: bigint;
    /**
     * @generated from protobuf field: bool prove = 4
     */
    prove: boolean;
}
/**
 * @generated from protobuf message tendermint.abci.RequestCheckTx
 */
export interface RequestCheckTx {
    /**
     * @generated from protobuf field: bytes tx = 1
     */
    tx: Uint8Array;
    /**
     * @generated from protobuf field: tendermint.abci.CheckTxType type = 2
     */
    type: CheckTxType;
}
/**
 * @generated from protobuf message tendermint.abci.RequestCommit
 */
export interface RequestCommit {
}
/**
 * lists available snapshots
 *
 * @generated from protobuf message tendermint.abci.RequestListSnapshots
 */
export interface RequestListSnapshots {
}
/**
 * offers a snapshot to the application
 *
 * @generated from protobuf message tendermint.abci.RequestOfferSnapshot
 */
export interface RequestOfferSnapshot {
    /**
     * @generated from protobuf field: tendermint.abci.Snapshot snapshot = 1
     */
    snapshot?: Snapshot; // snapshot offered by peers
    /**
     * @generated from protobuf field: bytes app_hash = 2
     */
    appHash: Uint8Array; // light client-verified app hash for snapshot height
}
/**
 * loads a snapshot chunk
 *
 * @generated from protobuf message tendermint.abci.RequestLoadSnapshotChunk
 */
export interface RequestLoadSnapshotChunk {
    /**
     * @generated from protobuf field: uint64 height = 1
     */
    height: bigint;
    /**
     * @generated from protobuf field: uint32 format = 2
     */
    format: number;
    /**
     * @generated from protobuf field: uint32 chunk = 3
     */
    chunk: number;
}
/**
 * Applies a snapshot chunk
 *
 * @generated from protobuf message tendermint.abci.RequestApplySnapshotChunk
 */
export interface RequestApplySnapshotChunk {
    /**
     * @generated from protobuf field: uint32 index = 1
     */
    index: number;
    /**
     * @generated from protobuf field: bytes chunk = 2
     */
    chunk: Uint8Array;
    /**
     * @generated from protobuf field: string sender = 3
     */
    sender: string;
}
/**
 * @generated from protobuf message tendermint.abci.RequestPrepareProposal
 */
export interface RequestPrepareProposal {
    /**
     * the modified transactions cannot exceed this size.
     *
     * @generated from protobuf field: int64 max_tx_bytes = 1
     */
    maxTxBytes: bigint;
    /**
     * txs is an array of transactions that will be included in a block,
     * sent to the app for possible modifications.
     *
     * @generated from protobuf field: repeated bytes txs = 2
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: tendermint.abci.ExtendedCommitInfo local_last_commit = 3
     */
    localLastCommit?: ExtendedCommitInfo;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Misbehavior misbehavior = 4
     */
    misbehavior: Misbehavior[];
    /**
     * @generated from protobuf field: int64 height = 5
     */
    height: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * address of the public key of the validator proposing the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.RequestProcessProposal
 */
export interface RequestProcessProposal {
    /**
     * @generated from protobuf field: repeated bytes txs = 1
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: tendermint.abci.CommitInfo proposed_last_commit = 2
     */
    proposedLastCommit?: CommitInfo;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Misbehavior misbehavior = 3
     */
    misbehavior: Misbehavior[];
    /**
     * hash is the merkle root hash of the fields of the proposed block.
     *
     * @generated from protobuf field: bytes hash = 4
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: int64 height = 5
     */
    height: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * address of the public key of the original proposer of the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
}
/**
 * Extends a vote with application-injected data
 *
 * @generated from protobuf message tendermint.abci.RequestExtendVote
 */
export interface RequestExtendVote {
    /**
     * the hash of the block that this vote may be referring to
     *
     * @generated from protobuf field: bytes hash = 1
     */
    hash: Uint8Array;
    /**
     * the height of the extended vote
     *
     * @generated from protobuf field: int64 height = 2
     */
    height: bigint;
    /**
     * info of the block that this vote may be referring to
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 3
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: repeated bytes txs = 4
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: tendermint.abci.CommitInfo proposed_last_commit = 5
     */
    proposedLastCommit?: CommitInfo;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Misbehavior misbehavior = 6
     */
    misbehavior: Misbehavior[];
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * address of the public key of the original proposer of the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
}
/**
 * Verify the vote extension
 *
 * @generated from protobuf message tendermint.abci.RequestVerifyVoteExtension
 */
export interface RequestVerifyVoteExtension {
    /**
     * the hash of the block that this received vote corresponds to
     *
     * @generated from protobuf field: bytes hash = 1
     */
    hash: Uint8Array;
    /**
     * the validator that signed the vote extension
     *
     * @generated from protobuf field: bytes validator_address = 2
     */
    validatorAddress: Uint8Array;
    /**
     * @generated from protobuf field: int64 height = 3
     */
    height: bigint;
    /**
     * @generated from protobuf field: bytes vote_extension = 4
     */
    voteExtension: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.RequestFinalizeBlock
 */
export interface RequestFinalizeBlock {
    /**
     * @generated from protobuf field: repeated bytes txs = 1
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: tendermint.abci.CommitInfo decided_last_commit = 2
     */
    decidedLastCommit?: CommitInfo;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Misbehavior misbehavior = 3
     */
    misbehavior: Misbehavior[];
    /**
     * hash is the merkle root hash of the fields of the decided block.
     *
     * @generated from protobuf field: bytes hash = 4
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: int64 height = 5
     */
    height: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * proposer_address is the address of the public key of the original proposer of the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
}
// ----------------------------------------
// Response types

/**
 * @generated from protobuf message tendermint.abci.Response
 */
export interface Response {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "exception";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseException exception = 1
         */
        exception: ResponseException;
    } | {
        oneofKind: "echo";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseEcho echo = 2
         */
        echo: ResponseEcho;
    } | {
        oneofKind: "flush";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseFlush flush = 3
         */
        flush: ResponseFlush;
    } | {
        oneofKind: "info";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseInfo info = 4
         */
        info: ResponseInfo;
    } | {
        oneofKind: "initChain";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseInitChain init_chain = 6
         */
        initChain: ResponseInitChain;
    } | {
        oneofKind: "query";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseQuery query = 7
         */
        query: ResponseQuery;
    } | {
        oneofKind: "checkTx";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseCheckTx check_tx = 9
         */
        checkTx: ResponseCheckTx;
    } | {
        oneofKind: "commit";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseCommit commit = 12
         */
        commit: ResponseCommit;
    } | {
        oneofKind: "listSnapshots";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseListSnapshots list_snapshots = 13
         */
        listSnapshots: ResponseListSnapshots;
    } | {
        oneofKind: "offerSnapshot";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14
         */
        offerSnapshot: ResponseOfferSnapshot;
    } | {
        oneofKind: "loadSnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15
         */
        loadSnapshotChunk: ResponseLoadSnapshotChunk;
    } | {
        oneofKind: "applySnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16
         */
        applySnapshotChunk: ResponseApplySnapshotChunk;
    } | {
        oneofKind: "prepareProposal";
        /**
         * @generated from protobuf field: tendermint.abci.ResponsePrepareProposal prepare_proposal = 17
         */
        prepareProposal: ResponsePrepareProposal;
    } | {
        oneofKind: "processProposal";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseProcessProposal process_proposal = 18
         */
        processProposal: ResponseProcessProposal;
    } | {
        oneofKind: "extendVote";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseExtendVote extend_vote = 19
         */
        extendVote: ResponseExtendVote;
    } | {
        oneofKind: "verifyVoteExtension";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseVerifyVoteExtension verify_vote_extension = 20
         */
        verifyVoteExtension: ResponseVerifyVoteExtension;
    } | {
        oneofKind: "finalizeBlock";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseFinalizeBlock finalize_block = 21
         */
        finalizeBlock: ResponseFinalizeBlock;
    } | {
        oneofKind: undefined;
    };
}
/**
 * nondeterministic
 *
 * @generated from protobuf message tendermint.abci.ResponseException
 */
export interface ResponseException {
    /**
     * @generated from protobuf field: string error = 1
     */
    error: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseEcho
 */
export interface ResponseEcho {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseFlush
 */
export interface ResponseFlush {
}
/**
 * @generated from protobuf message tendermint.abci.ResponseInfo
 */
export interface ResponseInfo {
    /**
     * @generated from protobuf field: string data = 1
     */
    data: string;
    /**
     * @generated from protobuf field: string version = 2
     */
    version: string;
    /**
     * @generated from protobuf field: uint64 app_version = 3
     */
    appVersion: bigint;
    /**
     * @generated from protobuf field: int64 last_block_height = 4
     */
    lastBlockHeight: bigint;
    /**
     * @generated from protobuf field: bytes last_block_app_hash = 5
     */
    lastBlockAppHash: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseInitChain
 */
export interface ResponseInitChain {
    /**
     * @generated from protobuf field: tendermint.types.ConsensusParams consensus_params = 1
     */
    consensusParams?: ConsensusParams;
    /**
     * @generated from protobuf field: repeated tendermint.abci.ValidatorUpdate validators = 2
     */
    validators: ValidatorUpdate[];
    /**
     * @generated from protobuf field: bytes app_hash = 3
     */
    appHash: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseQuery
 */
export interface ResponseQuery {
    /**
     * @generated from protobuf field: uint32 code = 1
     */
    code: number;
    /**
     * bytes data = 2; // use "value" instead.
     *
     * @generated from protobuf field: string log = 3
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 index = 5
     */
    index: bigint;
    /**
     * @generated from protobuf field: bytes key = 6
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 7
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: tendermint.crypto.ProofOps proof_ops = 8
     */
    proofOps?: ProofOps;
    /**
     * @generated from protobuf field: int64 height = 9
     */
    height: bigint;
    /**
     * @generated from protobuf field: string codespace = 10
     */
    codespace: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseCheckTx
 */
export interface ResponseCheckTx {
    /**
     * @generated from protobuf field: uint32 code = 1
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string log = 3
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 gas_wanted = 5 [json_name = "gas_wanted"]
     */
    gasWanted: bigint;
    /**
     * @generated from protobuf field: int64 gas_used = 6 [json_name = "gas_used"]
     */
    gasUsed: bigint;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Event events = 7
     */
    events: Event[];
    /**
     * @generated from protobuf field: string codespace = 8
     */
    codespace: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseCommit
 */
export interface ResponseCommit {
    /**
     * @generated from protobuf field: int64 retain_height = 3
     */
    retainHeight: bigint;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseListSnapshots
 */
export interface ResponseListSnapshots {
    /**
     * @generated from protobuf field: repeated tendermint.abci.Snapshot snapshots = 1
     */
    snapshots: Snapshot[];
}
/**
 * @generated from protobuf message tendermint.abci.ResponseOfferSnapshot
 */
export interface ResponseOfferSnapshot {
    /**
     * @generated from protobuf field: tendermint.abci.ResponseOfferSnapshot.Result result = 1
     */
    result: ResponseOfferSnapshot_Result;
}
/**
 * @generated from protobuf enum tendermint.abci.ResponseOfferSnapshot.Result
 */
export enum ResponseOfferSnapshot_Result {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Snapshot accepted, apply chunks
     *
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: ABORT = 2;
     */
    ABORT = 2,
    /**
     * Reject this specific snapshot, try others
     *
     * @generated from protobuf enum value: REJECT = 3;
     */
    REJECT = 3,
    /**
     * Reject all snapshots of this format, try others
     *
     * @generated from protobuf enum value: REJECT_FORMAT = 4;
     */
    REJECT_FORMAT = 4,
    /**
     * Reject all snapshots from the sender(s), try others
     *
     * @generated from protobuf enum value: REJECT_SENDER = 5;
     */
    REJECT_SENDER = 5
}
/**
 * @generated from protobuf message tendermint.abci.ResponseLoadSnapshotChunk
 */
export interface ResponseLoadSnapshotChunk {
    /**
     * @generated from protobuf field: bytes chunk = 1
     */
    chunk: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseApplySnapshotChunk
 */
export interface ResponseApplySnapshotChunk {
    /**
     * @generated from protobuf field: tendermint.abci.ResponseApplySnapshotChunk.Result result = 1
     */
    result: ResponseApplySnapshotChunk_Result;
    /**
     * @generated from protobuf field: repeated uint32 refetch_chunks = 2
     */
    refetchChunks: number[]; // Chunks to refetch and reapply
    /**
     * @generated from protobuf field: repeated string reject_senders = 3
     */
    rejectSenders: string[]; // Chunk senders to reject and ban
}
/**
 * @generated from protobuf enum tendermint.abci.ResponseApplySnapshotChunk.Result
 */
export enum ResponseApplySnapshotChunk_Result {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Chunk successfully accepted
     *
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: ABORT = 2;
     */
    ABORT = 2,
    /**
     * Retry chunk (combine with refetch and reject)
     *
     * @generated from protobuf enum value: RETRY = 3;
     */
    RETRY = 3,
    /**
     * Retry snapshot (combine with refetch and reject)
     *
     * @generated from protobuf enum value: RETRY_SNAPSHOT = 4;
     */
    RETRY_SNAPSHOT = 4,
    /**
     * Reject this snapshot, try others
     *
     * @generated from protobuf enum value: REJECT_SNAPSHOT = 5;
     */
    REJECT_SNAPSHOT = 5
}
/**
 * @generated from protobuf message tendermint.abci.ResponsePrepareProposal
 */
export interface ResponsePrepareProposal {
    /**
     * @generated from protobuf field: repeated bytes txs = 1
     */
    txs: Uint8Array[];
}
/**
 * @generated from protobuf message tendermint.abci.ResponseProcessProposal
 */
export interface ResponseProcessProposal {
    /**
     * @generated from protobuf field: tendermint.abci.ResponseProcessProposal.ProposalStatus status = 1
     */
    status: ResponseProcessProposal_ProposalStatus;
}
/**
 * @generated from protobuf enum tendermint.abci.ResponseProcessProposal.ProposalStatus
 */
export enum ResponseProcessProposal_ProposalStatus {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * @generated from protobuf enum value: REJECT = 2;
     */
    REJECT = 2
}
/**
 * @generated from protobuf message tendermint.abci.ResponseExtendVote
 */
export interface ResponseExtendVote {
    /**
     * @generated from protobuf field: bytes vote_extension = 1
     */
    voteExtension: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseVerifyVoteExtension
 */
export interface ResponseVerifyVoteExtension {
    /**
     * @generated from protobuf field: tendermint.abci.ResponseVerifyVoteExtension.VerifyStatus status = 1
     */
    status: ResponseVerifyVoteExtension_VerifyStatus;
}
/**
 * @generated from protobuf enum tendermint.abci.ResponseVerifyVoteExtension.VerifyStatus
 */
export enum ResponseVerifyVoteExtension_VerifyStatus {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Rejecting the vote extension will reject the entire precommit by the sender.
     * Incorrectly implementing this thus has liveness implications as it may affect
     * CometBFT's ability to receive 2/3+ valid votes to finalize the block.
     * Honest nodes should never be rejected.
     *
     * @generated from protobuf enum value: REJECT = 2;
     */
    REJECT = 2
}
/**
 * @generated from protobuf message tendermint.abci.ResponseFinalizeBlock
 */
export interface ResponseFinalizeBlock {
    /**
     * set of block events emitted as part of executing the block
     *
     * @generated from protobuf field: repeated tendermint.abci.Event events = 1
     */
    events: Event[];
    /**
     * the result of executing each transaction including the events
     * the particular transaction emitted. This should match the order
     * of the transactions delivered in the block itself
     *
     * @generated from protobuf field: repeated tendermint.abci.ExecTxResult tx_results = 2
     */
    txResults: ExecTxResult[];
    /**
     * a list of updates to the validator set. These will reflect the validator set at current height + 2.
     *
     * @generated from protobuf field: repeated tendermint.abci.ValidatorUpdate validator_updates = 3
     */
    validatorUpdates: ValidatorUpdate[];
    /**
     * updates to the consensus params, if any.
     *
     * @generated from protobuf field: tendermint.types.ConsensusParams consensus_param_updates = 4
     */
    consensusParamUpdates?: ConsensusParams;
    /**
     * app_hash is the hash of the applications' state which is used to confirm that execution of the transactions was deterministic. It is up to the application to decide which algorithm to use.
     *
     * @generated from protobuf field: bytes app_hash = 5
     */
    appHash: Uint8Array;
}
// ----------------------------------------
// Misc.

/**
 * @generated from protobuf message tendermint.abci.CommitInfo
 */
export interface CommitInfo {
    /**
     * @generated from protobuf field: int32 round = 1
     */
    round: number;
    /**
     * @generated from protobuf field: repeated tendermint.abci.VoteInfo votes = 2
     */
    votes: VoteInfo[];
}
/**
 * ExtendedCommitInfo is similar to CommitInfo except that it is only used in
 * the PrepareProposal request such that CometBFT can provide vote extensions
 * to the application.
 *
 * @generated from protobuf message tendermint.abci.ExtendedCommitInfo
 */
export interface ExtendedCommitInfo {
    /**
     * The round at which the block proposer decided in the previous height.
     *
     * @generated from protobuf field: int32 round = 1
     */
    round: number;
    /**
     * List of validators' addresses in the last validator set with their voting
     * information, including vote extensions.
     *
     * @generated from protobuf field: repeated tendermint.abci.ExtendedVoteInfo votes = 2
     */
    votes: ExtendedVoteInfo[];
}
/**
 * Event allows application developers to attach additional information to
 * ResponseFinalizeBlock and ResponseCheckTx.
 * Later, transactions may be queried using these events.
 *
 * @generated from protobuf message tendermint.abci.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: string type = 1
     */
    type: string;
    /**
     * @generated from protobuf field: repeated tendermint.abci.EventAttribute attributes = 2
     */
    attributes: EventAttribute[];
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 *
 * @generated from protobuf message tendermint.abci.EventAttribute
 */
export interface EventAttribute {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2
     */
    value: string;
    /**
     * @generated from protobuf field: bool index = 3
     */
    index: boolean; // nondeterministic
}
/**
 * ExecTxResult contains results of executing one individual transaction.
 *
 * * Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted
 *
 * @generated from protobuf message tendermint.abci.ExecTxResult
 */
export interface ExecTxResult {
    /**
     * @generated from protobuf field: uint32 code = 1
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string log = 3
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 gas_wanted = 5 [json_name = "gas_wanted"]
     */
    gasWanted: bigint;
    /**
     * @generated from protobuf field: int64 gas_used = 6 [json_name = "gas_used"]
     */
    gasUsed: bigint;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Event events = 7
     */
    events: Event[]; // nondeterministic
    /**
     * @generated from protobuf field: string codespace = 8
     */
    codespace: string;
}
/**
 * TxResult contains results of executing the transaction.
 *
 * One usage is indexing transaction results.
 *
 * @generated from protobuf message tendermint.abci.TxResult
 */
export interface TxResult {
    /**
     * @generated from protobuf field: int64 height = 1
     */
    height: bigint;
    /**
     * @generated from protobuf field: uint32 index = 2
     */
    index: number;
    /**
     * @generated from protobuf field: bytes tx = 3
     */
    tx: Uint8Array;
    /**
     * @generated from protobuf field: tendermint.abci.ExecTxResult result = 4
     */
    result?: ExecTxResult;
}
// ----------------------------------------
// Blockchain Types

/**
 * @generated from protobuf message tendermint.abci.Validator
 */
export interface Validator {
    /**
     * @generated from protobuf field: bytes address = 1
     */
    address: Uint8Array; // The first 20 bytes of SHA256(public key)
    /**
     * PubKey pub_key = 2 [(gogoproto.nullable)=false];
     *
     * @generated from protobuf field: int64 power = 3
     */
    power: bigint; // The voting power
}
/**
 * @generated from protobuf message tendermint.abci.ValidatorUpdate
 */
export interface ValidatorUpdate {
    /**
     * @generated from protobuf field: tendermint.crypto.PublicKey pub_key = 1
     */
    pubKey?: PublicKey;
    /**
     * @generated from protobuf field: int64 power = 2
     */
    power: bigint;
}
/**
 * @generated from protobuf message tendermint.abci.VoteInfo
 */
export interface VoteInfo {
    /**
     * @generated from protobuf field: tendermint.abci.Validator validator = 1
     */
    validator?: Validator;
    /**
     * @generated from protobuf field: tendermint.types.BlockIDFlag block_id_flag = 3
     */
    blockIdFlag: BlockIDFlag;
}
/**
 * @generated from protobuf message tendermint.abci.ExtendedVoteInfo
 */
export interface ExtendedVoteInfo {
    /**
     * The validator that sent the vote.
     *
     * @generated from protobuf field: tendermint.abci.Validator validator = 1
     */
    validator?: Validator;
    /**
     * Non-deterministic extension provided by the sending validator's application.
     *
     * @generated from protobuf field: bytes vote_extension = 3
     */
    voteExtension: Uint8Array;
    /**
     * Vote extension signature created by CometBFT
     *
     * @generated from protobuf field: bytes extension_signature = 4
     */
    extensionSignature: Uint8Array;
    /**
     * block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all
     *
     * @generated from protobuf field: tendermint.types.BlockIDFlag block_id_flag = 5
     */
    blockIdFlag: BlockIDFlag;
}
/**
 * @generated from protobuf message tendermint.abci.Misbehavior
 */
export interface Misbehavior {
    /**
     * @generated from protobuf field: tendermint.abci.MisbehaviorType type = 1
     */
    type: MisbehaviorType;
    /**
     * The offending validator
     *
     * @generated from protobuf field: tendermint.abci.Validator validator = 2
     */
    validator?: Validator;
    /**
     * The height when the offense occurred
     *
     * @generated from protobuf field: int64 height = 3
     */
    height: bigint;
    /**
     * The corresponding time where the offense occurred
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 4
     */
    time?: Timestamp;
    /**
     * Total voting power of the validator set in case the ABCI application does
     * not store historical validators.
     * https://github.com/tendermint/tendermint/issues/4581
     *
     * @generated from protobuf field: int64 total_voting_power = 5
     */
    totalVotingPower: bigint;
}
// ----------------------------------------
// State Sync Types

/**
 * @generated from protobuf message tendermint.abci.Snapshot
 */
export interface Snapshot {
    /**
     * @generated from protobuf field: uint64 height = 1
     */
    height: bigint; // The height at which the snapshot was taken
    /**
     * @generated from protobuf field: uint32 format = 2
     */
    format: number; // The application-specific snapshot format
    /**
     * @generated from protobuf field: uint32 chunks = 3
     */
    chunks: number; // Number of chunks in the snapshot
    /**
     * @generated from protobuf field: bytes hash = 4
     */
    hash: Uint8Array; // Arbitrary snapshot hash, equal only if identical
    /**
     * @generated from protobuf field: bytes metadata = 5
     */
    metadata: Uint8Array; // Arbitrary application metadata
}
/**
 * @generated from protobuf enum tendermint.abci.CheckTxType
 */
export enum CheckTxType {
    /**
     * @generated from protobuf enum value: NEW = 0;
     */
    NEW = 0,
    /**
     * @generated from protobuf enum value: RECHECK = 1;
     */
    RECHECK = 1
}
/**
 * @generated from protobuf enum tendermint.abci.MisbehaviorType
 */
export enum MisbehaviorType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: DUPLICATE_VOTE = 1;
     */
    DUPLICATE_VOTE = 1,
    /**
     * @generated from protobuf enum value: LIGHT_CLIENT_ATTACK = 2;
     */
    LIGHT_CLIENT_ATTACK = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Request$Type extends MessageType<Request> {
    constructor() {
        super("tendermint.abci.Request", [
            { no: 1, name: "echo", kind: "message", oneof: "value", T: () => RequestEcho },
            { no: 2, name: "flush", kind: "message", oneof: "value", T: () => RequestFlush },
            { no: 3, name: "info", kind: "message", oneof: "value", T: () => RequestInfo },
            { no: 5, name: "init_chain", kind: "message", oneof: "value", T: () => RequestInitChain },
            { no: 6, name: "query", kind: "message", oneof: "value", T: () => RequestQuery },
            { no: 8, name: "check_tx", kind: "message", oneof: "value", T: () => RequestCheckTx },
            { no: 11, name: "commit", kind: "message", oneof: "value", T: () => RequestCommit },
            { no: 12, name: "list_snapshots", kind: "message", oneof: "value", T: () => RequestListSnapshots },
            { no: 13, name: "offer_snapshot", kind: "message", oneof: "value", T: () => RequestOfferSnapshot },
            { no: 14, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestLoadSnapshotChunk },
            { no: 15, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestApplySnapshotChunk },
            { no: 16, name: "prepare_proposal", kind: "message", oneof: "value", T: () => RequestPrepareProposal },
            { no: 17, name: "process_proposal", kind: "message", oneof: "value", T: () => RequestProcessProposal },
            { no: 18, name: "extend_vote", kind: "message", oneof: "value", T: () => RequestExtendVote },
            { no: 19, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => RequestVerifyVoteExtension },
            { no: 20, name: "finalize_block", kind: "message", oneof: "value", T: () => RequestFinalizeBlock }
        ]);
    }
    create(value?: PartialMessage<Request>): Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Request): Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.RequestEcho echo */ 1:
                    message.value = {
                        oneofKind: "echo",
                        echo: RequestEcho.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).echo)
                    };
                    break;
                case /* tendermint.abci.RequestFlush flush */ 2:
                    message.value = {
                        oneofKind: "flush",
                        flush: RequestFlush.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).flush)
                    };
                    break;
                case /* tendermint.abci.RequestInfo info */ 3:
                    message.value = {
                        oneofKind: "info",
                        info: RequestInfo.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).info)
                    };
                    break;
                case /* tendermint.abci.RequestInitChain init_chain */ 5:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: RequestInitChain.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).initChain)
                    };
                    break;
                case /* tendermint.abci.RequestQuery query */ 6:
                    message.value = {
                        oneofKind: "query",
                        query: RequestQuery.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).query)
                    };
                    break;
                case /* tendermint.abci.RequestCheckTx check_tx */ 8:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: RequestCheckTx.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).checkTx)
                    };
                    break;
                case /* tendermint.abci.RequestCommit commit */ 11:
                    message.value = {
                        oneofKind: "commit",
                        commit: RequestCommit.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).commit)
                    };
                    break;
                case /* tendermint.abci.RequestListSnapshots list_snapshots */ 12:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: RequestListSnapshots.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).listSnapshots)
                    };
                    break;
                case /* tendermint.abci.RequestOfferSnapshot offer_snapshot */ 13:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: RequestOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).offerSnapshot)
                    };
                    break;
                case /* tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk */ 14:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: RequestLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).loadSnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: RequestApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).applySnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.RequestPrepareProposal prepare_proposal */ 16:
                    message.value = {
                        oneofKind: "prepareProposal",
                        prepareProposal: RequestPrepareProposal.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).prepareProposal)
                    };
                    break;
                case /* tendermint.abci.RequestProcessProposal process_proposal */ 17:
                    message.value = {
                        oneofKind: "processProposal",
                        processProposal: RequestProcessProposal.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).processProposal)
                    };
                    break;
                case /* tendermint.abci.RequestExtendVote extend_vote */ 18:
                    message.value = {
                        oneofKind: "extendVote",
                        extendVote: RequestExtendVote.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).extendVote)
                    };
                    break;
                case /* tendermint.abci.RequestVerifyVoteExtension verify_vote_extension */ 19:
                    message.value = {
                        oneofKind: "verifyVoteExtension",
                        verifyVoteExtension: RequestVerifyVoteExtension.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).verifyVoteExtension)
                    };
                    break;
                case /* tendermint.abci.RequestFinalizeBlock finalize_block */ 20:
                    message.value = {
                        oneofKind: "finalizeBlock",
                        finalizeBlock: RequestFinalizeBlock.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).finalizeBlock)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.RequestEcho echo = 1; */
        if (message.value.oneofKind === "echo")
            RequestEcho.internalBinaryWrite(message.value.echo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestFlush flush = 2; */
        if (message.value.oneofKind === "flush")
            RequestFlush.internalBinaryWrite(message.value.flush, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestInfo info = 3; */
        if (message.value.oneofKind === "info")
            RequestInfo.internalBinaryWrite(message.value.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestInitChain init_chain = 5; */
        if (message.value.oneofKind === "initChain")
            RequestInitChain.internalBinaryWrite(message.value.initChain, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestQuery query = 6; */
        if (message.value.oneofKind === "query")
            RequestQuery.internalBinaryWrite(message.value.query, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestCheckTx check_tx = 8; */
        if (message.value.oneofKind === "checkTx")
            RequestCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestCommit commit = 11; */
        if (message.value.oneofKind === "commit")
            RequestCommit.internalBinaryWrite(message.value.commit, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestListSnapshots list_snapshots = 12; */
        if (message.value.oneofKind === "listSnapshots")
            RequestListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestOfferSnapshot offer_snapshot = 13; */
        if (message.value.oneofKind === "offerSnapshot")
            RequestOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            RequestLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15; */
        if (message.value.oneofKind === "applySnapshotChunk")
            RequestApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestPrepareProposal prepare_proposal = 16; */
        if (message.value.oneofKind === "prepareProposal")
            RequestPrepareProposal.internalBinaryWrite(message.value.prepareProposal, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestProcessProposal process_proposal = 17; */
        if (message.value.oneofKind === "processProposal")
            RequestProcessProposal.internalBinaryWrite(message.value.processProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestExtendVote extend_vote = 18; */
        if (message.value.oneofKind === "extendVote")
            RequestExtendVote.internalBinaryWrite(message.value.extendVote, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestVerifyVoteExtension verify_vote_extension = 19; */
        if (message.value.oneofKind === "verifyVoteExtension")
            RequestVerifyVoteExtension.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestFinalizeBlock finalize_block = 20; */
        if (message.value.oneofKind === "finalizeBlock")
            RequestFinalizeBlock.internalBinaryWrite(message.value.finalizeBlock, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Request
 */
export const Request = new Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestEcho$Type extends MessageType<RequestEcho> {
    constructor() {
        super("tendermint.abci.RequestEcho", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestEcho>): RequestEcho {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RequestEcho>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestEcho): RequestEcho {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestEcho, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestEcho
 */
export const RequestEcho = new RequestEcho$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestFlush$Type extends MessageType<RequestFlush> {
    constructor() {
        super("tendermint.abci.RequestFlush", []);
    }
    create(value?: PartialMessage<RequestFlush>): RequestFlush {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RequestFlush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestFlush): RequestFlush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestFlush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestFlush
 */
export const RequestFlush = new RequestFlush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestInfo$Type extends MessageType<RequestInfo> {
    constructor() {
        super("tendermint.abci.RequestInfo", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "p2p_version", kind: "scalar", jsonName: "p2pVersion", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "abci_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestInfo>): RequestInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.blockVersion = 0n;
        message.p2PVersion = 0n;
        message.abciVersion = "";
        if (value !== undefined)
            reflectionMergePartial<RequestInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestInfo): RequestInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* uint64 block_version */ 2:
                    message.blockVersion = reader.uint64().toBigInt();
                    break;
                case /* uint64 p2p_version */ 3:
                    message.p2PVersion = reader.uint64().toBigInt();
                    break;
                case /* string abci_version */ 4:
                    message.abciVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* uint64 block_version = 2; */
        if (message.blockVersion !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockVersion);
        /* uint64 p2p_version = 3; */
        if (message.p2PVersion !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.p2PVersion);
        /* string abci_version = 4; */
        if (message.abciVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.abciVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestInfo
 */
export const RequestInfo = new RequestInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestInitChain$Type extends MessageType<RequestInitChain> {
    constructor() {
        super("tendermint.abci.RequestInitChain", [
            { no: 1, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 2, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 4, name: "validators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 5, name: "app_state_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "initial_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RequestInitChain>): RequestInitChain {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = "";
        message.validators = [];
        message.appStateBytes = new Uint8Array(0);
        message.initialHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<RequestInitChain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestInitChain): RequestInitChain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp time */ 1:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string chain_id */ 2:
                    message.chainId = reader.string();
                    break;
                case /* tendermint.types.ConsensusParams consensus_params */ 3:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated tendermint.abci.ValidatorUpdate validators */ 4:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_state_bytes */ 5:
                    message.appStateBytes = reader.bytes();
                    break;
                case /* int64 initial_height */ 6:
                    message.initialHeight = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestInitChain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp time = 1; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string chain_id = 2; */
        if (message.chainId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chainId);
        /* tendermint.types.ConsensusParams consensus_params = 3; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ValidatorUpdate validators = 4; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_state_bytes = 5; */
        if (message.appStateBytes.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.appStateBytes);
        /* int64 initial_height = 6; */
        if (message.initialHeight !== 0n)
            writer.tag(6, WireType.Varint).int64(message.initialHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestInitChain
 */
export const RequestInitChain = new RequestInitChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestQuery$Type extends MessageType<RequestQuery> {
    constructor() {
        super("tendermint.abci.RequestQuery", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "prove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RequestQuery>): RequestQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.path = "";
        message.height = 0n;
        message.prove = false;
        if (value !== undefined)
            reflectionMergePartial<RequestQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestQuery): RequestQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* bool prove */ 4:
                    message.prove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* int64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).int64(message.height);
        /* bool prove = 4; */
        if (message.prove !== false)
            writer.tag(4, WireType.Varint).bool(message.prove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestQuery
 */
export const RequestQuery = new RequestQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestCheckTx$Type extends MessageType<RequestCheckTx> {
    constructor() {
        super("tendermint.abci.RequestCheckTx", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["tendermint.abci.CheckTxType", CheckTxType] }
        ]);
    }
    create(value?: PartialMessage<RequestCheckTx>): RequestCheckTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tx = new Uint8Array(0);
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<RequestCheckTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestCheckTx): RequestCheckTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                case /* tendermint.abci.CheckTxType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestCheckTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        /* tendermint.abci.CheckTxType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestCheckTx
 */
export const RequestCheckTx = new RequestCheckTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestCommit$Type extends MessageType<RequestCommit> {
    constructor() {
        super("tendermint.abci.RequestCommit", []);
    }
    create(value?: PartialMessage<RequestCommit>): RequestCommit {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RequestCommit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestCommit): RequestCommit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestCommit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestCommit
 */
export const RequestCommit = new RequestCommit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestListSnapshots$Type extends MessageType<RequestListSnapshots> {
    constructor() {
        super("tendermint.abci.RequestListSnapshots", []);
    }
    create(value?: PartialMessage<RequestListSnapshots>): RequestListSnapshots {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RequestListSnapshots>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestListSnapshots): RequestListSnapshots {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestListSnapshots, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestListSnapshots
 */
export const RequestListSnapshots = new RequestListSnapshots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestOfferSnapshot$Type extends MessageType<RequestOfferSnapshot> {
    constructor() {
        super("tendermint.abci.RequestOfferSnapshot", [
            { no: 1, name: "snapshot", kind: "message", T: () => Snapshot },
            { no: 2, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestOfferSnapshot>): RequestOfferSnapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RequestOfferSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestOfferSnapshot): RequestOfferSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.Snapshot snapshot */ 1:
                    message.snapshot = Snapshot.internalBinaryRead(reader, reader.uint32(), options, message.snapshot);
                    break;
                case /* bytes app_hash */ 2:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestOfferSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.Snapshot snapshot = 1; */
        if (message.snapshot)
            Snapshot.internalBinaryWrite(message.snapshot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 2; */
        if (message.appHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestOfferSnapshot
 */
export const RequestOfferSnapshot = new RequestOfferSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestLoadSnapshotChunk$Type extends MessageType<RequestLoadSnapshotChunk> {
    constructor() {
        super("tendermint.abci.RequestLoadSnapshotChunk", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunk", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RequestLoadSnapshotChunk>): RequestLoadSnapshotChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.format = 0;
        message.chunk = 0;
        if (value !== undefined)
            reflectionMergePartial<RequestLoadSnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestLoadSnapshotChunk): RequestLoadSnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunk */ 3:
                    message.chunk = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestLoadSnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunk = 3; */
        if (message.chunk !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestLoadSnapshotChunk
 */
export const RequestLoadSnapshotChunk = new RequestLoadSnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestApplySnapshotChunk$Type extends MessageType<RequestApplySnapshotChunk> {
    constructor() {
        super("tendermint.abci.RequestApplySnapshotChunk", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestApplySnapshotChunk>): RequestApplySnapshotChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0;
        message.chunk = new Uint8Array(0);
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<RequestApplySnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestApplySnapshotChunk): RequestApplySnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* bytes chunk */ 2:
                    message.chunk = reader.bytes();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestApplySnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).uint32(message.index);
        /* bytes chunk = 2; */
        if (message.chunk.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chunk);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestApplySnapshotChunk
 */
export const RequestApplySnapshotChunk = new RequestApplySnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestPrepareProposal$Type extends MessageType<RequestPrepareProposal> {
    constructor() {
        super("tendermint.abci.RequestPrepareProposal", [
            { no: 1, name: "max_tx_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "local_last_commit", kind: "message", T: () => ExtendedCommitInfo, options: { "gogoproto.nullable": false } },
            { no: 4, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 5, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestPrepareProposal>): RequestPrepareProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxTxBytes = 0n;
        message.txs = [];
        message.misbehavior = [];
        message.height = 0n;
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RequestPrepareProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestPrepareProposal): RequestPrepareProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 max_tx_bytes */ 1:
                    message.maxTxBytes = reader.int64().toBigInt();
                    break;
                case /* repeated bytes txs */ 2:
                    message.txs.push(reader.bytes());
                    break;
                case /* tendermint.abci.ExtendedCommitInfo local_last_commit */ 3:
                    message.localLastCommit = ExtendedCommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.localLastCommit);
                    break;
                case /* repeated tendermint.abci.Misbehavior misbehavior */ 4:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 height */ 5:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestPrepareProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 max_tx_bytes = 1; */
        if (message.maxTxBytes !== 0n)
            writer.tag(1, WireType.Varint).int64(message.maxTxBytes);
        /* repeated bytes txs = 2; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.txs[i]);
        /* tendermint.abci.ExtendedCommitInfo local_last_commit = 3; */
        if (message.localLastCommit)
            ExtendedCommitInfo.internalBinaryWrite(message.localLastCommit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Misbehavior misbehavior = 4; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestPrepareProposal
 */
export const RequestPrepareProposal = new RequestPrepareProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestProcessProposal$Type extends MessageType<RequestProcessProposal> {
    constructor() {
        super("tendermint.abci.RequestProcessProposal", [
            { no: 1, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
            { no: 3, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestProcessProposal>): RequestProcessProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txs = [];
        message.misbehavior = [];
        message.hash = new Uint8Array(0);
        message.height = 0n;
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RequestProcessProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestProcessProposal): RequestProcessProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes txs */ 1:
                    message.txs.push(reader.bytes());
                    break;
                case /* tendermint.abci.CommitInfo proposed_last_commit */ 2:
                    message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
                    break;
                case /* repeated tendermint.abci.Misbehavior misbehavior */ 3:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* int64 height */ 5:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestProcessProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes txs = 1; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
        /* tendermint.abci.CommitInfo proposed_last_commit = 2; */
        if (message.proposedLastCommit)
            CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Misbehavior misbehavior = 3; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* int64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestProcessProposal
 */
export const RequestProcessProposal = new RequestProcessProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestExtendVote$Type extends MessageType<RequestExtendVote> {
    constructor() {
        super("tendermint.abci.RequestExtendVote", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 4, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
            { no: 6, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestExtendVote>): RequestExtendVote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = new Uint8Array(0);
        message.height = 0n;
        message.txs = [];
        message.misbehavior = [];
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RequestExtendVote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestExtendVote): RequestExtendVote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* int64 height */ 2:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 3:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* repeated bytes txs */ 4:
                    message.txs.push(reader.bytes());
                    break;
                case /* tendermint.abci.CommitInfo proposed_last_commit */ 5:
                    message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
                    break;
                case /* repeated tendermint.abci.Misbehavior misbehavior */ 6:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestExtendVote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* int64 height = 2; */
        if (message.height !== 0n)
            writer.tag(2, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 3; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes txs = 4; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.txs[i]);
        /* tendermint.abci.CommitInfo proposed_last_commit = 5; */
        if (message.proposedLastCommit)
            CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Misbehavior misbehavior = 6; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestExtendVote
 */
export const RequestExtendVote = new RequestExtendVote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestVerifyVoteExtension$Type extends MessageType<RequestVerifyVoteExtension> {
    constructor() {
        super("tendermint.abci.RequestVerifyVoteExtension", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "validator_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "vote_extension", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestVerifyVoteExtension>): RequestVerifyVoteExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = new Uint8Array(0);
        message.validatorAddress = new Uint8Array(0);
        message.height = 0n;
        message.voteExtension = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RequestVerifyVoteExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestVerifyVoteExtension): RequestVerifyVoteExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* bytes validator_address */ 2:
                    message.validatorAddress = reader.bytes();
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* bytes vote_extension */ 4:
                    message.voteExtension = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestVerifyVoteExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* bytes validator_address = 2; */
        if (message.validatorAddress.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.validatorAddress);
        /* int64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).int64(message.height);
        /* bytes vote_extension = 4; */
        if (message.voteExtension.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.voteExtension);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestVerifyVoteExtension
 */
export const RequestVerifyVoteExtension = new RequestVerifyVoteExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestFinalizeBlock$Type extends MessageType<RequestFinalizeBlock> {
    constructor() {
        super("tendermint.abci.RequestFinalizeBlock", [
            { no: 1, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "decided_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
            { no: 3, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestFinalizeBlock>): RequestFinalizeBlock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txs = [];
        message.misbehavior = [];
        message.hash = new Uint8Array(0);
        message.height = 0n;
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RequestFinalizeBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestFinalizeBlock): RequestFinalizeBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes txs */ 1:
                    message.txs.push(reader.bytes());
                    break;
                case /* tendermint.abci.CommitInfo decided_last_commit */ 2:
                    message.decidedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.decidedLastCommit);
                    break;
                case /* repeated tendermint.abci.Misbehavior misbehavior */ 3:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* int64 height */ 5:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestFinalizeBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes txs = 1; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
        /* tendermint.abci.CommitInfo decided_last_commit = 2; */
        if (message.decidedLastCommit)
            CommitInfo.internalBinaryWrite(message.decidedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Misbehavior misbehavior = 3; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* int64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestFinalizeBlock
 */
export const RequestFinalizeBlock = new RequestFinalizeBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("tendermint.abci.Response", [
            { no: 1, name: "exception", kind: "message", oneof: "value", T: () => ResponseException },
            { no: 2, name: "echo", kind: "message", oneof: "value", T: () => ResponseEcho },
            { no: 3, name: "flush", kind: "message", oneof: "value", T: () => ResponseFlush },
            { no: 4, name: "info", kind: "message", oneof: "value", T: () => ResponseInfo },
            { no: 6, name: "init_chain", kind: "message", oneof: "value", T: () => ResponseInitChain },
            { no: 7, name: "query", kind: "message", oneof: "value", T: () => ResponseQuery },
            { no: 9, name: "check_tx", kind: "message", oneof: "value", T: () => ResponseCheckTx },
            { no: 12, name: "commit", kind: "message", oneof: "value", T: () => ResponseCommit },
            { no: 13, name: "list_snapshots", kind: "message", oneof: "value", T: () => ResponseListSnapshots },
            { no: 14, name: "offer_snapshot", kind: "message", oneof: "value", T: () => ResponseOfferSnapshot },
            { no: 15, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseLoadSnapshotChunk },
            { no: 16, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseApplySnapshotChunk },
            { no: 17, name: "prepare_proposal", kind: "message", oneof: "value", T: () => ResponsePrepareProposal },
            { no: 18, name: "process_proposal", kind: "message", oneof: "value", T: () => ResponseProcessProposal },
            { no: 19, name: "extend_vote", kind: "message", oneof: "value", T: () => ResponseExtendVote },
            { no: 20, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => ResponseVerifyVoteExtension },
            { no: 21, name: "finalize_block", kind: "message", oneof: "value", T: () => ResponseFinalizeBlock }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseException exception */ 1:
                    message.value = {
                        oneofKind: "exception",
                        exception: ResponseException.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).exception)
                    };
                    break;
                case /* tendermint.abci.ResponseEcho echo */ 2:
                    message.value = {
                        oneofKind: "echo",
                        echo: ResponseEcho.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).echo)
                    };
                    break;
                case /* tendermint.abci.ResponseFlush flush */ 3:
                    message.value = {
                        oneofKind: "flush",
                        flush: ResponseFlush.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).flush)
                    };
                    break;
                case /* tendermint.abci.ResponseInfo info */ 4:
                    message.value = {
                        oneofKind: "info",
                        info: ResponseInfo.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).info)
                    };
                    break;
                case /* tendermint.abci.ResponseInitChain init_chain */ 6:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: ResponseInitChain.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).initChain)
                    };
                    break;
                case /* tendermint.abci.ResponseQuery query */ 7:
                    message.value = {
                        oneofKind: "query",
                        query: ResponseQuery.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).query)
                    };
                    break;
                case /* tendermint.abci.ResponseCheckTx check_tx */ 9:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: ResponseCheckTx.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).checkTx)
                    };
                    break;
                case /* tendermint.abci.ResponseCommit commit */ 12:
                    message.value = {
                        oneofKind: "commit",
                        commit: ResponseCommit.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).commit)
                    };
                    break;
                case /* tendermint.abci.ResponseListSnapshots list_snapshots */ 13:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: ResponseListSnapshots.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).listSnapshots)
                    };
                    break;
                case /* tendermint.abci.ResponseOfferSnapshot offer_snapshot */ 14:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: ResponseOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).offerSnapshot)
                    };
                    break;
                case /* tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: ResponseLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).loadSnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk */ 16:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: ResponseApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).applySnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.ResponsePrepareProposal prepare_proposal */ 17:
                    message.value = {
                        oneofKind: "prepareProposal",
                        prepareProposal: ResponsePrepareProposal.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).prepareProposal)
                    };
                    break;
                case /* tendermint.abci.ResponseProcessProposal process_proposal */ 18:
                    message.value = {
                        oneofKind: "processProposal",
                        processProposal: ResponseProcessProposal.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).processProposal)
                    };
                    break;
                case /* tendermint.abci.ResponseExtendVote extend_vote */ 19:
                    message.value = {
                        oneofKind: "extendVote",
                        extendVote: ResponseExtendVote.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).extendVote)
                    };
                    break;
                case /* tendermint.abci.ResponseVerifyVoteExtension verify_vote_extension */ 20:
                    message.value = {
                        oneofKind: "verifyVoteExtension",
                        verifyVoteExtension: ResponseVerifyVoteExtension.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).verifyVoteExtension)
                    };
                    break;
                case /* tendermint.abci.ResponseFinalizeBlock finalize_block */ 21:
                    message.value = {
                        oneofKind: "finalizeBlock",
                        finalizeBlock: ResponseFinalizeBlock.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).finalizeBlock)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseException exception = 1; */
        if (message.value.oneofKind === "exception")
            ResponseException.internalBinaryWrite(message.value.exception, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseEcho echo = 2; */
        if (message.value.oneofKind === "echo")
            ResponseEcho.internalBinaryWrite(message.value.echo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseFlush flush = 3; */
        if (message.value.oneofKind === "flush")
            ResponseFlush.internalBinaryWrite(message.value.flush, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseInfo info = 4; */
        if (message.value.oneofKind === "info")
            ResponseInfo.internalBinaryWrite(message.value.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseInitChain init_chain = 6; */
        if (message.value.oneofKind === "initChain")
            ResponseInitChain.internalBinaryWrite(message.value.initChain, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseQuery query = 7; */
        if (message.value.oneofKind === "query")
            ResponseQuery.internalBinaryWrite(message.value.query, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseCheckTx check_tx = 9; */
        if (message.value.oneofKind === "checkTx")
            ResponseCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseCommit commit = 12; */
        if (message.value.oneofKind === "commit")
            ResponseCommit.internalBinaryWrite(message.value.commit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseListSnapshots list_snapshots = 13; */
        if (message.value.oneofKind === "listSnapshots")
            ResponseListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14; */
        if (message.value.oneofKind === "offerSnapshot")
            ResponseOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            ResponseLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16; */
        if (message.value.oneofKind === "applySnapshotChunk")
            ResponseApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponsePrepareProposal prepare_proposal = 17; */
        if (message.value.oneofKind === "prepareProposal")
            ResponsePrepareProposal.internalBinaryWrite(message.value.prepareProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseProcessProposal process_proposal = 18; */
        if (message.value.oneofKind === "processProposal")
            ResponseProcessProposal.internalBinaryWrite(message.value.processProposal, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseExtendVote extend_vote = 19; */
        if (message.value.oneofKind === "extendVote")
            ResponseExtendVote.internalBinaryWrite(message.value.extendVote, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseVerifyVoteExtension verify_vote_extension = 20; */
        if (message.value.oneofKind === "verifyVoteExtension")
            ResponseVerifyVoteExtension.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseFinalizeBlock finalize_block = 21; */
        if (message.value.oneofKind === "finalizeBlock")
            ResponseFinalizeBlock.internalBinaryWrite(message.value.finalizeBlock, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseException$Type extends MessageType<ResponseException> {
    constructor() {
        super("tendermint.abci.ResponseException", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseException>): ResponseException {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ResponseException>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseException): ResponseException {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseException, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseException
 */
export const ResponseException = new ResponseException$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseEcho$Type extends MessageType<ResponseEcho> {
    constructor() {
        super("tendermint.abci.ResponseEcho", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseEcho>): ResponseEcho {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ResponseEcho>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseEcho): ResponseEcho {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseEcho, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseEcho
 */
export const ResponseEcho = new ResponseEcho$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFlush$Type extends MessageType<ResponseFlush> {
    constructor() {
        super("tendermint.abci.ResponseFlush", []);
    }
    create(value?: PartialMessage<ResponseFlush>): ResponseFlush {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResponseFlush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseFlush): ResponseFlush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseFlush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseFlush
 */
export const ResponseFlush = new ResponseFlush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseInfo$Type extends MessageType<ResponseInfo> {
    constructor() {
        super("tendermint.abci.ResponseInfo", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "last_block_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "last_block_app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseInfo>): ResponseInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = "";
        message.version = "";
        message.appVersion = 0n;
        message.lastBlockHeight = 0n;
        message.lastBlockAppHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ResponseInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseInfo): ResponseInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* uint64 app_version */ 3:
                    message.appVersion = reader.uint64().toBigInt();
                    break;
                case /* int64 last_block_height */ 4:
                    message.lastBlockHeight = reader.int64().toBigInt();
                    break;
                case /* bytes last_block_app_hash */ 5:
                    message.lastBlockAppHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* uint64 app_version = 3; */
        if (message.appVersion !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.appVersion);
        /* int64 last_block_height = 4; */
        if (message.lastBlockHeight !== 0n)
            writer.tag(4, WireType.Varint).int64(message.lastBlockHeight);
        /* bytes last_block_app_hash = 5; */
        if (message.lastBlockAppHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.lastBlockAppHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseInfo
 */
export const ResponseInfo = new ResponseInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseInitChain$Type extends MessageType<ResponseInitChain> {
    constructor() {
        super("tendermint.abci.ResponseInitChain", [
            { no: 1, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 2, name: "validators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 3, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseInitChain>): ResponseInitChain {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validators = [];
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ResponseInitChain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseInitChain): ResponseInitChain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.types.ConsensusParams consensus_params */ 1:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated tendermint.abci.ValidatorUpdate validators */ 2:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_hash */ 3:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseInitChain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.types.ConsensusParams consensus_params = 1; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ValidatorUpdate validators = 2; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 3; */
        if (message.appHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseInitChain
 */
export const ResponseInitChain = new ResponseInitChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseQuery$Type extends MessageType<ResponseQuery> {
    constructor() {
        super("tendermint.abci.ResponseQuery", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proof_ops", kind: "message", T: () => ProofOps },
            { no: 9, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseQuery>): ResponseQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.log = "";
        message.info = "";
        message.index = 0n;
        message.key = new Uint8Array(0);
        message.value = new Uint8Array(0);
        message.height = 0n;
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial<ResponseQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseQuery): ResponseQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 index */ 5:
                    message.index = reader.int64().toBigInt();
                    break;
                case /* bytes key */ 6:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 7:
                    message.value = reader.bytes();
                    break;
                case /* tendermint.crypto.ProofOps proof_ops */ 8:
                    message.proofOps = ProofOps.internalBinaryRead(reader, reader.uint32(), options, message.proofOps);
                    break;
                case /* int64 height */ 9:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* string codespace */ 10:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 index = 5; */
        if (message.index !== 0n)
            writer.tag(5, WireType.Varint).int64(message.index);
        /* bytes key = 6; */
        if (message.key.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 7; */
        if (message.value.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.value);
        /* tendermint.crypto.ProofOps proof_ops = 8; */
        if (message.proofOps)
            ProofOps.internalBinaryWrite(message.proofOps, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 9; */
        if (message.height !== 0n)
            writer.tag(9, WireType.Varint).int64(message.height);
        /* string codespace = 10; */
        if (message.codespace !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseQuery
 */
export const ResponseQuery = new ResponseQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseCheckTx$Type extends MessageType<ResponseCheckTx> {
    constructor() {
        super("tendermint.abci.ResponseCheckTx", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseCheckTx>): ResponseCheckTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.data = new Uint8Array(0);
        message.log = "";
        message.info = "";
        message.gasWanted = 0n;
        message.gasUsed = 0n;
        message.events = [];
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial<ResponseCheckTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseCheckTx): ResponseCheckTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */ 5:
                    message.gasWanted = reader.int64().toBigInt();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"] */ 6:
                    message.gasUsed = reader.int64().toBigInt();
                    break;
                case /* repeated tendermint.abci.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseCheckTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== 0n)
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== 0n)
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated tendermint.abci.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseCheckTx
 */
export const ResponseCheckTx = new ResponseCheckTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseCommit$Type extends MessageType<ResponseCommit> {
    constructor() {
        super("tendermint.abci.ResponseCommit", [
            { no: 3, name: "retain_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseCommit>): ResponseCommit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.retainHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<ResponseCommit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseCommit): ResponseCommit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 retain_height */ 3:
                    message.retainHeight = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseCommit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 retain_height = 3; */
        if (message.retainHeight !== 0n)
            writer.tag(3, WireType.Varint).int64(message.retainHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseCommit
 */
export const ResponseCommit = new ResponseCommit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseListSnapshots$Type extends MessageType<ResponseListSnapshots> {
    constructor() {
        super("tendermint.abci.ResponseListSnapshots", [
            { no: 1, name: "snapshots", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Snapshot }
        ]);
    }
    create(value?: PartialMessage<ResponseListSnapshots>): ResponseListSnapshots {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snapshots = [];
        if (value !== undefined)
            reflectionMergePartial<ResponseListSnapshots>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseListSnapshots): ResponseListSnapshots {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.Snapshot snapshots */ 1:
                    message.snapshots.push(Snapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseListSnapshots, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tendermint.abci.Snapshot snapshots = 1; */
        for (let i = 0; i < message.snapshots.length; i++)
            Snapshot.internalBinaryWrite(message.snapshots[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseListSnapshots
 */
export const ResponseListSnapshots = new ResponseListSnapshots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseOfferSnapshot$Type extends MessageType<ResponseOfferSnapshot> {
    constructor() {
        super("tendermint.abci.ResponseOfferSnapshot", [
            { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseOfferSnapshot.Result", ResponseOfferSnapshot_Result] }
        ]);
    }
    create(value?: PartialMessage<ResponseOfferSnapshot>): ResponseOfferSnapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseOfferSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseOfferSnapshot): ResponseOfferSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseOfferSnapshot.Result result */ 1:
                    message.result = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseOfferSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseOfferSnapshot.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseOfferSnapshot
 */
export const ResponseOfferSnapshot = new ResponseOfferSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseLoadSnapshotChunk$Type extends MessageType<ResponseLoadSnapshotChunk> {
    constructor() {
        super("tendermint.abci.ResponseLoadSnapshotChunk", [
            { no: 1, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseLoadSnapshotChunk>): ResponseLoadSnapshotChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chunk = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ResponseLoadSnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseLoadSnapshotChunk): ResponseLoadSnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes chunk */ 1:
                    message.chunk = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseLoadSnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes chunk = 1; */
        if (message.chunk.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseLoadSnapshotChunk
 */
export const ResponseLoadSnapshotChunk = new ResponseLoadSnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseApplySnapshotChunk$Type extends MessageType<ResponseApplySnapshotChunk> {
    constructor() {
        super("tendermint.abci.ResponseApplySnapshotChunk", [
            { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseApplySnapshotChunk.Result", ResponseApplySnapshotChunk_Result] },
            { no: 2, name: "refetch_chunks", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "reject_senders", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseApplySnapshotChunk>): ResponseApplySnapshotChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.refetchChunks = [];
        message.rejectSenders = [];
        if (value !== undefined)
            reflectionMergePartial<ResponseApplySnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseApplySnapshotChunk): ResponseApplySnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseApplySnapshotChunk.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* repeated uint32 refetch_chunks */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.refetchChunks.push(reader.uint32());
                    else
                        message.refetchChunks.push(reader.uint32());
                    break;
                case /* repeated string reject_senders */ 3:
                    message.rejectSenders.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseApplySnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseApplySnapshotChunk.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* repeated uint32 refetch_chunks = 2; */
        if (message.refetchChunks.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.refetchChunks.length; i++)
                writer.uint32(message.refetchChunks[i]);
            writer.join();
        }
        /* repeated string reject_senders = 3; */
        for (let i = 0; i < message.rejectSenders.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.rejectSenders[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseApplySnapshotChunk
 */
export const ResponseApplySnapshotChunk = new ResponseApplySnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponsePrepareProposal$Type extends MessageType<ResponsePrepareProposal> {
    constructor() {
        super("tendermint.abci.ResponsePrepareProposal", [
            { no: 1, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponsePrepareProposal>): ResponsePrepareProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txs = [];
        if (value !== undefined)
            reflectionMergePartial<ResponsePrepareProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponsePrepareProposal): ResponsePrepareProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes txs */ 1:
                    message.txs.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponsePrepareProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes txs = 1; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponsePrepareProposal
 */
export const ResponsePrepareProposal = new ResponsePrepareProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseProcessProposal$Type extends MessageType<ResponseProcessProposal> {
    constructor() {
        super("tendermint.abci.ResponseProcessProposal", [
            { no: 1, name: "status", kind: "enum", T: () => ["tendermint.abci.ResponseProcessProposal.ProposalStatus", ResponseProcessProposal_ProposalStatus] }
        ]);
    }
    create(value?: PartialMessage<ResponseProcessProposal>): ResponseProcessProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseProcessProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseProcessProposal): ResponseProcessProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseProcessProposal.ProposalStatus status */ 1:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseProcessProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseProcessProposal.ProposalStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseProcessProposal
 */
export const ResponseProcessProposal = new ResponseProcessProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseExtendVote$Type extends MessageType<ResponseExtendVote> {
    constructor() {
        super("tendermint.abci.ResponseExtendVote", [
            { no: 1, name: "vote_extension", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseExtendVote>): ResponseExtendVote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.voteExtension = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ResponseExtendVote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseExtendVote): ResponseExtendVote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes vote_extension */ 1:
                    message.voteExtension = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseExtendVote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes vote_extension = 1; */
        if (message.voteExtension.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.voteExtension);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseExtendVote
 */
export const ResponseExtendVote = new ResponseExtendVote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseVerifyVoteExtension$Type extends MessageType<ResponseVerifyVoteExtension> {
    constructor() {
        super("tendermint.abci.ResponseVerifyVoteExtension", [
            { no: 1, name: "status", kind: "enum", T: () => ["tendermint.abci.ResponseVerifyVoteExtension.VerifyStatus", ResponseVerifyVoteExtension_VerifyStatus] }
        ]);
    }
    create(value?: PartialMessage<ResponseVerifyVoteExtension>): ResponseVerifyVoteExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseVerifyVoteExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseVerifyVoteExtension): ResponseVerifyVoteExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseVerifyVoteExtension.VerifyStatus status */ 1:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseVerifyVoteExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseVerifyVoteExtension.VerifyStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseVerifyVoteExtension
 */
export const ResponseVerifyVoteExtension = new ResponseVerifyVoteExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFinalizeBlock$Type extends MessageType<ResponseFinalizeBlock> {
    constructor() {
        super("tendermint.abci.ResponseFinalizeBlock", [
            { no: 1, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 2, name: "tx_results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExecTxResult },
            { no: 3, name: "validator_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 4, name: "consensus_param_updates", kind: "message", T: () => ConsensusParams },
            { no: 5, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseFinalizeBlock>): ResponseFinalizeBlock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        message.txResults = [];
        message.validatorUpdates = [];
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ResponseFinalizeBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseFinalizeBlock): ResponseFinalizeBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tendermint.abci.ExecTxResult tx_results */ 2:
                    message.txResults.push(ExecTxResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tendermint.abci.ValidatorUpdate validator_updates */ 3:
                    message.validatorUpdates.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tendermint.types.ConsensusParams consensus_param_updates */ 4:
                    message.consensusParamUpdates = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParamUpdates);
                    break;
                case /* bytes app_hash */ 5:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseFinalizeBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tendermint.abci.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ExecTxResult tx_results = 2; */
        for (let i = 0; i < message.txResults.length; i++)
            ExecTxResult.internalBinaryWrite(message.txResults[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ValidatorUpdate validator_updates = 3; */
        for (let i = 0; i < message.validatorUpdates.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validatorUpdates[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.ConsensusParams consensus_param_updates = 4; */
        if (message.consensusParamUpdates)
            ConsensusParams.internalBinaryWrite(message.consensusParamUpdates, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 5; */
        if (message.appHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseFinalizeBlock
 */
export const ResponseFinalizeBlock = new ResponseFinalizeBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitInfo$Type extends MessageType<CommitInfo> {
    constructor() {
        super("tendermint.abci.CommitInfo", [
            { no: 1, name: "round", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "votes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => VoteInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<CommitInfo>): CommitInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0;
        message.votes = [];
        if (value !== undefined)
            reflectionMergePartial<CommitInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitInfo): CommitInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32();
                    break;
                case /* repeated tendermint.abci.VoteInfo votes */ 2:
                    message.votes.push(VoteInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 round = 1; */
        if (message.round !== 0)
            writer.tag(1, WireType.Varint).int32(message.round);
        /* repeated tendermint.abci.VoteInfo votes = 2; */
        for (let i = 0; i < message.votes.length; i++)
            VoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.CommitInfo
 */
export const CommitInfo = new CommitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendedCommitInfo$Type extends MessageType<ExtendedCommitInfo> {
    constructor() {
        super("tendermint.abci.ExtendedCommitInfo", [
            { no: 1, name: "round", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "votes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExtendedVoteInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<ExtendedCommitInfo>): ExtendedCommitInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0;
        message.votes = [];
        if (value !== undefined)
            reflectionMergePartial<ExtendedCommitInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendedCommitInfo): ExtendedCommitInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32();
                    break;
                case /* repeated tendermint.abci.ExtendedVoteInfo votes */ 2:
                    message.votes.push(ExtendedVoteInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendedCommitInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 round = 1; */
        if (message.round !== 0)
            writer.tag(1, WireType.Varint).int32(message.round);
        /* repeated tendermint.abci.ExtendedVoteInfo votes = 2; */
        for (let i = 0; i < message.votes.length; i++)
            ExtendedVoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ExtendedCommitInfo
 */
export const ExtendedCommitInfo = new ExtendedCommitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("tendermint.abci.Event", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EventAttribute, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "attributes,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated tendermint.abci.EventAttribute attributes */ 2:
                    message.attributes.push(EventAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated tendermint.abci.EventAttribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            EventAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAttribute$Type extends MessageType<EventAttribute> {
    constructor() {
        super("tendermint.abci.EventAttribute", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EventAttribute>): EventAttribute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        message.index = false;
        if (value !== undefined)
            reflectionMergePartial<EventAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAttribute): EventAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* bool index */ 3:
                    message.index = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* bool index = 3; */
        if (message.index !== false)
            writer.tag(3, WireType.Varint).bool(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.EventAttribute
 */
export const EventAttribute = new EventAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecTxResult$Type extends MessageType<ExecTxResult> {
    constructor() {
        super("tendermint.abci.ExecTxResult", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExecTxResult>): ExecTxResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.data = new Uint8Array(0);
        message.log = "";
        message.info = "";
        message.gasWanted = 0n;
        message.gasUsed = 0n;
        message.events = [];
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial<ExecTxResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecTxResult): ExecTxResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */ 5:
                    message.gasWanted = reader.int64().toBigInt();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"] */ 6:
                    message.gasUsed = reader.int64().toBigInt();
                    break;
                case /* repeated tendermint.abci.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecTxResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== 0n)
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== 0n)
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated tendermint.abci.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ExecTxResult
 */
export const ExecTxResult = new ExecTxResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxResult$Type extends MessageType<TxResult> {
    constructor() {
        super("tendermint.abci.TxResult", [
            { no: 1, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "result", kind: "message", T: () => ExecTxResult, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<TxResult>): TxResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.index = 0;
        message.tx = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TxResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxResult): TxResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 height */ 1:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* uint32 index */ 2:
                    message.index = reader.uint32();
                    break;
                case /* bytes tx */ 3:
                    message.tx = reader.bytes();
                    break;
                case /* tendermint.abci.ExecTxResult result */ 4:
                    message.result = ExecTxResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).int64(message.height);
        /* uint32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.index);
        /* bytes tx = 3; */
        if (message.tx.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.tx);
        /* tendermint.abci.ExecTxResult result = 4; */
        if (message.result)
            ExecTxResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.TxResult
 */
export const TxResult = new TxResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Validator$Type extends MessageType<Validator> {
    constructor() {
        super("tendermint.abci.Validator", [
            { no: 1, name: "address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Validator>): Validator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = new Uint8Array(0);
        message.power = 0n;
        if (value !== undefined)
            reflectionMergePartial<Validator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Validator): Validator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes address */ 1:
                    message.address = reader.bytes();
                    break;
                case /* int64 power */ 3:
                    message.power = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Validator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes address = 1; */
        if (message.address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.address);
        /* int64 power = 3; */
        if (message.power !== 0n)
            writer.tag(3, WireType.Varint).int64(message.power);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Validator
 */
export const Validator = new Validator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidatorUpdate$Type extends MessageType<ValidatorUpdate> {
    constructor() {
        super("tendermint.abci.ValidatorUpdate", [
            { no: 1, name: "pub_key", kind: "message", T: () => PublicKey, options: { "gogoproto.nullable": false } },
            { no: 2, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ValidatorUpdate>): ValidatorUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.power = 0n;
        if (value !== undefined)
            reflectionMergePartial<ValidatorUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorUpdate): ValidatorUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.crypto.PublicKey pub_key */ 1:
                    message.pubKey = PublicKey.internalBinaryRead(reader, reader.uint32(), options, message.pubKey);
                    break;
                case /* int64 power */ 2:
                    message.power = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidatorUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.crypto.PublicKey pub_key = 1; */
        if (message.pubKey)
            PublicKey.internalBinaryWrite(message.pubKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 power = 2; */
        if (message.power !== 0n)
            writer.tag(2, WireType.Varint).int64(message.power);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ValidatorUpdate
 */
export const ValidatorUpdate = new ValidatorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoteInfo$Type extends MessageType<VoteInfo> {
    constructor() {
        super("tendermint.abci.VoteInfo", [
            { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "block_id_flag", kind: "enum", T: () => ["tendermint.types.BlockIDFlag", BlockIDFlag] }
        ]);
    }
    create(value?: PartialMessage<VoteInfo>): VoteInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blockIdFlag = 0;
        if (value !== undefined)
            reflectionMergePartial<VoteInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoteInfo): VoteInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.Validator validator */ 1:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* tendermint.types.BlockIDFlag block_id_flag */ 3:
                    message.blockIdFlag = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoteInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.Validator validator = 1; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.BlockIDFlag block_id_flag = 3; */
        if (message.blockIdFlag !== 0)
            writer.tag(3, WireType.Varint).int32(message.blockIdFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.VoteInfo
 */
export const VoteInfo = new VoteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendedVoteInfo$Type extends MessageType<ExtendedVoteInfo> {
    constructor() {
        super("tendermint.abci.ExtendedVoteInfo", [
            { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "vote_extension", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "extension_signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "block_id_flag", kind: "enum", T: () => ["tendermint.types.BlockIDFlag", BlockIDFlag] }
        ]);
    }
    create(value?: PartialMessage<ExtendedVoteInfo>): ExtendedVoteInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.voteExtension = new Uint8Array(0);
        message.extensionSignature = new Uint8Array(0);
        message.blockIdFlag = 0;
        if (value !== undefined)
            reflectionMergePartial<ExtendedVoteInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendedVoteInfo): ExtendedVoteInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.Validator validator */ 1:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* bytes vote_extension */ 3:
                    message.voteExtension = reader.bytes();
                    break;
                case /* bytes extension_signature */ 4:
                    message.extensionSignature = reader.bytes();
                    break;
                case /* tendermint.types.BlockIDFlag block_id_flag */ 5:
                    message.blockIdFlag = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendedVoteInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.Validator validator = 1; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes vote_extension = 3; */
        if (message.voteExtension.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.voteExtension);
        /* bytes extension_signature = 4; */
        if (message.extensionSignature.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.extensionSignature);
        /* tendermint.types.BlockIDFlag block_id_flag = 5; */
        if (message.blockIdFlag !== 0)
            writer.tag(5, WireType.Varint).int32(message.blockIdFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ExtendedVoteInfo
 */
export const ExtendedVoteInfo = new ExtendedVoteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Misbehavior$Type extends MessageType<Misbehavior> {
    constructor() {
        super("tendermint.abci.Misbehavior", [
            { no: 1, name: "type", kind: "enum", T: () => ["tendermint.abci.MisbehaviorType", MisbehaviorType] },
            { no: 2, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 5, name: "total_voting_power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Misbehavior>): Misbehavior {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.height = 0n;
        message.totalVotingPower = 0n;
        if (value !== undefined)
            reflectionMergePartial<Misbehavior>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Misbehavior): Misbehavior {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.MisbehaviorType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* tendermint.abci.Validator validator */ 2:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 4:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* int64 total_voting_power */ 5:
                    message.totalVotingPower = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Misbehavior, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.MisbehaviorType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* tendermint.abci.Validator validator = 2; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 4; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_voting_power = 5; */
        if (message.totalVotingPower !== 0n)
            writer.tag(5, WireType.Varint).int64(message.totalVotingPower);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Misbehavior
 */
export const Misbehavior = new Misbehavior$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Snapshot$Type extends MessageType<Snapshot> {
    constructor() {
        super("tendermint.abci.Snapshot", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Snapshot>): Snapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.format = 0;
        message.chunks = 0;
        message.hash = new Uint8Array(0);
        message.metadata = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Snapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Snapshot): Snapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunks */ 3:
                    message.chunks = reader.uint32();
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* bytes metadata */ 5:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Snapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunks = 3; */
        if (message.chunks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunks);
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* bytes metadata = 5; */
        if (message.metadata.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Snapshot
 */
export const Snapshot = new Snapshot$Type();
/**
 * @generated ServiceType for protobuf service tendermint.abci.ABCI
 */
export const ABCI = new ServiceType("tendermint.abci.ABCI", [
    { name: "Echo", options: {}, I: RequestEcho, O: ResponseEcho },
    { name: "Flush", options: {}, I: RequestFlush, O: ResponseFlush },
    { name: "Info", options: {}, I: RequestInfo, O: ResponseInfo },
    { name: "CheckTx", options: {}, I: RequestCheckTx, O: ResponseCheckTx },
    { name: "Query", options: {}, I: RequestQuery, O: ResponseQuery },
    { name: "Commit", options: {}, I: RequestCommit, O: ResponseCommit },
    { name: "InitChain", options: {}, I: RequestInitChain, O: ResponseInitChain },
    { name: "ListSnapshots", options: {}, I: RequestListSnapshots, O: ResponseListSnapshots },
    { name: "OfferSnapshot", options: {}, I: RequestOfferSnapshot, O: ResponseOfferSnapshot },
    { name: "LoadSnapshotChunk", options: {}, I: RequestLoadSnapshotChunk, O: ResponseLoadSnapshotChunk },
    { name: "ApplySnapshotChunk", options: {}, I: RequestApplySnapshotChunk, O: ResponseApplySnapshotChunk },
    { name: "PrepareProposal", options: {}, I: RequestPrepareProposal, O: ResponsePrepareProposal },
    { name: "ProcessProposal", options: {}, I: RequestProcessProposal, O: ResponseProcessProposal },
    { name: "ExtendVote", options: {}, I: RequestExtendVote, O: ResponseExtendVote },
    { name: "VerifyVoteExtension", options: {}, I: RequestVerifyVoteExtension, O: ResponseVerifyVoteExtension },
    { name: "FinalizeBlock", options: {}, I: RequestFinalizeBlock, O: ResponseFinalizeBlock }
]);
