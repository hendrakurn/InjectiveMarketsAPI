import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BlockID } from "../types/types_pb.js";
import { SignedMsgType } from "../types/types_pb.js";
import { Vote as Vote$ } from "../types/types_pb.js";
import { Part } from "../types/types_pb.js";
import { Proposal as Proposal$ } from "../types/types_pb.js";
import { BitArray } from "../libs/bits/types_pb.js";
import { PartSetHeader } from "../types/types_pb.js";
class NewRoundStep$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.NewRoundStep", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "step",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "seconds_since_start_time",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "last_commit_round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.round = 0;
    message.step = 0;
    message.secondsSinceStartTime = 0n;
    message.lastCommitRound = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* int32 round */
        2:
          message.round = reader.int32();
          break;
        case /* uint32 step */
        3:
          message.step = reader.uint32();
          break;
        case /* int64 seconds_since_start_time */
        4:
          message.secondsSinceStartTime = reader.int64().toBigInt();
          break;
        case /* int32 last_commit_round */
        5:
          message.lastCommitRound = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.round !== 0)
      writer.tag(2, WireType.Varint).int32(message.round);
    if (message.step !== 0)
      writer.tag(3, WireType.Varint).uint32(message.step);
    if (message.secondsSinceStartTime !== 0n)
      writer.tag(4, WireType.Varint).int64(message.secondsSinceStartTime);
    if (message.lastCommitRound !== 0)
      writer.tag(5, WireType.Varint).int32(message.lastCommitRound);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const NewRoundStep = new NewRoundStep$Type();
class NewValidBlock$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.NewValidBlock", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 3, name: "block_part_set_header", kind: "message", T: () => PartSetHeader, options: { "gogoproto.nullable": false } },
      { no: 4, name: "block_parts", kind: "message", T: () => BitArray },
      {
        no: 5,
        name: "is_commit",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.round = 0;
    message.isCommit = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* int32 round */
        2:
          message.round = reader.int32();
          break;
        case /* tendermint.types.PartSetHeader block_part_set_header */
        3:
          message.blockPartSetHeader = PartSetHeader.internalBinaryRead(reader, reader.uint32(), options, message.blockPartSetHeader);
          break;
        case /* tendermint.libs.bits.BitArray block_parts */
        4:
          message.blockParts = BitArray.internalBinaryRead(reader, reader.uint32(), options, message.blockParts);
          break;
        case /* bool is_commit */
        5:
          message.isCommit = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.round !== 0)
      writer.tag(2, WireType.Varint).int32(message.round);
    if (message.blockPartSetHeader)
      PartSetHeader.internalBinaryWrite(message.blockPartSetHeader, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.blockParts)
      BitArray.internalBinaryWrite(message.blockParts, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.isCommit !== false)
      writer.tag(5, WireType.Varint).bool(message.isCommit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const NewValidBlock = new NewValidBlock$Type();
class Proposal$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.Proposal", [
      { no: 1, name: "proposal", kind: "message", T: () => Proposal$, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.types.Proposal proposal */
        1:
          message.proposal = Proposal$.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.proposal)
      Proposal$.internalBinaryWrite(message.proposal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Proposal = new Proposal$Type();
class ProposalPOL$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.ProposalPOL", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "proposal_pol_round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 3, name: "proposal_pol", kind: "message", T: () => BitArray, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.proposalPolRound = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* int32 proposal_pol_round */
        2:
          message.proposalPolRound = reader.int32();
          break;
        case /* tendermint.libs.bits.BitArray proposal_pol */
        3:
          message.proposalPol = BitArray.internalBinaryRead(reader, reader.uint32(), options, message.proposalPol);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.proposalPolRound !== 0)
      writer.tag(2, WireType.Varint).int32(message.proposalPolRound);
    if (message.proposalPol)
      BitArray.internalBinaryWrite(message.proposalPol, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProposalPOL = new ProposalPOL$Type();
class BlockPart$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.BlockPart", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 3, name: "part", kind: "message", T: () => Part, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.round = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* int32 round */
        2:
          message.round = reader.int32();
          break;
        case /* tendermint.types.Part part */
        3:
          message.part = Part.internalBinaryRead(reader, reader.uint32(), options, message.part);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.round !== 0)
      writer.tag(2, WireType.Varint).int32(message.round);
    if (message.part)
      Part.internalBinaryWrite(message.part, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BlockPart = new BlockPart$Type();
class Vote$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.Vote", [
      { no: 1, name: "vote", kind: "message", T: () => Vote$ }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.types.Vote vote */
        1:
          message.vote = Vote$.internalBinaryRead(reader, reader.uint32(), options, message.vote);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vote)
      Vote$.internalBinaryWrite(message.vote, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Vote = new Vote$Type();
class HasVote$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.HasVote", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 3, name: "type", kind: "enum", T: () => ["tendermint.types.SignedMsgType", SignedMsgType, "SIGNED_MSG_TYPE_"] },
      {
        no: 4,
        name: "index",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.round = 0;
    message.type = 0;
    message.index = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* int32 round */
        2:
          message.round = reader.int32();
          break;
        case /* tendermint.types.SignedMsgType type */
        3:
          message.type = reader.int32();
          break;
        case /* int32 index */
        4:
          message.index = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.round !== 0)
      writer.tag(2, WireType.Varint).int32(message.round);
    if (message.type !== 0)
      writer.tag(3, WireType.Varint).int32(message.type);
    if (message.index !== 0)
      writer.tag(4, WireType.Varint).int32(message.index);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HasVote = new HasVote$Type();
class VoteSetMaj23$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.VoteSetMaj23", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 3, name: "type", kind: "enum", T: () => ["tendermint.types.SignedMsgType", SignedMsgType, "SIGNED_MSG_TYPE_"] },
      { no: 4, name: "block_id", kind: "message", T: () => BlockID, options: { "gogoproto.nullable": false, "gogoproto.customname": "BlockID" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.round = 0;
    message.type = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* int32 round */
        2:
          message.round = reader.int32();
          break;
        case /* tendermint.types.SignedMsgType type */
        3:
          message.type = reader.int32();
          break;
        case /* tendermint.types.BlockID block_id */
        4:
          message.blockId = BlockID.internalBinaryRead(reader, reader.uint32(), options, message.blockId);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.round !== 0)
      writer.tag(2, WireType.Varint).int32(message.round);
    if (message.type !== 0)
      writer.tag(3, WireType.Varint).int32(message.type);
    if (message.blockId)
      BlockID.internalBinaryWrite(message.blockId, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VoteSetMaj23 = new VoteSetMaj23$Type();
class VoteSetBits$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.VoteSetBits", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 3, name: "type", kind: "enum", T: () => ["tendermint.types.SignedMsgType", SignedMsgType, "SIGNED_MSG_TYPE_"] },
      { no: 4, name: "block_id", kind: "message", T: () => BlockID, options: { "gogoproto.nullable": false, "gogoproto.customname": "BlockID" } },
      { no: 5, name: "votes", kind: "message", T: () => BitArray, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.round = 0;
    message.type = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* int32 round */
        2:
          message.round = reader.int32();
          break;
        case /* tendermint.types.SignedMsgType type */
        3:
          message.type = reader.int32();
          break;
        case /* tendermint.types.BlockID block_id */
        4:
          message.blockId = BlockID.internalBinaryRead(reader, reader.uint32(), options, message.blockId);
          break;
        case /* tendermint.libs.bits.BitArray votes */
        5:
          message.votes = BitArray.internalBinaryRead(reader, reader.uint32(), options, message.votes);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.round !== 0)
      writer.tag(2, WireType.Varint).int32(message.round);
    if (message.type !== 0)
      writer.tag(3, WireType.Varint).int32(message.type);
    if (message.blockId)
      BlockID.internalBinaryWrite(message.blockId, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.votes)
      BitArray.internalBinaryWrite(message.votes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VoteSetBits = new VoteSetBits$Type();
class Message$Type extends MessageType {
  constructor() {
    super("tendermint.consensus.Message", [
      { no: 1, name: "new_round_step", kind: "message", oneof: "sum", T: () => NewRoundStep },
      { no: 2, name: "new_valid_block", kind: "message", oneof: "sum", T: () => NewValidBlock },
      { no: 3, name: "proposal", kind: "message", oneof: "sum", T: () => Proposal },
      { no: 4, name: "proposal_pol", kind: "message", oneof: "sum", T: () => ProposalPOL },
      { no: 5, name: "block_part", kind: "message", oneof: "sum", T: () => BlockPart },
      { no: 6, name: "vote", kind: "message", oneof: "sum", T: () => Vote },
      { no: 7, name: "has_vote", kind: "message", oneof: "sum", T: () => HasVote },
      { no: 8, name: "vote_set_maj23", kind: "message", oneof: "sum", T: () => VoteSetMaj23 },
      { no: 9, name: "vote_set_bits", kind: "message", oneof: "sum", T: () => VoteSetBits }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sum = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* tendermint.consensus.NewRoundStep new_round_step */
        1:
          message.sum = {
            oneofKind: "newRoundStep",
            newRoundStep: NewRoundStep.internalBinaryRead(reader, reader.uint32(), options, message.sum.newRoundStep)
          };
          break;
        case /* tendermint.consensus.NewValidBlock new_valid_block */
        2:
          message.sum = {
            oneofKind: "newValidBlock",
            newValidBlock: NewValidBlock.internalBinaryRead(reader, reader.uint32(), options, message.sum.newValidBlock)
          };
          break;
        case /* tendermint.consensus.Proposal proposal */
        3:
          message.sum = {
            oneofKind: "proposal",
            proposal: Proposal.internalBinaryRead(reader, reader.uint32(), options, message.sum.proposal)
          };
          break;
        case /* tendermint.consensus.ProposalPOL proposal_pol */
        4:
          message.sum = {
            oneofKind: "proposalPol",
            proposalPol: ProposalPOL.internalBinaryRead(reader, reader.uint32(), options, message.sum.proposalPol)
          };
          break;
        case /* tendermint.consensus.BlockPart block_part */
        5:
          message.sum = {
            oneofKind: "blockPart",
            blockPart: BlockPart.internalBinaryRead(reader, reader.uint32(), options, message.sum.blockPart)
          };
          break;
        case /* tendermint.consensus.Vote vote */
        6:
          message.sum = {
            oneofKind: "vote",
            vote: Vote.internalBinaryRead(reader, reader.uint32(), options, message.sum.vote)
          };
          break;
        case /* tendermint.consensus.HasVote has_vote */
        7:
          message.sum = {
            oneofKind: "hasVote",
            hasVote: HasVote.internalBinaryRead(reader, reader.uint32(), options, message.sum.hasVote)
          };
          break;
        case /* tendermint.consensus.VoteSetMaj23 vote_set_maj23 */
        8:
          message.sum = {
            oneofKind: "voteSetMaj23",
            voteSetMaj23: VoteSetMaj23.internalBinaryRead(reader, reader.uint32(), options, message.sum.voteSetMaj23)
          };
          break;
        case /* tendermint.consensus.VoteSetBits vote_set_bits */
        9:
          message.sum = {
            oneofKind: "voteSetBits",
            voteSetBits: VoteSetBits.internalBinaryRead(reader, reader.uint32(), options, message.sum.voteSetBits)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sum.oneofKind === "newRoundStep")
      NewRoundStep.internalBinaryWrite(message.sum.newRoundStep, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "newValidBlock")
      NewValidBlock.internalBinaryWrite(message.sum.newValidBlock, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "proposal")
      Proposal.internalBinaryWrite(message.sum.proposal, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "proposalPol")
      ProposalPOL.internalBinaryWrite(message.sum.proposalPol, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "blockPart")
      BlockPart.internalBinaryWrite(message.sum.blockPart, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "vote")
      Vote.internalBinaryWrite(message.sum.vote, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "hasVote")
      HasVote.internalBinaryWrite(message.sum.hasVote, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "voteSetMaj23")
      VoteSetMaj23.internalBinaryWrite(message.sum.voteSetMaj23, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "voteSetBits")
      VoteSetBits.internalBinaryWrite(message.sum.voteSetBits, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Message = new Message$Type();
export {
  BlockPart,
  HasVote,
  Message,
  NewRoundStep,
  NewValidBlock,
  Proposal,
  ProposalPOL,
  Vote,
  VoteSetBits,
  VoteSetMaj23
};
