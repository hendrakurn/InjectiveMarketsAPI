// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "ibc/applications/fee/v1/genesis.proto" (package "ibc.applications.fee.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PacketId } from "../../../core/channel/v1/channel_pb";
import { IdentifiedPacketFees } from "./fee_pb";
/**
 * GenesisState defines the ICS29 fee middleware genesis state
 *
 * @generated from protobuf message ibc.applications.fee.v1.GenesisState
 */
export interface GenesisState {
    /**
     * list of identified packet fees
     *
     * @generated from protobuf field: repeated ibc.applications.fee.v1.IdentifiedPacketFees identified_fees = 1
     */
    identifiedFees: IdentifiedPacketFees[];
    /**
     * list of fee enabled channels
     *
     * @generated from protobuf field: repeated ibc.applications.fee.v1.FeeEnabledChannel fee_enabled_channels = 2
     */
    feeEnabledChannels: FeeEnabledChannel[];
    /**
     * list of registered payees
     *
     * @generated from protobuf field: repeated ibc.applications.fee.v1.RegisteredPayee registered_payees = 3
     */
    registeredPayees: RegisteredPayee[];
    /**
     * list of registered counterparty payees
     *
     * @generated from protobuf field: repeated ibc.applications.fee.v1.RegisteredCounterpartyPayee registered_counterparty_payees = 4
     */
    registeredCounterpartyPayees: RegisteredCounterpartyPayee[];
    /**
     * list of forward relayer addresses
     *
     * @generated from protobuf field: repeated ibc.applications.fee.v1.ForwardRelayerAddress forward_relayers = 5
     */
    forwardRelayers: ForwardRelayerAddress[];
}
/**
 * FeeEnabledChannel contains the PortID & ChannelID for a fee enabled channel
 *
 * @generated from protobuf message ibc.applications.fee.v1.FeeEnabledChannel
 */
export interface FeeEnabledChannel {
    /**
     * unique port identifier
     *
     * @generated from protobuf field: string port_id = 1
     */
    portId: string;
    /**
     * unique channel identifier
     *
     * @generated from protobuf field: string channel_id = 2
     */
    channelId: string;
}
/**
 * RegisteredPayee contains the relayer address and payee address for a specific channel
 *
 * @generated from protobuf message ibc.applications.fee.v1.RegisteredPayee
 */
export interface RegisteredPayee {
    /**
     * unique channel identifier
     *
     * @generated from protobuf field: string channel_id = 1
     */
    channelId: string;
    /**
     * the relayer address
     *
     * @generated from protobuf field: string relayer = 2
     */
    relayer: string;
    /**
     * the payee address
     *
     * @generated from protobuf field: string payee = 3
     */
    payee: string;
}
/**
 * RegisteredCounterpartyPayee contains the relayer address and counterparty payee address for a specific channel (used
 * for recv fee distribution)
 *
 * @generated from protobuf message ibc.applications.fee.v1.RegisteredCounterpartyPayee
 */
export interface RegisteredCounterpartyPayee {
    /**
     * unique channel identifier
     *
     * @generated from protobuf field: string channel_id = 1
     */
    channelId: string;
    /**
     * the relayer address
     *
     * @generated from protobuf field: string relayer = 2
     */
    relayer: string;
    /**
     * the counterparty payee address
     *
     * @generated from protobuf field: string counterparty_payee = 3
     */
    counterpartyPayee: string;
}
/**
 * ForwardRelayerAddress contains the forward relayer address and PacketId used for async acknowledgements
 *
 * @generated from protobuf message ibc.applications.fee.v1.ForwardRelayerAddress
 */
export interface ForwardRelayerAddress {
    /**
     * the forward relayer address
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * unique packet identifer comprised of the channel ID, port ID and sequence
     *
     * @generated from protobuf field: ibc.core.channel.v1.PacketId packet_id = 2
     */
    packetId?: PacketId;
}
// @generated message type with reflection information, may provide speed optimized methods
class GenesisState$Type extends MessageType<GenesisState> {
    constructor() {
        super("ibc.applications.fee.v1.GenesisState", [
            { no: 1, name: "identified_fees", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => IdentifiedPacketFees, options: { "gogoproto.nullable": false } },
            { no: 2, name: "fee_enabled_channels", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeeEnabledChannel, options: { "gogoproto.nullable": false } },
            { no: 3, name: "registered_payees", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RegisteredPayee, options: { "gogoproto.nullable": false } },
            { no: 4, name: "registered_counterparty_payees", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RegisteredCounterpartyPayee, options: { "gogoproto.nullable": false } },
            { no: 5, name: "forward_relayers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ForwardRelayerAddress, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<GenesisState>): GenesisState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.identifiedFees = [];
        message.feeEnabledChannels = [];
        message.registeredPayees = [];
        message.registeredCounterpartyPayees = [];
        message.forwardRelayers = [];
        if (value !== undefined)
            reflectionMergePartial<GenesisState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenesisState): GenesisState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ibc.applications.fee.v1.IdentifiedPacketFees identified_fees */ 1:
                    message.identifiedFees.push(IdentifiedPacketFees.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ibc.applications.fee.v1.FeeEnabledChannel fee_enabled_channels */ 2:
                    message.feeEnabledChannels.push(FeeEnabledChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ibc.applications.fee.v1.RegisteredPayee registered_payees */ 3:
                    message.registeredPayees.push(RegisteredPayee.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ibc.applications.fee.v1.RegisteredCounterpartyPayee registered_counterparty_payees */ 4:
                    message.registeredCounterpartyPayees.push(RegisteredCounterpartyPayee.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ibc.applications.fee.v1.ForwardRelayerAddress forward_relayers */ 5:
                    message.forwardRelayers.push(ForwardRelayerAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenesisState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ibc.applications.fee.v1.IdentifiedPacketFees identified_fees = 1; */
        for (let i = 0; i < message.identifiedFees.length; i++)
            IdentifiedPacketFees.internalBinaryWrite(message.identifiedFees[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ibc.applications.fee.v1.FeeEnabledChannel fee_enabled_channels = 2; */
        for (let i = 0; i < message.feeEnabledChannels.length; i++)
            FeeEnabledChannel.internalBinaryWrite(message.feeEnabledChannels[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ibc.applications.fee.v1.RegisteredPayee registered_payees = 3; */
        for (let i = 0; i < message.registeredPayees.length; i++)
            RegisteredPayee.internalBinaryWrite(message.registeredPayees[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated ibc.applications.fee.v1.RegisteredCounterpartyPayee registered_counterparty_payees = 4; */
        for (let i = 0; i < message.registeredCounterpartyPayees.length; i++)
            RegisteredCounterpartyPayee.internalBinaryWrite(message.registeredCounterpartyPayees[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated ibc.applications.fee.v1.ForwardRelayerAddress forward_relayers = 5; */
        for (let i = 0; i < message.forwardRelayers.length; i++)
            ForwardRelayerAddress.internalBinaryWrite(message.forwardRelayers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.applications.fee.v1.GenesisState
 */
export const GenesisState = new GenesisState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeEnabledChannel$Type extends MessageType<FeeEnabledChannel> {
    constructor() {
        super("ibc.applications.fee.v1.FeeEnabledChannel", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeeEnabledChannel>): FeeEnabledChannel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.portId = "";
        message.channelId = "";
        if (value !== undefined)
            reflectionMergePartial<FeeEnabledChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeEnabledChannel): FeeEnabledChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeEnabledChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.applications.fee.v1.FeeEnabledChannel
 */
export const FeeEnabledChannel = new FeeEnabledChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisteredPayee$Type extends MessageType<RegisteredPayee> {
    constructor() {
        super("ibc.applications.fee.v1.RegisteredPayee", [
            { no: 1, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relayer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "payee", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisteredPayee>): RegisteredPayee {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channelId = "";
        message.relayer = "";
        message.payee = "";
        if (value !== undefined)
            reflectionMergePartial<RegisteredPayee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisteredPayee): RegisteredPayee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string channel_id */ 1:
                    message.channelId = reader.string();
                    break;
                case /* string relayer */ 2:
                    message.relayer = reader.string();
                    break;
                case /* string payee */ 3:
                    message.payee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisteredPayee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string channel_id = 1; */
        if (message.channelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.channelId);
        /* string relayer = 2; */
        if (message.relayer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relayer);
        /* string payee = 3; */
        if (message.payee !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.applications.fee.v1.RegisteredPayee
 */
export const RegisteredPayee = new RegisteredPayee$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisteredCounterpartyPayee$Type extends MessageType<RegisteredCounterpartyPayee> {
    constructor() {
        super("ibc.applications.fee.v1.RegisteredCounterpartyPayee", [
            { no: 1, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relayer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "counterparty_payee", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisteredCounterpartyPayee>): RegisteredCounterpartyPayee {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channelId = "";
        message.relayer = "";
        message.counterpartyPayee = "";
        if (value !== undefined)
            reflectionMergePartial<RegisteredCounterpartyPayee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisteredCounterpartyPayee): RegisteredCounterpartyPayee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string channel_id */ 1:
                    message.channelId = reader.string();
                    break;
                case /* string relayer */ 2:
                    message.relayer = reader.string();
                    break;
                case /* string counterparty_payee */ 3:
                    message.counterpartyPayee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisteredCounterpartyPayee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string channel_id = 1; */
        if (message.channelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.channelId);
        /* string relayer = 2; */
        if (message.relayer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relayer);
        /* string counterparty_payee = 3; */
        if (message.counterpartyPayee !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.counterpartyPayee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.applications.fee.v1.RegisteredCounterpartyPayee
 */
export const RegisteredCounterpartyPayee = new RegisteredCounterpartyPayee$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForwardRelayerAddress$Type extends MessageType<ForwardRelayerAddress> {
    constructor() {
        super("ibc.applications.fee.v1.ForwardRelayerAddress", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "packet_id", kind: "message", T: () => PacketId, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<ForwardRelayerAddress>): ForwardRelayerAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<ForwardRelayerAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForwardRelayerAddress): ForwardRelayerAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* ibc.core.channel.v1.PacketId packet_id */ 2:
                    message.packetId = PacketId.internalBinaryRead(reader, reader.uint32(), options, message.packetId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForwardRelayerAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* ibc.core.channel.v1.PacketId packet_id = 2; */
        if (message.packetId)
            PacketId.internalBinaryWrite(message.packetId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.applications.fee.v1.ForwardRelayerAddress
 */
export const ForwardRelayerAddress = new ForwardRelayerAddress$Type();
