import { Query } from "./query_pb.js";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
class QueryClient {
  constructor(_transport) {
    this._transport = _transport;
    this.typeName = Query.typeName;
    this.methods = Query.methods;
    this.options = Query.options;
  }
  /**
   * Channel queries an IBC Channel.
   *
   * @generated from protobuf rpc: Channel
   */
  channel(input, options) {
    const method = this.methods[0], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Channels queries all the IBC channels of a chain.
   *
   * @generated from protobuf rpc: Channels
   */
  channels(input, options) {
    const method = this.methods[1], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * ConnectionChannels queries all the channels associated with a connection
   * end.
   *
   * @generated from protobuf rpc: ConnectionChannels
   */
  connectionChannels(input, options) {
    const method = this.methods[2], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * ChannelClientState queries for the client state for the channel associated
   * with the provided channel identifiers.
   *
   * @generated from protobuf rpc: ChannelClientState
   */
  channelClientState(input, options) {
    const method = this.methods[3], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * ChannelConsensusState queries for the consensus state for the channel
   * associated with the provided channel identifiers.
   *
   * @generated from protobuf rpc: ChannelConsensusState
   */
  channelConsensusState(input, options) {
    const method = this.methods[4], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * PacketCommitment queries a stored packet commitment hash.
   *
   * @generated from protobuf rpc: PacketCommitment
   */
  packetCommitment(input, options) {
    const method = this.methods[5], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * PacketCommitments returns all the packet commitments hashes associated
   * with a channel.
   *
   * @generated from protobuf rpc: PacketCommitments
   */
  packetCommitments(input, options) {
    const method = this.methods[6], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * PacketReceipt queries if a given packet sequence has been received on the
   * queried chain
   *
   * @generated from protobuf rpc: PacketReceipt
   */
  packetReceipt(input, options) {
    const method = this.methods[7], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * PacketAcknowledgement queries a stored packet acknowledgement hash.
   *
   * @generated from protobuf rpc: PacketAcknowledgement
   */
  packetAcknowledgement(input, options) {
    const method = this.methods[8], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * PacketAcknowledgements returns all the packet acknowledgements associated
   * with a channel.
   *
   * @generated from protobuf rpc: PacketAcknowledgements
   */
  packetAcknowledgements(input, options) {
    const method = this.methods[9], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * UnreceivedPackets returns all the unreceived IBC packets associated with a
   * channel and sequences.
   *
   * @generated from protobuf rpc: UnreceivedPackets
   */
  unreceivedPackets(input, options) {
    const method = this.methods[10], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * UnreceivedAcks returns all the unreceived IBC acknowledgements associated
   * with a channel and sequences.
   *
   * @generated from protobuf rpc: UnreceivedAcks
   */
  unreceivedAcks(input, options) {
    const method = this.methods[11], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * NextSequenceReceive returns the next receive sequence for a given channel.
   *
   * @generated from protobuf rpc: NextSequenceReceive
   */
  nextSequenceReceive(input, options) {
    const method = this.methods[12], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * NextSequenceSend returns the next send sequence for a given channel.
   *
   * @generated from protobuf rpc: NextSequenceSend
   */
  nextSequenceSend(input, options) {
    const method = this.methods[13], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * UpgradeError returns the error receipt if the upgrade handshake failed.
   *
   * @generated from protobuf rpc: UpgradeError
   */
  upgradeError(input, options) {
    const method = this.methods[14], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Upgrade returns the upgrade for a given port and channel id.
   *
   * @generated from protobuf rpc: Upgrade
   */
  upgrade(input, options) {
    const method = this.methods[15], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * ChannelParams queries all parameters of the ibc channel submodule.
   *
   * @generated from protobuf rpc: ChannelParams
   */
  channelParams(input, options) {
    const method = this.methods[16], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
}
export {
  QueryClient
};
