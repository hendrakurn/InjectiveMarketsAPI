// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "ibc/core/channel/v1/query.proto" (package "ibc.core.channel.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Query } from "./query_pb";
import type { QueryChannelParamsResponse } from "./query_pb";
import type { QueryChannelParamsRequest } from "./query_pb";
import type { QueryUpgradeResponse } from "./query_pb";
import type { QueryUpgradeRequest } from "./query_pb";
import type { QueryUpgradeErrorResponse } from "./query_pb";
import type { QueryUpgradeErrorRequest } from "./query_pb";
import type { QueryNextSequenceSendResponse } from "./query_pb";
import type { QueryNextSequenceSendRequest } from "./query_pb";
import type { QueryNextSequenceReceiveResponse } from "./query_pb";
import type { QueryNextSequenceReceiveRequest } from "./query_pb";
import type { QueryUnreceivedAcksResponse } from "./query_pb";
import type { QueryUnreceivedAcksRequest } from "./query_pb";
import type { QueryUnreceivedPacketsResponse } from "./query_pb";
import type { QueryUnreceivedPacketsRequest } from "./query_pb";
import type { QueryPacketAcknowledgementsResponse } from "./query_pb";
import type { QueryPacketAcknowledgementsRequest } from "./query_pb";
import type { QueryPacketAcknowledgementResponse } from "./query_pb";
import type { QueryPacketAcknowledgementRequest } from "./query_pb";
import type { QueryPacketReceiptResponse } from "./query_pb";
import type { QueryPacketReceiptRequest } from "./query_pb";
import type { QueryPacketCommitmentsResponse } from "./query_pb";
import type { QueryPacketCommitmentsRequest } from "./query_pb";
import type { QueryPacketCommitmentResponse } from "./query_pb";
import type { QueryPacketCommitmentRequest } from "./query_pb";
import type { QueryChannelConsensusStateResponse } from "./query_pb";
import type { QueryChannelConsensusStateRequest } from "./query_pb";
import type { QueryChannelClientStateResponse } from "./query_pb";
import type { QueryChannelClientStateRequest } from "./query_pb";
import type { QueryConnectionChannelsResponse } from "./query_pb";
import type { QueryConnectionChannelsRequest } from "./query_pb";
import type { QueryChannelsResponse } from "./query_pb";
import type { QueryChannelsRequest } from "./query_pb";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { QueryChannelResponse } from "./query_pb";
import type { QueryChannelRequest } from "./query_pb";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Query provides defines the gRPC querier service
 *
 * @generated from protobuf service ibc.core.channel.v1.Query
 */
export interface IQueryClient {
    /**
     * Channel queries an IBC Channel.
     *
     * @generated from protobuf rpc: Channel
     */
    channel(input: QueryChannelRequest, options?: RpcOptions): UnaryCall<QueryChannelRequest, QueryChannelResponse>;
    /**
     * Channels queries all the IBC channels of a chain.
     *
     * @generated from protobuf rpc: Channels
     */
    channels(input: QueryChannelsRequest, options?: RpcOptions): UnaryCall<QueryChannelsRequest, QueryChannelsResponse>;
    /**
     * ConnectionChannels queries all the channels associated with a connection
     * end.
     *
     * @generated from protobuf rpc: ConnectionChannels
     */
    connectionChannels(input: QueryConnectionChannelsRequest, options?: RpcOptions): UnaryCall<QueryConnectionChannelsRequest, QueryConnectionChannelsResponse>;
    /**
     * ChannelClientState queries for the client state for the channel associated
     * with the provided channel identifiers.
     *
     * @generated from protobuf rpc: ChannelClientState
     */
    channelClientState(input: QueryChannelClientStateRequest, options?: RpcOptions): UnaryCall<QueryChannelClientStateRequest, QueryChannelClientStateResponse>;
    /**
     * ChannelConsensusState queries for the consensus state for the channel
     * associated with the provided channel identifiers.
     *
     * @generated from protobuf rpc: ChannelConsensusState
     */
    channelConsensusState(input: QueryChannelConsensusStateRequest, options?: RpcOptions): UnaryCall<QueryChannelConsensusStateRequest, QueryChannelConsensusStateResponse>;
    /**
     * PacketCommitment queries a stored packet commitment hash.
     *
     * @generated from protobuf rpc: PacketCommitment
     */
    packetCommitment(input: QueryPacketCommitmentRequest, options?: RpcOptions): UnaryCall<QueryPacketCommitmentRequest, QueryPacketCommitmentResponse>;
    /**
     * PacketCommitments returns all the packet commitments hashes associated
     * with a channel.
     *
     * @generated from protobuf rpc: PacketCommitments
     */
    packetCommitments(input: QueryPacketCommitmentsRequest, options?: RpcOptions): UnaryCall<QueryPacketCommitmentsRequest, QueryPacketCommitmentsResponse>;
    /**
     * PacketReceipt queries if a given packet sequence has been received on the
     * queried chain
     *
     * @generated from protobuf rpc: PacketReceipt
     */
    packetReceipt(input: QueryPacketReceiptRequest, options?: RpcOptions): UnaryCall<QueryPacketReceiptRequest, QueryPacketReceiptResponse>;
    /**
     * PacketAcknowledgement queries a stored packet acknowledgement hash.
     *
     * @generated from protobuf rpc: PacketAcknowledgement
     */
    packetAcknowledgement(input: QueryPacketAcknowledgementRequest, options?: RpcOptions): UnaryCall<QueryPacketAcknowledgementRequest, QueryPacketAcknowledgementResponse>;
    /**
     * PacketAcknowledgements returns all the packet acknowledgements associated
     * with a channel.
     *
     * @generated from protobuf rpc: PacketAcknowledgements
     */
    packetAcknowledgements(input: QueryPacketAcknowledgementsRequest, options?: RpcOptions): UnaryCall<QueryPacketAcknowledgementsRequest, QueryPacketAcknowledgementsResponse>;
    /**
     * UnreceivedPackets returns all the unreceived IBC packets associated with a
     * channel and sequences.
     *
     * @generated from protobuf rpc: UnreceivedPackets
     */
    unreceivedPackets(input: QueryUnreceivedPacketsRequest, options?: RpcOptions): UnaryCall<QueryUnreceivedPacketsRequest, QueryUnreceivedPacketsResponse>;
    /**
     * UnreceivedAcks returns all the unreceived IBC acknowledgements associated
     * with a channel and sequences.
     *
     * @generated from protobuf rpc: UnreceivedAcks
     */
    unreceivedAcks(input: QueryUnreceivedAcksRequest, options?: RpcOptions): UnaryCall<QueryUnreceivedAcksRequest, QueryUnreceivedAcksResponse>;
    /**
     * NextSequenceReceive returns the next receive sequence for a given channel.
     *
     * @generated from protobuf rpc: NextSequenceReceive
     */
    nextSequenceReceive(input: QueryNextSequenceReceiveRequest, options?: RpcOptions): UnaryCall<QueryNextSequenceReceiveRequest, QueryNextSequenceReceiveResponse>;
    /**
     * NextSequenceSend returns the next send sequence for a given channel.
     *
     * @generated from protobuf rpc: NextSequenceSend
     */
    nextSequenceSend(input: QueryNextSequenceSendRequest, options?: RpcOptions): UnaryCall<QueryNextSequenceSendRequest, QueryNextSequenceSendResponse>;
    /**
     * UpgradeError returns the error receipt if the upgrade handshake failed.
     *
     * @generated from protobuf rpc: UpgradeError
     */
    upgradeError(input: QueryUpgradeErrorRequest, options?: RpcOptions): UnaryCall<QueryUpgradeErrorRequest, QueryUpgradeErrorResponse>;
    /**
     * Upgrade returns the upgrade for a given port and channel id.
     *
     * @generated from protobuf rpc: Upgrade
     */
    upgrade(input: QueryUpgradeRequest, options?: RpcOptions): UnaryCall<QueryUpgradeRequest, QueryUpgradeResponse>;
    /**
     * ChannelParams queries all parameters of the ibc channel submodule.
     *
     * @generated from protobuf rpc: ChannelParams
     */
    channelParams(input: QueryChannelParamsRequest, options?: RpcOptions): UnaryCall<QueryChannelParamsRequest, QueryChannelParamsResponse>;
}
/**
 * Query provides defines the gRPC querier service
 *
 * @generated from protobuf service ibc.core.channel.v1.Query
 */
export class QueryClient implements IQueryClient, ServiceInfo {
    typeName = Query.typeName;
    methods = Query.methods;
    options = Query.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Channel queries an IBC Channel.
     *
     * @generated from protobuf rpc: Channel
     */
    channel(input: QueryChannelRequest, options?: RpcOptions): UnaryCall<QueryChannelRequest, QueryChannelResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryChannelRequest, QueryChannelResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Channels queries all the IBC channels of a chain.
     *
     * @generated from protobuf rpc: Channels
     */
    channels(input: QueryChannelsRequest, options?: RpcOptions): UnaryCall<QueryChannelsRequest, QueryChannelsResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryChannelsRequest, QueryChannelsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ConnectionChannels queries all the channels associated with a connection
     * end.
     *
     * @generated from protobuf rpc: ConnectionChannels
     */
    connectionChannels(input: QueryConnectionChannelsRequest, options?: RpcOptions): UnaryCall<QueryConnectionChannelsRequest, QueryConnectionChannelsResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryConnectionChannelsRequest, QueryConnectionChannelsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ChannelClientState queries for the client state for the channel associated
     * with the provided channel identifiers.
     *
     * @generated from protobuf rpc: ChannelClientState
     */
    channelClientState(input: QueryChannelClientStateRequest, options?: RpcOptions): UnaryCall<QueryChannelClientStateRequest, QueryChannelClientStateResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryChannelClientStateRequest, QueryChannelClientStateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ChannelConsensusState queries for the consensus state for the channel
     * associated with the provided channel identifiers.
     *
     * @generated from protobuf rpc: ChannelConsensusState
     */
    channelConsensusState(input: QueryChannelConsensusStateRequest, options?: RpcOptions): UnaryCall<QueryChannelConsensusStateRequest, QueryChannelConsensusStateResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryChannelConsensusStateRequest, QueryChannelConsensusStateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PacketCommitment queries a stored packet commitment hash.
     *
     * @generated from protobuf rpc: PacketCommitment
     */
    packetCommitment(input: QueryPacketCommitmentRequest, options?: RpcOptions): UnaryCall<QueryPacketCommitmentRequest, QueryPacketCommitmentResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryPacketCommitmentRequest, QueryPacketCommitmentResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PacketCommitments returns all the packet commitments hashes associated
     * with a channel.
     *
     * @generated from protobuf rpc: PacketCommitments
     */
    packetCommitments(input: QueryPacketCommitmentsRequest, options?: RpcOptions): UnaryCall<QueryPacketCommitmentsRequest, QueryPacketCommitmentsResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryPacketCommitmentsRequest, QueryPacketCommitmentsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PacketReceipt queries if a given packet sequence has been received on the
     * queried chain
     *
     * @generated from protobuf rpc: PacketReceipt
     */
    packetReceipt(input: QueryPacketReceiptRequest, options?: RpcOptions): UnaryCall<QueryPacketReceiptRequest, QueryPacketReceiptResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryPacketReceiptRequest, QueryPacketReceiptResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PacketAcknowledgement queries a stored packet acknowledgement hash.
     *
     * @generated from protobuf rpc: PacketAcknowledgement
     */
    packetAcknowledgement(input: QueryPacketAcknowledgementRequest, options?: RpcOptions): UnaryCall<QueryPacketAcknowledgementRequest, QueryPacketAcknowledgementResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryPacketAcknowledgementRequest, QueryPacketAcknowledgementResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PacketAcknowledgements returns all the packet acknowledgements associated
     * with a channel.
     *
     * @generated from protobuf rpc: PacketAcknowledgements
     */
    packetAcknowledgements(input: QueryPacketAcknowledgementsRequest, options?: RpcOptions): UnaryCall<QueryPacketAcknowledgementsRequest, QueryPacketAcknowledgementsResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryPacketAcknowledgementsRequest, QueryPacketAcknowledgementsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UnreceivedPackets returns all the unreceived IBC packets associated with a
     * channel and sequences.
     *
     * @generated from protobuf rpc: UnreceivedPackets
     */
    unreceivedPackets(input: QueryUnreceivedPacketsRequest, options?: RpcOptions): UnaryCall<QueryUnreceivedPacketsRequest, QueryUnreceivedPacketsResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryUnreceivedPacketsRequest, QueryUnreceivedPacketsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UnreceivedAcks returns all the unreceived IBC acknowledgements associated
     * with a channel and sequences.
     *
     * @generated from protobuf rpc: UnreceivedAcks
     */
    unreceivedAcks(input: QueryUnreceivedAcksRequest, options?: RpcOptions): UnaryCall<QueryUnreceivedAcksRequest, QueryUnreceivedAcksResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryUnreceivedAcksRequest, QueryUnreceivedAcksResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * NextSequenceReceive returns the next receive sequence for a given channel.
     *
     * @generated from protobuf rpc: NextSequenceReceive
     */
    nextSequenceReceive(input: QueryNextSequenceReceiveRequest, options?: RpcOptions): UnaryCall<QueryNextSequenceReceiveRequest, QueryNextSequenceReceiveResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryNextSequenceReceiveRequest, QueryNextSequenceReceiveResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * NextSequenceSend returns the next send sequence for a given channel.
     *
     * @generated from protobuf rpc: NextSequenceSend
     */
    nextSequenceSend(input: QueryNextSequenceSendRequest, options?: RpcOptions): UnaryCall<QueryNextSequenceSendRequest, QueryNextSequenceSendResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryNextSequenceSendRequest, QueryNextSequenceSendResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpgradeError returns the error receipt if the upgrade handshake failed.
     *
     * @generated from protobuf rpc: UpgradeError
     */
    upgradeError(input: QueryUpgradeErrorRequest, options?: RpcOptions): UnaryCall<QueryUpgradeErrorRequest, QueryUpgradeErrorResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryUpgradeErrorRequest, QueryUpgradeErrorResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Upgrade returns the upgrade for a given port and channel id.
     *
     * @generated from protobuf rpc: Upgrade
     */
    upgrade(input: QueryUpgradeRequest, options?: RpcOptions): UnaryCall<QueryUpgradeRequest, QueryUpgradeResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryUpgradeRequest, QueryUpgradeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ChannelParams queries all parameters of the ibc channel submodule.
     *
     * @generated from protobuf rpc: ChannelParams
     */
    channelParams(input: QueryChannelParamsRequest, options?: RpcOptions): UnaryCall<QueryChannelParamsRequest, QueryChannelParamsResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryChannelParamsRequest, QueryChannelParamsResponse>("unary", this._transport, method, opt, input);
    }
}
