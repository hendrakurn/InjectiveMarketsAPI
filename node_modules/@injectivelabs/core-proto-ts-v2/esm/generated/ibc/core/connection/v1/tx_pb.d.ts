// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "ibc/core/connection/v1/tx.proto" (package "ibc.core.connection.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Params } from "./connection_pb";
import { Height } from "../../client/v1/client_pb";
import { Any } from "../../../../google/protobuf/any_pb";
import { Version } from "./connection_pb";
import { Counterparty } from "./connection_pb";
/**
 * MsgConnectionOpenInit defines the msg sent by an account on Chain A to
 * initialize a connection with Chain B.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenInit
 */
export interface MsgConnectionOpenInit {
    /**
     * @generated from protobuf field: string client_id = 1
     */
    clientId: string;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Counterparty counterparty = 2
     */
    counterparty?: Counterparty;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Version version = 3
     */
    version?: Version;
    /**
     * @generated from protobuf field: uint64 delay_period = 4
     */
    delayPeriod: bigint;
    /**
     * @generated from protobuf field: string signer = 5
     */
    signer: string;
}
/**
 * MsgConnectionOpenInitResponse defines the Msg/ConnectionOpenInit response
 * type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenInitResponse
 */
export interface MsgConnectionOpenInitResponse {
}
/**
 * MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a
 * connection on Chain B.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenTry
 */
export interface MsgConnectionOpenTry {
    /**
     * @generated from protobuf field: string client_id = 1
     */
    clientId: string;
    /**
     * Deprecated: this field is unused. Crossing hellos are no longer supported in core IBC.
     *
     * @deprecated
     * @generated from protobuf field: string previous_connection_id = 2 [deprecated = true]
     */
    previousConnectionId: string;
    /**
     * @deprecated
     * @generated from protobuf field: google.protobuf.Any client_state = 3 [deprecated = true]
     */
    clientState?: Any;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Counterparty counterparty = 4
     */
    counterparty?: Counterparty;
    /**
     * @generated from protobuf field: uint64 delay_period = 5
     */
    delayPeriod: bigint;
    /**
     * @generated from protobuf field: repeated ibc.core.connection.v1.Version counterparty_versions = 6
     */
    counterpartyVersions: Version[];
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 7
     */
    proofHeight?: Height;
    /**
     * proof of the initialization the connection on Chain A: `UNITIALIZED ->
     * INIT`
     *
     * @generated from protobuf field: bytes proof_init = 8
     */
    proofInit: Uint8Array;
    /**
     * proof of client state included in message
     *
     * @deprecated
     * @generated from protobuf field: bytes proof_client = 9 [deprecated = true]
     */
    proofClient: Uint8Array;
    /**
     * proof of client consensus state
     *
     * @deprecated
     * @generated from protobuf field: bytes proof_consensus = 10 [deprecated = true]
     */
    proofConsensus: Uint8Array;
    /**
     * @deprecated
     * @generated from protobuf field: ibc.core.client.v1.Height consensus_height = 11 [deprecated = true]
     */
    consensusHeight?: Height;
    /**
     * @generated from protobuf field: string signer = 12
     */
    signer: string;
    /**
     * optional proof data for host state machines that are unable to introspect their own consensus state
     *
     * @deprecated
     * @generated from protobuf field: bytes host_consensus_state_proof = 13 [deprecated = true]
     */
    hostConsensusStateProof: Uint8Array;
}
/**
 * MsgConnectionOpenTryResponse defines the Msg/ConnectionOpenTry response type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenTryResponse
 */
export interface MsgConnectionOpenTryResponse {
}
/**
 * MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to
 * acknowledge the change of connection state to TRYOPEN on Chain B.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenAck
 */
export interface MsgConnectionOpenAck {
    /**
     * @generated from protobuf field: string connection_id = 1
     */
    connectionId: string;
    /**
     * @generated from protobuf field: string counterparty_connection_id = 2
     */
    counterpartyConnectionId: string;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Version version = 3
     */
    version?: Version;
    /**
     * @deprecated
     * @generated from protobuf field: google.protobuf.Any client_state = 4 [deprecated = true]
     */
    clientState?: Any;
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 5
     */
    proofHeight?: Height;
    /**
     * proof of the initialization the connection on Chain B: `UNITIALIZED ->
     * TRYOPEN`
     *
     * @generated from protobuf field: bytes proof_try = 6
     */
    proofTry: Uint8Array;
    /**
     * proof of client state included in message
     *
     * @deprecated
     * @generated from protobuf field: bytes proof_client = 7 [deprecated = true]
     */
    proofClient: Uint8Array;
    /**
     * proof of client consensus state
     *
     * @deprecated
     * @generated from protobuf field: bytes proof_consensus = 8 [deprecated = true]
     */
    proofConsensus: Uint8Array;
    /**
     * @deprecated
     * @generated from protobuf field: ibc.core.client.v1.Height consensus_height = 9 [deprecated = true]
     */
    consensusHeight?: Height;
    /**
     * @generated from protobuf field: string signer = 10
     */
    signer: string;
    /**
     * optional proof data for host state machines that are unable to introspect their own consensus state
     *
     * @deprecated
     * @generated from protobuf field: bytes host_consensus_state_proof = 11 [deprecated = true]
     */
    hostConsensusStateProof: Uint8Array;
}
/**
 * MsgConnectionOpenAckResponse defines the Msg/ConnectionOpenAck response type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenAckResponse
 */
export interface MsgConnectionOpenAckResponse {
}
/**
 * MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to
 * acknowledge the change of connection state to OPEN on Chain A.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirm
 */
export interface MsgConnectionOpenConfirm {
    /**
     * @generated from protobuf field: string connection_id = 1
     */
    connectionId: string;
    /**
     * proof for the change of the connection state on Chain A: `INIT -> OPEN`
     *
     * @generated from protobuf field: bytes proof_ack = 2
     */
    proofAck: Uint8Array;
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 3
     */
    proofHeight?: Height;
    /**
     * @generated from protobuf field: string signer = 4
     */
    signer: string;
}
/**
 * MsgConnectionOpenConfirmResponse defines the Msg/ConnectionOpenConfirm
 * response type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirmResponse
 */
export interface MsgConnectionOpenConfirmResponse {
}
/**
 * MsgUpdateParams defines the sdk.Msg type to update the connection parameters.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * signer address
     *
     * @generated from protobuf field: string signer = 1
     */
    signer: string;
    /**
     * params defines the connection parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: ibc.core.connection.v1.Params params = 2
     */
    params?: Params;
}
/**
 * MsgUpdateParamsResponse defines the MsgUpdateParams response type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenInit$Type extends MessageType<MsgConnectionOpenInit> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenInit", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "counterparty", kind: "message", T: () => Counterparty, options: { "gogoproto.nullable": false } },
            { no: 3, name: "version", kind: "message", T: () => Version },
            { no: 4, name: "delay_period", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgConnectionOpenInit>): MsgConnectionOpenInit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = "";
        message.delayPeriod = 0n;
        message.signer = "";
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenInit): MsgConnectionOpenInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* ibc.core.connection.v1.Counterparty counterparty */ 2:
                    message.counterparty = Counterparty.internalBinaryRead(reader, reader.uint32(), options, message.counterparty);
                    break;
                case /* ibc.core.connection.v1.Version version */ 3:
                    message.version = Version.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* uint64 delay_period */ 4:
                    message.delayPeriod = reader.uint64().toBigInt();
                    break;
                case /* string signer */ 5:
                    message.signer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* ibc.core.connection.v1.Counterparty counterparty = 2; */
        if (message.counterparty)
            Counterparty.internalBinaryWrite(message.counterparty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.connection.v1.Version version = 3; */
        if (message.version)
            Version.internalBinaryWrite(message.version, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 delay_period = 4; */
        if (message.delayPeriod !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.delayPeriod);
        /* string signer = 5; */
        if (message.signer !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.signer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenInit
 */
export const MsgConnectionOpenInit = new MsgConnectionOpenInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenInitResponse$Type extends MessageType<MsgConnectionOpenInitResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenInitResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenInitResponse>): MsgConnectionOpenInitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenInitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenInitResponse): MsgConnectionOpenInitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenInitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenInitResponse
 */
export const MsgConnectionOpenInitResponse = new MsgConnectionOpenInitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenTry$Type extends MessageType<MsgConnectionOpenTry> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenTry", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "previous_connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_state", kind: "message", T: () => Any },
            { no: 4, name: "counterparty", kind: "message", T: () => Counterparty, options: { "gogoproto.nullable": false } },
            { no: 5, name: "delay_period", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "counterparty_versions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Version },
            { no: 7, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } },
            { no: 8, name: "proof_init", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "proof_client", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "proof_consensus", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "consensus_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } },
            { no: 12, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "host_consensus_state_proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgConnectionOpenTry>): MsgConnectionOpenTry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = "";
        message.previousConnectionId = "";
        message.delayPeriod = 0n;
        message.counterpartyVersions = [];
        message.proofInit = new Uint8Array(0);
        message.proofClient = new Uint8Array(0);
        message.proofConsensus = new Uint8Array(0);
        message.signer = "";
        message.hostConsensusStateProof = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenTry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenTry): MsgConnectionOpenTry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* string previous_connection_id = 2 [deprecated = true] */ 2:
                    message.previousConnectionId = reader.string();
                    break;
                case /* google.protobuf.Any client_state = 3 [deprecated = true] */ 3:
                    message.clientState = Any.internalBinaryRead(reader, reader.uint32(), options, message.clientState);
                    break;
                case /* ibc.core.connection.v1.Counterparty counterparty */ 4:
                    message.counterparty = Counterparty.internalBinaryRead(reader, reader.uint32(), options, message.counterparty);
                    break;
                case /* uint64 delay_period */ 5:
                    message.delayPeriod = reader.uint64().toBigInt();
                    break;
                case /* repeated ibc.core.connection.v1.Version counterparty_versions */ 6:
                    message.counterpartyVersions.push(Version.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 7:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                case /* bytes proof_init */ 8:
                    message.proofInit = reader.bytes();
                    break;
                case /* bytes proof_client = 9 [deprecated = true] */ 9:
                    message.proofClient = reader.bytes();
                    break;
                case /* bytes proof_consensus = 10 [deprecated = true] */ 10:
                    message.proofConsensus = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height consensus_height = 11 [deprecated = true] */ 11:
                    message.consensusHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.consensusHeight);
                    break;
                case /* string signer */ 12:
                    message.signer = reader.string();
                    break;
                case /* bytes host_consensus_state_proof = 13 [deprecated = true] */ 13:
                    message.hostConsensusStateProof = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenTry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string previous_connection_id = 2 [deprecated = true]; */
        if (message.previousConnectionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.previousConnectionId);
        /* google.protobuf.Any client_state = 3 [deprecated = true]; */
        if (message.clientState)
            Any.internalBinaryWrite(message.clientState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.connection.v1.Counterparty counterparty = 4; */
        if (message.counterparty)
            Counterparty.internalBinaryWrite(message.counterparty, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint64 delay_period = 5; */
        if (message.delayPeriod !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.delayPeriod);
        /* repeated ibc.core.connection.v1.Version counterparty_versions = 6; */
        for (let i = 0; i < message.counterpartyVersions.length; i++)
            Version.internalBinaryWrite(message.counterpartyVersions[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height proof_height = 7; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bytes proof_init = 8; */
        if (message.proofInit.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proofInit);
        /* bytes proof_client = 9 [deprecated = true]; */
        if (message.proofClient.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.proofClient);
        /* bytes proof_consensus = 10 [deprecated = true]; */
        if (message.proofConsensus.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.proofConsensus);
        /* ibc.core.client.v1.Height consensus_height = 11 [deprecated = true]; */
        if (message.consensusHeight)
            Height.internalBinaryWrite(message.consensusHeight, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string signer = 12; */
        if (message.signer !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.signer);
        /* bytes host_consensus_state_proof = 13 [deprecated = true]; */
        if (message.hostConsensusStateProof.length)
            writer.tag(13, WireType.LengthDelimited).bytes(message.hostConsensusStateProof);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenTry
 */
export const MsgConnectionOpenTry = new MsgConnectionOpenTry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenTryResponse$Type extends MessageType<MsgConnectionOpenTryResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenTryResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenTryResponse>): MsgConnectionOpenTryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenTryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenTryResponse): MsgConnectionOpenTryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenTryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenTryResponse
 */
export const MsgConnectionOpenTryResponse = new MsgConnectionOpenTryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenAck$Type extends MessageType<MsgConnectionOpenAck> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenAck", [
            { no: 1, name: "connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "counterparty_connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "message", T: () => Version },
            { no: 4, name: "client_state", kind: "message", T: () => Any },
            { no: 5, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } },
            { no: 6, name: "proof_try", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "proof_client", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proof_consensus", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "consensus_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } },
            { no: 10, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "host_consensus_state_proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgConnectionOpenAck>): MsgConnectionOpenAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectionId = "";
        message.counterpartyConnectionId = "";
        message.proofTry = new Uint8Array(0);
        message.proofClient = new Uint8Array(0);
        message.proofConsensus = new Uint8Array(0);
        message.signer = "";
        message.hostConsensusStateProof = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenAck): MsgConnectionOpenAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connection_id */ 1:
                    message.connectionId = reader.string();
                    break;
                case /* string counterparty_connection_id */ 2:
                    message.counterpartyConnectionId = reader.string();
                    break;
                case /* ibc.core.connection.v1.Version version */ 3:
                    message.version = Version.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* google.protobuf.Any client_state = 4 [deprecated = true] */ 4:
                    message.clientState = Any.internalBinaryRead(reader, reader.uint32(), options, message.clientState);
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 5:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                case /* bytes proof_try */ 6:
                    message.proofTry = reader.bytes();
                    break;
                case /* bytes proof_client = 7 [deprecated = true] */ 7:
                    message.proofClient = reader.bytes();
                    break;
                case /* bytes proof_consensus = 8 [deprecated = true] */ 8:
                    message.proofConsensus = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height consensus_height = 9 [deprecated = true] */ 9:
                    message.consensusHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.consensusHeight);
                    break;
                case /* string signer */ 10:
                    message.signer = reader.string();
                    break;
                case /* bytes host_consensus_state_proof = 11 [deprecated = true] */ 11:
                    message.hostConsensusStateProof = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connection_id = 1; */
        if (message.connectionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectionId);
        /* string counterparty_connection_id = 2; */
        if (message.counterpartyConnectionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.counterpartyConnectionId);
        /* ibc.core.connection.v1.Version version = 3; */
        if (message.version)
            Version.internalBinaryWrite(message.version, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any client_state = 4 [deprecated = true]; */
        if (message.clientState)
            Any.internalBinaryWrite(message.clientState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height proof_height = 5; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bytes proof_try = 6; */
        if (message.proofTry.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.proofTry);
        /* bytes proof_client = 7 [deprecated = true]; */
        if (message.proofClient.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.proofClient);
        /* bytes proof_consensus = 8 [deprecated = true]; */
        if (message.proofConsensus.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proofConsensus);
        /* ibc.core.client.v1.Height consensus_height = 9 [deprecated = true]; */
        if (message.consensusHeight)
            Height.internalBinaryWrite(message.consensusHeight, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string signer = 10; */
        if (message.signer !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.signer);
        /* bytes host_consensus_state_proof = 11 [deprecated = true]; */
        if (message.hostConsensusStateProof.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.hostConsensusStateProof);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenAck
 */
export const MsgConnectionOpenAck = new MsgConnectionOpenAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenAckResponse$Type extends MessageType<MsgConnectionOpenAckResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenAckResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenAckResponse>): MsgConnectionOpenAckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenAckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenAckResponse): MsgConnectionOpenAckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenAckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenAckResponse
 */
export const MsgConnectionOpenAckResponse = new MsgConnectionOpenAckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenConfirm$Type extends MessageType<MsgConnectionOpenConfirm> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenConfirm", [
            { no: 1, name: "connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proof_ack", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } },
            { no: 4, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgConnectionOpenConfirm>): MsgConnectionOpenConfirm {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectionId = "";
        message.proofAck = new Uint8Array(0);
        message.signer = "";
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenConfirm): MsgConnectionOpenConfirm {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connection_id */ 1:
                    message.connectionId = reader.string();
                    break;
                case /* bytes proof_ack */ 2:
                    message.proofAck = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 3:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                case /* string signer */ 4:
                    message.signer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenConfirm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connection_id = 1; */
        if (message.connectionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectionId);
        /* bytes proof_ack = 2; */
        if (message.proofAck.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proofAck);
        /* ibc.core.client.v1.Height proof_height = 3; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string signer = 4; */
        if (message.signer !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.signer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirm
 */
export const MsgConnectionOpenConfirm = new MsgConnectionOpenConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenConfirmResponse$Type extends MessageType<MsgConnectionOpenConfirmResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenConfirmResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenConfirmResponse>): MsgConnectionOpenConfirmResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenConfirmResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenConfirmResponse): MsgConnectionOpenConfirmResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenConfirmResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirmResponse
 */
export const MsgConnectionOpenConfirmResponse = new MsgConnectionOpenConfirmResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("ibc.core.connection.v1.MsgUpdateParams", [
            { no: 1, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signer = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string signer */ 1:
                    message.signer = reader.string();
                    break;
                case /* ibc.core.connection.v1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string signer = 1; */
        if (message.signer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signer);
        /* ibc.core.connection.v1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
/**
 * @generated ServiceType for protobuf service ibc.core.connection.v1.Msg
 */
export const Msg = new ServiceType("ibc.core.connection.v1.Msg", [
    { name: "ConnectionOpenInit", options: {}, I: MsgConnectionOpenInit, O: MsgConnectionOpenInitResponse },
    { name: "ConnectionOpenTry", options: {}, I: MsgConnectionOpenTry, O: MsgConnectionOpenTryResponse },
    { name: "ConnectionOpenAck", options: {}, I: MsgConnectionOpenAck, O: MsgConnectionOpenAckResponse },
    { name: "ConnectionOpenConfirm", options: {}, I: MsgConnectionOpenConfirm, O: MsgConnectionOpenConfirmResponse },
    { name: "UpdateConnectionParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse }
], { "cosmos.msg.v1.service": true });
