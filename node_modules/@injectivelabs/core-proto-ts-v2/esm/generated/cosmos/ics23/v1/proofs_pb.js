import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
var HashOp = /* @__PURE__ */ ((HashOp2) => {
  HashOp2[HashOp2["NO_HASH"] = 0] = "NO_HASH";
  HashOp2[HashOp2["SHA256"] = 1] = "SHA256";
  HashOp2[HashOp2["SHA512"] = 2] = "SHA512";
  HashOp2[HashOp2["KECCAK256"] = 3] = "KECCAK256";
  HashOp2[HashOp2["RIPEMD160"] = 4] = "RIPEMD160";
  HashOp2[HashOp2["BITCOIN"] = 5] = "BITCOIN";
  HashOp2[HashOp2["SHA512_256"] = 6] = "SHA512_256";
  HashOp2[HashOp2["BLAKE2B_512"] = 7] = "BLAKE2B_512";
  HashOp2[HashOp2["BLAKE2S_256"] = 8] = "BLAKE2S_256";
  HashOp2[HashOp2["BLAKE3"] = 9] = "BLAKE3";
  return HashOp2;
})(HashOp || {});
var LengthOp = /* @__PURE__ */ ((LengthOp2) => {
  LengthOp2[LengthOp2["NO_PREFIX"] = 0] = "NO_PREFIX";
  LengthOp2[LengthOp2["VAR_PROTO"] = 1] = "VAR_PROTO";
  LengthOp2[LengthOp2["VAR_RLP"] = 2] = "VAR_RLP";
  LengthOp2[LengthOp2["FIXED32_BIG"] = 3] = "FIXED32_BIG";
  LengthOp2[LengthOp2["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
  LengthOp2[LengthOp2["FIXED64_BIG"] = 5] = "FIXED64_BIG";
  LengthOp2[LengthOp2["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
  LengthOp2[LengthOp2["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
  LengthOp2[LengthOp2["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
  return LengthOp2;
})(LengthOp || {});
class ExistenceProof$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.ExistenceProof", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "leaf", kind: "message", T: () => LeafOp },
      { no: 4, name: "path", kind: "message", repeat: 2, T: () => InnerOp }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = new Uint8Array(0);
    message.value = new Uint8Array(0);
    message.path = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes key */
        1:
          message.key = reader.bytes();
          break;
        case /* bytes value */
        2:
          message.value = reader.bytes();
          break;
        case /* cosmos.ics23.v1.LeafOp leaf */
        3:
          message.leaf = LeafOp.internalBinaryRead(reader, reader.uint32(), options, message.leaf);
          break;
        case /* repeated cosmos.ics23.v1.InnerOp path */
        4:
          message.path.push(InnerOp.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.key.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.key);
    if (message.value.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.value);
    if (message.leaf)
      LeafOp.internalBinaryWrite(message.leaf, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.path.length; i++)
      InnerOp.internalBinaryWrite(message.path[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExistenceProof = new ExistenceProof$Type();
class NonExistenceProof$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.NonExistenceProof", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "left", kind: "message", T: () => ExistenceProof },
      { no: 3, name: "right", kind: "message", T: () => ExistenceProof }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes key */
        1:
          message.key = reader.bytes();
          break;
        case /* cosmos.ics23.v1.ExistenceProof left */
        2:
          message.left = ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.left);
          break;
        case /* cosmos.ics23.v1.ExistenceProof right */
        3:
          message.right = ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.right);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.key.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.key);
    if (message.left)
      ExistenceProof.internalBinaryWrite(message.left, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.right)
      ExistenceProof.internalBinaryWrite(message.right, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const NonExistenceProof = new NonExistenceProof$Type();
class CommitmentProof$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.CommitmentProof", [
      { no: 1, name: "exist", kind: "message", oneof: "proof", T: () => ExistenceProof },
      { no: 2, name: "nonexist", kind: "message", oneof: "proof", T: () => NonExistenceProof },
      { no: 3, name: "batch", kind: "message", oneof: "proof", T: () => BatchProof },
      { no: 4, name: "compressed", kind: "message", oneof: "proof", T: () => CompressedBatchProof }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.proof = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.ics23.v1.ExistenceProof exist */
        1:
          message.proof = {
            oneofKind: "exist",
            exist: ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.exist)
          };
          break;
        case /* cosmos.ics23.v1.NonExistenceProof nonexist */
        2:
          message.proof = {
            oneofKind: "nonexist",
            nonexist: NonExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.nonexist)
          };
          break;
        case /* cosmos.ics23.v1.BatchProof batch */
        3:
          message.proof = {
            oneofKind: "batch",
            batch: BatchProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.batch)
          };
          break;
        case /* cosmos.ics23.v1.CompressedBatchProof compressed */
        4:
          message.proof = {
            oneofKind: "compressed",
            compressed: CompressedBatchProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.compressed)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.proof.oneofKind === "exist")
      ExistenceProof.internalBinaryWrite(message.proof.exist, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.proof.oneofKind === "nonexist")
      NonExistenceProof.internalBinaryWrite(message.proof.nonexist, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.proof.oneofKind === "batch")
      BatchProof.internalBinaryWrite(message.proof.batch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.proof.oneofKind === "compressed")
      CompressedBatchProof.internalBinaryWrite(message.proof.compressed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommitmentProof = new CommitmentProof$Type();
class LeafOp$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.LeafOp", [
      { no: 1, name: "hash", kind: "enum", T: () => ["cosmos.ics23.v1.HashOp", HashOp] },
      { no: 2, name: "prehash_key", kind: "enum", T: () => ["cosmos.ics23.v1.HashOp", HashOp] },
      { no: 3, name: "prehash_value", kind: "enum", T: () => ["cosmos.ics23.v1.HashOp", HashOp] },
      { no: 4, name: "length", kind: "enum", T: () => ["cosmos.ics23.v1.LengthOp", LengthOp] },
      {
        no: 5,
        name: "prefix",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = 0;
    message.prehashKey = 0;
    message.prehashValue = 0;
    message.length = 0;
    message.prefix = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.ics23.v1.HashOp hash */
        1:
          message.hash = reader.int32();
          break;
        case /* cosmos.ics23.v1.HashOp prehash_key */
        2:
          message.prehashKey = reader.int32();
          break;
        case /* cosmos.ics23.v1.HashOp prehash_value */
        3:
          message.prehashValue = reader.int32();
          break;
        case /* cosmos.ics23.v1.LengthOp length */
        4:
          message.length = reader.int32();
          break;
        case /* bytes prefix */
        5:
          message.prefix = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash !== 0)
      writer.tag(1, WireType.Varint).int32(message.hash);
    if (message.prehashKey !== 0)
      writer.tag(2, WireType.Varint).int32(message.prehashKey);
    if (message.prehashValue !== 0)
      writer.tag(3, WireType.Varint).int32(message.prehashValue);
    if (message.length !== 0)
      writer.tag(4, WireType.Varint).int32(message.length);
    if (message.prefix.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.prefix);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeafOp = new LeafOp$Type();
class InnerOp$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.InnerOp", [
      { no: 1, name: "hash", kind: "enum", T: () => ["cosmos.ics23.v1.HashOp", HashOp] },
      {
        no: 2,
        name: "prefix",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "suffix",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = 0;
    message.prefix = new Uint8Array(0);
    message.suffix = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.ics23.v1.HashOp hash */
        1:
          message.hash = reader.int32();
          break;
        case /* bytes prefix */
        2:
          message.prefix = reader.bytes();
          break;
        case /* bytes suffix */
        3:
          message.suffix = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash !== 0)
      writer.tag(1, WireType.Varint).int32(message.hash);
    if (message.prefix.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.prefix);
    if (message.suffix.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.suffix);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InnerOp = new InnerOp$Type();
class ProofSpec$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.ProofSpec", [
      { no: 1, name: "leaf_spec", kind: "message", T: () => LeafOp },
      { no: 2, name: "inner_spec", kind: "message", T: () => InnerSpec },
      {
        no: 3,
        name: "max_depth",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "min_depth",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "prehash_key_before_comparison",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.maxDepth = 0;
    message.minDepth = 0;
    message.prehashKeyBeforeComparison = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.ics23.v1.LeafOp leaf_spec */
        1:
          message.leafSpec = LeafOp.internalBinaryRead(reader, reader.uint32(), options, message.leafSpec);
          break;
        case /* cosmos.ics23.v1.InnerSpec inner_spec */
        2:
          message.innerSpec = InnerSpec.internalBinaryRead(reader, reader.uint32(), options, message.innerSpec);
          break;
        case /* int32 max_depth */
        3:
          message.maxDepth = reader.int32();
          break;
        case /* int32 min_depth */
        4:
          message.minDepth = reader.int32();
          break;
        case /* bool prehash_key_before_comparison */
        5:
          message.prehashKeyBeforeComparison = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.leafSpec)
      LeafOp.internalBinaryWrite(message.leafSpec, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.innerSpec)
      InnerSpec.internalBinaryWrite(message.innerSpec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.maxDepth !== 0)
      writer.tag(3, WireType.Varint).int32(message.maxDepth);
    if (message.minDepth !== 0)
      writer.tag(4, WireType.Varint).int32(message.minDepth);
    if (message.prehashKeyBeforeComparison !== false)
      writer.tag(5, WireType.Varint).bool(message.prehashKeyBeforeComparison);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProofSpec = new ProofSpec$Type();
class InnerSpec$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.InnerSpec", [
      {
        no: 1,
        name: "child_order",
        kind: "scalar",
        repeat: 1,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "child_size",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "min_prefix_length",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "max_prefix_length",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "empty_child",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 6, name: "hash", kind: "enum", T: () => ["cosmos.ics23.v1.HashOp", HashOp] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.childOrder = [];
    message.childSize = 0;
    message.minPrefixLength = 0;
    message.maxPrefixLength = 0;
    message.emptyChild = new Uint8Array(0);
    message.hash = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated int32 child_order */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.childOrder.push(reader.int32());
          else
            message.childOrder.push(reader.int32());
          break;
        case /* int32 child_size */
        2:
          message.childSize = reader.int32();
          break;
        case /* int32 min_prefix_length */
        3:
          message.minPrefixLength = reader.int32();
          break;
        case /* int32 max_prefix_length */
        4:
          message.maxPrefixLength = reader.int32();
          break;
        case /* bytes empty_child */
        5:
          message.emptyChild = reader.bytes();
          break;
        case /* cosmos.ics23.v1.HashOp hash */
        6:
          message.hash = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.childOrder.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.childOrder.length; i++)
        writer.int32(message.childOrder[i]);
      writer.join();
    }
    if (message.childSize !== 0)
      writer.tag(2, WireType.Varint).int32(message.childSize);
    if (message.minPrefixLength !== 0)
      writer.tag(3, WireType.Varint).int32(message.minPrefixLength);
    if (message.maxPrefixLength !== 0)
      writer.tag(4, WireType.Varint).int32(message.maxPrefixLength);
    if (message.emptyChild.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.emptyChild);
    if (message.hash !== 0)
      writer.tag(6, WireType.Varint).int32(message.hash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InnerSpec = new InnerSpec$Type();
class BatchProof$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.BatchProof", [
      { no: 1, name: "entries", kind: "message", repeat: 2, T: () => BatchEntry }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.entries = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.ics23.v1.BatchEntry entries */
        1:
          message.entries.push(BatchEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.entries.length; i++)
      BatchEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchProof = new BatchProof$Type();
class BatchEntry$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.BatchEntry", [
      { no: 1, name: "exist", kind: "message", oneof: "proof", T: () => ExistenceProof },
      { no: 2, name: "nonexist", kind: "message", oneof: "proof", T: () => NonExistenceProof }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.proof = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.ics23.v1.ExistenceProof exist */
        1:
          message.proof = {
            oneofKind: "exist",
            exist: ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.exist)
          };
          break;
        case /* cosmos.ics23.v1.NonExistenceProof nonexist */
        2:
          message.proof = {
            oneofKind: "nonexist",
            nonexist: NonExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.nonexist)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.proof.oneofKind === "exist")
      ExistenceProof.internalBinaryWrite(message.proof.exist, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.proof.oneofKind === "nonexist")
      NonExistenceProof.internalBinaryWrite(message.proof.nonexist, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchEntry = new BatchEntry$Type();
class CompressedBatchProof$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.CompressedBatchProof", [
      { no: 1, name: "entries", kind: "message", repeat: 2, T: () => CompressedBatchEntry },
      { no: 2, name: "lookup_inners", kind: "message", repeat: 2, T: () => InnerOp }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.entries = [];
    message.lookupInners = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.ics23.v1.CompressedBatchEntry entries */
        1:
          message.entries.push(CompressedBatchEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated cosmos.ics23.v1.InnerOp lookup_inners */
        2:
          message.lookupInners.push(InnerOp.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.entries.length; i++)
      CompressedBatchEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.lookupInners.length; i++)
      InnerOp.internalBinaryWrite(message.lookupInners[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CompressedBatchProof = new CompressedBatchProof$Type();
class CompressedBatchEntry$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.CompressedBatchEntry", [
      { no: 1, name: "exist", kind: "message", oneof: "proof", T: () => CompressedExistenceProof },
      { no: 2, name: "nonexist", kind: "message", oneof: "proof", T: () => CompressedNonExistenceProof }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.proof = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.ics23.v1.CompressedExistenceProof exist */
        1:
          message.proof = {
            oneofKind: "exist",
            exist: CompressedExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.exist)
          };
          break;
        case /* cosmos.ics23.v1.CompressedNonExistenceProof nonexist */
        2:
          message.proof = {
            oneofKind: "nonexist",
            nonexist: CompressedNonExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.nonexist)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.proof.oneofKind === "exist")
      CompressedExistenceProof.internalBinaryWrite(message.proof.exist, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.proof.oneofKind === "nonexist")
      CompressedNonExistenceProof.internalBinaryWrite(message.proof.nonexist, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CompressedBatchEntry = new CompressedBatchEntry$Type();
class CompressedExistenceProof$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.CompressedExistenceProof", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "leaf", kind: "message", T: () => LeafOp },
      {
        no: 4,
        name: "path",
        kind: "scalar",
        repeat: 1,
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = new Uint8Array(0);
    message.value = new Uint8Array(0);
    message.path = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes key */
        1:
          message.key = reader.bytes();
          break;
        case /* bytes value */
        2:
          message.value = reader.bytes();
          break;
        case /* cosmos.ics23.v1.LeafOp leaf */
        3:
          message.leaf = LeafOp.internalBinaryRead(reader, reader.uint32(), options, message.leaf);
          break;
        case /* repeated int32 path */
        4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.path.push(reader.int32());
          else
            message.path.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.key.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.key);
    if (message.value.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.value);
    if (message.leaf)
      LeafOp.internalBinaryWrite(message.leaf, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.path.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.path.length; i++)
        writer.int32(message.path[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CompressedExistenceProof = new CompressedExistenceProof$Type();
class CompressedNonExistenceProof$Type extends MessageType {
  constructor() {
    super("cosmos.ics23.v1.CompressedNonExistenceProof", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "left", kind: "message", T: () => CompressedExistenceProof },
      { no: 3, name: "right", kind: "message", T: () => CompressedExistenceProof }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes key */
        1:
          message.key = reader.bytes();
          break;
        case /* cosmos.ics23.v1.CompressedExistenceProof left */
        2:
          message.left = CompressedExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.left);
          break;
        case /* cosmos.ics23.v1.CompressedExistenceProof right */
        3:
          message.right = CompressedExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.right);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.key.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.key);
    if (message.left)
      CompressedExistenceProof.internalBinaryWrite(message.left, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.right)
      CompressedExistenceProof.internalBinaryWrite(message.right, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CompressedNonExistenceProof = new CompressedNonExistenceProof$Type();
export {
  BatchEntry,
  BatchProof,
  CommitmentProof,
  CompressedBatchEntry,
  CompressedBatchProof,
  CompressedExistenceProof,
  CompressedNonExistenceProof,
  ExistenceProof,
  HashOp,
  InnerOp,
  InnerSpec,
  LeafOp,
  LengthOp,
  NonExistenceProof,
  ProofSpec
};
