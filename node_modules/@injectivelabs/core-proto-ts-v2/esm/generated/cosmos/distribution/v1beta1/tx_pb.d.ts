// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "cosmos/distribution/v1beta1/tx.proto" (package "cosmos.distribution.v1beta1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Params } from "./distribution_pb";
import { Coin } from "../../base/v1beta1/coin_pb";
/**
 * MsgSetWithdrawAddress sets the withdraw address for
 * a delegator (or validator self-delegation).
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgSetWithdrawAddress
 */
export interface MsgSetWithdrawAddress {
    /**
     * @generated from protobuf field: string delegator_address = 1
     */
    delegatorAddress: string;
    /**
     * @generated from protobuf field: string withdraw_address = 2
     */
    withdrawAddress: string;
}
/**
 * MsgSetWithdrawAddressResponse defines the Msg/SetWithdrawAddress response
 * type.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse
 */
export interface MsgSetWithdrawAddressResponse {
}
/**
 * MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator
 * from a single validator.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward
 */
export interface MsgWithdrawDelegatorReward {
    /**
     * @generated from protobuf field: string delegator_address = 1
     */
    delegatorAddress: string;
    /**
     * @generated from protobuf field: string validator_address = 2
     */
    validatorAddress: string;
}
/**
 * MsgWithdrawDelegatorRewardResponse defines the Msg/WithdrawDelegatorReward
 * response type.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse
 */
export interface MsgWithdrawDelegatorRewardResponse {
    /**
     * Since: cosmos-sdk 0.46
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1
     */
    amount: Coin[];
}
/**
 * MsgWithdrawValidatorCommission withdraws the full commission to the validator
 * address.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission
 */
export interface MsgWithdrawValidatorCommission {
    /**
     * @generated from protobuf field: string validator_address = 1
     */
    validatorAddress: string;
}
/**
 * MsgWithdrawValidatorCommissionResponse defines the
 * Msg/WithdrawValidatorCommission response type.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse
 */
export interface MsgWithdrawValidatorCommissionResponse {
    /**
     * Since: cosmos-sdk 0.46
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1
     */
    amount: Coin[];
}
/**
 * MsgFundCommunityPool allows an account to directly
 * fund the community pool.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgFundCommunityPool
 */
export interface MsgFundCommunityPool {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1
     */
    amount: Coin[];
    /**
     * @generated from protobuf field: string depositor = 2
     */
    depositor: string;
}
/**
 * MsgFundCommunityPoolResponse defines the Msg/FundCommunityPool response type.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse
 */
export interface MsgFundCommunityPoolResponse {
}
/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 *
 * Since: cosmos-sdk 0.47
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * authority is the address that controls the module (defaults to x/gov unless overwritten).
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the x/distribution parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: cosmos.distribution.v1beta1.Params params = 2
     */
    params?: Params;
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * Since: cosmos-sdk 0.47
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgCommunityPoolSpend defines a message for sending tokens from the community
 * pool to another account. This message is typically executed via a governance
 * proposal with the governance module being the executing authority.
 *
 * Since: cosmos-sdk 0.47
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgCommunityPoolSpend
 */
export interface MsgCommunityPoolSpend {
    /**
     * authority is the address that controls the module (defaults to x/gov unless overwritten).
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * @generated from protobuf field: string recipient = 2
     */
    recipient: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 3
     */
    amount: Coin[];
}
/**
 * MsgCommunityPoolSpendResponse defines the response to executing a
 * MsgCommunityPoolSpend message.
 *
 * Since: cosmos-sdk 0.47
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse
 */
export interface MsgCommunityPoolSpendResponse {
}
/**
 * DepositValidatorRewardsPool defines the request structure to provide
 * additional rewards to delegators from a specific validator.
 *
 * Since: cosmos-sdk 0.50
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool
 */
export interface MsgDepositValidatorRewardsPool {
    /**
     * @generated from protobuf field: string depositor = 1
     */
    depositor: string;
    /**
     * @generated from protobuf field: string validator_address = 2
     */
    validatorAddress: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 3
     */
    amount: Coin[];
}
/**
 * MsgDepositValidatorRewardsPoolResponse defines the response to executing a
 * MsgDepositValidatorRewardsPool message.
 *
 * Since: cosmos-sdk 0.50
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse
 */
export interface MsgDepositValidatorRewardsPoolResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgSetWithdrawAddress$Type extends MessageType<MsgSetWithdrawAddress> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgSetWithdrawAddress", [
            { no: 1, name: "delegator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "withdraw_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "cosmos-sdk/MsgModifyWithdrawAddress", "cosmos.msg.v1.signer": ["delegator_address"] });
    }
    create(value?: PartialMessage<MsgSetWithdrawAddress>): MsgSetWithdrawAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.delegatorAddress = "";
        message.withdrawAddress = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSetWithdrawAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSetWithdrawAddress): MsgSetWithdrawAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string delegator_address */ 1:
                    message.delegatorAddress = reader.string();
                    break;
                case /* string withdraw_address */ 2:
                    message.withdrawAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSetWithdrawAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string delegator_address = 1; */
        if (message.delegatorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.delegatorAddress);
        /* string withdraw_address = 2; */
        if (message.withdrawAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.withdrawAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgSetWithdrawAddress
 */
export const MsgSetWithdrawAddress = new MsgSetWithdrawAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSetWithdrawAddressResponse$Type extends MessageType<MsgSetWithdrawAddressResponse> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse", []);
    }
    create(value?: PartialMessage<MsgSetWithdrawAddressResponse>): MsgSetWithdrawAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSetWithdrawAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSetWithdrawAddressResponse): MsgSetWithdrawAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSetWithdrawAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse
 */
export const MsgSetWithdrawAddressResponse = new MsgSetWithdrawAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawDelegatorReward$Type extends MessageType<MsgWithdrawDelegatorReward> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", [
            { no: 1, name: "delegator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "validator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "cosmos-sdk/MsgWithdrawDelegationReward", "cosmos.msg.v1.signer": ["delegator_address"] });
    }
    create(value?: PartialMessage<MsgWithdrawDelegatorReward>): MsgWithdrawDelegatorReward {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.delegatorAddress = "";
        message.validatorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawDelegatorReward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawDelegatorReward): MsgWithdrawDelegatorReward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string delegator_address */ 1:
                    message.delegatorAddress = reader.string();
                    break;
                case /* string validator_address */ 2:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawDelegatorReward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string delegator_address = 1; */
        if (message.delegatorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.delegatorAddress);
        /* string validator_address = 2; */
        if (message.validatorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.validatorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward
 */
export const MsgWithdrawDelegatorReward = new MsgWithdrawDelegatorReward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawDelegatorRewardResponse$Type extends MessageType<MsgWithdrawDelegatorRewardResponse> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse", [
            { no: 1, name: "amount", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } }
        ]);
    }
    create(value?: PartialMessage<MsgWithdrawDelegatorRewardResponse>): MsgWithdrawDelegatorRewardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = [];
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawDelegatorRewardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawDelegatorRewardResponse): MsgWithdrawDelegatorRewardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin amount */ 1:
                    message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawDelegatorRewardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin amount = 1; */
        for (let i = 0; i < message.amount.length; i++)
            Coin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse
 */
export const MsgWithdrawDelegatorRewardResponse = new MsgWithdrawDelegatorRewardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawValidatorCommission$Type extends MessageType<MsgWithdrawValidatorCommission> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", [
            { no: 1, name: "validator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "cosmos-sdk/MsgWithdrawValCommission", "cosmos.msg.v1.signer": ["validator_address"] });
    }
    create(value?: PartialMessage<MsgWithdrawValidatorCommission>): MsgWithdrawValidatorCommission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validatorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawValidatorCommission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawValidatorCommission): MsgWithdrawValidatorCommission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string validator_address */ 1:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawValidatorCommission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string validator_address = 1; */
        if (message.validatorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission
 */
export const MsgWithdrawValidatorCommission = new MsgWithdrawValidatorCommission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawValidatorCommissionResponse$Type extends MessageType<MsgWithdrawValidatorCommissionResponse> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse", [
            { no: 1, name: "amount", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } }
        ]);
    }
    create(value?: PartialMessage<MsgWithdrawValidatorCommissionResponse>): MsgWithdrawValidatorCommissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = [];
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawValidatorCommissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawValidatorCommissionResponse): MsgWithdrawValidatorCommissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin amount */ 1:
                    message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawValidatorCommissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin amount = 1; */
        for (let i = 0; i < message.amount.length; i++)
            Coin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse
 */
export const MsgWithdrawValidatorCommissionResponse = new MsgWithdrawValidatorCommissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgFundCommunityPool$Type extends MessageType<MsgFundCommunityPool> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgFundCommunityPool", [
            { no: 1, name: "amount", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
            { no: 2, name: "depositor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "cosmos-sdk/MsgFundCommunityPool", "cosmos.msg.v1.signer": ["depositor"] });
    }
    create(value?: PartialMessage<MsgFundCommunityPool>): MsgFundCommunityPool {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = [];
        message.depositor = "";
        if (value !== undefined)
            reflectionMergePartial<MsgFundCommunityPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgFundCommunityPool): MsgFundCommunityPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin amount */ 1:
                    message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string depositor */ 2:
                    message.depositor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgFundCommunityPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin amount = 1; */
        for (let i = 0; i < message.amount.length; i++)
            Coin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string depositor = 2; */
        if (message.depositor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.depositor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgFundCommunityPool
 */
export const MsgFundCommunityPool = new MsgFundCommunityPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgFundCommunityPoolResponse$Type extends MessageType<MsgFundCommunityPoolResponse> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse", []);
    }
    create(value?: PartialMessage<MsgFundCommunityPoolResponse>): MsgFundCommunityPoolResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgFundCommunityPoolResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgFundCommunityPoolResponse): MsgFundCommunityPoolResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgFundCommunityPoolResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse
 */
export const MsgFundCommunityPoolResponse = new MsgFundCommunityPoolResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
        ], { "amino.name": "cosmos-sdk/distribution/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* cosmos.distribution.v1beta1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* cosmos.distribution.v1beta1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCommunityPoolSpend$Type extends MessageType<MsgCommunityPoolSpend> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgCommunityPoolSpend", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } }
        ], { "amino.name": "cosmos-sdk/distr/MsgCommunityPoolSpend", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgCommunityPoolSpend>): MsgCommunityPoolSpend {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.recipient = "";
        message.amount = [];
        if (value !== undefined)
            reflectionMergePartial<MsgCommunityPoolSpend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCommunityPoolSpend): MsgCommunityPoolSpend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* string recipient */ 2:
                    message.recipient = reader.string();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCommunityPoolSpend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* string recipient = 2; */
        if (message.recipient !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.recipient);
        /* repeated cosmos.base.v1beta1.Coin amount = 3; */
        for (let i = 0; i < message.amount.length; i++)
            Coin.internalBinaryWrite(message.amount[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgCommunityPoolSpend
 */
export const MsgCommunityPoolSpend = new MsgCommunityPoolSpend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCommunityPoolSpendResponse$Type extends MessageType<MsgCommunityPoolSpendResponse> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse", []);
    }
    create(value?: PartialMessage<MsgCommunityPoolSpendResponse>): MsgCommunityPoolSpendResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCommunityPoolSpendResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCommunityPoolSpendResponse): MsgCommunityPoolSpendResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCommunityPoolSpendResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse
 */
export const MsgCommunityPoolSpendResponse = new MsgCommunityPoolSpendResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositValidatorRewardsPool$Type extends MessageType<MsgDepositValidatorRewardsPool> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool", [
            { no: 1, name: "depositor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "validator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } },
            { no: 3, name: "amount", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "cosmos-sdk/distr/MsgDepositValRewards", "cosmos.msg.v1.signer": ["depositor"] });
    }
    create(value?: PartialMessage<MsgDepositValidatorRewardsPool>): MsgDepositValidatorRewardsPool {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.depositor = "";
        message.validatorAddress = "";
        message.amount = [];
        if (value !== undefined)
            reflectionMergePartial<MsgDepositValidatorRewardsPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositValidatorRewardsPool): MsgDepositValidatorRewardsPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string depositor */ 1:
                    message.depositor = reader.string();
                    break;
                case /* string validator_address */ 2:
                    message.validatorAddress = reader.string();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDepositValidatorRewardsPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string depositor = 1; */
        if (message.depositor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.depositor);
        /* string validator_address = 2; */
        if (message.validatorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.validatorAddress);
        /* repeated cosmos.base.v1beta1.Coin amount = 3; */
        for (let i = 0; i < message.amount.length; i++)
            Coin.internalBinaryWrite(message.amount[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool
 */
export const MsgDepositValidatorRewardsPool = new MsgDepositValidatorRewardsPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositValidatorRewardsPoolResponse$Type extends MessageType<MsgDepositValidatorRewardsPoolResponse> {
    constructor() {
        super("cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse", []);
    }
    create(value?: PartialMessage<MsgDepositValidatorRewardsPoolResponse>): MsgDepositValidatorRewardsPoolResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgDepositValidatorRewardsPoolResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositValidatorRewardsPoolResponse): MsgDepositValidatorRewardsPoolResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDepositValidatorRewardsPoolResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse
 */
export const MsgDepositValidatorRewardsPoolResponse = new MsgDepositValidatorRewardsPoolResponse$Type();
/**
 * @generated ServiceType for protobuf service cosmos.distribution.v1beta1.Msg
 */
export const Msg = new ServiceType("cosmos.distribution.v1beta1.Msg", [
    { name: "SetWithdrawAddress", options: {}, I: MsgSetWithdrawAddress, O: MsgSetWithdrawAddressResponse },
    { name: "WithdrawDelegatorReward", options: {}, I: MsgWithdrawDelegatorReward, O: MsgWithdrawDelegatorRewardResponse },
    { name: "WithdrawValidatorCommission", options: {}, I: MsgWithdrawValidatorCommission, O: MsgWithdrawValidatorCommissionResponse },
    { name: "FundCommunityPool", options: {}, I: MsgFundCommunityPool, O: MsgFundCommunityPoolResponse },
    { name: "UpdateParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse },
    { name: "CommunityPoolSpend", options: {}, I: MsgCommunityPoolSpend, O: MsgCommunityPoolSpendResponse },
    { name: "DepositValidatorRewardsPool", options: {}, I: MsgDepositValidatorRewardsPool, O: MsgDepositValidatorRewardsPoolResponse }
], { "cosmos.msg.v1.service": true });
