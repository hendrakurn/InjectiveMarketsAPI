import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DelegationDelegatorReward } from "./distribution_pb.js";
import { PageResponse } from "../../base/query/v1beta1/pagination_pb.js";
import { ValidatorSlashEvent } from "./distribution_pb.js";
import { PageRequest } from "../../base/query/v1beta1/pagination_pb.js";
import { ValidatorAccumulatedCommission } from "./distribution_pb.js";
import { ValidatorOutstandingRewards } from "./distribution_pb.js";
import { DecCoin } from "../../base/v1beta1/coin_pb.js";
import { Params } from "./distribution_pb.js";
class QueryParamsRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryParamsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsRequest = new QueryParamsRequest$Type();
class QueryParamsResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryParamsResponse", [
      { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.distribution.v1beta1.Params params */
        1:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsResponse = new QueryParamsResponse$Type();
class QueryValidatorDistributionInfoRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest", [
      { no: 1, name: "validator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string validator_address */
        1:
          message.validatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorDistributionInfoRequest = new QueryValidatorDistributionInfoRequest$Type();
class QueryValidatorDistributionInfoResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse", [
      { no: 1, name: "operator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } },
      { no: 2, name: "self_bond_rewards", kind: "message", repeat: 2, T: () => DecCoin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.DecCoins", "amino.dont_omitempty": true } },
      { no: 3, name: "commission", kind: "message", repeat: 2, T: () => DecCoin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.DecCoins" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operatorAddress = "";
    message.selfBondRewards = [];
    message.commission = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string operator_address */
        1:
          message.operatorAddress = reader.string();
          break;
        case /* repeated cosmos.base.v1beta1.DecCoin self_bond_rewards */
        2:
          message.selfBondRewards.push(DecCoin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated cosmos.base.v1beta1.DecCoin commission */
        3:
          message.commission.push(DecCoin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.operatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.operatorAddress);
    for (let i = 0; i < message.selfBondRewards.length; i++)
      DecCoin.internalBinaryWrite(message.selfBondRewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.commission.length; i++)
      DecCoin.internalBinaryWrite(message.commission[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorDistributionInfoResponse = new QueryValidatorDistributionInfoResponse$Type();
class QueryValidatorOutstandingRewardsRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest", [
      { no: 1, name: "validator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string validator_address */
        1:
          message.validatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorOutstandingRewardsRequest = new QueryValidatorOutstandingRewardsRequest$Type();
class QueryValidatorOutstandingRewardsResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse", [
      { no: 1, name: "rewards", kind: "message", T: () => ValidatorOutstandingRewards, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.distribution.v1beta1.ValidatorOutstandingRewards rewards */
        1:
          message.rewards = ValidatorOutstandingRewards.internalBinaryRead(reader, reader.uint32(), options, message.rewards);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rewards)
      ValidatorOutstandingRewards.internalBinaryWrite(message.rewards, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorOutstandingRewardsResponse = new QueryValidatorOutstandingRewardsResponse$Type();
class QueryValidatorCommissionRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorCommissionRequest", [
      { no: 1, name: "validator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string validator_address */
        1:
          message.validatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorCommissionRequest = new QueryValidatorCommissionRequest$Type();
class QueryValidatorCommissionResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorCommissionResponse", [
      { no: 1, name: "commission", kind: "message", T: () => ValidatorAccumulatedCommission, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.distribution.v1beta1.ValidatorAccumulatedCommission commission */
        1:
          message.commission = ValidatorAccumulatedCommission.internalBinaryRead(reader, reader.uint32(), options, message.commission);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.commission)
      ValidatorAccumulatedCommission.internalBinaryWrite(message.commission, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorCommissionResponse = new QueryValidatorCommissionResponse$Type();
class QueryValidatorSlashesRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorSlashesRequest", [
      { no: 1, name: "validator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } },
      {
        no: 2,
        name: "starting_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "ending_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => PageRequest }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validatorAddress = "";
    message.startingHeight = 0n;
    message.endingHeight = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string validator_address */
        1:
          message.validatorAddress = reader.string();
          break;
        case /* uint64 starting_height */
        2:
          message.startingHeight = reader.uint64().toBigInt();
          break;
        case /* uint64 ending_height */
        3:
          message.endingHeight = reader.uint64().toBigInt();
          break;
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        4:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
    if (message.startingHeight !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.startingHeight);
    if (message.endingHeight !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.endingHeight);
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorSlashesRequest = new QueryValidatorSlashesRequest$Type();
class QueryValidatorSlashesResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryValidatorSlashesResponse", [
      { no: 1, name: "slashes", kind: "message", repeat: 2, T: () => ValidatorSlashEvent, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.slashes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.distribution.v1beta1.ValidatorSlashEvent slashes */
        1:
          message.slashes.push(ValidatorSlashEvent.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.slashes.length; i++)
      ValidatorSlashEvent.internalBinaryWrite(message.slashes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorSlashesResponse = new QueryValidatorSlashesResponse$Type();
class QueryDelegationRewardsRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegationRewardsRequest", [
      { no: 1, name: "delegator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      { no: 2, name: "validator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.ValidatorAddressString" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.delegatorAddress = "";
    message.validatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string delegator_address */
        1:
          message.delegatorAddress = reader.string();
          break;
        case /* string validator_address */
        2:
          message.validatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.delegatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.delegatorAddress);
    if (message.validatorAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.validatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegationRewardsRequest = new QueryDelegationRewardsRequest$Type();
class QueryDelegationRewardsResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegationRewardsResponse", [
      { no: 1, name: "rewards", kind: "message", repeat: 2, T: () => DecCoin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.DecCoins", "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.DecCoin rewards */
        1:
          message.rewards.push(DecCoin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.rewards.length; i++)
      DecCoin.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegationRewardsResponse = new QueryDelegationRewardsResponse$Type();
class QueryDelegationTotalRewardsRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest", [
      { no: 1, name: "delegator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.delegatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string delegator_address */
        1:
          message.delegatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.delegatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.delegatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegationTotalRewardsRequest = new QueryDelegationTotalRewardsRequest$Type();
class QueryDelegationTotalRewardsResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse", [
      { no: 1, name: "rewards", kind: "message", repeat: 2, T: () => DelegationDelegatorReward, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } },
      { no: 2, name: "total", kind: "message", repeat: 2, T: () => DecCoin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.DecCoins", "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rewards = [];
    message.total = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.distribution.v1beta1.DelegationDelegatorReward rewards */
        1:
          message.rewards.push(DelegationDelegatorReward.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated cosmos.base.v1beta1.DecCoin total */
        2:
          message.total.push(DecCoin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.rewards.length; i++)
      DelegationDelegatorReward.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.total.length; i++)
      DecCoin.internalBinaryWrite(message.total[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegationTotalRewardsResponse = new QueryDelegationTotalRewardsResponse$Type();
class QueryDelegatorValidatorsRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest", [
      { no: 1, name: "delegator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.delegatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string delegator_address */
        1:
          message.delegatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.delegatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.delegatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegatorValidatorsRequest = new QueryDelegatorValidatorsRequest$Type();
class QueryDelegatorValidatorsResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse", [
      {
        no: 1,
        name: "validators",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validators = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string validators */
        1:
          message.validators.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.validators.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.validators[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegatorValidatorsResponse = new QueryDelegatorValidatorsResponse$Type();
class QueryDelegatorWithdrawAddressRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest", [
      { no: 1, name: "delegator_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.delegatorAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string delegator_address */
        1:
          message.delegatorAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.delegatorAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.delegatorAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegatorWithdrawAddressRequest = new QueryDelegatorWithdrawAddressRequest$Type();
class QueryDelegatorWithdrawAddressResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse", [
      { no: 1, name: "withdraw_address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.withdrawAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string withdraw_address */
        1:
          message.withdrawAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.withdrawAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.withdrawAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDelegatorWithdrawAddressResponse = new QueryDelegatorWithdrawAddressResponse$Type();
class QueryCommunityPoolRequest$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryCommunityPoolRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryCommunityPoolRequest = new QueryCommunityPoolRequest$Type();
class QueryCommunityPoolResponse$Type extends MessageType {
  constructor() {
    super("cosmos.distribution.v1beta1.QueryCommunityPoolResponse", [
      { no: 1, name: "pool", kind: "message", repeat: 2, T: () => DecCoin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.DecCoins", "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.pool = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.DecCoin pool */
        1:
          message.pool.push(DecCoin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.pool.length; i++)
      DecCoin.internalBinaryWrite(message.pool[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryCommunityPoolResponse = new QueryCommunityPoolResponse$Type();
const Query = new ServiceType("cosmos.distribution.v1beta1.Query", [
  { name: "Params", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/params" } }, I: QueryParamsRequest, O: QueryParamsResponse },
  { name: "ValidatorDistributionInfo", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/validators/{validator_address}" } }, I: QueryValidatorDistributionInfoRequest, O: QueryValidatorDistributionInfoResponse },
  { name: "ValidatorOutstandingRewards", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards" } }, I: QueryValidatorOutstandingRewardsRequest, O: QueryValidatorOutstandingRewardsResponse },
  { name: "ValidatorCommission", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/validators/{validator_address}/commission" } }, I: QueryValidatorCommissionRequest, O: QueryValidatorCommissionResponse },
  { name: "ValidatorSlashes", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes" } }, I: QueryValidatorSlashesRequest, O: QueryValidatorSlashesResponse },
  { name: "DelegationRewards", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}" } }, I: QueryDelegationRewardsRequest, O: QueryDelegationRewardsResponse },
  { name: "DelegationTotalRewards", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards" } }, I: QueryDelegationTotalRewardsRequest, O: QueryDelegationTotalRewardsResponse },
  { name: "DelegatorValidators", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators" } }, I: QueryDelegatorValidatorsRequest, O: QueryDelegatorValidatorsResponse },
  { name: "DelegatorWithdrawAddress", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address" } }, I: QueryDelegatorWithdrawAddressRequest, O: QueryDelegatorWithdrawAddressResponse },
  { name: "CommunityPool", options: { "google.api.http": { get: "/cosmos/distribution/v1beta1/community_pool" } }, I: QueryCommunityPoolRequest, O: QueryCommunityPoolResponse }
]);
export {
  Query,
  QueryCommunityPoolRequest,
  QueryCommunityPoolResponse,
  QueryDelegationRewardsRequest,
  QueryDelegationRewardsResponse,
  QueryDelegationTotalRewardsRequest,
  QueryDelegationTotalRewardsResponse,
  QueryDelegatorValidatorsRequest,
  QueryDelegatorValidatorsResponse,
  QueryDelegatorWithdrawAddressRequest,
  QueryDelegatorWithdrawAddressResponse,
  QueryParamsRequest,
  QueryParamsResponse,
  QueryValidatorCommissionRequest,
  QueryValidatorCommissionResponse,
  QueryValidatorDistributionInfoRequest,
  QueryValidatorDistributionInfoResponse,
  QueryValidatorOutstandingRewardsRequest,
  QueryValidatorOutstandingRewardsResponse,
  QueryValidatorSlashesRequest,
  QueryValidatorSlashesResponse
};
