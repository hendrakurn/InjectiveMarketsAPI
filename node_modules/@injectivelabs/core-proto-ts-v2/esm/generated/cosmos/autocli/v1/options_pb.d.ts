// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "cosmos/autocli/v1/options.proto" (package "cosmos.autocli.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * ModuleOptions describes the CLI options for a Cosmos SDK module.
 *
 * @generated from protobuf message cosmos.autocli.v1.ModuleOptions
 */
export interface ModuleOptions {
    /**
     * tx describes the tx commands for the module.
     *
     * @generated from protobuf field: cosmos.autocli.v1.ServiceCommandDescriptor tx = 1
     */
    tx?: ServiceCommandDescriptor;
    /**
     * query describes the queries commands for the module.
     *
     * @generated from protobuf field: cosmos.autocli.v1.ServiceCommandDescriptor query = 2
     */
    query?: ServiceCommandDescriptor;
}
/**
 * ServiceCommandDescriptor describes a CLI command based on a protobuf service.
 *
 * @generated from protobuf message cosmos.autocli.v1.ServiceCommandDescriptor
 */
export interface ServiceCommandDescriptor {
    /**
     * service is the fully qualified name of the protobuf service to build
     * the command from. It can be left empty if sub_commands are used instead
     * which may be the case if a module provides multiple tx and/or query services.
     *
     * @generated from protobuf field: string service = 1
     */
    service: string;
    /**
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     *
     * @generated from protobuf field: repeated cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2
     */
    rpcCommandOptions: RpcCommandOptions[];
    /**
     * sub_commands is a map of optional sub-commands for this command based on
     * different protobuf services. The map key is used as the name of the
     * sub-command.
     *
     * @generated from protobuf field: map<string, cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3
     */
    subCommands: {
        [key: string]: ServiceCommandDescriptor;
    };
    /**
     * enhance_custom_commands specifies whether to skip the service when generating commands, if a custom command already
     * exists, or enhance the existing command. If set to true, the custom command will be enhanced with the services from
     * gRPC. otherwise when a custom command exists, no commands will be generated for the service.
     *
     * @generated from protobuf field: bool enhance_custom_command = 4
     */
    enhanceCustomCommand: boolean;
    /**
     * short is an optional parameter used to override the short description of the auto generated command.
     *
     * @generated from protobuf field: string short = 5
     */
    short: string;
}
/**
 * RpcCommandOptions specifies options for commands generated from protobuf
 * rpc methods.
 *
 * @generated from protobuf message cosmos.autocli.v1.RpcCommandOptions
 */
export interface RpcCommandOptions {
    /**
     * rpc_method is short name of the protobuf rpc method that this command is
     * generated from.
     *
     * @generated from protobuf field: string rpc_method = 1
     */
    rpcMethod: string;
    /**
     * use is the one-line usage method. It also allows specifying an alternate
     * name for the command as the first word of the usage text.
     *
     * By default the name of an rpc command is the kebab-case short name of the
     * rpc method.
     *
     * @generated from protobuf field: string use = 2
     */
    use: string;
    /**
     * long is the long message shown in the 'help <this-command>' output.
     *
     * @generated from protobuf field: string long = 3
     */
    long: string;
    /**
     * short is the short description shown in the 'help' output.
     *
     * @generated from protobuf field: string short = 4
     */
    short: string;
    /**
     * example is examples of how to use the command.
     *
     * @generated from protobuf field: string example = 5
     */
    example: string;
    /**
     * alias is an array of aliases that can be used instead of the first word in Use.
     *
     * @generated from protobuf field: repeated string alias = 6
     */
    alias: string[];
    /**
     * suggest_for is an array of command names for which this command will be suggested -
     * similar to aliases but only suggests.
     *
     * @generated from protobuf field: repeated string suggest_for = 7
     */
    suggestFor: string[];
    /**
     * deprecated defines, if this command is deprecated and should print this string when used.
     *
     * @generated from protobuf field: string deprecated = 8
     */
    deprecated: string;
    /**
     * version defines the version for this command. If this value is non-empty and the command does not
     * define a "version" flag, a "version" boolean flag will be added to the command and, if specified,
     * will print content of the "Version" variable. A shorthand "v" flag will also be added if the
     * command does not define one.
     *
     * @generated from protobuf field: string version = 9
     */
    version: string;
    /**
     * flag_options are options for flags generated from rpc request fields.
     * By default all request fields are configured as flags. They can
     * also be configured as positional args instead using positional_args.
     *
     * @generated from protobuf field: map<string, cosmos.autocli.v1.FlagOptions> flag_options = 10
     */
    flagOptions: {
        [key: string]: FlagOptions;
    };
    /**
     * positional_args specifies positional arguments for the command.
     *
     * @generated from protobuf field: repeated cosmos.autocli.v1.PositionalArgDescriptor positional_args = 11
     */
    positionalArgs: PositionalArgDescriptor[];
    /**
     * skip specifies whether to skip this rpc method when generating commands.
     *
     * @generated from protobuf field: bool skip = 12
     */
    skip: boolean;
}
/**
 * FlagOptions are options for flags generated from rpc request fields.
 * By default, all request fields are configured as flags based on the
 * kebab-case name of the field. Fields can be turned into positional arguments
 * instead by using RpcCommandOptions.positional_args.
 *
 * @generated from protobuf message cosmos.autocli.v1.FlagOptions
 */
export interface FlagOptions {
    /**
     * name is an alternate name to use for the field flag.
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * shorthand is a one-letter abbreviated flag.
     *
     * @generated from protobuf field: string shorthand = 2
     */
    shorthand: string;
    /**
     * usage is the help message.
     *
     * @generated from protobuf field: string usage = 3
     */
    usage: string;
    /**
     * default_value is the default value as text.
     *
     * @generated from protobuf field: string default_value = 4
     */
    defaultValue: string;
    /**
     * deprecated is the usage text to show if this flag is deprecated.
     *
     * @generated from protobuf field: string deprecated = 6
     */
    deprecated: string;
    /**
     * shorthand_deprecated is the usage text to show if the shorthand of this flag is deprecated.
     *
     * @generated from protobuf field: string shorthand_deprecated = 7
     */
    shorthandDeprecated: string;
    /**
     * hidden hides the flag from help/usage text
     *
     * @generated from protobuf field: bool hidden = 8
     */
    hidden: boolean;
}
/**
 * PositionalArgDescriptor describes a positional argument.
 *
 * @generated from protobuf message cosmos.autocli.v1.PositionalArgDescriptor
 */
export interface PositionalArgDescriptor {
    /**
     * proto_field specifies the proto field to use as the positional arg. Any
     * fields used as positional args will not have a flag generated.
     *
     * @generated from protobuf field: string proto_field = 1
     */
    protoField: string;
    /**
     * varargs makes a positional parameter a varargs parameter. This can only be
     * applied to last positional parameter and the proto_field must a repeated
     * field. Note: It is mutually exclusive with optional.
     *
     * @generated from protobuf field: bool varargs = 2
     */
    varargs: boolean;
    /**
     * optional makes the last positional parameter optional.
     * Note: It is mutually exclusive with varargs.
     *
     * @generated from protobuf field: bool optional = 3
     */
    optional: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class ModuleOptions$Type extends MessageType<ModuleOptions> {
    constructor() {
        super("cosmos.autocli.v1.ModuleOptions", [
            { no: 1, name: "tx", kind: "message", T: () => ServiceCommandDescriptor },
            { no: 2, name: "query", kind: "message", T: () => ServiceCommandDescriptor }
        ]);
    }
    create(value?: PartialMessage<ModuleOptions>): ModuleOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ModuleOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleOptions): ModuleOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.autocli.v1.ServiceCommandDescriptor tx */ 1:
                    message.tx = ServiceCommandDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.tx);
                    break;
                case /* cosmos.autocli.v1.ServiceCommandDescriptor query */ 2:
                    message.query = ServiceCommandDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.autocli.v1.ServiceCommandDescriptor tx = 1; */
        if (message.tx)
            ServiceCommandDescriptor.internalBinaryWrite(message.tx, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.autocli.v1.ServiceCommandDescriptor query = 2; */
        if (message.query)
            ServiceCommandDescriptor.internalBinaryWrite(message.query, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.autocli.v1.ModuleOptions
 */
export const ModuleOptions = new ModuleOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceCommandDescriptor$Type extends MessageType<ServiceCommandDescriptor> {
    constructor() {
        super("cosmos.autocli.v1.ServiceCommandDescriptor", [
            { no: 1, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rpc_command_options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RpcCommandOptions },
            { no: 3, name: "sub_commands", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ServiceCommandDescriptor } },
            { no: 4, name: "enhance_custom_command", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "short", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceCommandDescriptor>): ServiceCommandDescriptor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.service = "";
        message.rpcCommandOptions = [];
        message.subCommands = {};
        message.enhanceCustomCommand = false;
        message.short = "";
        if (value !== undefined)
            reflectionMergePartial<ServiceCommandDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceCommandDescriptor): ServiceCommandDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service */ 1:
                    message.service = reader.string();
                    break;
                case /* repeated cosmos.autocli.v1.RpcCommandOptions rpc_command_options */ 2:
                    message.rpcCommandOptions.push(RpcCommandOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands */ 3:
                    this.binaryReadMap3(message.subCommands, reader, options);
                    break;
                case /* bool enhance_custom_command */ 4:
                    message.enhanceCustomCommand = reader.bool();
                    break;
                case /* string short */ 5:
                    message.short = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: ServiceCommandDescriptor["subCommands"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ServiceCommandDescriptor["subCommands"] | undefined, val: ServiceCommandDescriptor["subCommands"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ServiceCommandDescriptor.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for cosmos.autocli.v1.ServiceCommandDescriptor.sub_commands");
            }
        }
        map[key ?? ""] = val ?? ServiceCommandDescriptor.create();
    }
    internalBinaryWrite(message: ServiceCommandDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service = 1; */
        if (message.service !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.service);
        /* repeated cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2; */
        for (let i = 0; i < message.rpcCommandOptions.length; i++)
            RpcCommandOptions.internalBinaryWrite(message.rpcCommandOptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3; */
        for (let k of globalThis.Object.keys(message.subCommands)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ServiceCommandDescriptor.internalBinaryWrite(message.subCommands[k], writer, options);
            writer.join().join();
        }
        /* bool enhance_custom_command = 4; */
        if (message.enhanceCustomCommand !== false)
            writer.tag(4, WireType.Varint).bool(message.enhanceCustomCommand);
        /* string short = 5; */
        if (message.short !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.short);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.autocli.v1.ServiceCommandDescriptor
 */
export const ServiceCommandDescriptor = new ServiceCommandDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcCommandOptions$Type extends MessageType<RpcCommandOptions> {
    constructor() {
        super("cosmos.autocli.v1.RpcCommandOptions", [
            { no: 1, name: "rpc_method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "use", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "long", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "short", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "example", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "alias", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "suggest_for", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "deprecated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "flag_options", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => FlagOptions } },
            { no: 11, name: "positional_args", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PositionalArgDescriptor },
            { no: 12, name: "skip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RpcCommandOptions>): RpcCommandOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rpcMethod = "";
        message.use = "";
        message.long = "";
        message.short = "";
        message.example = "";
        message.alias = [];
        message.suggestFor = [];
        message.deprecated = "";
        message.version = "";
        message.flagOptions = {};
        message.positionalArgs = [];
        message.skip = false;
        if (value !== undefined)
            reflectionMergePartial<RpcCommandOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcCommandOptions): RpcCommandOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string rpc_method */ 1:
                    message.rpcMethod = reader.string();
                    break;
                case /* string use */ 2:
                    message.use = reader.string();
                    break;
                case /* string long */ 3:
                    message.long = reader.string();
                    break;
                case /* string short */ 4:
                    message.short = reader.string();
                    break;
                case /* string example */ 5:
                    message.example = reader.string();
                    break;
                case /* repeated string alias */ 6:
                    message.alias.push(reader.string());
                    break;
                case /* repeated string suggest_for */ 7:
                    message.suggestFor.push(reader.string());
                    break;
                case /* string deprecated */ 8:
                    message.deprecated = reader.string();
                    break;
                case /* string version */ 9:
                    message.version = reader.string();
                    break;
                case /* map<string, cosmos.autocli.v1.FlagOptions> flag_options */ 10:
                    this.binaryReadMap10(message.flagOptions, reader, options);
                    break;
                case /* repeated cosmos.autocli.v1.PositionalArgDescriptor positional_args */ 11:
                    message.positionalArgs.push(PositionalArgDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool skip */ 12:
                    message.skip = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: RpcCommandOptions["flagOptions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RpcCommandOptions["flagOptions"] | undefined, val: RpcCommandOptions["flagOptions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = FlagOptions.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for cosmos.autocli.v1.RpcCommandOptions.flag_options");
            }
        }
        map[key ?? ""] = val ?? FlagOptions.create();
    }
    internalBinaryWrite(message: RpcCommandOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string rpc_method = 1; */
        if (message.rpcMethod !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rpcMethod);
        /* string use = 2; */
        if (message.use !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.use);
        /* string long = 3; */
        if (message.long !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.long);
        /* string short = 4; */
        if (message.short !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.short);
        /* string example = 5; */
        if (message.example !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.example);
        /* repeated string alias = 6; */
        for (let i = 0; i < message.alias.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.alias[i]);
        /* repeated string suggest_for = 7; */
        for (let i = 0; i < message.suggestFor.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.suggestFor[i]);
        /* string deprecated = 8; */
        if (message.deprecated !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.deprecated);
        /* string version = 9; */
        if (message.version !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.version);
        /* map<string, cosmos.autocli.v1.FlagOptions> flag_options = 10; */
        for (let k of globalThis.Object.keys(message.flagOptions)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            FlagOptions.internalBinaryWrite(message.flagOptions[k], writer, options);
            writer.join().join();
        }
        /* repeated cosmos.autocli.v1.PositionalArgDescriptor positional_args = 11; */
        for (let i = 0; i < message.positionalArgs.length; i++)
            PositionalArgDescriptor.internalBinaryWrite(message.positionalArgs[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool skip = 12; */
        if (message.skip !== false)
            writer.tag(12, WireType.Varint).bool(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.autocli.v1.RpcCommandOptions
 */
export const RpcCommandOptions = new RpcCommandOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlagOptions$Type extends MessageType<FlagOptions> {
    constructor() {
        super("cosmos.autocli.v1.FlagOptions", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shorthand", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "usage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "default_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "deprecated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "shorthand_deprecated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FlagOptions>): FlagOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.shorthand = "";
        message.usage = "";
        message.defaultValue = "";
        message.deprecated = "";
        message.shorthandDeprecated = "";
        message.hidden = false;
        if (value !== undefined)
            reflectionMergePartial<FlagOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlagOptions): FlagOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string shorthand */ 2:
                    message.shorthand = reader.string();
                    break;
                case /* string usage */ 3:
                    message.usage = reader.string();
                    break;
                case /* string default_value */ 4:
                    message.defaultValue = reader.string();
                    break;
                case /* string deprecated */ 6:
                    message.deprecated = reader.string();
                    break;
                case /* string shorthand_deprecated */ 7:
                    message.shorthandDeprecated = reader.string();
                    break;
                case /* bool hidden */ 8:
                    message.hidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlagOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string shorthand = 2; */
        if (message.shorthand !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shorthand);
        /* string usage = 3; */
        if (message.usage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.usage);
        /* string default_value = 4; */
        if (message.defaultValue !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.defaultValue);
        /* string deprecated = 6; */
        if (message.deprecated !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.deprecated);
        /* string shorthand_deprecated = 7; */
        if (message.shorthandDeprecated !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.shorthandDeprecated);
        /* bool hidden = 8; */
        if (message.hidden !== false)
            writer.tag(8, WireType.Varint).bool(message.hidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.autocli.v1.FlagOptions
 */
export const FlagOptions = new FlagOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionalArgDescriptor$Type extends MessageType<PositionalArgDescriptor> {
    constructor() {
        super("cosmos.autocli.v1.PositionalArgDescriptor", [
            { no: 1, name: "proto_field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "varargs", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "optional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PositionalArgDescriptor>): PositionalArgDescriptor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protoField = "";
        message.varargs = false;
        message.optional = false;
        if (value !== undefined)
            reflectionMergePartial<PositionalArgDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionalArgDescriptor): PositionalArgDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string proto_field */ 1:
                    message.protoField = reader.string();
                    break;
                case /* bool varargs */ 2:
                    message.varargs = reader.bool();
                    break;
                case /* bool optional */ 3:
                    message.optional = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionalArgDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string proto_field = 1; */
        if (message.protoField !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.protoField);
        /* bool varargs = 2; */
        if (message.varargs !== false)
            writer.tag(2, WireType.Varint).bool(message.varargs);
        /* bool optional = 3; */
        if (message.optional !== false)
            writer.tag(3, WireType.Varint).bool(message.optional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.autocli.v1.PositionalArgDescriptor
 */
export const PositionalArgDescriptor = new PositionalArgDescriptor$Type();
