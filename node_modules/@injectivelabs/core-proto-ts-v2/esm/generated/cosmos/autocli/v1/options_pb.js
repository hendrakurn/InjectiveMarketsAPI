import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class ModuleOptions$Type extends MessageType {
  constructor() {
    super("cosmos.autocli.v1.ModuleOptions", [
      { no: 1, name: "tx", kind: "message", T: () => ServiceCommandDescriptor },
      { no: 2, name: "query", kind: "message", T: () => ServiceCommandDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.autocli.v1.ServiceCommandDescriptor tx */
        1:
          message.tx = ServiceCommandDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.tx);
          break;
        case /* cosmos.autocli.v1.ServiceCommandDescriptor query */
        2:
          message.query = ServiceCommandDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tx)
      ServiceCommandDescriptor.internalBinaryWrite(message.tx, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.query)
      ServiceCommandDescriptor.internalBinaryWrite(message.query, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ModuleOptions = new ModuleOptions$Type();
class ServiceCommandDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.autocli.v1.ServiceCommandDescriptor", [
      {
        no: 1,
        name: "service",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "rpc_command_options", kind: "message", repeat: 2, T: () => RpcCommandOptions },
      { no: 3, name: "sub_commands", kind: "map", K: 9, V: { kind: "message", T: () => ServiceCommandDescriptor } },
      {
        no: 4,
        name: "enhance_custom_command",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "short",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.service = "";
    message.rpcCommandOptions = [];
    message.subCommands = {};
    message.enhanceCustomCommand = false;
    message.short = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string service */
        1:
          message.service = reader.string();
          break;
        case /* repeated cosmos.autocli.v1.RpcCommandOptions rpc_command_options */
        2:
          message.rpcCommandOptions.push(RpcCommandOptions.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* map<string, cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands */
        3:
          this.binaryReadMap3(message.subCommands, reader, options);
          break;
        case /* bool enhance_custom_command */
        4:
          message.enhanceCustomCommand = reader.bool();
          break;
        case /* string short */
        5:
          message.short = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap3(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = ServiceCommandDescriptor.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error("unknown map entry field for cosmos.autocli.v1.ServiceCommandDescriptor.sub_commands");
      }
    }
    map[key ?? ""] = val ?? ServiceCommandDescriptor.create();
  }
  internalBinaryWrite(message, writer, options) {
    if (message.service !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.service);
    for (let i = 0; i < message.rpcCommandOptions.length; i++)
      RpcCommandOptions.internalBinaryWrite(message.rpcCommandOptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let k of globalThis.Object.keys(message.subCommands)) {
      writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      ServiceCommandDescriptor.internalBinaryWrite(message.subCommands[k], writer, options);
      writer.join().join();
    }
    if (message.enhanceCustomCommand !== false)
      writer.tag(4, WireType.Varint).bool(message.enhanceCustomCommand);
    if (message.short !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.short);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ServiceCommandDescriptor = new ServiceCommandDescriptor$Type();
class RpcCommandOptions$Type extends MessageType {
  constructor() {
    super("cosmos.autocli.v1.RpcCommandOptions", [
      {
        no: 1,
        name: "rpc_method",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "use",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "long",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "short",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "example",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "alias",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "suggest_for",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "deprecated",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 10, name: "flag_options", kind: "map", K: 9, V: { kind: "message", T: () => FlagOptions } },
      { no: 11, name: "positional_args", kind: "message", repeat: 2, T: () => PositionalArgDescriptor },
      {
        no: 12,
        name: "skip",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rpcMethod = "";
    message.use = "";
    message.long = "";
    message.short = "";
    message.example = "";
    message.alias = [];
    message.suggestFor = [];
    message.deprecated = "";
    message.version = "";
    message.flagOptions = {};
    message.positionalArgs = [];
    message.skip = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string rpc_method */
        1:
          message.rpcMethod = reader.string();
          break;
        case /* string use */
        2:
          message.use = reader.string();
          break;
        case /* string long */
        3:
          message.long = reader.string();
          break;
        case /* string short */
        4:
          message.short = reader.string();
          break;
        case /* string example */
        5:
          message.example = reader.string();
          break;
        case /* repeated string alias */
        6:
          message.alias.push(reader.string());
          break;
        case /* repeated string suggest_for */
        7:
          message.suggestFor.push(reader.string());
          break;
        case /* string deprecated */
        8:
          message.deprecated = reader.string();
          break;
        case /* string version */
        9:
          message.version = reader.string();
          break;
        case /* map<string, cosmos.autocli.v1.FlagOptions> flag_options */
        10:
          this.binaryReadMap10(message.flagOptions, reader, options);
          break;
        case /* repeated cosmos.autocli.v1.PositionalArgDescriptor positional_args */
        11:
          message.positionalArgs.push(PositionalArgDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bool skip */
        12:
          message.skip = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap10(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = FlagOptions.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error("unknown map entry field for cosmos.autocli.v1.RpcCommandOptions.flag_options");
      }
    }
    map[key ?? ""] = val ?? FlagOptions.create();
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rpcMethod !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.rpcMethod);
    if (message.use !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.use);
    if (message.long !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.long);
    if (message.short !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.short);
    if (message.example !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.example);
    for (let i = 0; i < message.alias.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.alias[i]);
    for (let i = 0; i < message.suggestFor.length; i++)
      writer.tag(7, WireType.LengthDelimited).string(message.suggestFor[i]);
    if (message.deprecated !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.deprecated);
    if (message.version !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.version);
    for (let k of globalThis.Object.keys(message.flagOptions)) {
      writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      FlagOptions.internalBinaryWrite(message.flagOptions[k], writer, options);
      writer.join().join();
    }
    for (let i = 0; i < message.positionalArgs.length; i++)
      PositionalArgDescriptor.internalBinaryWrite(message.positionalArgs[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.skip !== false)
      writer.tag(12, WireType.Varint).bool(message.skip);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RpcCommandOptions = new RpcCommandOptions$Type();
class FlagOptions$Type extends MessageType {
  constructor() {
    super("cosmos.autocli.v1.FlagOptions", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "shorthand",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "usage",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "default_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "deprecated",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "shorthand_deprecated",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "hidden",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.shorthand = "";
    message.usage = "";
    message.defaultValue = "";
    message.deprecated = "";
    message.shorthandDeprecated = "";
    message.hidden = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string shorthand */
        2:
          message.shorthand = reader.string();
          break;
        case /* string usage */
        3:
          message.usage = reader.string();
          break;
        case /* string default_value */
        4:
          message.defaultValue = reader.string();
          break;
        case /* string deprecated */
        6:
          message.deprecated = reader.string();
          break;
        case /* string shorthand_deprecated */
        7:
          message.shorthandDeprecated = reader.string();
          break;
        case /* bool hidden */
        8:
          message.hidden = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.shorthand !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.shorthand);
    if (message.usage !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.usage);
    if (message.defaultValue !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.defaultValue);
    if (message.deprecated !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.deprecated);
    if (message.shorthandDeprecated !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.shorthandDeprecated);
    if (message.hidden !== false)
      writer.tag(8, WireType.Varint).bool(message.hidden);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FlagOptions = new FlagOptions$Type();
class PositionalArgDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.autocli.v1.PositionalArgDescriptor", [
      {
        no: 1,
        name: "proto_field",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "varargs",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "optional",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.protoField = "";
    message.varargs = false;
    message.optional = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string proto_field */
        1:
          message.protoField = reader.string();
          break;
        case /* bool varargs */
        2:
          message.varargs = reader.bool();
          break;
        case /* bool optional */
        3:
          message.optional = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.protoField !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.protoField);
    if (message.varargs !== false)
      writer.tag(2, WireType.Varint).bool(message.varargs);
    if (message.optional !== false)
      writer.tag(3, WireType.Varint).bool(message.optional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionalArgDescriptor = new PositionalArgDescriptor$Type();
export {
  FlagOptions,
  ModuleOptions,
  PositionalArgDescriptor,
  RpcCommandOptions,
  ServiceCommandDescriptor
};
