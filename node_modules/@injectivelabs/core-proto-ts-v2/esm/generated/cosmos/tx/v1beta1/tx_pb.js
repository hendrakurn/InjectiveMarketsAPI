import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../base/v1beta1/coin_pb.js";
import { CompactBitArray } from "../../crypto/multisig/v1beta1/multisig_pb.js";
import { SignMode } from "../signing/v1beta1/signing_pb.js";
import { Any } from "../../../google/protobuf/any_pb.js";
class Tx$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.Tx", [
      { no: 1, name: "body", kind: "message", T: () => TxBody },
      { no: 2, name: "auth_info", kind: "message", T: () => AuthInfo },
      {
        no: 3,
        name: "signatures",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signatures = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.tx.v1beta1.TxBody body */
        1:
          message.body = TxBody.internalBinaryRead(reader, reader.uint32(), options, message.body);
          break;
        case /* cosmos.tx.v1beta1.AuthInfo auth_info */
        2:
          message.authInfo = AuthInfo.internalBinaryRead(reader, reader.uint32(), options, message.authInfo);
          break;
        case /* repeated bytes signatures */
        3:
          message.signatures.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.body)
      TxBody.internalBinaryWrite(message.body, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.authInfo)
      AuthInfo.internalBinaryWrite(message.authInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.signatures.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.signatures[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Tx = new Tx$Type();
class TxRaw$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.TxRaw", [
      {
        no: 1,
        name: "body_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "auth_info_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "signatures",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bodyBytes = new Uint8Array(0);
    message.authInfoBytes = new Uint8Array(0);
    message.signatures = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes body_bytes */
        1:
          message.bodyBytes = reader.bytes();
          break;
        case /* bytes auth_info_bytes */
        2:
          message.authInfoBytes = reader.bytes();
          break;
        case /* repeated bytes signatures */
        3:
          message.signatures.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bodyBytes.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.bodyBytes);
    if (message.authInfoBytes.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.authInfoBytes);
    for (let i = 0; i < message.signatures.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.signatures[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxRaw = new TxRaw$Type();
class SignDoc$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.SignDoc", [
      {
        no: 1,
        name: "body_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "auth_info_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "chain_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "account_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bodyBytes = new Uint8Array(0);
    message.authInfoBytes = new Uint8Array(0);
    message.chainId = "";
    message.accountNumber = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes body_bytes */
        1:
          message.bodyBytes = reader.bytes();
          break;
        case /* bytes auth_info_bytes */
        2:
          message.authInfoBytes = reader.bytes();
          break;
        case /* string chain_id */
        3:
          message.chainId = reader.string();
          break;
        case /* uint64 account_number */
        4:
          message.accountNumber = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bodyBytes.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.bodyBytes);
    if (message.authInfoBytes.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.authInfoBytes);
    if (message.chainId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.chainId);
    if (message.accountNumber !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.accountNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SignDoc = new SignDoc$Type();
class SignDocDirectAux$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.SignDocDirectAux", [
      {
        no: 1,
        name: "body_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "public_key", kind: "message", T: () => Any },
      {
        no: 3,
        name: "chain_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "account_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "tip", kind: "message", T: () => Tip }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bodyBytes = new Uint8Array(0);
    message.chainId = "";
    message.accountNumber = 0n;
    message.sequence = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes body_bytes */
        1:
          message.bodyBytes = reader.bytes();
          break;
        case /* google.protobuf.Any public_key */
        2:
          message.publicKey = Any.internalBinaryRead(reader, reader.uint32(), options, message.publicKey);
          break;
        case /* string chain_id */
        3:
          message.chainId = reader.string();
          break;
        case /* uint64 account_number */
        4:
          message.accountNumber = reader.uint64().toBigInt();
          break;
        case /* uint64 sequence */
        5:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* cosmos.tx.v1beta1.Tip tip = 6 [deprecated = true] */
        6:
          message.tip = Tip.internalBinaryRead(reader, reader.uint32(), options, message.tip);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bodyBytes.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.bodyBytes);
    if (message.publicKey)
      Any.internalBinaryWrite(message.publicKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.chainId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.chainId);
    if (message.accountNumber !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.accountNumber);
    if (message.sequence !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.sequence);
    if (message.tip)
      Tip.internalBinaryWrite(message.tip, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SignDocDirectAux = new SignDocDirectAux$Type();
class TxBody$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.TxBody", [
      { no: 1, name: "messages", kind: "message", repeat: 2, T: () => Any },
      {
        no: 2,
        name: "memo",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timeout_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 1023, name: "extension_options", kind: "message", repeat: 2, T: () => Any },
      { no: 2047, name: "non_critical_extension_options", kind: "message", repeat: 2, T: () => Any }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messages = [];
    message.memo = "";
    message.timeoutHeight = 0n;
    message.extensionOptions = [];
    message.nonCriticalExtensionOptions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.protobuf.Any messages */
        1:
          message.messages.push(Any.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string memo */
        2:
          message.memo = reader.string();
          break;
        case /* uint64 timeout_height */
        3:
          message.timeoutHeight = reader.uint64().toBigInt();
          break;
        case /* repeated google.protobuf.Any extension_options */
        1023:
          message.extensionOptions.push(Any.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated google.protobuf.Any non_critical_extension_options */
        2047:
          message.nonCriticalExtensionOptions.push(Any.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.messages.length; i++)
      Any.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.memo !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.memo);
    if (message.timeoutHeight !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.timeoutHeight);
    for (let i = 0; i < message.extensionOptions.length; i++)
      Any.internalBinaryWrite(message.extensionOptions[i], writer.tag(1023, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.nonCriticalExtensionOptions.length; i++)
      Any.internalBinaryWrite(message.nonCriticalExtensionOptions[i], writer.tag(2047, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxBody = new TxBody$Type();
class AuthInfo$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.AuthInfo", [
      { no: 1, name: "signer_infos", kind: "message", repeat: 2, T: () => SignerInfo },
      { no: 2, name: "fee", kind: "message", T: () => Fee },
      { no: 3, name: "tip", kind: "message", T: () => Tip }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signerInfos = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.tx.v1beta1.SignerInfo signer_infos */
        1:
          message.signerInfos.push(SignerInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.tx.v1beta1.Fee fee */
        2:
          message.fee = Fee.internalBinaryRead(reader, reader.uint32(), options, message.fee);
          break;
        case /* cosmos.tx.v1beta1.Tip tip = 3 [deprecated = true] */
        3:
          message.tip = Tip.internalBinaryRead(reader, reader.uint32(), options, message.tip);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.signerInfos.length; i++)
      SignerInfo.internalBinaryWrite(message.signerInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.fee)
      Fee.internalBinaryWrite(message.fee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.tip)
      Tip.internalBinaryWrite(message.tip, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AuthInfo = new AuthInfo$Type();
class SignerInfo$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.SignerInfo", [
      { no: 1, name: "public_key", kind: "message", T: () => Any },
      { no: 2, name: "mode_info", kind: "message", T: () => ModeInfo },
      {
        no: 3,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sequence = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Any public_key */
        1:
          message.publicKey = Any.internalBinaryRead(reader, reader.uint32(), options, message.publicKey);
          break;
        case /* cosmos.tx.v1beta1.ModeInfo mode_info */
        2:
          message.modeInfo = ModeInfo.internalBinaryRead(reader, reader.uint32(), options, message.modeInfo);
          break;
        case /* uint64 sequence */
        3:
          message.sequence = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.publicKey)
      Any.internalBinaryWrite(message.publicKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.modeInfo)
      ModeInfo.internalBinaryWrite(message.modeInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.sequence !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.sequence);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SignerInfo = new SignerInfo$Type();
class ModeInfo$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.ModeInfo", [
      { no: 1, name: "single", kind: "message", oneof: "sum", T: () => ModeInfo_Single },
      { no: 2, name: "multi", kind: "message", oneof: "sum", T: () => ModeInfo_Multi }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sum = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.tx.v1beta1.ModeInfo.Single single */
        1:
          message.sum = {
            oneofKind: "single",
            single: ModeInfo_Single.internalBinaryRead(reader, reader.uint32(), options, message.sum.single)
          };
          break;
        case /* cosmos.tx.v1beta1.ModeInfo.Multi multi */
        2:
          message.sum = {
            oneofKind: "multi",
            multi: ModeInfo_Multi.internalBinaryRead(reader, reader.uint32(), options, message.sum.multi)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sum.oneofKind === "single")
      ModeInfo_Single.internalBinaryWrite(message.sum.single, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.sum.oneofKind === "multi")
      ModeInfo_Multi.internalBinaryWrite(message.sum.multi, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ModeInfo = new ModeInfo$Type();
class ModeInfo_Single$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.ModeInfo.Single", [
      { no: 1, name: "mode", kind: "enum", T: () => ["cosmos.tx.signing.v1beta1.SignMode", SignMode, "SIGN_MODE_"] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.mode = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.tx.signing.v1beta1.SignMode mode */
        1:
          message.mode = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.mode !== 0)
      writer.tag(1, WireType.Varint).int32(message.mode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ModeInfo_Single = new ModeInfo_Single$Type();
class ModeInfo_Multi$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.ModeInfo.Multi", [
      { no: 1, name: "bitarray", kind: "message", T: () => CompactBitArray },
      { no: 2, name: "mode_infos", kind: "message", repeat: 2, T: () => ModeInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.modeInfos = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.crypto.multisig.v1beta1.CompactBitArray bitarray */
        1:
          message.bitarray = CompactBitArray.internalBinaryRead(reader, reader.uint32(), options, message.bitarray);
          break;
        case /* repeated cosmos.tx.v1beta1.ModeInfo mode_infos */
        2:
          message.modeInfos.push(ModeInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bitarray)
      CompactBitArray.internalBinaryWrite(message.bitarray, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.modeInfos.length; i++)
      ModeInfo.internalBinaryWrite(message.modeInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ModeInfo_Multi = new ModeInfo_Multi$Type();
class Fee$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.Fee", [
      { no: 1, name: "amount", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
      {
        no: 2,
        name: "gas_limit",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "payer", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      { no: 4, name: "granter", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.amount = [];
    message.gasLimit = 0n;
    message.payer = "";
    message.granter = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.Coin amount */
        1:
          message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 gas_limit */
        2:
          message.gasLimit = reader.uint64().toBigInt();
          break;
        case /* string payer */
        3:
          message.payer = reader.string();
          break;
        case /* string granter */
        4:
          message.granter = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.amount.length; i++)
      Coin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.gasLimit !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.gasLimit);
    if (message.payer !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.payer);
    if (message.granter !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.granter);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Fee = new Fee$Type();
class Tip$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.Tip", [
      { no: 1, name: "amount", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
      { no: 2, name: "tipper", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.amount = [];
    message.tipper = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.Coin amount */
        1:
          message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string tipper */
        2:
          message.tipper = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.amount.length; i++)
      Coin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.tipper !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.tipper);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Tip = new Tip$Type();
class AuxSignerData$Type extends MessageType {
  constructor() {
    super("cosmos.tx.v1beta1.AuxSignerData", [
      { no: 1, name: "address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      { no: 2, name: "sign_doc", kind: "message", T: () => SignDocDirectAux },
      { no: 3, name: "mode", kind: "enum", T: () => ["cosmos.tx.signing.v1beta1.SignMode", SignMode, "SIGN_MODE_"] },
      {
        no: 4,
        name: "sig",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.mode = 0;
    message.sig = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* cosmos.tx.v1beta1.SignDocDirectAux sign_doc */
        2:
          message.signDoc = SignDocDirectAux.internalBinaryRead(reader, reader.uint32(), options, message.signDoc);
          break;
        case /* cosmos.tx.signing.v1beta1.SignMode mode */
        3:
          message.mode = reader.int32();
          break;
        case /* bytes sig */
        4:
          message.sig = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.signDoc)
      SignDocDirectAux.internalBinaryWrite(message.signDoc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.mode !== 0)
      writer.tag(3, WireType.Varint).int32(message.mode);
    if (message.sig.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.sig);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AuxSignerData = new AuxSignerData$Type();
export {
  AuthInfo,
  AuxSignerData,
  Fee,
  ModeInfo,
  ModeInfo_Multi,
  ModeInfo_Single,
  SignDoc,
  SignDocDirectAux,
  SignerInfo,
  Tip,
  Tx,
  TxBody,
  TxRaw
};
