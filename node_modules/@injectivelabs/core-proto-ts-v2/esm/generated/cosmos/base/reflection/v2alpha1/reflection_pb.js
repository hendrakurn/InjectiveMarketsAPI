import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class AppDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.AppDescriptor", [
      { no: 1, name: "authn", kind: "message", T: () => AuthnDescriptor },
      { no: 2, name: "chain", kind: "message", T: () => ChainDescriptor },
      { no: 3, name: "codec", kind: "message", T: () => CodecDescriptor },
      { no: 4, name: "configuration", kind: "message", T: () => ConfigurationDescriptor },
      { no: 5, name: "query_services", kind: "message", T: () => QueryServicesDescriptor },
      { no: 6, name: "tx", kind: "message", T: () => TxDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.reflection.v2alpha1.AuthnDescriptor authn */
        1:
          message.authn = AuthnDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.authn);
          break;
        case /* cosmos.base.reflection.v2alpha1.ChainDescriptor chain */
        2:
          message.chain = ChainDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.chain);
          break;
        case /* cosmos.base.reflection.v2alpha1.CodecDescriptor codec */
        3:
          message.codec = CodecDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.codec);
          break;
        case /* cosmos.base.reflection.v2alpha1.ConfigurationDescriptor configuration */
        4:
          message.configuration = ConfigurationDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
          break;
        case /* cosmos.base.reflection.v2alpha1.QueryServicesDescriptor query_services */
        5:
          message.queryServices = QueryServicesDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.queryServices);
          break;
        case /* cosmos.base.reflection.v2alpha1.TxDescriptor tx */
        6:
          message.tx = TxDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.tx);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.authn)
      AuthnDescriptor.internalBinaryWrite(message.authn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.chain)
      ChainDescriptor.internalBinaryWrite(message.chain, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.codec)
      CodecDescriptor.internalBinaryWrite(message.codec, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.configuration)
      ConfigurationDescriptor.internalBinaryWrite(message.configuration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.queryServices)
      QueryServicesDescriptor.internalBinaryWrite(message.queryServices, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.tx)
      TxDescriptor.internalBinaryWrite(message.tx, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AppDescriptor = new AppDescriptor$Type();
class TxDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.TxDescriptor", [
      {
        no: 1,
        name: "fullname",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "msgs", kind: "message", repeat: 2, T: () => MsgDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fullname = "";
    message.msgs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string fullname */
        1:
          message.fullname = reader.string();
          break;
        case /* repeated cosmos.base.reflection.v2alpha1.MsgDescriptor msgs */
        2:
          message.msgs.push(MsgDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fullname !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.fullname);
    for (let i = 0; i < message.msgs.length; i++)
      MsgDescriptor.internalBinaryWrite(message.msgs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxDescriptor = new TxDescriptor$Type();
class AuthnDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.AuthnDescriptor", [
      { no: 1, name: "sign_modes", kind: "message", repeat: 2, T: () => SigningModeDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signModes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.reflection.v2alpha1.SigningModeDescriptor sign_modes */
        1:
          message.signModes.push(SigningModeDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.signModes.length; i++)
      SigningModeDescriptor.internalBinaryWrite(message.signModes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AuthnDescriptor = new AuthnDescriptor$Type();
class SigningModeDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.SigningModeDescriptor", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "number",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "authn_info_provider_method_fullname",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.number = 0;
    message.authnInfoProviderMethodFullname = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* int32 number */
        2:
          message.number = reader.int32();
          break;
        case /* string authn_info_provider_method_fullname */
        3:
          message.authnInfoProviderMethodFullname = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.number !== 0)
      writer.tag(2, WireType.Varint).int32(message.number);
    if (message.authnInfoProviderMethodFullname !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.authnInfoProviderMethodFullname);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SigningModeDescriptor = new SigningModeDescriptor$Type();
class ChainDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.ChainDescriptor", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ChainDescriptor = new ChainDescriptor$Type();
class CodecDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.CodecDescriptor", [
      { no: 1, name: "interfaces", kind: "message", repeat: 2, T: () => InterfaceDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.interfaces = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.reflection.v2alpha1.InterfaceDescriptor interfaces */
        1:
          message.interfaces.push(InterfaceDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.interfaces.length; i++)
      InterfaceDescriptor.internalBinaryWrite(message.interfaces[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CodecDescriptor = new CodecDescriptor$Type();
class InterfaceDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.InterfaceDescriptor", [
      {
        no: 1,
        name: "fullname",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "interface_accepting_messages", kind: "message", repeat: 2, T: () => InterfaceAcceptingMessageDescriptor },
      { no: 3, name: "interface_implementers", kind: "message", repeat: 2, T: () => InterfaceImplementerDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fullname = "";
    message.interfaceAcceptingMessages = [];
    message.interfaceImplementers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string fullname */
        1:
          message.fullname = reader.string();
          break;
        case /* repeated cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor interface_accepting_messages */
        2:
          message.interfaceAcceptingMessages.push(InterfaceAcceptingMessageDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor interface_implementers */
        3:
          message.interfaceImplementers.push(InterfaceImplementerDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fullname !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.fullname);
    for (let i = 0; i < message.interfaceAcceptingMessages.length; i++)
      InterfaceAcceptingMessageDescriptor.internalBinaryWrite(message.interfaceAcceptingMessages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.interfaceImplementers.length; i++)
      InterfaceImplementerDescriptor.internalBinaryWrite(message.interfaceImplementers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InterfaceDescriptor = new InterfaceDescriptor$Type();
class InterfaceImplementerDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor", [
      {
        no: 1,
        name: "fullname",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "type_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fullname = "";
    message.typeUrl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string fullname */
        1:
          message.fullname = reader.string();
          break;
        case /* string type_url */
        2:
          message.typeUrl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fullname !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.fullname);
    if (message.typeUrl !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.typeUrl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InterfaceImplementerDescriptor = new InterfaceImplementerDescriptor$Type();
class InterfaceAcceptingMessageDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor", [
      {
        no: 1,
        name: "fullname",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "field_descriptor_names",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fullname = "";
    message.fieldDescriptorNames = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string fullname */
        1:
          message.fullname = reader.string();
          break;
        case /* repeated string field_descriptor_names */
        2:
          message.fieldDescriptorNames.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fullname !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.fullname);
    for (let i = 0; i < message.fieldDescriptorNames.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.fieldDescriptorNames[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InterfaceAcceptingMessageDescriptor = new InterfaceAcceptingMessageDescriptor$Type();
class ConfigurationDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.ConfigurationDescriptor", [
      {
        no: 1,
        name: "bech32_account_address_prefix",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bech32AccountAddressPrefix = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string bech32_account_address_prefix */
        1:
          message.bech32AccountAddressPrefix = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bech32AccountAddressPrefix !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.bech32AccountAddressPrefix);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ConfigurationDescriptor = new ConfigurationDescriptor$Type();
class MsgDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.MsgDescriptor", [
      {
        no: 1,
        name: "msg_type_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.msgTypeUrl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string msg_type_url */
        1:
          message.msgTypeUrl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.msgTypeUrl !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.msgTypeUrl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgDescriptor = new MsgDescriptor$Type();
class GetAuthnDescriptorRequest$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetAuthnDescriptorRequest = new GetAuthnDescriptorRequest$Type();
class GetAuthnDescriptorResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse", [
      { no: 1, name: "authn", kind: "message", T: () => AuthnDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.reflection.v2alpha1.AuthnDescriptor authn */
        1:
          message.authn = AuthnDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.authn);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.authn)
      AuthnDescriptor.internalBinaryWrite(message.authn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetAuthnDescriptorResponse = new GetAuthnDescriptorResponse$Type();
class GetChainDescriptorRequest$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetChainDescriptorRequest = new GetChainDescriptorRequest$Type();
class GetChainDescriptorResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse", [
      { no: 1, name: "chain", kind: "message", T: () => ChainDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.reflection.v2alpha1.ChainDescriptor chain */
        1:
          message.chain = ChainDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.chain);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.chain)
      ChainDescriptor.internalBinaryWrite(message.chain, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetChainDescriptorResponse = new GetChainDescriptorResponse$Type();
class GetCodecDescriptorRequest$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCodecDescriptorRequest = new GetCodecDescriptorRequest$Type();
class GetCodecDescriptorResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse", [
      { no: 1, name: "codec", kind: "message", T: () => CodecDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.reflection.v2alpha1.CodecDescriptor codec */
        1:
          message.codec = CodecDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.codec);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.codec)
      CodecDescriptor.internalBinaryWrite(message.codec, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCodecDescriptorResponse = new GetCodecDescriptorResponse$Type();
class GetConfigurationDescriptorRequest$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetConfigurationDescriptorRequest = new GetConfigurationDescriptorRequest$Type();
class GetConfigurationDescriptorResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse", [
      { no: 1, name: "config", kind: "message", T: () => ConfigurationDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.reflection.v2alpha1.ConfigurationDescriptor config */
        1:
          message.config = ConfigurationDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.config);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.config)
      ConfigurationDescriptor.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetConfigurationDescriptorResponse = new GetConfigurationDescriptorResponse$Type();
class GetQueryServicesDescriptorRequest$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetQueryServicesDescriptorRequest = new GetQueryServicesDescriptorRequest$Type();
class GetQueryServicesDescriptorResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse", [
      { no: 1, name: "queries", kind: "message", T: () => QueryServicesDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.reflection.v2alpha1.QueryServicesDescriptor queries */
        1:
          message.queries = QueryServicesDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.queries);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.queries)
      QueryServicesDescriptor.internalBinaryWrite(message.queries, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetQueryServicesDescriptorResponse = new GetQueryServicesDescriptorResponse$Type();
class GetTxDescriptorRequest$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxDescriptorRequest = new GetTxDescriptorRequest$Type();
class GetTxDescriptorResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse", [
      { no: 1, name: "tx", kind: "message", T: () => TxDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.reflection.v2alpha1.TxDescriptor tx */
        1:
          message.tx = TxDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.tx);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tx)
      TxDescriptor.internalBinaryWrite(message.tx, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTxDescriptorResponse = new GetTxDescriptorResponse$Type();
class QueryServicesDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.QueryServicesDescriptor", [
      { no: 1, name: "query_services", kind: "message", repeat: 2, T: () => QueryServiceDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.queryServices = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.reflection.v2alpha1.QueryServiceDescriptor query_services */
        1:
          message.queryServices.push(QueryServiceDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.queryServices.length; i++)
      QueryServiceDescriptor.internalBinaryWrite(message.queryServices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryServicesDescriptor = new QueryServicesDescriptor$Type();
class QueryServiceDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.QueryServiceDescriptor", [
      {
        no: 1,
        name: "fullname",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "is_module",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 3, name: "methods", kind: "message", repeat: 2, T: () => QueryMethodDescriptor }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fullname = "";
    message.isModule = false;
    message.methods = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string fullname */
        1:
          message.fullname = reader.string();
          break;
        case /* bool is_module */
        2:
          message.isModule = reader.bool();
          break;
        case /* repeated cosmos.base.reflection.v2alpha1.QueryMethodDescriptor methods */
        3:
          message.methods.push(QueryMethodDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fullname !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.fullname);
    if (message.isModule !== false)
      writer.tag(2, WireType.Varint).bool(message.isModule);
    for (let i = 0; i < message.methods.length; i++)
      QueryMethodDescriptor.internalBinaryWrite(message.methods[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryServiceDescriptor = new QueryServiceDescriptor$Type();
class QueryMethodDescriptor$Type extends MessageType {
  constructor() {
    super("cosmos.base.reflection.v2alpha1.QueryMethodDescriptor", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "full_query_path",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.fullQueryPath = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string full_query_path */
        2:
          message.fullQueryPath = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.fullQueryPath !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.fullQueryPath);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMethodDescriptor = new QueryMethodDescriptor$Type();
const ReflectionService = new ServiceType("cosmos.base.reflection.v2alpha1.ReflectionService", [
  { name: "GetAuthnDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/authn" } }, I: GetAuthnDescriptorRequest, O: GetAuthnDescriptorResponse },
  { name: "GetChainDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/chain" } }, I: GetChainDescriptorRequest, O: GetChainDescriptorResponse },
  { name: "GetCodecDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/codec" } }, I: GetCodecDescriptorRequest, O: GetCodecDescriptorResponse },
  { name: "GetConfigurationDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/configuration" } }, I: GetConfigurationDescriptorRequest, O: GetConfigurationDescriptorResponse },
  { name: "GetQueryServicesDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/query_services" } }, I: GetQueryServicesDescriptorRequest, O: GetQueryServicesDescriptorResponse },
  { name: "GetTxDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/tx_descriptor" } }, I: GetTxDescriptorRequest, O: GetTxDescriptorResponse }
]);
export {
  AppDescriptor,
  AuthnDescriptor,
  ChainDescriptor,
  CodecDescriptor,
  ConfigurationDescriptor,
  GetAuthnDescriptorRequest,
  GetAuthnDescriptorResponse,
  GetChainDescriptorRequest,
  GetChainDescriptorResponse,
  GetCodecDescriptorRequest,
  GetCodecDescriptorResponse,
  GetConfigurationDescriptorRequest,
  GetConfigurationDescriptorResponse,
  GetQueryServicesDescriptorRequest,
  GetQueryServicesDescriptorResponse,
  GetTxDescriptorRequest,
  GetTxDescriptorResponse,
  InterfaceAcceptingMessageDescriptor,
  InterfaceDescriptor,
  InterfaceImplementerDescriptor,
  MsgDescriptor,
  QueryMethodDescriptor,
  QueryServiceDescriptor,
  QueryServicesDescriptor,
  ReflectionService,
  SigningModeDescriptor,
  TxDescriptor
};
