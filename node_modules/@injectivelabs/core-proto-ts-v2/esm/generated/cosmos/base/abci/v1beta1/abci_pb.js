import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Block } from "../../../../cometbft/types/v1/block_pb.js";
import { Event } from "../../../../cometbft/abci/v1/types_pb.js";
import { Any } from "../../../../google/protobuf/any_pb.js";
class TxResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.TxResponse", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "txhash", kind: "scalar", T: 9, options: { "gogoproto.customname": "TxHash" } },
      {
        no: 3,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "data",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "raw_log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "logs", kind: "message", repeat: 2, T: () => ABCIMessageLog, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "ABCIMessageLogs" } },
      {
        no: 8,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "gas_wanted",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "gas_used",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 11, name: "tx", kind: "message", T: () => Any },
      {
        no: 12,
        name: "timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 13, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.txhash = "";
    message.codespace = "";
    message.code = 0;
    message.data = "";
    message.rawLog = "";
    message.logs = [];
    message.info = "";
    message.gasWanted = 0n;
    message.gasUsed = 0n;
    message.timestamp = "";
    message.events = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* string txhash */
        2:
          message.txhash = reader.string();
          break;
        case /* string codespace */
        3:
          message.codespace = reader.string();
          break;
        case /* uint32 code */
        4:
          message.code = reader.uint32();
          break;
        case /* string data */
        5:
          message.data = reader.string();
          break;
        case /* string raw_log */
        6:
          message.rawLog = reader.string();
          break;
        case /* repeated cosmos.base.abci.v1beta1.ABCIMessageLog logs */
        7:
          message.logs.push(ABCIMessageLog.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string info */
        8:
          message.info = reader.string();
          break;
        case /* int64 gas_wanted */
        9:
          message.gasWanted = reader.int64().toBigInt();
          break;
        case /* int64 gas_used */
        10:
          message.gasUsed = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Any tx */
        11:
          message.tx = Any.internalBinaryRead(reader, reader.uint32(), options, message.tx);
          break;
        case /* string timestamp */
        12:
          message.timestamp = reader.string();
          break;
        case /* repeated cometbft.abci.v1.Event events */
        13:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.txhash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.txhash);
    if (message.codespace !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.codespace);
    if (message.code !== 0)
      writer.tag(4, WireType.Varint).uint32(message.code);
    if (message.data !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.data);
    if (message.rawLog !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.rawLog);
    for (let i = 0; i < message.logs.length; i++)
      ABCIMessageLog.internalBinaryWrite(message.logs[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.info !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.info);
    if (message.gasWanted !== 0n)
      writer.tag(9, WireType.Varint).int64(message.gasWanted);
    if (message.gasUsed !== 0n)
      writer.tag(10, WireType.Varint).int64(message.gasUsed);
    if (message.tx)
      Any.internalBinaryWrite(message.tx, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.timestamp);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxResponse = new TxResponse$Type();
class ABCIMessageLog$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.ABCIMessageLog", [
      { no: 1, name: "msg_index", kind: "scalar", T: 13, options: { "gogoproto.jsontag": "msg_index" } },
      {
        no: 2,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "events", kind: "message", repeat: 2, T: () => StringEvent, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "StringEvents" } }
    ], { "gogoproto.stringer": true });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.msgIndex = 0;
    message.log = "";
    message.events = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 msg_index */
        1:
          message.msgIndex = reader.uint32();
          break;
        case /* string log */
        2:
          message.log = reader.string();
          break;
        case /* repeated cosmos.base.abci.v1beta1.StringEvent events */
        3:
          message.events.push(StringEvent.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.msgIndex !== 0)
      writer.tag(1, WireType.Varint).uint32(message.msgIndex);
    if (message.log !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.log);
    for (let i = 0; i < message.events.length; i++)
      StringEvent.internalBinaryWrite(message.events[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ABCIMessageLog = new ABCIMessageLog$Type();
class StringEvent$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.StringEvent", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "attributes", kind: "message", repeat: 2, T: () => Attribute, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.stringer": true });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = "";
    message.attributes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */
        1:
          message.type = reader.string();
          break;
        case /* repeated cosmos.base.abci.v1beta1.Attribute attributes */
        2:
          message.attributes.push(Attribute.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    for (let i = 0; i < message.attributes.length; i++)
      Attribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StringEvent = new StringEvent$Type();
class Attribute$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.Attribute", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = "";
    message.value = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */
        1:
          message.key = reader.string();
          break;
        case /* string value */
        2:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    if (message.value !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Attribute = new Attribute$Type();
class GasInfo$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.GasInfo", [
      {
        no: 1,
        name: "gas_wanted",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "gas_used",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.gasWanted = 0n;
    message.gasUsed = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 gas_wanted */
        1:
          message.gasWanted = reader.uint64().toBigInt();
          break;
        case /* uint64 gas_used */
        2:
          message.gasUsed = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.gasWanted !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.gasWanted);
    if (message.gasUsed !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.gasUsed);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GasInfo = new GasInfo$Type();
class Result$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.Result", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false } },
      { no: 4, name: "msg_responses", kind: "message", repeat: 2, T: () => Any }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    message.log = "";
    message.events = [];
    message.msgResponses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data = 1 [deprecated = true] */
        1:
          message.data = reader.bytes();
          break;
        case /* string log */
        2:
          message.log = reader.string();
          break;
        case /* repeated cometbft.abci.v1.Event events */
        3:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated google.protobuf.Any msg_responses */
        4:
          message.msgResponses.push(Any.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    if (message.log !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.log);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.msgResponses.length; i++)
      Any.internalBinaryWrite(message.msgResponses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Result = new Result$Type();
class SimulationResponse$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.SimulationResponse", [
      { no: 1, name: "gas_info", kind: "message", T: () => GasInfo, options: { "gogoproto.nullable": false, "gogoproto.embed": true } },
      { no: 2, name: "result", kind: "message", T: () => Result }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.abci.v1beta1.GasInfo gas_info */
        1:
          message.gasInfo = GasInfo.internalBinaryRead(reader, reader.uint32(), options, message.gasInfo);
          break;
        case /* cosmos.base.abci.v1beta1.Result result */
        2:
          message.result = Result.internalBinaryRead(reader, reader.uint32(), options, message.result);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.gasInfo)
      GasInfo.internalBinaryWrite(message.gasInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.result)
      Result.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SimulationResponse = new SimulationResponse$Type();
class MsgData$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.MsgData", [
      {
        no: 1,
        name: "msg_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ], { "gogoproto.stringer": true });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.msgType = "";
    message.data = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string msg_type */
        1:
          message.msgType = reader.string();
          break;
        case /* bytes data */
        2:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.msgType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.msgType);
    if (message.data.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgData = new MsgData$Type();
class TxMsgData$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.TxMsgData", [
      { no: 1, name: "data", kind: "message", repeat: 2, T: () => MsgData },
      { no: 2, name: "msg_responses", kind: "message", repeat: 2, T: () => Any }
    ], { "gogoproto.stringer": true });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    message.msgResponses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.abci.v1beta1.MsgData data = 1 [deprecated = true] */
        1:
          message.data.push(MsgData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated google.protobuf.Any msg_responses */
        2:
          message.msgResponses.push(Any.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.data.length; i++)
      MsgData.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.msgResponses.length; i++)
      Any.internalBinaryWrite(message.msgResponses[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxMsgData = new TxMsgData$Type();
class SearchTxsResult$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.SearchTxsResult", [
      {
        no: 1,
        name: "total_count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "page_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "page_total",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "limit",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "txs", kind: "message", repeat: 2, T: () => TxResponse }
    ], { "gogoproto.stringer": true });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.totalCount = 0n;
    message.count = 0n;
    message.pageNumber = 0n;
    message.pageTotal = 0n;
    message.limit = 0n;
    message.txs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 total_count */
        1:
          message.totalCount = reader.uint64().toBigInt();
          break;
        case /* uint64 count */
        2:
          message.count = reader.uint64().toBigInt();
          break;
        case /* uint64 page_number */
        3:
          message.pageNumber = reader.uint64().toBigInt();
          break;
        case /* uint64 page_total */
        4:
          message.pageTotal = reader.uint64().toBigInt();
          break;
        case /* uint64 limit */
        5:
          message.limit = reader.uint64().toBigInt();
          break;
        case /* repeated cosmos.base.abci.v1beta1.TxResponse txs */
        6:
          message.txs.push(TxResponse.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalCount !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.totalCount);
    if (message.count !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.count);
    if (message.pageNumber !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.pageNumber);
    if (message.pageTotal !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.pageTotal);
    if (message.limit !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.limit);
    for (let i = 0; i < message.txs.length; i++)
      TxResponse.internalBinaryWrite(message.txs[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SearchTxsResult = new SearchTxsResult$Type();
class SearchBlocksResult$Type extends MessageType {
  constructor() {
    super("cosmos.base.abci.v1beta1.SearchBlocksResult", [
      {
        no: 1,
        name: "total_count",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "page_number",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "page_total",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "limit",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "blocks", kind: "message", repeat: 2, T: () => Block }
    ], { "gogoproto.stringer": true });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.totalCount = 0n;
    message.count = 0n;
    message.pageNumber = 0n;
    message.pageTotal = 0n;
    message.limit = 0n;
    message.blocks = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 total_count */
        1:
          message.totalCount = reader.int64().toBigInt();
          break;
        case /* int64 count */
        2:
          message.count = reader.int64().toBigInt();
          break;
        case /* int64 page_number */
        3:
          message.pageNumber = reader.int64().toBigInt();
          break;
        case /* int64 page_total */
        4:
          message.pageTotal = reader.int64().toBigInt();
          break;
        case /* int64 limit */
        5:
          message.limit = reader.int64().toBigInt();
          break;
        case /* repeated cometbft.types.v1.Block blocks */
        6:
          message.blocks.push(Block.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalCount !== 0n)
      writer.tag(1, WireType.Varint).int64(message.totalCount);
    if (message.count !== 0n)
      writer.tag(2, WireType.Varint).int64(message.count);
    if (message.pageNumber !== 0n)
      writer.tag(3, WireType.Varint).int64(message.pageNumber);
    if (message.pageTotal !== 0n)
      writer.tag(4, WireType.Varint).int64(message.pageTotal);
    if (message.limit !== 0n)
      writer.tag(5, WireType.Varint).int64(message.limit);
    for (let i = 0; i < message.blocks.length; i++)
      Block.internalBinaryWrite(message.blocks[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SearchBlocksResult = new SearchBlocksResult$Type();
export {
  ABCIMessageLog,
  Attribute,
  GasInfo,
  MsgData,
  Result,
  SearchBlocksResult,
  SearchTxsResult,
  SimulationResponse,
  StringEvent,
  TxMsgData,
  TxResponse
};
