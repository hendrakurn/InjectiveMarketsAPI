import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SendEnabled } from "./bank_pb.js";
import { Metadata } from "./bank_pb.js";
import { Params } from "./bank_pb.js";
import { PageResponse } from "../../base/query/v1beta1/pagination_pb.js";
import { PageRequest } from "../../base/query/v1beta1/pagination_pb.js";
import { Coin } from "../../base/v1beta1/coin_pb.js";
class QueryBalanceRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryBalanceRequest", [
      { no: 1, name: "address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceRequest = new QueryBalanceRequest$Type();
class QueryBalanceResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryBalanceResponse", [
      { no: 1, name: "balance", kind: "message", T: () => Coin }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.Coin balance */
        1:
          message.balance = Coin.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance)
      Coin.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceResponse = new QueryBalanceResponse$Type();
class QueryAllBalancesRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryAllBalancesRequest", [
      { no: 1, name: "address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      { no: 2, name: "pagination", kind: "message", T: () => PageRequest },
      {
        no: 3,
        name: "resolve_denom",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.resolveDenom = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        2:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        case /* bool resolve_denom */
        3:
          message.resolveDenom = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.resolveDenom !== false)
      writer.tag(3, WireType.Varint).bool(message.resolveDenom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAllBalancesRequest = new QueryAllBalancesRequest$Type();
class QueryAllBalancesResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryAllBalancesResponse", [
      { no: 1, name: "balances", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.Coin balances */
        1:
          message.balances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balances.length; i++)
      Coin.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAllBalancesResponse = new QueryAllBalancesResponse$Type();
class QuerySpendableBalancesRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySpendableBalancesRequest", [
      { no: 1, name: "address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      { no: 2, name: "pagination", kind: "message", T: () => PageRequest }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        2:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpendableBalancesRequest = new QuerySpendableBalancesRequest$Type();
class QuerySpendableBalancesResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySpendableBalancesResponse", [
      { no: 1, name: "balances", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.Coin balances */
        1:
          message.balances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balances.length; i++)
      Coin.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpendableBalancesResponse = new QuerySpendableBalancesResponse$Type();
class QuerySpendableBalanceByDenomRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest", [
      { no: 1, name: "address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpendableBalanceByDenomRequest = new QuerySpendableBalanceByDenomRequest$Type();
class QuerySpendableBalanceByDenomResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse", [
      { no: 1, name: "balance", kind: "message", T: () => Coin }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.Coin balance */
        1:
          message.balance = Coin.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance)
      Coin.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpendableBalanceByDenomResponse = new QuerySpendableBalanceByDenomResponse$Type();
class QueryTotalSupplyRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryTotalSupplyRequest", [
      { no: 1, name: "pagination", kind: "message", T: () => PageRequest }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        1:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTotalSupplyRequest = new QueryTotalSupplyRequest$Type();
class QueryTotalSupplyResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryTotalSupplyResponse", [
      { no: 1, name: "supply", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.supply = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.Coin supply */
        1:
          message.supply.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.supply.length; i++)
      Coin.internalBinaryWrite(message.supply[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTotalSupplyResponse = new QueryTotalSupplyResponse$Type();
class QuerySupplyOfRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySupplyOfRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySupplyOfRequest = new QuerySupplyOfRequest$Type();
class QuerySupplyOfResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySupplyOfResponse", [
      { no: 1, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.Coin amount */
        1:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySupplyOfResponse = new QuerySupplyOfResponse$Type();
class QueryParamsRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryParamsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsRequest = new QueryParamsRequest$Type();
class QueryParamsResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryParamsResponse", [
      { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.bank.v1beta1.Params params */
        1:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsResponse = new QueryParamsResponse$Type();
class QueryDenomsMetadataRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomsMetadataRequest", [
      { no: 1, name: "pagination", kind: "message", T: () => PageRequest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        1:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomsMetadataRequest = new QueryDenomsMetadataRequest$Type();
class QueryDenomsMetadataResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomsMetadataResponse", [
      { no: 1, name: "metadatas", kind: "message", repeat: 2, T: () => Metadata, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.metadatas = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.bank.v1beta1.Metadata metadatas */
        1:
          message.metadatas.push(Metadata.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.metadatas.length; i++)
      Metadata.internalBinaryWrite(message.metadatas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomsMetadataResponse = new QueryDenomsMetadataResponse$Type();
class QueryDenomMetadataRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomMetadataRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMetadataRequest = new QueryDenomMetadataRequest$Type();
class QueryDenomMetadataResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomMetadataResponse", [
      { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.bank.v1beta1.Metadata metadata */
        1:
          message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.metadata)
      Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMetadataResponse = new QueryDenomMetadataResponse$Type();
class QueryDenomMetadataByQueryStringRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMetadataByQueryStringRequest = new QueryDenomMetadataByQueryStringRequest$Type();
class QueryDenomMetadataByQueryStringResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse", [
      { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.bank.v1beta1.Metadata metadata */
        1:
          message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.metadata)
      Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMetadataByQueryStringResponse = new QueryDenomMetadataByQueryStringResponse$Type();
class QueryDenomOwnersRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomOwnersRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "pagination", kind: "message", T: () => PageRequest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        2:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomOwnersRequest = new QueryDenomOwnersRequest$Type();
class DenomOwner$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.DenomOwner", [
      { no: 1, name: "address", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      { no: 2, name: "balance", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin balance */
        2:
          message.balance = Coin.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.balance)
      Coin.internalBinaryWrite(message.balance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomOwner = new DenomOwner$Type();
class QueryDenomOwnersResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomOwnersResponse", [
      { no: 1, name: "denom_owners", kind: "message", repeat: 2, T: () => DenomOwner },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denomOwners = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.bank.v1beta1.DenomOwner denom_owners */
        1:
          message.denomOwners.push(DenomOwner.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.denomOwners.length; i++)
      DenomOwner.internalBinaryWrite(message.denomOwners[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomOwnersResponse = new QueryDenomOwnersResponse$Type();
class QueryDenomOwnersByQueryRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomOwnersByQueryRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "pagination", kind: "message", T: () => PageRequest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        2:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomOwnersByQueryRequest = new QueryDenomOwnersByQueryRequest$Type();
class QueryDenomOwnersByQueryResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse", [
      { no: 1, name: "denom_owners", kind: "message", repeat: 2, T: () => DenomOwner },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denomOwners = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.bank.v1beta1.DenomOwner denom_owners */
        1:
          message.denomOwners.push(DenomOwner.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.denomOwners.length; i++)
      DenomOwner.internalBinaryWrite(message.denomOwners[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomOwnersByQueryResponse = new QueryDenomOwnersByQueryResponse$Type();
class QuerySendEnabledRequest$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySendEnabledRequest", [
      {
        no: 1,
        name: "denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 99, name: "pagination", kind: "message", T: () => PageRequest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denoms = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string denoms */
        1:
          message.denoms.push(reader.string());
          break;
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        99:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.denoms.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.denoms[i]);
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(99, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySendEnabledRequest = new QuerySendEnabledRequest$Type();
class QuerySendEnabledResponse$Type extends MessageType {
  constructor() {
    super("cosmos.bank.v1beta1.QuerySendEnabledResponse", [
      { no: 1, name: "send_enabled", kind: "message", repeat: 2, T: () => SendEnabled },
      { no: 99, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sendEnabled = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.bank.v1beta1.SendEnabled send_enabled */
        1:
          message.sendEnabled.push(SendEnabled.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        99:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.sendEnabled.length; i++)
      SendEnabled.internalBinaryWrite(message.sendEnabled[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(99, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySendEnabledResponse = new QuerySendEnabledResponse$Type();
const Query = new ServiceType("cosmos.bank.v1beta1.Query", [
  { name: "Balance", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/balances/{address}/by_denom" }, "cosmos.query.v1.module_query_safe": true }, I: QueryBalanceRequest, O: QueryBalanceResponse },
  { name: "AllBalances", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/balances/{address}" }, "cosmos.query.v1.module_query_safe": true }, I: QueryAllBalancesRequest, O: QueryAllBalancesResponse },
  { name: "SpendableBalances", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/spendable_balances/{address}" }, "cosmos.query.v1.module_query_safe": true }, I: QuerySpendableBalancesRequest, O: QuerySpendableBalancesResponse },
  { name: "SpendableBalanceByDenom", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom" }, "cosmos.query.v1.module_query_safe": true }, I: QuerySpendableBalanceByDenomRequest, O: QuerySpendableBalanceByDenomResponse },
  { name: "TotalSupply", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/supply" }, "cosmos.query.v1.module_query_safe": true }, I: QueryTotalSupplyRequest, O: QueryTotalSupplyResponse },
  { name: "SupplyOf", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/supply/by_denom" }, "cosmos.query.v1.module_query_safe": true }, I: QuerySupplyOfRequest, O: QuerySupplyOfResponse },
  { name: "Params", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/params" }, "cosmos.query.v1.module_query_safe": true }, I: QueryParamsRequest, O: QueryParamsResponse },
  { name: "DenomMetadata", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/denoms_metadata/{denom}" }, "cosmos.query.v1.module_query_safe": true }, I: QueryDenomMetadataRequest, O: QueryDenomMetadataResponse },
  { name: "DenomMetadataByQueryString", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/denoms_metadata_by_query_string" }, "cosmos.query.v1.module_query_safe": true }, I: QueryDenomMetadataByQueryStringRequest, O: QueryDenomMetadataByQueryStringResponse },
  { name: "DenomsMetadata", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/denoms_metadata" }, "cosmos.query.v1.module_query_safe": true }, I: QueryDenomsMetadataRequest, O: QueryDenomsMetadataResponse },
  { name: "DenomOwners", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/denom_owners/{denom}" }, "cosmos.query.v1.module_query_safe": true }, I: QueryDenomOwnersRequest, O: QueryDenomOwnersResponse },
  { name: "DenomOwnersByQuery", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/denom_owners_by_query" }, "cosmos.query.v1.module_query_safe": true }, I: QueryDenomOwnersByQueryRequest, O: QueryDenomOwnersByQueryResponse },
  { name: "SendEnabled", options: { "google.api.http": { get: "/cosmos/bank/v1beta1/send_enabled" }, "cosmos.query.v1.module_query_safe": true }, I: QuerySendEnabledRequest, O: QuerySendEnabledResponse }
]);
export {
  DenomOwner,
  Query,
  QueryAllBalancesRequest,
  QueryAllBalancesResponse,
  QueryBalanceRequest,
  QueryBalanceResponse,
  QueryDenomMetadataByQueryStringRequest,
  QueryDenomMetadataByQueryStringResponse,
  QueryDenomMetadataRequest,
  QueryDenomMetadataResponse,
  QueryDenomOwnersByQueryRequest,
  QueryDenomOwnersByQueryResponse,
  QueryDenomOwnersRequest,
  QueryDenomOwnersResponse,
  QueryDenomsMetadataRequest,
  QueryDenomsMetadataResponse,
  QueryParamsRequest,
  QueryParamsResponse,
  QuerySendEnabledRequest,
  QuerySendEnabledResponse,
  QuerySpendableBalanceByDenomRequest,
  QuerySpendableBalanceByDenomResponse,
  QuerySpendableBalancesRequest,
  QuerySpendableBalancesResponse,
  QuerySupplyOfRequest,
  QuerySupplyOfResponse,
  QueryTotalSupplyRequest,
  QueryTotalSupplyResponse
};
