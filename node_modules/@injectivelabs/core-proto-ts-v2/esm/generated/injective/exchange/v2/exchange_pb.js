import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MarketVolume } from "./market_pb.js";
import { AtomicMarketOrderAccessLevel } from "./order_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
var ExecutionType = /* @__PURE__ */ ((ExecutionType2) => {
  ExecutionType2[ExecutionType2["UnspecifiedExecutionType"] = 0] = "UnspecifiedExecutionType";
  ExecutionType2[ExecutionType2["Market"] = 1] = "Market";
  ExecutionType2[ExecutionType2["LimitFill"] = 2] = "LimitFill";
  ExecutionType2[ExecutionType2["LimitMatchRestingOrder"] = 3] = "LimitMatchRestingOrder";
  ExecutionType2[ExecutionType2["LimitMatchNewOrder"] = 4] = "LimitMatchNewOrder";
  ExecutionType2[ExecutionType2["MarketLiquidation"] = 5] = "MarketLiquidation";
  ExecutionType2[ExecutionType2["ExpiryMarketSettlement"] = 6] = "ExpiryMarketSettlement";
  ExecutionType2[ExecutionType2["OffsettingPosition"] = 7] = "OffsettingPosition";
  return ExecutionType2;
})(ExecutionType || {});
class Params$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.Params", [
      { no: 1, name: "spot_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
      { no: 2, name: "derivative_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
      { no: 3, name: "default_spot_maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "default_spot_taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "default_derivative_maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "default_derivative_taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "default_initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "default_maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 9,
        name: "default_funding_interval",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "funding_multiple",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 11, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "default_hourly_funding_rate_cap", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "default_hourly_interest_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 14,
        name: "max_derivative_order_side_count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 15, name: "inj_reward_staked_requirement_threshold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 16,
        name: "trading_rewards_vesting_duration",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 17, name: "liquidator_reward_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 18, name: "binary_options_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
      { no: 19, name: "atomic_market_order_access_level", kind: "enum", T: () => ["injective.exchange.v2.AtomicMarketOrderAccessLevel", AtomicMarketOrderAccessLevel] },
      { no: 20, name: "spot_atomic_market_order_fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 21, name: "derivative_atomic_market_order_fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 22, name: "binary_options_atomic_market_order_fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 23, name: "minimal_protocol_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 24,
        name: "is_instant_derivative_market_launch_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 25,
        name: "post_only_mode_height_threshold",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 26,
        name: "margin_decrease_price_timestamp_threshold_seconds",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 27,
        name: "exchange_admins",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 28, name: "inj_auction_max_cap", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 29,
        name: "fixed_gas_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 30,
        name: "emit_legacy_version_events",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 31, name: "default_reduce_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 33,
        name: "post_only_mode_blocks_amount",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 34,
        name: "min_post_only_mode_downtime_duration",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 35,
        name: "post_only_mode_blocks_amount_after_downtime",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ], { "gogoproto.equal": true, "amino.name": "exchange/Params" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.defaultSpotMakerFeeRate = "";
    message.defaultSpotTakerFeeRate = "";
    message.defaultDerivativeMakerFeeRate = "";
    message.defaultDerivativeTakerFeeRate = "";
    message.defaultInitialMarginRatio = "";
    message.defaultMaintenanceMarginRatio = "";
    message.defaultFundingInterval = 0n;
    message.fundingMultiple = 0n;
    message.relayerFeeShareRate = "";
    message.defaultHourlyFundingRateCap = "";
    message.defaultHourlyInterestRate = "";
    message.maxDerivativeOrderSideCount = 0;
    message.injRewardStakedRequirementThreshold = "";
    message.tradingRewardsVestingDuration = 0n;
    message.liquidatorRewardShareRate = "";
    message.atomicMarketOrderAccessLevel = 0;
    message.spotAtomicMarketOrderFeeMultiplier = "";
    message.derivativeAtomicMarketOrderFeeMultiplier = "";
    message.binaryOptionsAtomicMarketOrderFeeMultiplier = "";
    message.minimalProtocolFeeRate = "";
    message.isInstantDerivativeMarketLaunchEnabled = false;
    message.postOnlyModeHeightThreshold = 0n;
    message.marginDecreasePriceTimestampThresholdSeconds = 0n;
    message.exchangeAdmins = [];
    message.injAuctionMaxCap = "";
    message.fixedGasEnabled = false;
    message.emitLegacyVersionEvents = false;
    message.defaultReduceMarginRatio = "";
    message.postOnlyModeBlocksAmount = 0n;
    message.minPostOnlyModeDowntimeDuration = "";
    message.postOnlyModeBlocksAmountAfterDowntime = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.Coin spot_market_instant_listing_fee */
        1:
          message.spotMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.spotMarketInstantListingFee);
          break;
        case /* cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee */
        2:
          message.derivativeMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.derivativeMarketInstantListingFee);
          break;
        case /* string default_spot_maker_fee_rate */
        3:
          message.defaultSpotMakerFeeRate = reader.string();
          break;
        case /* string default_spot_taker_fee_rate */
        4:
          message.defaultSpotTakerFeeRate = reader.string();
          break;
        case /* string default_derivative_maker_fee_rate */
        5:
          message.defaultDerivativeMakerFeeRate = reader.string();
          break;
        case /* string default_derivative_taker_fee_rate */
        6:
          message.defaultDerivativeTakerFeeRate = reader.string();
          break;
        case /* string default_initial_margin_ratio */
        7:
          message.defaultInitialMarginRatio = reader.string();
          break;
        case /* string default_maintenance_margin_ratio */
        8:
          message.defaultMaintenanceMarginRatio = reader.string();
          break;
        case /* int64 default_funding_interval */
        9:
          message.defaultFundingInterval = reader.int64().toBigInt();
          break;
        case /* int64 funding_multiple */
        10:
          message.fundingMultiple = reader.int64().toBigInt();
          break;
        case /* string relayer_fee_share_rate */
        11:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* string default_hourly_funding_rate_cap */
        12:
          message.defaultHourlyFundingRateCap = reader.string();
          break;
        case /* string default_hourly_interest_rate */
        13:
          message.defaultHourlyInterestRate = reader.string();
          break;
        case /* uint32 max_derivative_order_side_count */
        14:
          message.maxDerivativeOrderSideCount = reader.uint32();
          break;
        case /* string inj_reward_staked_requirement_threshold */
        15:
          message.injRewardStakedRequirementThreshold = reader.string();
          break;
        case /* int64 trading_rewards_vesting_duration */
        16:
          message.tradingRewardsVestingDuration = reader.int64().toBigInt();
          break;
        case /* string liquidator_reward_share_rate */
        17:
          message.liquidatorRewardShareRate = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee */
        18:
          message.binaryOptionsMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.binaryOptionsMarketInstantListingFee);
          break;
        case /* injective.exchange.v2.AtomicMarketOrderAccessLevel atomic_market_order_access_level */
        19:
          message.atomicMarketOrderAccessLevel = reader.int32();
          break;
        case /* string spot_atomic_market_order_fee_multiplier */
        20:
          message.spotAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case /* string derivative_atomic_market_order_fee_multiplier */
        21:
          message.derivativeAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case /* string binary_options_atomic_market_order_fee_multiplier */
        22:
          message.binaryOptionsAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case /* string minimal_protocol_fee_rate */
        23:
          message.minimalProtocolFeeRate = reader.string();
          break;
        case /* bool is_instant_derivative_market_launch_enabled */
        24:
          message.isInstantDerivativeMarketLaunchEnabled = reader.bool();
          break;
        case /* int64 post_only_mode_height_threshold */
        25:
          message.postOnlyModeHeightThreshold = reader.int64().toBigInt();
          break;
        case /* int64 margin_decrease_price_timestamp_threshold_seconds */
        26:
          message.marginDecreasePriceTimestampThresholdSeconds = reader.int64().toBigInt();
          break;
        case /* repeated string exchange_admins */
        27:
          message.exchangeAdmins.push(reader.string());
          break;
        case /* string inj_auction_max_cap */
        28:
          message.injAuctionMaxCap = reader.string();
          break;
        case /* bool fixed_gas_enabled */
        29:
          message.fixedGasEnabled = reader.bool();
          break;
        case /* bool emit_legacy_version_events */
        30:
          message.emitLegacyVersionEvents = reader.bool();
          break;
        case /* string default_reduce_margin_ratio */
        31:
          message.defaultReduceMarginRatio = reader.string();
          break;
        case /* uint64 post_only_mode_blocks_amount */
        33:
          message.postOnlyModeBlocksAmount = reader.uint64().toBigInt();
          break;
        case /* string min_post_only_mode_downtime_duration */
        34:
          message.minPostOnlyModeDowntimeDuration = reader.string();
          break;
        case /* uint64 post_only_mode_blocks_amount_after_downtime */
        35:
          message.postOnlyModeBlocksAmountAfterDowntime = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.spotMarketInstantListingFee)
      Coin.internalBinaryWrite(message.spotMarketInstantListingFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.derivativeMarketInstantListingFee)
      Coin.internalBinaryWrite(message.derivativeMarketInstantListingFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.defaultSpotMakerFeeRate !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.defaultSpotMakerFeeRate);
    if (message.defaultSpotTakerFeeRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.defaultSpotTakerFeeRate);
    if (message.defaultDerivativeMakerFeeRate !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.defaultDerivativeMakerFeeRate);
    if (message.defaultDerivativeTakerFeeRate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.defaultDerivativeTakerFeeRate);
    if (message.defaultInitialMarginRatio !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.defaultInitialMarginRatio);
    if (message.defaultMaintenanceMarginRatio !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.defaultMaintenanceMarginRatio);
    if (message.defaultFundingInterval !== 0n)
      writer.tag(9, WireType.Varint).int64(message.defaultFundingInterval);
    if (message.fundingMultiple !== 0n)
      writer.tag(10, WireType.Varint).int64(message.fundingMultiple);
    if (message.relayerFeeShareRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.defaultHourlyFundingRateCap !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.defaultHourlyFundingRateCap);
    if (message.defaultHourlyInterestRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.defaultHourlyInterestRate);
    if (message.maxDerivativeOrderSideCount !== 0)
      writer.tag(14, WireType.Varint).uint32(message.maxDerivativeOrderSideCount);
    if (message.injRewardStakedRequirementThreshold !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.injRewardStakedRequirementThreshold);
    if (message.tradingRewardsVestingDuration !== 0n)
      writer.tag(16, WireType.Varint).int64(message.tradingRewardsVestingDuration);
    if (message.liquidatorRewardShareRate !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.liquidatorRewardShareRate);
    if (message.binaryOptionsMarketInstantListingFee)
      Coin.internalBinaryWrite(message.binaryOptionsMarketInstantListingFee, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.atomicMarketOrderAccessLevel !== 0)
      writer.tag(19, WireType.Varint).int32(message.atomicMarketOrderAccessLevel);
    if (message.spotAtomicMarketOrderFeeMultiplier !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.spotAtomicMarketOrderFeeMultiplier);
    if (message.derivativeAtomicMarketOrderFeeMultiplier !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.derivativeAtomicMarketOrderFeeMultiplier);
    if (message.binaryOptionsAtomicMarketOrderFeeMultiplier !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.binaryOptionsAtomicMarketOrderFeeMultiplier);
    if (message.minimalProtocolFeeRate !== "")
      writer.tag(23, WireType.LengthDelimited).string(message.minimalProtocolFeeRate);
    if (message.isInstantDerivativeMarketLaunchEnabled !== false)
      writer.tag(24, WireType.Varint).bool(message.isInstantDerivativeMarketLaunchEnabled);
    if (message.postOnlyModeHeightThreshold !== 0n)
      writer.tag(25, WireType.Varint).int64(message.postOnlyModeHeightThreshold);
    if (message.marginDecreasePriceTimestampThresholdSeconds !== 0n)
      writer.tag(26, WireType.Varint).int64(message.marginDecreasePriceTimestampThresholdSeconds);
    for (let i = 0; i < message.exchangeAdmins.length; i++)
      writer.tag(27, WireType.LengthDelimited).string(message.exchangeAdmins[i]);
    if (message.injAuctionMaxCap !== "")
      writer.tag(28, WireType.LengthDelimited).string(message.injAuctionMaxCap);
    if (message.fixedGasEnabled !== false)
      writer.tag(29, WireType.Varint).bool(message.fixedGasEnabled);
    if (message.emitLegacyVersionEvents !== false)
      writer.tag(30, WireType.Varint).bool(message.emitLegacyVersionEvents);
    if (message.defaultReduceMarginRatio !== "")
      writer.tag(31, WireType.LengthDelimited).string(message.defaultReduceMarginRatio);
    if (message.postOnlyModeBlocksAmount !== 0n)
      writer.tag(33, WireType.Varint).uint64(message.postOnlyModeBlocksAmount);
    if (message.minPostOnlyModeDowntimeDuration !== "")
      writer.tag(34, WireType.LengthDelimited).string(message.minPostOnlyModeDowntimeDuration);
    if (message.postOnlyModeBlocksAmountAfterDowntime !== 0n)
      writer.tag(35, WireType.Varint).uint64(message.postOnlyModeBlocksAmountAfterDowntime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Params = new Params$Type();
class NextFundingTimestamp$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.NextFundingTimestamp", [
      {
        no: 1,
        name: "next_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.nextTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 next_timestamp */
        1:
          message.nextTimestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.nextTimestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.nextTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const NextFundingTimestamp = new NextFundingTimestamp$Type();
class MidPriceAndTOB$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MidPriceAndTOB", [
      { no: 1, name: "mid_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "best_buy_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "best_sell_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.midPrice = "";
    message.bestBuyPrice = "";
    message.bestSellPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string mid_price */
        1:
          message.midPrice = reader.string();
          break;
        case /* string best_buy_price */
        2:
          message.bestBuyPrice = reader.string();
          break;
        case /* string best_sell_price */
        3:
          message.bestSellPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.midPrice !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
    if (message.bestBuyPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
    if (message.bestSellPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MidPriceAndTOB = new MidPriceAndTOB$Type();
class Deposit$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.Deposit", [
      { no: 1, name: "available_balance", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "total_balance", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.availableBalance = "";
    message.totalBalance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string available_balance */
        1:
          message.availableBalance = reader.string();
          break;
        case /* string total_balance */
        2:
          message.totalBalance = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.availableBalance !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.availableBalance);
    if (message.totalBalance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.totalBalance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Deposit = new Deposit$Type();
class SubaccountTradeNonce$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountTradeNonce", [
      {
        no: 1,
        name: "nonce",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.nonce = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 nonce */
        1:
          message.nonce = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.nonce !== 0)
      writer.tag(1, WireType.Varint).uint32(message.nonce);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountTradeNonce = new SubaccountTradeNonce$Type();
class SubaccountOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountOrder", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "isReduceOnly",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.isReduceOnly = false;
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* bool isReduceOnly */
        3:
          message.isReduceOnly = reader.bool();
          break;
        case /* string cid */
        4:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.isReduceOnly !== false)
      writer.tag(3, WireType.Varint).bool(message.isReduceOnly);
    if (message.cid !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrder = new SubaccountOrder$Type();
class SubaccountOrderData$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountOrderData", [
      { no: 1, name: "order", kind: "message", T: () => SubaccountOrder },
      {
        no: 2,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.SubaccountOrder order */
        1:
          message.order = SubaccountOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* bytes order_hash */
        2:
          message.orderHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.order)
      SubaccountOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderHash.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.orderHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrderData = new SubaccountOrderData$Type();
class Position$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.Position", [
      {
        no: 1,
        name: "isLong",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "entry_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "cumulative_funding_entry", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.isLong = false;
    message.quantity = "";
    message.entryPrice = "";
    message.margin = "";
    message.cumulativeFundingEntry = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool isLong */
        1:
          message.isLong = reader.bool();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        3:
          message.entryPrice = reader.string();
          break;
        case /* string margin */
        4:
          message.margin = reader.string();
          break;
        case /* string cumulative_funding_entry */
        5:
          message.cumulativeFundingEntry = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.isLong !== false)
      writer.tag(1, WireType.Varint).bool(message.isLong);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.entryPrice);
    if (message.margin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.margin);
    if (message.cumulativeFundingEntry !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Position = new Position$Type();
class Balance$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.Balance", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "deposits", kind: "message", T: () => Deposit }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        case /* injective.exchange.v2.Deposit deposits */
        3:
          message.deposits = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposits);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    if (message.deposits)
      Deposit.internalBinaryWrite(message.deposits, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Balance = new Balance$Type();
class DerivativePosition$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativePosition", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "position", kind: "message", T: () => Position }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.Position position */
        3:
          message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.position)
      Position.internalBinaryWrite(message.position, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativePosition = new DerivativePosition$Type();
class MarketOrderIndicator$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MarketOrderIndicator", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "isBuy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isBuy = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool isBuy */
        2:
          message.isBuy = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isBuy !== false)
      writer.tag(2, WireType.Varint).bool(message.isBuy);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketOrderIndicator = new MarketOrderIndicator$Type();
class TradeLog$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradeLog", [
      { no: 1, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12, options: { "gogoproto.nullable": true } },
      {
        no: 7,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.quantity = "";
    message.price = "";
    message.subaccountId = new Uint8Array(0);
    message.fee = "";
    message.orderHash = new Uint8Array(0);
    message.feeRecipientAddress = new Uint8Array(0);
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string quantity */
        1:
          message.quantity = reader.string();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        case /* bytes subaccount_id */
        3:
          message.subaccountId = reader.bytes();
          break;
        case /* string fee */
        4:
          message.fee = reader.string();
          break;
        case /* bytes order_hash */
        5:
          message.orderHash = reader.bytes();
          break;
        case /* bytes fee_recipient_address */
        6:
          message.feeRecipientAddress = reader.bytes();
          break;
        case /* string cid */
        7:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.quantity !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.quantity);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    if (message.subaccountId.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.fee !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fee);
    if (message.orderHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.feeRecipientAddress.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
    if (message.cid !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeLog = new TradeLog$Type();
class PositionDelta$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PositionDelta", [
      {
        no: 1,
        name: "is_long",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "execution_quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "execution_margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "execution_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.isLong = false;
    message.executionQuantity = "";
    message.executionMargin = "";
    message.executionPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool is_long */
        1:
          message.isLong = reader.bool();
          break;
        case /* string execution_quantity */
        2:
          message.executionQuantity = reader.string();
          break;
        case /* string execution_margin */
        3:
          message.executionMargin = reader.string();
          break;
        case /* string execution_price */
        4:
          message.executionPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.isLong !== false)
      writer.tag(1, WireType.Varint).bool(message.isLong);
    if (message.executionQuantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionQuantity);
    if (message.executionMargin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionMargin);
    if (message.executionPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.executionPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionDelta = new PositionDelta$Type();
class DerivativeTradeLog$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeTradeLog", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "position_delta", kind: "message", T: () => PositionDelta },
      { no: 3, name: "payout", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12, options: { "gogoproto.nullable": true } },
      {
        no: 7,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "pnl", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = new Uint8Array(0);
    message.payout = "";
    message.fee = "";
    message.orderHash = new Uint8Array(0);
    message.feeRecipientAddress = new Uint8Array(0);
    message.cid = "";
    message.pnl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes subaccount_id */
        1:
          message.subaccountId = reader.bytes();
          break;
        case /* injective.exchange.v2.PositionDelta position_delta */
        2:
          message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
          break;
        case /* string payout */
        3:
          message.payout = reader.string();
          break;
        case /* string fee */
        4:
          message.fee = reader.string();
          break;
        case /* bytes order_hash */
        5:
          message.orderHash = reader.bytes();
          break;
        case /* bytes fee_recipient_address */
        6:
          message.feeRecipientAddress = reader.bytes();
          break;
        case /* string cid */
        7:
          message.cid = reader.string();
          break;
        case /* string pnl */
        8:
          message.pnl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.positionDelta)
      PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.payout !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.payout);
    if (message.fee !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fee);
    if (message.orderHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.feeRecipientAddress.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
    if (message.cid !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.cid);
    if (message.pnl !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.pnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeTradeLog = new DerivativeTradeLog$Type();
class SubaccountPosition$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountPosition", [
      { no: 1, name: "position", kind: "message", T: () => Position },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.Position position */
        1:
          message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        case /* bytes subaccount_id */
        2:
          message.subaccountId = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.position)
      Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.subaccountId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountPosition = new SubaccountPosition$Type();
class SubaccountDeposit$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountDeposit", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "deposit", kind: "message", T: () => Deposit }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes subaccount_id */
        1:
          message.subaccountId = reader.bytes();
          break;
        case /* injective.exchange.v2.Deposit deposit */
        2:
          message.deposit = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.deposit)
      Deposit.internalBinaryWrite(message.deposit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountDeposit = new SubaccountDeposit$Type();
class DepositUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DepositUpdate", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "deposits", kind: "message", repeat: 2, T: () => SubaccountDeposit }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.deposits = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* repeated injective.exchange.v2.SubaccountDeposit deposits */
        2:
          message.deposits.push(SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    for (let i = 0; i < message.deposits.length; i++)
      SubaccountDeposit.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DepositUpdate = new DepositUpdate$Type();
class PointsMultiplier$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PointsMultiplier", [
      { no: 1, name: "maker_points_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "taker_points_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.makerPointsMultiplier = "";
    message.takerPointsMultiplier = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string maker_points_multiplier */
        1:
          message.makerPointsMultiplier = reader.string();
          break;
        case /* string taker_points_multiplier */
        2:
          message.takerPointsMultiplier = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.makerPointsMultiplier !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.makerPointsMultiplier);
    if (message.takerPointsMultiplier !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.takerPointsMultiplier);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsMultiplier = new PointsMultiplier$Type();
class TradingRewardCampaignBoostInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradingRewardCampaignBoostInfo", [
      {
        no: 1,
        name: "boosted_spot_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "spot_market_multipliers", kind: "message", repeat: 2, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "boosted_derivative_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "derivative_market_multipliers", kind: "message", repeat: 2, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.boostedSpotMarketIds = [];
    message.spotMarketMultipliers = [];
    message.boostedDerivativeMarketIds = [];
    message.derivativeMarketMultipliers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string boosted_spot_market_ids */
        1:
          message.boostedSpotMarketIds.push(reader.string());
          break;
        case /* repeated injective.exchange.v2.PointsMultiplier spot_market_multipliers */
        2:
          message.spotMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string boosted_derivative_market_ids */
        3:
          message.boostedDerivativeMarketIds.push(reader.string());
          break;
        case /* repeated injective.exchange.v2.PointsMultiplier derivative_market_multipliers */
        4:
          message.derivativeMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.boostedSpotMarketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.boostedSpotMarketIds[i]);
    for (let i = 0; i < message.spotMarketMultipliers.length; i++)
      PointsMultiplier.internalBinaryWrite(message.spotMarketMultipliers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.boostedDerivativeMarketIds.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.boostedDerivativeMarketIds[i]);
    for (let i = 0; i < message.derivativeMarketMultipliers.length; i++)
      PointsMultiplier.internalBinaryWrite(message.derivativeMarketMultipliers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignBoostInfo = new TradingRewardCampaignBoostInfo$Type();
class CampaignRewardPool$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.CampaignRewardPool", [
      {
        no: 1,
        name: "start_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "max_campaign_rewards", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.startTimestamp = 0n;
    message.maxCampaignRewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 start_timestamp */
        1:
          message.startTimestamp = reader.int64().toBigInt();
          break;
        case /* repeated cosmos.base.v1beta1.Coin max_campaign_rewards */
        2:
          message.maxCampaignRewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.startTimestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.startTimestamp);
    for (let i = 0; i < message.maxCampaignRewards.length; i++)
      Coin.internalBinaryWrite(message.maxCampaignRewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CampaignRewardPool = new CampaignRewardPool$Type();
class TradingRewardCampaignInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradingRewardCampaignInfo", [
      {
        no: 1,
        name: "campaign_duration_seconds",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "quote_denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "trading_reward_boost_info", kind: "message", T: () => TradingRewardCampaignBoostInfo },
      {
        no: 4,
        name: "disqualified_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.campaignDurationSeconds = 0n;
    message.quoteDenoms = [];
    message.disqualifiedMarketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 campaign_duration_seconds */
        1:
          message.campaignDurationSeconds = reader.int64().toBigInt();
          break;
        case /* repeated string quote_denoms */
        2:
          message.quoteDenoms.push(reader.string());
          break;
        case /* injective.exchange.v2.TradingRewardCampaignBoostInfo trading_reward_boost_info */
        3:
          message.tradingRewardBoostInfo = TradingRewardCampaignBoostInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardBoostInfo);
          break;
        case /* repeated string disqualified_market_ids */
        4:
          message.disqualifiedMarketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.campaignDurationSeconds !== 0n)
      writer.tag(1, WireType.Varint).int64(message.campaignDurationSeconds);
    for (let i = 0; i < message.quoteDenoms.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.quoteDenoms[i]);
    if (message.tradingRewardBoostInfo)
      TradingRewardCampaignBoostInfo.internalBinaryWrite(message.tradingRewardBoostInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignInfo = new TradingRewardCampaignInfo$Type();
class FeeDiscountTierInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FeeDiscountTierInfo", [
      { no: 1, name: "maker_discount_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "taker_discount_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "staked_amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      { no: 4, name: "volume", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.makerDiscountRate = "";
    message.takerDiscountRate = "";
    message.stakedAmount = "";
    message.volume = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string maker_discount_rate */
        1:
          message.makerDiscountRate = reader.string();
          break;
        case /* string taker_discount_rate */
        2:
          message.takerDiscountRate = reader.string();
          break;
        case /* string staked_amount */
        3:
          message.stakedAmount = reader.string();
          break;
        case /* string volume */
        4:
          message.volume = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.makerDiscountRate !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.makerDiscountRate);
    if (message.takerDiscountRate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.takerDiscountRate);
    if (message.stakedAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.stakedAmount);
    if (message.volume !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.volume);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountTierInfo = new FeeDiscountTierInfo$Type();
class FeeDiscountSchedule$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FeeDiscountSchedule", [
      {
        no: 1,
        name: "bucket_count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "bucket_duration",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "quote_denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "tier_infos", kind: "message", repeat: 2, T: () => FeeDiscountTierInfo },
      {
        no: 5,
        name: "disqualified_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketCount = 0n;
    message.bucketDuration = 0n;
    message.quoteDenoms = [];
    message.tierInfos = [];
    message.disqualifiedMarketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucket_count */
        1:
          message.bucketCount = reader.uint64().toBigInt();
          break;
        case /* int64 bucket_duration */
        2:
          message.bucketDuration = reader.int64().toBigInt();
          break;
        case /* repeated string quote_denoms */
        3:
          message.quoteDenoms.push(reader.string());
          break;
        case /* repeated injective.exchange.v2.FeeDiscountTierInfo tier_infos */
        4:
          message.tierInfos.push(FeeDiscountTierInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string disqualified_market_ids */
        5:
          message.disqualifiedMarketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bucketCount !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.bucketCount);
    if (message.bucketDuration !== 0n)
      writer.tag(2, WireType.Varint).int64(message.bucketDuration);
    for (let i = 0; i < message.quoteDenoms.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.quoteDenoms[i]);
    for (let i = 0; i < message.tierInfos.length; i++)
      FeeDiscountTierInfo.internalBinaryWrite(message.tierInfos[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountSchedule = new FeeDiscountSchedule$Type();
class FeeDiscountTierTTL$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FeeDiscountTierTTL", [
      {
        no: 1,
        name: "tier",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "ttl_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tier = 0n;
    message.ttlTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 tier */
        1:
          message.tier = reader.uint64().toBigInt();
          break;
        case /* int64 ttl_timestamp */
        2:
          message.ttlTimestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tier !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.tier);
    if (message.ttlTimestamp !== 0n)
      writer.tag(2, WireType.Varint).int64(message.ttlTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountTierTTL = new FeeDiscountTierTTL$Type();
class AccountRewards$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.AccountRewards", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "rewards", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.rewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* repeated cosmos.base.v1beta1.Coin rewards */
        2:
          message.rewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    for (let i = 0; i < message.rewards.length; i++)
      Coin.internalBinaryWrite(message.rewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountRewards = new AccountRewards$Type();
class TradeRecords$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradeRecords", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "latest_trade_records", kind: "message", repeat: 2, T: () => TradeRecord }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.latestTradeRecords = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v2.TradeRecord latest_trade_records */
        2:
          message.latestTradeRecords.push(TradeRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.latestTradeRecords.length; i++)
      TradeRecord.internalBinaryWrite(message.latestTradeRecords[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeRecords = new TradeRecords$Type();
class SubaccountIDs$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountIDs", [
      {
        no: 1,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes subaccount_ids */
        1:
          message.subaccountIds.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountIDs = new SubaccountIDs$Type();
class TradeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradeRecord", [
      {
        no: 1,
        name: "timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    message.price = "";
    message.quantity = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 timestamp */
        1:
          message.timestamp = reader.int64().toBigInt();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        case /* string quantity */
        3:
          message.quantity = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.timestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.timestamp);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quantity);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeRecord = new TradeRecord$Type();
class Level$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.Level", [
      { no: 1, name: "p", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "q", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.p = "";
    message.q = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string p */
        1:
          message.p = reader.string();
          break;
        case /* string q */
        2:
          message.q = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.p !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.p);
    if (message.q !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.q);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Level = new Level$Type();
class AggregateSubaccountVolumeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.AggregateSubaccountVolumeRecord", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "market_volumes", kind: "message", repeat: 2, T: () => MarketVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketVolumes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* repeated injective.exchange.v2.MarketVolume market_volumes */
        2:
          message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.marketVolumes.length; i++)
      MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AggregateSubaccountVolumeRecord = new AggregateSubaccountVolumeRecord$Type();
class AggregateAccountVolumeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.AggregateAccountVolumeRecord", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "market_volumes", kind: "message", repeat: 2, T: () => MarketVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.marketVolumes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* repeated injective.exchange.v2.MarketVolume market_volumes */
        2:
          message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    for (let i = 0; i < message.marketVolumes.length; i++)
      MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AggregateAccountVolumeRecord = new AggregateAccountVolumeRecord$Type();
class DenomDecimals$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DenomDecimals", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "decimals",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.decimals = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* uint64 decimals */
        2:
          message.decimals = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.decimals !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.decimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomDecimals = new DenomDecimals$Type();
class GrantAuthorization$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.GrantAuthorization", [
      {
        no: 1,
        name: "grantee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.grantee = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string grantee */
        1:
          message.grantee = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.grantee !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.grantee);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GrantAuthorization = new GrantAuthorization$Type();
class ActiveGrant$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.ActiveGrant", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ActiveGrant = new ActiveGrant$Type();
class EffectiveGrant$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EffectiveGrant", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "net_granted_stake", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 3,
        name: "is_valid",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    message.netGrantedStake = "";
    message.isValid = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        case /* string net_granted_stake */
        2:
          message.netGrantedStake = reader.string();
          break;
        case /* bool is_valid */
        3:
          message.isValid = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    if (message.netGrantedStake !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.netGrantedStake);
    if (message.isValid !== false)
      writer.tag(3, WireType.Varint).bool(message.isValid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EffectiveGrant = new EffectiveGrant$Type();
class DenomMinNotional$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DenomMinNotional", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string min_notional */
        2:
          message.minNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.minNotional !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.minNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomMinNotional = new DenomMinNotional$Type();
export {
  AccountRewards,
  ActiveGrant,
  AggregateAccountVolumeRecord,
  AggregateSubaccountVolumeRecord,
  Balance,
  CampaignRewardPool,
  DenomDecimals,
  DenomMinNotional,
  Deposit,
  DepositUpdate,
  DerivativePosition,
  DerivativeTradeLog,
  EffectiveGrant,
  ExecutionType,
  FeeDiscountSchedule,
  FeeDiscountTierInfo,
  FeeDiscountTierTTL,
  GrantAuthorization,
  Level,
  MarketOrderIndicator,
  MidPriceAndTOB,
  NextFundingTimestamp,
  Params,
  PointsMultiplier,
  Position,
  PositionDelta,
  SubaccountDeposit,
  SubaccountIDs,
  SubaccountOrder,
  SubaccountOrderData,
  SubaccountPosition,
  SubaccountTradeNonce,
  TradeLog,
  TradeRecord,
  TradeRecords,
  TradingRewardCampaignBoostInfo,
  TradingRewardCampaignInfo
};
