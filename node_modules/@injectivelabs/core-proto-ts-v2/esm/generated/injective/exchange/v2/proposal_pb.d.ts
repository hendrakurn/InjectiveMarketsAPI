// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v2/proposal.proto" (package "injective.exchange.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DenomMinNotional } from "./exchange_pb";
import { MarketFeeMultiplier } from "./market_pb";
import { CommunityPoolSpendProposal } from "../../../cosmos/distribution/v1beta1/distribution_pb";
import { FeeDiscountSchedule } from "./exchange_pb";
import { CampaignRewardPool } from "./exchange_pb";
import { TradingRewardCampaignInfo } from "./exchange_pb";
import { DenomDecimals } from "./exchange_pb";
import { OpenNotionalCap } from "./market_pb";
import { OracleType } from "../../oracle/v1beta1/oracle_pb";
import { MarketStatus } from "./market_pb";
/**
 * @generated from protobuf message injective.exchange.v2.SpotMarketParamUpdateProposal
 */
export interface SpotMarketParamUpdateProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * maker_fee_rate defines the trade fee rate for makers on the spot market
     *
     * @generated from protobuf field: string maker_fee_rate = 4
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the trade fee rate for takers on the spot market
     *
     * @generated from protobuf field: string taker_fee_rate = 5
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the relayer fee share rate for the spot
     * market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 6
     */
    relayerFeeShareRate: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 7
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 8
     */
    minQuantityTickSize: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.MarketStatus status = 9
     */
    status: MarketStatus;
    /**
     * @generated from protobuf field: string ticker = 10
     */
    ticker: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 11
     */
    minNotional: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.AdminInfo admin_info = 12
     */
    adminInfo?: AdminInfo;
    /**
     * base token decimals
     *
     * @generated from protobuf field: uint32 base_decimals = 13
     */
    baseDecimals: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 14
     */
    quoteDecimals: number;
}
/**
 * @generated from protobuf message injective.exchange.v2.ExchangeEnableProposal
 */
export interface ExchangeEnableProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.ExchangeType exchangeType = 3
     */
    exchangeType: ExchangeType;
}
/**
 * @generated from protobuf message injective.exchange.v2.BatchExchangeModificationProposal
 */
export interface BatchExchangeModificationProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SpotMarketParamUpdateProposal spot_market_param_update_proposals = 3
     */
    spotMarketParamUpdateProposals: SpotMarketParamUpdateProposal[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals = 4
     */
    derivativeMarketParamUpdateProposals: DerivativeMarketParamUpdateProposal[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SpotMarketLaunchProposal spot_market_launch_proposals = 5
     */
    spotMarketLaunchProposals: SpotMarketLaunchProposal[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.PerpetualMarketLaunchProposal perpetual_market_launch_proposals = 6
     */
    perpetualMarketLaunchProposals: PerpetualMarketLaunchProposal[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals = 7
     */
    expiryFuturesMarketLaunchProposals: ExpiryFuturesMarketLaunchProposal[];
    /**
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal = 8
     */
    tradingRewardCampaignUpdateProposal?: TradingRewardCampaignUpdateProposal;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals = 9
     */
    binaryOptionsMarketLaunchProposals: BinaryOptionsMarketLaunchProposal[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals = 10
     */
    binaryOptionsParamUpdateProposals: BinaryOptionsMarketParamUpdateProposal[];
    /**
     * @generated from protobuf field: injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal auction_exchange_transfer_denom_decimals_update_proposal = 11
     */
    auctionExchangeTransferDenomDecimalsUpdateProposal?: UpdateAuctionExchangeTransferDenomDecimalsProposal;
    /**
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountProposal fee_discount_proposal = 12
     */
    feeDiscountProposal?: FeeDiscountProposal;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.MarketForcedSettlementProposal market_forced_settlement_proposals = 13
     */
    marketForcedSettlementProposals: MarketForcedSettlementProposal[];
    /**
     * @generated from protobuf field: injective.exchange.v2.DenomMinNotionalProposal denom_min_notional_proposal = 14
     */
    denomMinNotionalProposal?: DenomMinNotionalProposal;
}
/**
 * SpotMarketLaunchProposal defines a SDK message for proposing a new spot
 * market through governance
 *
 * @generated from protobuf message injective.exchange.v2.SpotMarketLaunchProposal
 */
export interface SpotMarketLaunchProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Ticker for the spot market.
     *
     * @generated from protobuf field: string ticker = 3
     */
    ticker: string;
    /**
     * type of coin to use as the base currency
     *
     * @generated from protobuf field: string base_denom = 4
     */
    baseDenom: string;
    /**
     * type of coin to use as the quote currency
     *
     * @generated from protobuf field: string quote_denom = 5
     */
    quoteDenom: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price
     *
     * @generated from protobuf field: string min_price_tick_size = 6
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 7
     */
    minQuantityTickSize: string;
    /**
     * maker_fee_rate defines the fee percentage makers pay when trading
     *
     * @generated from protobuf field: string maker_fee_rate = 8
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the fee percentage takers pay when trading
     *
     * @generated from protobuf field: string taker_fee_rate = 9
     */
    takerFeeRate: string;
    /**
     * min_notional defines the minimum notional for orders in the market
     *
     * @generated from protobuf field: string min_notional = 10
     */
    minNotional: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.AdminInfo admin_info = 11
     */
    adminInfo?: AdminInfo;
    /**
     * base token decimals
     *
     * @generated from protobuf field: uint32 base_decimals = 14
     */
    baseDecimals: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 15
     */
    quoteDecimals: number;
}
/**
 * PerpetualMarketLaunchProposal defines a SDK message for proposing a new
 * perpetual futures market through governance
 *
 * @generated from protobuf message injective.exchange.v2.PerpetualMarketLaunchProposal
 */
export interface PerpetualMarketLaunchProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Ticker for the derivative market.
     *
     * @generated from protobuf field: string ticker = 3
     */
    ticker: string;
    /**
     * type of coin to use as the base currency
     *
     * @generated from protobuf field: string quote_denom = 4
     */
    quoteDenom: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 5
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 6
     */
    oracleQuote: string;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 7
     */
    oracleScaleFactor: number;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 8
     */
    oracleType: OracleType;
    /**
     * initial_margin_ratio defines the initial margin ratio for the derivative
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 9
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio for the
     * derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 10
     */
    maintenanceMarginRatio: string;
    /**
     * maker_fee_rate defines the exchange trade fee for makers for the derivative
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 11
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the exchange trade fee for takers for the derivative
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 12
     */
    takerFeeRate: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 13
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 14
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 15
     */
    minNotional: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.AdminInfo admin_info = 16
     */
    adminInfo?: AdminInfo;
    /**
     * reduce_margin_ratio defines the ratio of the margin that is reduced
     *
     * @generated from protobuf field: string reduce_margin_ratio = 17
     */
    reduceMarginRatio: string;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 18
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective.exchange.v2.BinaryOptionsMarketLaunchProposal
 */
export interface BinaryOptionsMarketLaunchProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Ticker for the derivative contract.
     *
     * @generated from protobuf field: string ticker = 3
     */
    ticker: string;
    /**
     * Oracle symbol
     *
     * @generated from protobuf field: string oracle_symbol = 4
     */
    oracleSymbol: string;
    /**
     * Oracle Provider
     *
     * @generated from protobuf field: string oracle_provider = 5
     */
    oracleProvider: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 6
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 7
     */
    oracleScaleFactor: number;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 8
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 9
     */
    settlementTimestamp: bigint;
    /**
     * admin of the market
     *
     * @generated from protobuf field: string admin = 10
     */
    admin: string;
    /**
     * Address of the quote currency denomination for the binary options contract
     *
     * @generated from protobuf field: string quote_denom = 11
     */
    quoteDenom: string;
    /**
     * maker_fee_rate defines the maker fee rate of a binary options market
     *
     * @generated from protobuf field: string maker_fee_rate = 12
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the taker fee rate of a derivative market
     *
     * @generated from protobuf field: string taker_fee_rate = 13
     */
    takerFeeRate: string;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market
     *
     * @generated from protobuf field: string min_price_tick_size = 14
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market
     *
     * @generated from protobuf field: string min_quantity_tick_size = 15
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 16
     */
    minNotional: string;
    /**
     * @generated from protobuf field: uint32 admin_permissions = 17
     */
    adminPermissions: number;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 18
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new
 * expiry futures market through governance
 *
 * @generated from protobuf message injective.exchange.v2.ExpiryFuturesMarketLaunchProposal
 */
export interface ExpiryFuturesMarketLaunchProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Ticker for the derivative market.
     *
     * @generated from protobuf field: string ticker = 3
     */
    ticker: string;
    /**
     * type of coin to use as the quote currency
     *
     * @generated from protobuf field: string quote_denom = 4
     */
    quoteDenom: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 5
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 6
     */
    oracleQuote: string;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 7
     */
    oracleScaleFactor: number;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 8
     */
    oracleType: OracleType;
    /**
     * Expiration time of the market
     *
     * @generated from protobuf field: int64 expiry = 9
     */
    expiry: bigint;
    /**
     * initial_margin_ratio defines the initial margin ratio for the derivative
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 10
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio for the
     * derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 11
     */
    maintenanceMarginRatio: string;
    /**
     * maker_fee_rate defines the exchange trade fee for makers for the derivative
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 12
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the exchange trade fee for takers for the derivative
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 13
     */
    takerFeeRate: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 14
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 15
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 16
     */
    minNotional: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.AdminInfo admin_info = 17
     */
    adminInfo?: AdminInfo;
    /**
     * reduce_margin_ratio defines the ratio of the margin that is reduced
     *
     * @generated from protobuf field: string reduce_margin_ratio = 18
     */
    reduceMarginRatio: string;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 19
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective.exchange.v2.DerivativeMarketParamUpdateProposal
 */
export interface DerivativeMarketParamUpdateProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * initial_margin_ratio defines the initial margin ratio for the derivative
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 4
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio for the
     * derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 5
     */
    maintenanceMarginRatio: string;
    /**
     * maker_fee_rate defines the exchange trade fee for makers for the derivative
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 6
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the exchange trade fee for takers for the derivative
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 7
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the relayer fee share rate for the
     * derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 8
     */
    relayerFeeShareRate: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 9
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 10
     */
    minQuantityTickSize: string;
    /**
     * hourly_interest_rate defines the hourly interest rate
     *
     * @generated from protobuf field: string HourlyInterestRate = 11
     */
    hourlyInterestRate: string;
    /**
     * hourly_funding_rate_cap defines the maximum absolute value of the hourly
     * funding rate
     *
     * @generated from protobuf field: string HourlyFundingRateCap = 12
     */
    hourlyFundingRateCap: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.MarketStatus status = 13
     */
    status: MarketStatus;
    /**
     * @generated from protobuf field: injective.exchange.v2.OracleParams oracle_params = 14
     */
    oracleParams?: OracleParams;
    /**
     * @generated from protobuf field: string ticker = 15
     */
    ticker: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 16
     */
    minNotional: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.AdminInfo admin_info = 17
     */
    adminInfo?: AdminInfo;
    /**
     * reduce_margin_ratio defines the ratio of the margin that is reduced
     *
     * @generated from protobuf field: string reduce_margin_ratio = 18
     */
    reduceMarginRatio: string;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 19
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective.exchange.v2.AdminInfo
 */
export interface AdminInfo {
    /**
     * @generated from protobuf field: string admin = 1
     */
    admin: string;
    /**
     * @generated from protobuf field: uint32 admin_permissions = 2
     */
    adminPermissions: number;
}
/**
 * @generated from protobuf message injective.exchange.v2.MarketForcedSettlementProposal
 */
export interface MarketForcedSettlementProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * @generated from protobuf field: string settlement_price = 4
     */
    settlementPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal
 */
export interface UpdateAuctionExchangeTransferDenomDecimalsProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DenomDecimals denom_decimals = 3
     */
    denomDecimals: DenomDecimals[];
}
/**
 * @generated from protobuf message injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal
 */
export interface BinaryOptionsMarketParamUpdateProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * maker_fee_rate defines the exchange trade fee for makers for the derivative
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 4
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the exchange trade fee for takers for the derivative
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 5
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the relayer fee share rate for the
     * derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 6
     */
    relayerFeeShareRate: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 7
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 8
     */
    minQuantityTickSize: string;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 9
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 10
     */
    settlementTimestamp: bigint;
    /**
     * new price at which market will be settled
     *
     * @generated from protobuf field: string settlement_price = 11
     */
    settlementPrice: string;
    /**
     * admin of the market
     *
     * @generated from protobuf field: string admin = 12
     */
    admin: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.MarketStatus status = 13
     */
    status: MarketStatus;
    /**
     * @generated from protobuf field: injective.exchange.v2.ProviderOracleParams oracle_params = 14
     */
    oracleParams?: ProviderOracleParams;
    /**
     * @generated from protobuf field: string ticker = 15
     */
    ticker: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 16
     */
    minNotional: string;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 17
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective.exchange.v2.ProviderOracleParams
 */
export interface ProviderOracleParams {
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string provider = 2
     */
    provider: string;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 3
     */
    oracleScaleFactor: number;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
     */
    oracleType: OracleType;
}
/**
 * @generated from protobuf message injective.exchange.v2.OracleParams
 */
export interface OracleParams {
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 1
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 2
     */
    oracleQuote: string;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 3
     */
    oracleScaleFactor: number;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
     */
    oracleType: OracleType;
}
/**
 * @generated from protobuf message injective.exchange.v2.TradingRewardCampaignLaunchProposal
 */
export interface TradingRewardCampaignLaunchProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignInfo campaign_info = 3
     */
    campaignInfo?: TradingRewardCampaignInfo;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools = 4
     */
    campaignRewardPools: CampaignRewardPool[];
}
/**
 * @generated from protobuf message injective.exchange.v2.TradingRewardCampaignUpdateProposal
 */
export interface TradingRewardCampaignUpdateProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignInfo campaign_info = 3
     */
    campaignInfo?: TradingRewardCampaignInfo;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_additions = 4
     */
    campaignRewardPoolsAdditions: CampaignRewardPool[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_updates = 5
     */
    campaignRewardPoolsUpdates: CampaignRewardPool[];
}
/**
 * @generated from protobuf message injective.exchange.v2.RewardPointUpdate
 */
export interface RewardPointUpdate {
    /**
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * new_points overwrites the current trading reward points for the account
     *
     * @generated from protobuf field: string new_points = 12
     */
    newPoints: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.TradingRewardPendingPointsUpdateProposal
 */
export interface TradingRewardPendingPointsUpdateProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: int64 pending_pool_timestamp = 3
     */
    pendingPoolTimestamp: bigint;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.RewardPointUpdate reward_point_updates = 4
     */
    rewardPointUpdates: RewardPointUpdate[];
}
/**
 * @generated from protobuf message injective.exchange.v2.FeeDiscountProposal
 */
export interface FeeDiscountProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountSchedule schedule = 3
     */
    schedule?: FeeDiscountSchedule;
}
/**
 * @generated from protobuf message injective.exchange.v2.BatchCommunityPoolSpendProposal
 */
export interface BatchCommunityPoolSpendProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: repeated cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals = 3
     */
    proposals: CommunityPoolSpendProposal[];
}
/**
 * AtomicMarketOrderFeeMultiplierScheduleProposal defines a SDK message for
 * proposing new atomic take fee multipliers for specified markets
 *
 * @generated from protobuf message injective.exchange.v2.AtomicMarketOrderFeeMultiplierScheduleProposal
 */
export interface AtomicMarketOrderFeeMultiplierScheduleProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers = 3
     */
    marketFeeMultipliers: MarketFeeMultiplier[];
}
/**
 * @generated from protobuf message injective.exchange.v2.DenomMinNotionalProposal
 */
export interface DenomMinNotionalProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DenomMinNotional denom_min_notionals = 3
     */
    denomMinNotionals: DenomMinNotional[];
}
/**
 * @generated from protobuf enum injective.exchange.v2.ExchangeType
 */
export enum ExchangeType {
    /**
     * @generated from protobuf enum value: EXCHANGE_UNSPECIFIED = 0;
     */
    EXCHANGE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SPOT = 1;
     */
    SPOT = 1,
    /**
     * @generated from protobuf enum value: DERIVATIVES = 2;
     */
    DERIVATIVES = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketParamUpdateProposal$Type extends MessageType<SpotMarketParamUpdateProposal> {
    constructor() {
        super("injective.exchange.v2.SpotMarketParamUpdateProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
            { no: 10, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true } },
            { no: 11, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "admin_info", kind: "message", T: () => AdminInfo },
            { no: 13, name: "base_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/SpotMarketParamUpdateProposal" });
    }
    create(value?: PartialMessage<SpotMarketParamUpdateProposal>): SpotMarketParamUpdateProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.marketId = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.status = 0;
        message.ticker = "";
        message.minNotional = "";
        message.baseDecimals = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<SpotMarketParamUpdateProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketParamUpdateProposal): SpotMarketParamUpdateProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string maker_fee_rate */ 4:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 5:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 6:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* string min_price_tick_size */ 7:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 8:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* injective.exchange.v2.MarketStatus status */ 9:
                    message.status = reader.int32();
                    break;
                case /* string ticker */ 10:
                    message.ticker = reader.string();
                    break;
                case /* string min_notional */ 11:
                    message.minNotional = reader.string();
                    break;
                case /* injective.exchange.v2.AdminInfo admin_info */ 12:
                    message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
                    break;
                case /* uint32 base_decimals */ 13:
                    message.baseDecimals = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 14:
                    message.quoteDecimals = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketParamUpdateProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string maker_fee_rate = 4; */
        if (message.makerFeeRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 5; */
        if (message.takerFeeRate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 6; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* string min_price_tick_size = 7; */
        if (message.minPriceTickSize !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 8; */
        if (message.minQuantityTickSize !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* injective.exchange.v2.MarketStatus status = 9; */
        if (message.status !== 0)
            writer.tag(9, WireType.Varint).int32(message.status);
        /* string ticker = 10; */
        if (message.ticker !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.ticker);
        /* string min_notional = 11; */
        if (message.minNotional !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.minNotional);
        /* injective.exchange.v2.AdminInfo admin_info = 12; */
        if (message.adminInfo)
            AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint32 base_decimals = 13; */
        if (message.baseDecimals !== 0)
            writer.tag(13, WireType.Varint).uint32(message.baseDecimals);
        /* uint32 quote_decimals = 14; */
        if (message.quoteDecimals !== 0)
            writer.tag(14, WireType.Varint).uint32(message.quoteDecimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SpotMarketParamUpdateProposal
 */
export const SpotMarketParamUpdateProposal = new SpotMarketParamUpdateProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExchangeEnableProposal$Type extends MessageType<ExchangeEnableProposal> {
    constructor() {
        super("injective.exchange.v2.ExchangeEnableProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "exchangeType", kind: "enum", T: () => ["injective.exchange.v2.ExchangeType", ExchangeType] }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/ExchangeEnableProposal" });
    }
    create(value?: PartialMessage<ExchangeEnableProposal>): ExchangeEnableProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.exchangeType = 0;
        if (value !== undefined)
            reflectionMergePartial<ExchangeEnableProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExchangeEnableProposal): ExchangeEnableProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* injective.exchange.v2.ExchangeType exchangeType */ 3:
                    message.exchangeType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExchangeEnableProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* injective.exchange.v2.ExchangeType exchangeType = 3; */
        if (message.exchangeType !== 0)
            writer.tag(3, WireType.Varint).int32(message.exchangeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.ExchangeEnableProposal
 */
export const ExchangeEnableProposal = new ExchangeEnableProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchExchangeModificationProposal$Type extends MessageType<BatchExchangeModificationProposal> {
    constructor() {
        super("injective.exchange.v2.BatchExchangeModificationProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spot_market_param_update_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotMarketParamUpdateProposal },
            { no: 4, name: "derivative_market_param_update_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeMarketParamUpdateProposal },
            { no: 5, name: "spot_market_launch_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotMarketLaunchProposal },
            { no: 6, name: "perpetual_market_launch_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PerpetualMarketLaunchProposal },
            { no: 7, name: "expiry_futures_market_launch_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExpiryFuturesMarketLaunchProposal },
            { no: 8, name: "trading_reward_campaign_update_proposal", kind: "message", T: () => TradingRewardCampaignUpdateProposal },
            { no: 9, name: "binary_options_market_launch_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BinaryOptionsMarketLaunchProposal },
            { no: 10, name: "binary_options_param_update_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BinaryOptionsMarketParamUpdateProposal },
            { no: 11, name: "auction_exchange_transfer_denom_decimals_update_proposal", kind: "message", T: () => UpdateAuctionExchangeTransferDenomDecimalsProposal },
            { no: 12, name: "fee_discount_proposal", kind: "message", T: () => FeeDiscountProposal },
            { no: 13, name: "market_forced_settlement_proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketForcedSettlementProposal },
            { no: 14, name: "denom_min_notional_proposal", kind: "message", T: () => DenomMinNotionalProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BatchExchangeModificationProposal" });
    }
    create(value?: PartialMessage<BatchExchangeModificationProposal>): BatchExchangeModificationProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.spotMarketParamUpdateProposals = [];
        message.derivativeMarketParamUpdateProposals = [];
        message.spotMarketLaunchProposals = [];
        message.perpetualMarketLaunchProposals = [];
        message.expiryFuturesMarketLaunchProposals = [];
        message.binaryOptionsMarketLaunchProposals = [];
        message.binaryOptionsParamUpdateProposals = [];
        message.marketForcedSettlementProposals = [];
        if (value !== undefined)
            reflectionMergePartial<BatchExchangeModificationProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchExchangeModificationProposal): BatchExchangeModificationProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated injective.exchange.v2.SpotMarketParamUpdateProposal spot_market_param_update_proposals */ 3:
                    message.spotMarketParamUpdateProposals.push(SpotMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals */ 4:
                    message.derivativeMarketParamUpdateProposals.push(DerivativeMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.SpotMarketLaunchProposal spot_market_launch_proposals */ 5:
                    message.spotMarketLaunchProposals.push(SpotMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.PerpetualMarketLaunchProposal perpetual_market_launch_proposals */ 6:
                    message.perpetualMarketLaunchProposals.push(PerpetualMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals */ 7:
                    message.expiryFuturesMarketLaunchProposals.push(ExpiryFuturesMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective.exchange.v2.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal */ 8:
                    message.tradingRewardCampaignUpdateProposal = TradingRewardCampaignUpdateProposal.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardCampaignUpdateProposal);
                    break;
                case /* repeated injective.exchange.v2.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals */ 9:
                    message.binaryOptionsMarketLaunchProposals.push(BinaryOptionsMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals */ 10:
                    message.binaryOptionsParamUpdateProposals.push(BinaryOptionsMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal auction_exchange_transfer_denom_decimals_update_proposal */ 11:
                    message.auctionExchangeTransferDenomDecimalsUpdateProposal = UpdateAuctionExchangeTransferDenomDecimalsProposal.internalBinaryRead(reader, reader.uint32(), options, message.auctionExchangeTransferDenomDecimalsUpdateProposal);
                    break;
                case /* injective.exchange.v2.FeeDiscountProposal fee_discount_proposal */ 12:
                    message.feeDiscountProposal = FeeDiscountProposal.internalBinaryRead(reader, reader.uint32(), options, message.feeDiscountProposal);
                    break;
                case /* repeated injective.exchange.v2.MarketForcedSettlementProposal market_forced_settlement_proposals */ 13:
                    message.marketForcedSettlementProposals.push(MarketForcedSettlementProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective.exchange.v2.DenomMinNotionalProposal denom_min_notional_proposal */ 14:
                    message.denomMinNotionalProposal = DenomMinNotionalProposal.internalBinaryRead(reader, reader.uint32(), options, message.denomMinNotionalProposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchExchangeModificationProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated injective.exchange.v2.SpotMarketParamUpdateProposal spot_market_param_update_proposals = 3; */
        for (let i = 0; i < message.spotMarketParamUpdateProposals.length; i++)
            SpotMarketParamUpdateProposal.internalBinaryWrite(message.spotMarketParamUpdateProposals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals = 4; */
        for (let i = 0; i < message.derivativeMarketParamUpdateProposals.length; i++)
            DerivativeMarketParamUpdateProposal.internalBinaryWrite(message.derivativeMarketParamUpdateProposals[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.SpotMarketLaunchProposal spot_market_launch_proposals = 5; */
        for (let i = 0; i < message.spotMarketLaunchProposals.length; i++)
            SpotMarketLaunchProposal.internalBinaryWrite(message.spotMarketLaunchProposals[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.PerpetualMarketLaunchProposal perpetual_market_launch_proposals = 6; */
        for (let i = 0; i < message.perpetualMarketLaunchProposals.length; i++)
            PerpetualMarketLaunchProposal.internalBinaryWrite(message.perpetualMarketLaunchProposals[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals = 7; */
        for (let i = 0; i < message.expiryFuturesMarketLaunchProposals.length; i++)
            ExpiryFuturesMarketLaunchProposal.internalBinaryWrite(message.expiryFuturesMarketLaunchProposals[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal = 8; */
        if (message.tradingRewardCampaignUpdateProposal)
            TradingRewardCampaignUpdateProposal.internalBinaryWrite(message.tradingRewardCampaignUpdateProposal, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals = 9; */
        for (let i = 0; i < message.binaryOptionsMarketLaunchProposals.length; i++)
            BinaryOptionsMarketLaunchProposal.internalBinaryWrite(message.binaryOptionsMarketLaunchProposals[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals = 10; */
        for (let i = 0; i < message.binaryOptionsParamUpdateProposals.length; i++)
            BinaryOptionsMarketParamUpdateProposal.internalBinaryWrite(message.binaryOptionsParamUpdateProposals[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal auction_exchange_transfer_denom_decimals_update_proposal = 11; */
        if (message.auctionExchangeTransferDenomDecimalsUpdateProposal)
            UpdateAuctionExchangeTransferDenomDecimalsProposal.internalBinaryWrite(message.auctionExchangeTransferDenomDecimalsUpdateProposal, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.FeeDiscountProposal fee_discount_proposal = 12; */
        if (message.feeDiscountProposal)
            FeeDiscountProposal.internalBinaryWrite(message.feeDiscountProposal, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.MarketForcedSettlementProposal market_forced_settlement_proposals = 13; */
        for (let i = 0; i < message.marketForcedSettlementProposals.length; i++)
            MarketForcedSettlementProposal.internalBinaryWrite(message.marketForcedSettlementProposals[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.DenomMinNotionalProposal denom_min_notional_proposal = 14; */
        if (message.denomMinNotionalProposal)
            DenomMinNotionalProposal.internalBinaryWrite(message.denomMinNotionalProposal, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.BatchExchangeModificationProposal
 */
export const BatchExchangeModificationProposal = new BatchExchangeModificationProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketLaunchProposal$Type extends MessageType<SpotMarketLaunchProposal> {
    constructor() {
        super("injective.exchange.v2.SpotMarketLaunchProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "admin_info", kind: "message", T: () => AdminInfo },
            { no: 14, name: "base_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/SpotMarketLaunchProposal" });
    }
    create(value?: PartialMessage<SpotMarketLaunchProposal>): SpotMarketLaunchProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.ticker = "";
        message.baseDenom = "";
        message.quoteDenom = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.minNotional = "";
        message.baseDecimals = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<SpotMarketLaunchProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketLaunchProposal): SpotMarketLaunchProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string base_denom */ 4:
                    message.baseDenom = reader.string();
                    break;
                case /* string quote_denom */ 5:
                    message.quoteDenom = reader.string();
                    break;
                case /* string min_price_tick_size */ 6:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 7:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string maker_fee_rate */ 8:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 9:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string min_notional */ 10:
                    message.minNotional = reader.string();
                    break;
                case /* injective.exchange.v2.AdminInfo admin_info */ 11:
                    message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
                    break;
                case /* uint32 base_decimals */ 14:
                    message.baseDecimals = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 15:
                    message.quoteDecimals = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketLaunchProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string base_denom = 4; */
        if (message.baseDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.baseDenom);
        /* string quote_denom = 5; */
        if (message.quoteDenom !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.quoteDenom);
        /* string min_price_tick_size = 6; */
        if (message.minPriceTickSize !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 7; */
        if (message.minQuantityTickSize !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string maker_fee_rate = 8; */
        if (message.makerFeeRate !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 9; */
        if (message.takerFeeRate !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string min_notional = 10; */
        if (message.minNotional !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.minNotional);
        /* injective.exchange.v2.AdminInfo admin_info = 11; */
        if (message.adminInfo)
            AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint32 base_decimals = 14; */
        if (message.baseDecimals !== 0)
            writer.tag(14, WireType.Varint).uint32(message.baseDecimals);
        /* uint32 quote_decimals = 15; */
        if (message.quoteDecimals !== 0)
            writer.tag(15, WireType.Varint).uint32(message.quoteDecimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SpotMarketLaunchProposal
 */
export const SpotMarketLaunchProposal = new SpotMarketLaunchProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketLaunchProposal$Type extends MessageType<PerpetualMarketLaunchProposal> {
    constructor() {
        super("injective.exchange.v2.PerpetualMarketLaunchProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 9, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "admin_info", kind: "message", T: () => AdminInfo },
            { no: 17, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 18, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/PerpetualMarketLaunchProposal" });
    }
    create(value?: PartialMessage<PerpetualMarketLaunchProposal>): PerpetualMarketLaunchProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.ticker = "";
        message.quoteDenom = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleScaleFactor = 0;
        message.oracleType = 0;
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketLaunchProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketLaunchProposal): PerpetualMarketLaunchProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string quote_denom */ 4:
                    message.quoteDenom = reader.string();
                    break;
                case /* string oracle_base */ 5:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 6:
                    message.oracleQuote = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 7:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 8:
                    message.oracleType = reader.int32();
                    break;
                case /* string initial_margin_ratio */ 9:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 10:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string maker_fee_rate */ 11:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 12:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string min_price_tick_size */ 13:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 14:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 15:
                    message.minNotional = reader.string();
                    break;
                case /* injective.exchange.v2.AdminInfo admin_info */ 16:
                    message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
                    break;
                case /* string reduce_margin_ratio */ 17:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 18:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketLaunchProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string quote_denom = 4; */
        if (message.quoteDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
        /* string oracle_base = 5; */
        if (message.oracleBase !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 6; */
        if (message.oracleQuote !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.oracleQuote);
        /* uint32 oracle_scale_factor = 7; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
        /* injective.oracle.v1beta1.OracleType oracle_type = 8; */
        if (message.oracleType !== 0)
            writer.tag(8, WireType.Varint).int32(message.oracleType);
        /* string initial_margin_ratio = 9; */
        if (message.initialMarginRatio !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 10; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string maker_fee_rate = 11; */
        if (message.makerFeeRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 12; */
        if (message.takerFeeRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string min_price_tick_size = 13; */
        if (message.minPriceTickSize !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 14; */
        if (message.minQuantityTickSize !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 15; */
        if (message.minNotional !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
        /* injective.exchange.v2.AdminInfo admin_info = 16; */
        if (message.adminInfo)
            AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string reduce_margin_ratio = 17; */
        if (message.reduceMarginRatio !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 18; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PerpetualMarketLaunchProposal
 */
export const PerpetualMarketLaunchProposal = new PerpetualMarketLaunchProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarketLaunchProposal$Type extends MessageType<BinaryOptionsMarketLaunchProposal> {
    constructor() {
        super("injective.exchange.v2.BinaryOptionsMarketLaunchProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BinaryOptionsMarketLaunchProposal" });
    }
    create(value?: PartialMessage<BinaryOptionsMarketLaunchProposal>): BinaryOptionsMarketLaunchProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.ticker = "";
        message.oracleSymbol = "";
        message.oracleProvider = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.admin = "";
        message.quoteDenom = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.adminPermissions = 0;
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarketLaunchProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarketLaunchProposal): BinaryOptionsMarketLaunchProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_symbol */ 4:
                    message.oracleSymbol = reader.string();
                    break;
                case /* string oracle_provider */ 5:
                    message.oracleProvider = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 6:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 7:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* int64 expiration_timestamp */ 8:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 9:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* string admin */ 10:
                    message.admin = reader.string();
                    break;
                case /* string quote_denom */ 11:
                    message.quoteDenom = reader.string();
                    break;
                case /* string maker_fee_rate */ 12:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 13:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string min_price_tick_size */ 14:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 15:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 16:
                    message.minNotional = reader.string();
                    break;
                case /* uint32 admin_permissions */ 17:
                    message.adminPermissions = reader.uint32();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 18:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarketLaunchProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_symbol = 4; */
        if (message.oracleSymbol !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleSymbol);
        /* string oracle_provider = 5; */
        if (message.oracleProvider !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleProvider);
        /* injective.oracle.v1beta1.OracleType oracle_type = 6; */
        if (message.oracleType !== 0)
            writer.tag(6, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 7; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
        /* int64 expiration_timestamp = 8; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(8, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 9; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(9, WireType.Varint).int64(message.settlementTimestamp);
        /* string admin = 10; */
        if (message.admin !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.admin);
        /* string quote_denom = 11; */
        if (message.quoteDenom !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.quoteDenom);
        /* string maker_fee_rate = 12; */
        if (message.makerFeeRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 13; */
        if (message.takerFeeRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string min_price_tick_size = 14; */
        if (message.minPriceTickSize !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 15; */
        if (message.minQuantityTickSize !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 16; */
        if (message.minNotional !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
        /* uint32 admin_permissions = 17; */
        if (message.adminPermissions !== 0)
            writer.tag(17, WireType.Varint).uint32(message.adminPermissions);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 18; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.BinaryOptionsMarketLaunchProposal
 */
export const BinaryOptionsMarketLaunchProposal = new BinaryOptionsMarketLaunchProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpiryFuturesMarketLaunchProposal$Type extends MessageType<ExpiryFuturesMarketLaunchProposal> {
    constructor() {
        super("injective.exchange.v2.ExpiryFuturesMarketLaunchProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 9, name: "expiry", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "admin_info", kind: "message", T: () => AdminInfo },
            { no: 18, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 19, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/ExpiryFuturesMarketLaunchProposal" });
    }
    create(value?: PartialMessage<ExpiryFuturesMarketLaunchProposal>): ExpiryFuturesMarketLaunchProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.ticker = "";
        message.quoteDenom = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleScaleFactor = 0;
        message.oracleType = 0;
        message.expiry = 0n;
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<ExpiryFuturesMarketLaunchProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpiryFuturesMarketLaunchProposal): ExpiryFuturesMarketLaunchProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string quote_denom */ 4:
                    message.quoteDenom = reader.string();
                    break;
                case /* string oracle_base */ 5:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 6:
                    message.oracleQuote = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 7:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 8:
                    message.oracleType = reader.int32();
                    break;
                case /* int64 expiry */ 9:
                    message.expiry = reader.int64().toBigInt();
                    break;
                case /* string initial_margin_ratio */ 10:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 11:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string maker_fee_rate */ 12:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 13:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string min_price_tick_size */ 14:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 15:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 16:
                    message.minNotional = reader.string();
                    break;
                case /* injective.exchange.v2.AdminInfo admin_info */ 17:
                    message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
                    break;
                case /* string reduce_margin_ratio */ 18:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 19:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpiryFuturesMarketLaunchProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string quote_denom = 4; */
        if (message.quoteDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
        /* string oracle_base = 5; */
        if (message.oracleBase !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 6; */
        if (message.oracleQuote !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.oracleQuote);
        /* uint32 oracle_scale_factor = 7; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
        /* injective.oracle.v1beta1.OracleType oracle_type = 8; */
        if (message.oracleType !== 0)
            writer.tag(8, WireType.Varint).int32(message.oracleType);
        /* int64 expiry = 9; */
        if (message.expiry !== 0n)
            writer.tag(9, WireType.Varint).int64(message.expiry);
        /* string initial_margin_ratio = 10; */
        if (message.initialMarginRatio !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 11; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string maker_fee_rate = 12; */
        if (message.makerFeeRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 13; */
        if (message.takerFeeRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string min_price_tick_size = 14; */
        if (message.minPriceTickSize !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 15; */
        if (message.minQuantityTickSize !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 16; */
        if (message.minNotional !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
        /* injective.exchange.v2.AdminInfo admin_info = 17; */
        if (message.adminInfo)
            AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* string reduce_margin_ratio = 18; */
        if (message.reduceMarginRatio !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 19; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.ExpiryFuturesMarketLaunchProposal
 */
export const ExpiryFuturesMarketLaunchProposal = new ExpiryFuturesMarketLaunchProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketParamUpdateProposal$Type extends MessageType<DerivativeMarketParamUpdateProposal> {
    constructor() {
        super("injective.exchange.v2.DerivativeMarketParamUpdateProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "HourlyInterestRate", kind: "scalar", jsonName: "HourlyInterestRate", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "HourlyFundingRateCap", kind: "scalar", jsonName: "HourlyFundingRateCap", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
            { no: 14, name: "oracle_params", kind: "message", T: () => OracleParams },
            { no: 15, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true } },
            { no: 16, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "admin_info", kind: "message", T: () => AdminInfo },
            { no: 18, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 19, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": true } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/DerivativeMarketParamUpdateProposal" });
    }
    create(value?: PartialMessage<DerivativeMarketParamUpdateProposal>): DerivativeMarketParamUpdateProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.marketId = "";
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.hourlyInterestRate = "";
        message.hourlyFundingRateCap = "";
        message.status = 0;
        message.ticker = "";
        message.minNotional = "";
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketParamUpdateProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketParamUpdateProposal): DerivativeMarketParamUpdateProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string initial_margin_ratio */ 4:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 5:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string maker_fee_rate */ 6:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 7:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 8:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* string min_price_tick_size */ 9:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 10:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string HourlyInterestRate */ 11:
                    message.hourlyInterestRate = reader.string();
                    break;
                case /* string HourlyFundingRateCap */ 12:
                    message.hourlyFundingRateCap = reader.string();
                    break;
                case /* injective.exchange.v2.MarketStatus status */ 13:
                    message.status = reader.int32();
                    break;
                case /* injective.exchange.v2.OracleParams oracle_params */ 14:
                    message.oracleParams = OracleParams.internalBinaryRead(reader, reader.uint32(), options, message.oracleParams);
                    break;
                case /* string ticker */ 15:
                    message.ticker = reader.string();
                    break;
                case /* string min_notional */ 16:
                    message.minNotional = reader.string();
                    break;
                case /* injective.exchange.v2.AdminInfo admin_info */ 17:
                    message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
                    break;
                case /* string reduce_margin_ratio */ 18:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 19:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketParamUpdateProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string initial_margin_ratio = 4; */
        if (message.initialMarginRatio !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 5; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string maker_fee_rate = 6; */
        if (message.makerFeeRate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 7; */
        if (message.takerFeeRate !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 8; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* string min_price_tick_size = 9; */
        if (message.minPriceTickSize !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 10; */
        if (message.minQuantityTickSize !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string HourlyInterestRate = 11; */
        if (message.hourlyInterestRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.hourlyInterestRate);
        /* string HourlyFundingRateCap = 12; */
        if (message.hourlyFundingRateCap !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
        /* injective.exchange.v2.MarketStatus status = 13; */
        if (message.status !== 0)
            writer.tag(13, WireType.Varint).int32(message.status);
        /* injective.exchange.v2.OracleParams oracle_params = 14; */
        if (message.oracleParams)
            OracleParams.internalBinaryWrite(message.oracleParams, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string ticker = 15; */
        if (message.ticker !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.ticker);
        /* string min_notional = 16; */
        if (message.minNotional !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
        /* injective.exchange.v2.AdminInfo admin_info = 17; */
        if (message.adminInfo)
            AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* string reduce_margin_ratio = 18; */
        if (message.reduceMarginRatio !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 19; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DerivativeMarketParamUpdateProposal
 */
export const DerivativeMarketParamUpdateProposal = new DerivativeMarketParamUpdateProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdminInfo$Type extends MessageType<AdminInfo> {
    constructor() {
        super("injective.exchange.v2.AdminInfo", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdminInfo>): AdminInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.admin = "";
        message.adminPermissions = 0;
        if (value !== undefined)
            reflectionMergePartial<AdminInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdminInfo): AdminInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* uint32 admin_permissions */ 2:
                    message.adminPermissions = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdminInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* uint32 admin_permissions = 2; */
        if (message.adminPermissions !== 0)
            writer.tag(2, WireType.Varint).uint32(message.adminPermissions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.AdminInfo
 */
export const AdminInfo = new AdminInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketForcedSettlementProposal$Type extends MessageType<MarketForcedSettlementProposal> {
    constructor() {
        super("injective.exchange.v2.MarketForcedSettlementProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/MarketForcedSettlementProposal" });
    }
    create(value?: PartialMessage<MarketForcedSettlementProposal>): MarketForcedSettlementProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.marketId = "";
        message.settlementPrice = "";
        if (value !== undefined)
            reflectionMergePartial<MarketForcedSettlementProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketForcedSettlementProposal): MarketForcedSettlementProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string settlement_price */ 4:
                    message.settlementPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketForcedSettlementProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string settlement_price = 4; */
        if (message.settlementPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.settlementPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MarketForcedSettlementProposal
 */
export const MarketForcedSettlementProposal = new MarketForcedSettlementProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAuctionExchangeTransferDenomDecimalsProposal$Type extends MessageType<UpdateAuctionExchangeTransferDenomDecimalsProposal> {
    constructor() {
        super("injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "denom_decimals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DenomDecimals }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/UpdateAuctionExchangeTransferDenomDecimalsProposal" });
    }
    create(value?: PartialMessage<UpdateAuctionExchangeTransferDenomDecimalsProposal>): UpdateAuctionExchangeTransferDenomDecimalsProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.denomDecimals = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateAuctionExchangeTransferDenomDecimalsProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAuctionExchangeTransferDenomDecimalsProposal): UpdateAuctionExchangeTransferDenomDecimalsProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated injective.exchange.v2.DenomDecimals denom_decimals */ 3:
                    message.denomDecimals.push(DenomDecimals.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAuctionExchangeTransferDenomDecimalsProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated injective.exchange.v2.DenomDecimals denom_decimals = 3; */
        for (let i = 0; i < message.denomDecimals.length; i++)
            DenomDecimals.internalBinaryWrite(message.denomDecimals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal
 */
export const UpdateAuctionExchangeTransferDenomDecimalsProposal = new UpdateAuctionExchangeTransferDenomDecimalsProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarketParamUpdateProposal$Type extends MessageType<BinaryOptionsMarketParamUpdateProposal> {
    constructor() {
        super("injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
            { no: 14, name: "oracle_params", kind: "message", T: () => ProviderOracleParams },
            { no: 15, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true } },
            { no: 16, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": true } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BinaryOptionsMarketParamUpdateProposal" });
    }
    create(value?: PartialMessage<BinaryOptionsMarketParamUpdateProposal>): BinaryOptionsMarketParamUpdateProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.marketId = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.settlementPrice = "";
        message.admin = "";
        message.status = 0;
        message.ticker = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarketParamUpdateProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarketParamUpdateProposal): BinaryOptionsMarketParamUpdateProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* string maker_fee_rate */ 4:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 5:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 6:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* string min_price_tick_size */ 7:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 8:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* int64 expiration_timestamp */ 9:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 10:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* string settlement_price */ 11:
                    message.settlementPrice = reader.string();
                    break;
                case /* string admin */ 12:
                    message.admin = reader.string();
                    break;
                case /* injective.exchange.v2.MarketStatus status */ 13:
                    message.status = reader.int32();
                    break;
                case /* injective.exchange.v2.ProviderOracleParams oracle_params */ 14:
                    message.oracleParams = ProviderOracleParams.internalBinaryRead(reader, reader.uint32(), options, message.oracleParams);
                    break;
                case /* string ticker */ 15:
                    message.ticker = reader.string();
                    break;
                case /* string min_notional */ 16:
                    message.minNotional = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 17:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarketParamUpdateProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* string maker_fee_rate = 4; */
        if (message.makerFeeRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 5; */
        if (message.takerFeeRate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 6; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* string min_price_tick_size = 7; */
        if (message.minPriceTickSize !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 8; */
        if (message.minQuantityTickSize !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* int64 expiration_timestamp = 9; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(9, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 10; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(10, WireType.Varint).int64(message.settlementTimestamp);
        /* string settlement_price = 11; */
        if (message.settlementPrice !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.settlementPrice);
        /* string admin = 12; */
        if (message.admin !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.admin);
        /* injective.exchange.v2.MarketStatus status = 13; */
        if (message.status !== 0)
            writer.tag(13, WireType.Varint).int32(message.status);
        /* injective.exchange.v2.ProviderOracleParams oracle_params = 14; */
        if (message.oracleParams)
            ProviderOracleParams.internalBinaryWrite(message.oracleParams, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string ticker = 15; */
        if (message.ticker !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.ticker);
        /* string min_notional = 16; */
        if (message.minNotional !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 17; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal
 */
export const BinaryOptionsMarketParamUpdateProposal = new BinaryOptionsMarketParamUpdateProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProviderOracleParams$Type extends MessageType<ProviderOracleParams> {
    constructor() {
        super("injective.exchange.v2.ProviderOracleParams", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] }
        ]);
    }
    create(value?: PartialMessage<ProviderOracleParams>): ProviderOracleParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        message.provider = "";
        message.oracleScaleFactor = 0;
        message.oracleType = 0;
        if (value !== undefined)
            reflectionMergePartial<ProviderOracleParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProviderOracleParams): ProviderOracleParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* string provider */ 2:
                    message.provider = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 3:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 4:
                    message.oracleType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProviderOracleParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* string provider = 2; */
        if (message.provider !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.provider);
        /* uint32 oracle_scale_factor = 3; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(3, WireType.Varint).uint32(message.oracleScaleFactor);
        /* injective.oracle.v1beta1.OracleType oracle_type = 4; */
        if (message.oracleType !== 0)
            writer.tag(4, WireType.Varint).int32(message.oracleType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.ProviderOracleParams
 */
export const ProviderOracleParams = new ProviderOracleParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OracleParams$Type extends MessageType<OracleParams> {
    constructor() {
        super("injective.exchange.v2.OracleParams", [
            { no: 1, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] }
        ]);
    }
    create(value?: PartialMessage<OracleParams>): OracleParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleScaleFactor = 0;
        message.oracleType = 0;
        if (value !== undefined)
            reflectionMergePartial<OracleParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OracleParams): OracleParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string oracle_base */ 1:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 2:
                    message.oracleQuote = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 3:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 4:
                    message.oracleType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OracleParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string oracle_base = 1; */
        if (message.oracleBase !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 2; */
        if (message.oracleQuote !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oracleQuote);
        /* uint32 oracle_scale_factor = 3; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(3, WireType.Varint).uint32(message.oracleScaleFactor);
        /* injective.oracle.v1beta1.OracleType oracle_type = 4; */
        if (message.oracleType !== 0)
            writer.tag(4, WireType.Varint).int32(message.oracleType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OracleParams
 */
export const OracleParams = new OracleParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignLaunchProposal$Type extends MessageType<TradingRewardCampaignLaunchProposal> {
    constructor() {
        super("injective.exchange.v2.TradingRewardCampaignLaunchProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
            { no: 4, name: "campaign_reward_pools", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/TradingRewardCampaignLaunchProposal" });
    }
    create(value?: PartialMessage<TradingRewardCampaignLaunchProposal>): TradingRewardCampaignLaunchProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.campaignRewardPools = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignLaunchProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignLaunchProposal): TradingRewardCampaignLaunchProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* injective.exchange.v2.TradingRewardCampaignInfo campaign_info */ 3:
                    message.campaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.campaignInfo);
                    break;
                case /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools */ 4:
                    message.campaignRewardPools.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignLaunchProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* injective.exchange.v2.TradingRewardCampaignInfo campaign_info = 3; */
        if (message.campaignInfo)
            TradingRewardCampaignInfo.internalBinaryWrite(message.campaignInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools = 4; */
        for (let i = 0; i < message.campaignRewardPools.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.campaignRewardPools[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradingRewardCampaignLaunchProposal
 */
export const TradingRewardCampaignLaunchProposal = new TradingRewardCampaignLaunchProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignUpdateProposal$Type extends MessageType<TradingRewardCampaignUpdateProposal> {
    constructor() {
        super("injective.exchange.v2.TradingRewardCampaignUpdateProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
            { no: 4, name: "campaign_reward_pools_additions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool },
            { no: 5, name: "campaign_reward_pools_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/TradingRewardCampaignUpdateProposal" });
    }
    create(value?: PartialMessage<TradingRewardCampaignUpdateProposal>): TradingRewardCampaignUpdateProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.campaignRewardPoolsAdditions = [];
        message.campaignRewardPoolsUpdates = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignUpdateProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignUpdateProposal): TradingRewardCampaignUpdateProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* injective.exchange.v2.TradingRewardCampaignInfo campaign_info */ 3:
                    message.campaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.campaignInfo);
                    break;
                case /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_additions */ 4:
                    message.campaignRewardPoolsAdditions.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_updates */ 5:
                    message.campaignRewardPoolsUpdates.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignUpdateProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* injective.exchange.v2.TradingRewardCampaignInfo campaign_info = 3; */
        if (message.campaignInfo)
            TradingRewardCampaignInfo.internalBinaryWrite(message.campaignInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_additions = 4; */
        for (let i = 0; i < message.campaignRewardPoolsAdditions.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.campaignRewardPoolsAdditions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_updates = 5; */
        for (let i = 0; i < message.campaignRewardPoolsUpdates.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.campaignRewardPoolsUpdates[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradingRewardCampaignUpdateProposal
 */
export const TradingRewardCampaignUpdateProposal = new TradingRewardCampaignUpdateProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardPointUpdate$Type extends MessageType<RewardPointUpdate> {
    constructor() {
        super("injective.exchange.v2.RewardPointUpdate", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "new_points", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<RewardPointUpdate>): RewardPointUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.newPoints = "";
        if (value !== undefined)
            reflectionMergePartial<RewardPointUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardPointUpdate): RewardPointUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* string new_points */ 12:
                    message.newPoints = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardPointUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* string new_points = 12; */
        if (message.newPoints !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.newPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.RewardPointUpdate
 */
export const RewardPointUpdate = new RewardPointUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardPendingPointsUpdateProposal$Type extends MessageType<TradingRewardPendingPointsUpdateProposal> {
    constructor() {
        super("injective.exchange.v2.TradingRewardPendingPointsUpdateProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pending_pool_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "reward_point_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RewardPointUpdate }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/TradingRewardPendingPointsUpdateProposal" });
    }
    create(value?: PartialMessage<TradingRewardPendingPointsUpdateProposal>): TradingRewardPendingPointsUpdateProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.pendingPoolTimestamp = 0n;
        message.rewardPointUpdates = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardPendingPointsUpdateProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardPendingPointsUpdateProposal): TradingRewardPendingPointsUpdateProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* int64 pending_pool_timestamp */ 3:
                    message.pendingPoolTimestamp = reader.int64().toBigInt();
                    break;
                case /* repeated injective.exchange.v2.RewardPointUpdate reward_point_updates */ 4:
                    message.rewardPointUpdates.push(RewardPointUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardPendingPointsUpdateProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* int64 pending_pool_timestamp = 3; */
        if (message.pendingPoolTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.pendingPoolTimestamp);
        /* repeated injective.exchange.v2.RewardPointUpdate reward_point_updates = 4; */
        for (let i = 0; i < message.rewardPointUpdates.length; i++)
            RewardPointUpdate.internalBinaryWrite(message.rewardPointUpdates[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradingRewardPendingPointsUpdateProposal
 */
export const TradingRewardPendingPointsUpdateProposal = new TradingRewardPendingPointsUpdateProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountProposal$Type extends MessageType<FeeDiscountProposal> {
    constructor() {
        super("injective.exchange.v2.FeeDiscountProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "schedule", kind: "message", T: () => FeeDiscountSchedule }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/FeeDiscountProposal" });
    }
    create(value?: PartialMessage<FeeDiscountProposal>): FeeDiscountProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountProposal): FeeDiscountProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* injective.exchange.v2.FeeDiscountSchedule schedule */ 3:
                    message.schedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.schedule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* injective.exchange.v2.FeeDiscountSchedule schedule = 3; */
        if (message.schedule)
            FeeDiscountSchedule.internalBinaryWrite(message.schedule, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FeeDiscountProposal
 */
export const FeeDiscountProposal = new FeeDiscountProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchCommunityPoolSpendProposal$Type extends MessageType<BatchCommunityPoolSpendProposal> {
    constructor() {
        super("injective.exchange.v2.BatchCommunityPoolSpendProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "proposals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CommunityPoolSpendProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BatchCommunityPoolSpendProposal" });
    }
    create(value?: PartialMessage<BatchCommunityPoolSpendProposal>): BatchCommunityPoolSpendProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.proposals = [];
        if (value !== undefined)
            reflectionMergePartial<BatchCommunityPoolSpendProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchCommunityPoolSpendProposal): BatchCommunityPoolSpendProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals */ 3:
                    message.proposals.push(CommunityPoolSpendProposal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchCommunityPoolSpendProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals = 3; */
        for (let i = 0; i < message.proposals.length; i++)
            CommunityPoolSpendProposal.internalBinaryWrite(message.proposals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.BatchCommunityPoolSpendProposal
 */
export const BatchCommunityPoolSpendProposal = new BatchCommunityPoolSpendProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AtomicMarketOrderFeeMultiplierScheduleProposal$Type extends MessageType<AtomicMarketOrderFeeMultiplierScheduleProposal> {
    constructor() {
        super("injective.exchange.v2.AtomicMarketOrderFeeMultiplierScheduleProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_fee_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketFeeMultiplier }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/AtomicMarketOrderFeeMultiplierScheduleProposal" });
    }
    create(value?: PartialMessage<AtomicMarketOrderFeeMultiplierScheduleProposal>): AtomicMarketOrderFeeMultiplierScheduleProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.marketFeeMultipliers = [];
        if (value !== undefined)
            reflectionMergePartial<AtomicMarketOrderFeeMultiplierScheduleProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AtomicMarketOrderFeeMultiplierScheduleProposal): AtomicMarketOrderFeeMultiplierScheduleProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers */ 3:
                    message.marketFeeMultipliers.push(MarketFeeMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AtomicMarketOrderFeeMultiplierScheduleProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers = 3; */
        for (let i = 0; i < message.marketFeeMultipliers.length; i++)
            MarketFeeMultiplier.internalBinaryWrite(message.marketFeeMultipliers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.AtomicMarketOrderFeeMultiplierScheduleProposal
 */
export const AtomicMarketOrderFeeMultiplierScheduleProposal = new AtomicMarketOrderFeeMultiplierScheduleProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomMinNotionalProposal$Type extends MessageType<DenomMinNotionalProposal> {
    constructor() {
        super("injective.exchange.v2.DenomMinNotionalProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "denom_min_notionals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DenomMinNotional }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/DenomMinNotionalProposal" });
    }
    create(value?: PartialMessage<DenomMinNotionalProposal>): DenomMinNotionalProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.denomMinNotionals = [];
        if (value !== undefined)
            reflectionMergePartial<DenomMinNotionalProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomMinNotionalProposal): DenomMinNotionalProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals */ 3:
                    message.denomMinNotionals.push(DenomMinNotional.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomMinNotionalProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals = 3; */
        for (let i = 0; i < message.denomMinNotionals.length; i++)
            DenomMinNotional.internalBinaryWrite(message.denomMinNotionals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DenomMinNotionalProposal
 */
export const DenomMinNotionalProposal = new DenomMinNotionalProposal$Type();
