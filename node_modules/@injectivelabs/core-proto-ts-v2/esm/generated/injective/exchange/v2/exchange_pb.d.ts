// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v2/exchange.proto" (package "injective.exchange.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MarketVolume } from "./market_pb";
import { AtomicMarketOrderAccessLevel } from "./order_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
/**
 * @generated from protobuf message injective.exchange.v2.Params
 */
export interface Params {
    /**
     * spot_market_instant_listing_fee defines the expedited fee in INJ required
     * to create a spot market by bypassing governance
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1
     */
    spotMarketInstantListingFee?: Coin;
    /**
     * derivative_market_instant_listing_fee defines the expedited fee in INJ
     * required to create a derivative market by bypassing governance
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2
     */
    derivativeMarketInstantListingFee?: Coin;
    /**
     * default_spot_maker_fee defines the default exchange trade fee for makers on
     * a spot market
     *
     * @generated from protobuf field: string default_spot_maker_fee_rate = 3
     */
    defaultSpotMakerFeeRate: string;
    /**
     * default_spot_taker_fee_rate defines the default exchange trade fee rate for
     * takers on a new spot market
     *
     * @generated from protobuf field: string default_spot_taker_fee_rate = 4
     */
    defaultSpotTakerFeeRate: string;
    /**
     * default_derivative_maker_fee defines the default exchange trade fee for
     * makers on a new derivative market
     *
     * @generated from protobuf field: string default_derivative_maker_fee_rate = 5
     */
    defaultDerivativeMakerFeeRate: string;
    /**
     * default_derivative_taker_fee defines the default exchange trade fee for
     * takers on a new derivative market
     *
     * @generated from protobuf field: string default_derivative_taker_fee_rate = 6
     */
    defaultDerivativeTakerFeeRate: string;
    /**
     * default_initial_margin_ratio defines the default initial margin ratio on a
     * new derivative market
     *
     * @generated from protobuf field: string default_initial_margin_ratio = 7
     */
    defaultInitialMarginRatio: string;
    /**
     * default_maintenance_margin_ratio defines the default maintenance margin
     * ratio on a new derivative market
     *
     * @generated from protobuf field: string default_maintenance_margin_ratio = 8
     */
    defaultMaintenanceMarginRatio: string;
    /**
     * default_funding_interval defines the default funding interval on a
     * derivative market
     *
     * @generated from protobuf field: int64 default_funding_interval = 9
     */
    defaultFundingInterval: bigint;
    /**
     * funding_multiple defines the timestamp multiple that the funding timestamp
     * should be a multiple of
     *
     * @generated from protobuf field: int64 funding_multiple = 10
     */
    fundingMultiple: bigint;
    /**
     * relayer_fee_share_rate defines the trade fee share percentage that goes to
     * relayers
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 11
     */
    relayerFeeShareRate: string;
    /**
     * default_hourly_funding_rate_cap defines the default maximum absolute value
     * of the hourly funding rate
     *
     * @generated from protobuf field: string default_hourly_funding_rate_cap = 12
     */
    defaultHourlyFundingRateCap: string;
    /**
     * hourly_interest_rate defines the hourly interest rate
     *
     * @generated from protobuf field: string default_hourly_interest_rate = 13
     */
    defaultHourlyInterestRate: string;
    /**
     * max_derivative_order_side_count defines the maximum number of derivative
     * active orders a subaccount can have for a given orderbook side
     *
     * @generated from protobuf field: uint32 max_derivative_order_side_count = 14
     */
    maxDerivativeOrderSideCount: number;
    /**
     * inj_reward_staked_requirement_threshold defines the threshold on INJ
     * rewards after which one also needs staked INJ to receive more
     *
     * @generated from protobuf field: string inj_reward_staked_requirement_threshold = 15
     */
    injRewardStakedRequirementThreshold: string;
    /**
     * the trading_rewards_vesting_duration defines the vesting times for trading
     * rewards
     *
     * @generated from protobuf field: int64 trading_rewards_vesting_duration = 16
     */
    tradingRewardsVestingDuration: bigint;
    /**
     * liquidator_reward_share_rate defines the ratio of the split of the surplus
     * collateral that goes to the liquidator
     *
     * @generated from protobuf field: string liquidator_reward_share_rate = 17
     */
    liquidatorRewardShareRate: string;
    /**
     * binary_options_market_instant_listing_fee defines the expedited fee in INJ
     * required to create a derivative market by bypassing governance
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18
     */
    binaryOptionsMarketInstantListingFee?: Coin;
    /**
     * atomic_market_order_access_level defines the required access permissions
     * for executing atomic market orders
     *
     * @generated from protobuf field: injective.exchange.v2.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19
     */
    atomicMarketOrderAccessLevel: AtomicMarketOrderAccessLevel;
    /**
     * spot_atomic_market_order_fee_multiplier defines the default multiplier for
     * executing atomic market orders in spot markets
     *
     * @generated from protobuf field: string spot_atomic_market_order_fee_multiplier = 20
     */
    spotAtomicMarketOrderFeeMultiplier: string;
    /**
     * derivative_atomic_market_order_fee_multiplier defines the default
     * multiplier for executing atomic market orders in derivative markets
     *
     * @generated from protobuf field: string derivative_atomic_market_order_fee_multiplier = 21
     */
    derivativeAtomicMarketOrderFeeMultiplier: string;
    /**
     * binary_options_atomic_market_order_fee_multiplier defines the default
     * multiplier for executing atomic market orders in binary markets
     *
     * @generated from protobuf field: string binary_options_atomic_market_order_fee_multiplier = 22
     */
    binaryOptionsAtomicMarketOrderFeeMultiplier: string;
    /**
     * minimal_protocol_fee_rate defines the minimal protocol fee rate
     *
     * @generated from protobuf field: string minimal_protocol_fee_rate = 23
     */
    minimalProtocolFeeRate: string;
    /**
     * is_instant_derivative_market_launch_enabled defines whether instant
     * derivative market launch is enabled
     *
     * @generated from protobuf field: bool is_instant_derivative_market_launch_enabled = 24
     */
    isInstantDerivativeMarketLaunchEnabled: boolean;
    /**
     * @generated from protobuf field: int64 post_only_mode_height_threshold = 25
     */
    postOnlyModeHeightThreshold: bigint;
    /**
     * Maximum time in seconds since the last mark price update to allow a
     * decrease in margin
     *
     * @generated from protobuf field: int64 margin_decrease_price_timestamp_threshold_seconds = 26
     */
    marginDecreasePriceTimestampThresholdSeconds: bigint;
    /**
     * List of addresses that are allowed to perform exchange admin operations
     *
     * @generated from protobuf field: repeated string exchange_admins = 27
     */
    exchangeAdmins: string[];
    /**
     * inj_auction_max_cap defines the maximum cap for INJ sent to auction
     *
     * @generated from protobuf field: string inj_auction_max_cap = 28
     */
    injAuctionMaxCap: string;
    /**
     * fixed_gas_enabled indicates if msg server will consume fixed gas amount for
     * certain msg types
     *
     * @generated from protobuf field: bool fixed_gas_enabled = 29
     */
    fixedGasEnabled: boolean;
    /**
     * emit_legacy_version_events indicates if events of legacy version types
     * should be emitted in parallel to the new version events
     *
     * @generated from protobuf field: bool emit_legacy_version_events = 30
     */
    emitLegacyVersionEvents: boolean;
    /**
     * default_reduce_margin_ratio defines the default reduce margin ratio on a
     * new derivative market
     *
     * @generated from protobuf field: string default_reduce_margin_ratio = 31
     */
    defaultReduceMarginRatio: string;
    /**
     * post_only_mode_blocks_amount defines the amount of blocks the post only
     * mode will be enabled after a chain upgrade
     *
     * @generated from protobuf field: uint64 post_only_mode_blocks_amount = 33
     */
    postOnlyModeBlocksAmount: bigint;
    /**
     * min_post_only_mode_downtime_duration defines the minimum downtime duration
     * that must pass before the post only mode is automatically enabled. The
     * accepted values are the Downtime enum values from the downtime_duration
     * module
     *
     * @generated from protobuf field: string min_post_only_mode_downtime_duration = 34
     */
    minPostOnlyModeDowntimeDuration: string;
    /**
     * post_only_mode_blocks_amount defines the amount of blocks the post only
     * mode will be enabled after the downtime-detector module detects a chain
     * downtime
     *
     * @generated from protobuf field: uint64 post_only_mode_blocks_amount_after_downtime = 35
     */
    postOnlyModeBlocksAmountAfterDowntime: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.NextFundingTimestamp
 */
export interface NextFundingTimestamp {
    /**
     * @generated from protobuf field: int64 next_timestamp = 1
     */
    nextTimestamp: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.MidPriceAndTOB
 */
export interface MidPriceAndTOB {
    /**
     * mid price of the market (in human readable format)
     *
     * @generated from protobuf field: string mid_price = 1
     */
    midPrice: string;
    /**
     * best buy price of the market (in human readable format)
     *
     * @generated from protobuf field: string best_buy_price = 2
     */
    bestBuyPrice: string;
    /**
     * best sell price of the market (in human readable format)
     *
     * @generated from protobuf field: string best_sell_price = 3
     */
    bestSellPrice: string;
}
/**
 * A subaccount's deposit for a given base currency
 *
 * @generated from protobuf message injective.exchange.v2.Deposit
 */
export interface Deposit {
    /**
     * the available balance (in chain format)
     *
     * @generated from protobuf field: string available_balance = 1
     */
    availableBalance: string;
    /**
     * the total balance (in chain format)
     *
     * @generated from protobuf field: string total_balance = 2
     */
    totalBalance: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountTradeNonce
 */
export interface SubaccountTradeNonce {
    /**
     * @generated from protobuf field: uint32 nonce = 1
     */
    nonce: number;
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountOrder
 */
export interface SubaccountOrder {
    /**
     * price of the order
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * the amount of the quantity remaining fillable
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * @generated from protobuf field: bool isReduceOnly = 3
     */
    isReduceOnly: boolean;
    /**
     * @generated from protobuf field: string cid = 4
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountOrderData
 */
export interface SubaccountOrderData {
    /**
     * @generated from protobuf field: injective.exchange.v2.SubaccountOrder order = 1
     */
    order?: SubaccountOrder;
    /**
     * @generated from protobuf field: bytes order_hash = 2
     */
    orderHash: Uint8Array;
}
/**
 * @generated from protobuf message injective.exchange.v2.Position
 */
export interface Position {
    /**
     * True if the position is long. False if the position is short.
     *
     * @generated from protobuf field: bool isLong = 1
     */
    isLong: boolean;
    /**
     * The quantity of the position (in human readable format)
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * The entry price of the position (in human readable format)
     *
     * @generated from protobuf field: string entry_price = 3
     */
    entryPrice: string;
    /**
     * The margin of the position (in human readable format)
     *
     * @generated from protobuf field: string margin = 4
     */
    margin: string;
    /**
     * The cumulative funding
     *
     * @generated from protobuf field: string cumulative_funding_entry = 5
     */
    cumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.Balance
 */
export interface Balance {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the denom of the balance
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * the token deposits details
     *
     * @generated from protobuf field: injective.exchange.v2.Deposit deposits = 3
     */
    deposits?: Deposit;
}
/**
 * @generated from protobuf message injective.exchange.v2.DerivativePosition
 */
export interface DerivativePosition {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * the position details
     *
     * @generated from protobuf field: injective.exchange.v2.Position position = 3
     */
    position?: Position;
}
/**
 * @generated from protobuf message injective.exchange.v2.MarketOrderIndicator
 */
export interface MarketOrderIndicator {
    /**
     * market_id represents the unique ID of the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: bool isBuy = 2
     */
    isBuy: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v2.TradeLog
 */
export interface TradeLog {
    /**
     * @generated from protobuf field: string quantity = 1
     */
    quantity: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * bytes32 subaccount ID that executed the trade
     *
     * @generated from protobuf field: bytes subaccount_id = 3
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: string fee = 4
     */
    fee: string;
    /**
     * @generated from protobuf field: bytes order_hash = 5
     */
    orderHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes fee_recipient_address = 6
     */
    feeRecipientAddress: Uint8Array;
    /**
     * @generated from protobuf field: string cid = 7
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.PositionDelta
 */
export interface PositionDelta {
    /**
     * @generated from protobuf field: bool is_long = 1
     */
    isLong: boolean;
    /**
     * @generated from protobuf field: string execution_quantity = 2
     */
    executionQuantity: string;
    /**
     * @generated from protobuf field: string execution_margin = 3
     */
    executionMargin: string;
    /**
     * @generated from protobuf field: string execution_price = 4
     */
    executionPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.DerivativeTradeLog
 */
export interface DerivativeTradeLog {
    /**
     * @generated from protobuf field: bytes subaccount_id = 1
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: injective.exchange.v2.PositionDelta position_delta = 2
     */
    positionDelta?: PositionDelta;
    /**
     * @generated from protobuf field: string payout = 3
     */
    payout: string;
    /**
     * @generated from protobuf field: string fee = 4
     */
    fee: string;
    /**
     * @generated from protobuf field: bytes order_hash = 5
     */
    orderHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes fee_recipient_address = 6
     */
    feeRecipientAddress: Uint8Array;
    /**
     * @generated from protobuf field: string cid = 7
     */
    cid: string;
    /**
     * @generated from protobuf field: string pnl = 8
     */
    pnl: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountPosition
 */
export interface SubaccountPosition {
    /**
     * @generated from protobuf field: injective.exchange.v2.Position position = 1
     */
    position?: Position;
    /**
     * @generated from protobuf field: bytes subaccount_id = 2
     */
    subaccountId: Uint8Array;
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountDeposit
 */
export interface SubaccountDeposit {
    /**
     * @generated from protobuf field: bytes subaccount_id = 1
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: injective.exchange.v2.Deposit deposit = 2
     */
    deposit?: Deposit;
}
/**
 * @generated from protobuf message injective.exchange.v2.DepositUpdate
 */
export interface DepositUpdate {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SubaccountDeposit deposits = 2
     */
    deposits: SubaccountDeposit[];
}
/**
 * @generated from protobuf message injective.exchange.v2.PointsMultiplier
 */
export interface PointsMultiplier {
    /**
     * @generated from protobuf field: string maker_points_multiplier = 1
     */
    makerPointsMultiplier: string;
    /**
     * @generated from protobuf field: string taker_points_multiplier = 2
     */
    takerPointsMultiplier: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.TradingRewardCampaignBoostInfo
 */
export interface TradingRewardCampaignBoostInfo {
    /**
     * @generated from protobuf field: repeated string boosted_spot_market_ids = 1
     */
    boostedSpotMarketIds: string[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.PointsMultiplier spot_market_multipliers = 2
     */
    spotMarketMultipliers: PointsMultiplier[];
    /**
     * @generated from protobuf field: repeated string boosted_derivative_market_ids = 3
     */
    boostedDerivativeMarketIds: string[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.PointsMultiplier derivative_market_multipliers = 4
     */
    derivativeMarketMultipliers: PointsMultiplier[];
}
/**
 * @generated from protobuf message injective.exchange.v2.CampaignRewardPool
 */
export interface CampaignRewardPool {
    /**
     * the campaign start timestamp in seconds
     *
     * @generated from protobuf field: int64 start_timestamp = 1
     */
    startTimestamp: bigint;
    /**
     * max_campaign_rewards are the maximum reward amounts to be disbursed at the
     * end of the campaign
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2
     */
    maxCampaignRewards: Coin[];
}
/**
 * @generated from protobuf message injective.exchange.v2.TradingRewardCampaignInfo
 */
export interface TradingRewardCampaignInfo {
    /**
     * number of seconds of the duration of each campaign
     *
     * @generated from protobuf field: int64 campaign_duration_seconds = 1
     */
    campaignDurationSeconds: bigint;
    /**
     * the trading fee quote denoms which will be counted for the rewards
     *
     * @generated from protobuf field: repeated string quote_denoms = 2
     */
    quoteDenoms: string[];
    /**
     * the optional boost info for markets
     *
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3
     */
    tradingRewardBoostInfo?: TradingRewardCampaignBoostInfo;
    /**
     * the marketIDs which are disqualified from being rewarded
     *
     * @generated from protobuf field: repeated string disqualified_market_ids = 4
     */
    disqualifiedMarketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v2.FeeDiscountTierInfo
 */
export interface FeeDiscountTierInfo {
    /**
     * the maker discount rate
     *
     * @generated from protobuf field: string maker_discount_rate = 1
     */
    makerDiscountRate: string;
    /**
     * the taker discount rate
     *
     * @generated from protobuf field: string taker_discount_rate = 2
     */
    takerDiscountRate: string;
    /**
     * the staked amount required to qualify for the discount (in chain format)
     *
     * @generated from protobuf field: string staked_amount = 3
     */
    stakedAmount: string;
    /**
     * the volume required to qualify for the discount (in human readable format)
     *
     * @generated from protobuf field: string volume = 4
     */
    volume: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.FeeDiscountSchedule
 */
export interface FeeDiscountSchedule {
    /**
     * the bucket number
     *
     * @generated from protobuf field: uint64 bucket_count = 1
     */
    bucketCount: bigint;
    /**
     * the bucket duration in seconds
     *
     * @generated from protobuf field: int64 bucket_duration = 2
     */
    bucketDuration: bigint;
    /**
     * the trading fee quote denoms which will be counted for the fee paid
     * contribution
     *
     * @generated from protobuf field: repeated string quote_denoms = 3
     */
    quoteDenoms: string[];
    /**
     * the fee discount tiers
     *
     * @generated from protobuf field: repeated injective.exchange.v2.FeeDiscountTierInfo tier_infos = 4
     */
    tierInfos: FeeDiscountTierInfo[];
    /**
     * the marketIDs which are disqualified from contributing to the fee paid
     * amount
     *
     * @generated from protobuf field: repeated string disqualified_market_ids = 5
     */
    disqualifiedMarketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v2.FeeDiscountTierTTL
 */
export interface FeeDiscountTierTTL {
    /**
     * the tier number
     *
     * @generated from protobuf field: uint64 tier = 1
     */
    tier: bigint;
    /**
     * the TTL timestamp in seconds
     *
     * @generated from protobuf field: int64 ttl_timestamp = 2
     */
    ttlTimestamp: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.AccountRewards
 */
export interface AccountRewards {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin rewards = 2
     */
    rewards: Coin[];
}
/**
 * @generated from protobuf message injective.exchange.v2.TradeRecords
 */
export interface TradeRecords {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TradeRecord latest_trade_records = 2
     */
    latestTradeRecords: TradeRecord[];
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountIDs
 */
export interface SubaccountIDs {
    /**
     * @generated from protobuf field: repeated bytes subaccount_ids = 1
     */
    subaccountIds: Uint8Array[];
}
/**
 * @generated from protobuf message injective.exchange.v2.TradeRecord
 */
export interface TradeRecord {
    /**
     * the timestamp of the trade
     *
     * @generated from protobuf field: int64 timestamp = 1
     */
    timestamp: bigint;
    /**
     * the price of the trade (in human readable format)
     *
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * the quantity of the trade (in human readable format)
     *
     * @generated from protobuf field: string quantity = 3
     */
    quantity: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.Level
 */
export interface Level {
    /**
     * price (in human readable format)
     *
     * @generated from protobuf field: string p = 1
     */
    p: string;
    /**
     * quantity (in human readable format)
     *
     * @generated from protobuf field: string q = 2
     */
    q: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.AggregateSubaccountVolumeRecord
 */
export interface AggregateSubaccountVolumeRecord {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the subaccount volumes for each market
     *
     * @generated from protobuf field: repeated injective.exchange.v2.MarketVolume market_volumes = 2
     */
    marketVolumes: MarketVolume[];
}
/**
 * @generated from protobuf message injective.exchange.v2.AggregateAccountVolumeRecord
 */
export interface AggregateAccountVolumeRecord {
    /**
     * account the volume belongs to
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * the aggregate volumes for each market
     *
     * @generated from protobuf field: repeated injective.exchange.v2.MarketVolume market_volumes = 2
     */
    marketVolumes: MarketVolume[];
}
/**
 * @generated from protobuf message injective.exchange.v2.DenomDecimals
 */
export interface DenomDecimals {
    /**
     * the denom of the token
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * the decimals of the token
     *
     * @generated from protobuf field: uint64 decimals = 2
     */
    decimals: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.GrantAuthorization
 */
export interface GrantAuthorization {
    /**
     * the grantee address
     *
     * @generated from protobuf field: string grantee = 1
     */
    grantee: string;
    /**
     * the amount of stake granted (INJ in chain format)
     *
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.ActiveGrant
 */
export interface ActiveGrant {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.EffectiveGrant
 */
export interface EffectiveGrant {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
    /**
     * @generated from protobuf field: string net_granted_stake = 2
     */
    netGrantedStake: string;
    /**
     * @generated from protobuf field: bool is_valid = 3
     */
    isValid: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v2.DenomMinNotional
 */
export interface DenomMinNotional {
    /**
     * the denom of the token
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * the minimum notional value for the token (in human readable format)
     *
     * @generated from protobuf field: string min_notional = 2
     */
    minNotional: string;
}
/**
 * @generated from protobuf enum injective.exchange.v2.ExecutionType
 */
export enum ExecutionType {
    /**
     * @generated from protobuf enum value: UnspecifiedExecutionType = 0;
     */
    UnspecifiedExecutionType = 0,
    /**
     * @generated from protobuf enum value: Market = 1;
     */
    Market = 1,
    /**
     * @generated from protobuf enum value: LimitFill = 2;
     */
    LimitFill = 2,
    /**
     * @generated from protobuf enum value: LimitMatchRestingOrder = 3;
     */
    LimitMatchRestingOrder = 3,
    /**
     * @generated from protobuf enum value: LimitMatchNewOrder = 4;
     */
    LimitMatchNewOrder = 4,
    /**
     * @generated from protobuf enum value: MarketLiquidation = 5;
     */
    MarketLiquidation = 5,
    /**
     * @generated from protobuf enum value: ExpiryMarketSettlement = 6;
     */
    ExpiryMarketSettlement = 6,
    /**
     * @generated from protobuf enum value: OffsettingPosition = 7;
     */
    OffsettingPosition = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class Params$Type extends MessageType<Params> {
    constructor() {
        super("injective.exchange.v2.Params", [
            { no: 1, name: "spot_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "derivative_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "default_spot_maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "default_spot_taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "default_derivative_maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "default_derivative_taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "default_initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "default_maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "default_funding_interval", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "funding_multiple", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "default_hourly_funding_rate_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "default_hourly_interest_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "max_derivative_order_side_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "inj_reward_staked_requirement_threshold", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 16, name: "trading_rewards_vesting_duration", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "liquidator_reward_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 18, name: "binary_options_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 19, name: "atomic_market_order_access_level", kind: "enum", T: () => ["injective.exchange.v2.AtomicMarketOrderAccessLevel", AtomicMarketOrderAccessLevel] },
            { no: 20, name: "spot_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 21, name: "derivative_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 22, name: "binary_options_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 23, name: "minimal_protocol_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 24, name: "is_instant_derivative_market_launch_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "post_only_mode_height_threshold", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 26, name: "margin_decrease_price_timestamp_threshold_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 27, name: "exchange_admins", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "inj_auction_max_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 29, name: "fixed_gas_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "emit_legacy_version_events", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "default_reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 33, name: "post_only_mode_blocks_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 34, name: "min_post_only_mode_downtime_duration", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "post_only_mode_blocks_amount_after_downtime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "gogoproto.equal": true, "amino.name": "exchange/Params" });
    }
    create(value?: PartialMessage<Params>): Params {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultSpotMakerFeeRate = "";
        message.defaultSpotTakerFeeRate = "";
        message.defaultDerivativeMakerFeeRate = "";
        message.defaultDerivativeTakerFeeRate = "";
        message.defaultInitialMarginRatio = "";
        message.defaultMaintenanceMarginRatio = "";
        message.defaultFundingInterval = 0n;
        message.fundingMultiple = 0n;
        message.relayerFeeShareRate = "";
        message.defaultHourlyFundingRateCap = "";
        message.defaultHourlyInterestRate = "";
        message.maxDerivativeOrderSideCount = 0;
        message.injRewardStakedRequirementThreshold = "";
        message.tradingRewardsVestingDuration = 0n;
        message.liquidatorRewardShareRate = "";
        message.atomicMarketOrderAccessLevel = 0;
        message.spotAtomicMarketOrderFeeMultiplier = "";
        message.derivativeAtomicMarketOrderFeeMultiplier = "";
        message.binaryOptionsAtomicMarketOrderFeeMultiplier = "";
        message.minimalProtocolFeeRate = "";
        message.isInstantDerivativeMarketLaunchEnabled = false;
        message.postOnlyModeHeightThreshold = 0n;
        message.marginDecreasePriceTimestampThresholdSeconds = 0n;
        message.exchangeAdmins = [];
        message.injAuctionMaxCap = "";
        message.fixedGasEnabled = false;
        message.emitLegacyVersionEvents = false;
        message.defaultReduceMarginRatio = "";
        message.postOnlyModeBlocksAmount = 0n;
        message.minPostOnlyModeDowntimeDuration = "";
        message.postOnlyModeBlocksAmountAfterDowntime = 0n;
        if (value !== undefined)
            reflectionMergePartial<Params>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin spot_market_instant_listing_fee */ 1:
                    message.spotMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.spotMarketInstantListingFee);
                    break;
                case /* cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee */ 2:
                    message.derivativeMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.derivativeMarketInstantListingFee);
                    break;
                case /* string default_spot_maker_fee_rate */ 3:
                    message.defaultSpotMakerFeeRate = reader.string();
                    break;
                case /* string default_spot_taker_fee_rate */ 4:
                    message.defaultSpotTakerFeeRate = reader.string();
                    break;
                case /* string default_derivative_maker_fee_rate */ 5:
                    message.defaultDerivativeMakerFeeRate = reader.string();
                    break;
                case /* string default_derivative_taker_fee_rate */ 6:
                    message.defaultDerivativeTakerFeeRate = reader.string();
                    break;
                case /* string default_initial_margin_ratio */ 7:
                    message.defaultInitialMarginRatio = reader.string();
                    break;
                case /* string default_maintenance_margin_ratio */ 8:
                    message.defaultMaintenanceMarginRatio = reader.string();
                    break;
                case /* int64 default_funding_interval */ 9:
                    message.defaultFundingInterval = reader.int64().toBigInt();
                    break;
                case /* int64 funding_multiple */ 10:
                    message.fundingMultiple = reader.int64().toBigInt();
                    break;
                case /* string relayer_fee_share_rate */ 11:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* string default_hourly_funding_rate_cap */ 12:
                    message.defaultHourlyFundingRateCap = reader.string();
                    break;
                case /* string default_hourly_interest_rate */ 13:
                    message.defaultHourlyInterestRate = reader.string();
                    break;
                case /* uint32 max_derivative_order_side_count */ 14:
                    message.maxDerivativeOrderSideCount = reader.uint32();
                    break;
                case /* string inj_reward_staked_requirement_threshold */ 15:
                    message.injRewardStakedRequirementThreshold = reader.string();
                    break;
                case /* int64 trading_rewards_vesting_duration */ 16:
                    message.tradingRewardsVestingDuration = reader.int64().toBigInt();
                    break;
                case /* string liquidator_reward_share_rate */ 17:
                    message.liquidatorRewardShareRate = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee */ 18:
                    message.binaryOptionsMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.binaryOptionsMarketInstantListingFee);
                    break;
                case /* injective.exchange.v2.AtomicMarketOrderAccessLevel atomic_market_order_access_level */ 19:
                    message.atomicMarketOrderAccessLevel = reader.int32();
                    break;
                case /* string spot_atomic_market_order_fee_multiplier */ 20:
                    message.spotAtomicMarketOrderFeeMultiplier = reader.string();
                    break;
                case /* string derivative_atomic_market_order_fee_multiplier */ 21:
                    message.derivativeAtomicMarketOrderFeeMultiplier = reader.string();
                    break;
                case /* string binary_options_atomic_market_order_fee_multiplier */ 22:
                    message.binaryOptionsAtomicMarketOrderFeeMultiplier = reader.string();
                    break;
                case /* string minimal_protocol_fee_rate */ 23:
                    message.minimalProtocolFeeRate = reader.string();
                    break;
                case /* bool is_instant_derivative_market_launch_enabled */ 24:
                    message.isInstantDerivativeMarketLaunchEnabled = reader.bool();
                    break;
                case /* int64 post_only_mode_height_threshold */ 25:
                    message.postOnlyModeHeightThreshold = reader.int64().toBigInt();
                    break;
                case /* int64 margin_decrease_price_timestamp_threshold_seconds */ 26:
                    message.marginDecreasePriceTimestampThresholdSeconds = reader.int64().toBigInt();
                    break;
                case /* repeated string exchange_admins */ 27:
                    message.exchangeAdmins.push(reader.string());
                    break;
                case /* string inj_auction_max_cap */ 28:
                    message.injAuctionMaxCap = reader.string();
                    break;
                case /* bool fixed_gas_enabled */ 29:
                    message.fixedGasEnabled = reader.bool();
                    break;
                case /* bool emit_legacy_version_events */ 30:
                    message.emitLegacyVersionEvents = reader.bool();
                    break;
                case /* string default_reduce_margin_ratio */ 31:
                    message.defaultReduceMarginRatio = reader.string();
                    break;
                case /* uint64 post_only_mode_blocks_amount */ 33:
                    message.postOnlyModeBlocksAmount = reader.uint64().toBigInt();
                    break;
                case /* string min_post_only_mode_downtime_duration */ 34:
                    message.minPostOnlyModeDowntimeDuration = reader.string();
                    break;
                case /* uint64 post_only_mode_blocks_amount_after_downtime */ 35:
                    message.postOnlyModeBlocksAmountAfterDowntime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1; */
        if (message.spotMarketInstantListingFee)
            Coin.internalBinaryWrite(message.spotMarketInstantListingFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2; */
        if (message.derivativeMarketInstantListingFee)
            Coin.internalBinaryWrite(message.derivativeMarketInstantListingFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string default_spot_maker_fee_rate = 3; */
        if (message.defaultSpotMakerFeeRate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.defaultSpotMakerFeeRate);
        /* string default_spot_taker_fee_rate = 4; */
        if (message.defaultSpotTakerFeeRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.defaultSpotTakerFeeRate);
        /* string default_derivative_maker_fee_rate = 5; */
        if (message.defaultDerivativeMakerFeeRate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.defaultDerivativeMakerFeeRate);
        /* string default_derivative_taker_fee_rate = 6; */
        if (message.defaultDerivativeTakerFeeRate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.defaultDerivativeTakerFeeRate);
        /* string default_initial_margin_ratio = 7; */
        if (message.defaultInitialMarginRatio !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.defaultInitialMarginRatio);
        /* string default_maintenance_margin_ratio = 8; */
        if (message.defaultMaintenanceMarginRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.defaultMaintenanceMarginRatio);
        /* int64 default_funding_interval = 9; */
        if (message.defaultFundingInterval !== 0n)
            writer.tag(9, WireType.Varint).int64(message.defaultFundingInterval);
        /* int64 funding_multiple = 10; */
        if (message.fundingMultiple !== 0n)
            writer.tag(10, WireType.Varint).int64(message.fundingMultiple);
        /* string relayer_fee_share_rate = 11; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* string default_hourly_funding_rate_cap = 12; */
        if (message.defaultHourlyFundingRateCap !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.defaultHourlyFundingRateCap);
        /* string default_hourly_interest_rate = 13; */
        if (message.defaultHourlyInterestRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.defaultHourlyInterestRate);
        /* uint32 max_derivative_order_side_count = 14; */
        if (message.maxDerivativeOrderSideCount !== 0)
            writer.tag(14, WireType.Varint).uint32(message.maxDerivativeOrderSideCount);
        /* string inj_reward_staked_requirement_threshold = 15; */
        if (message.injRewardStakedRequirementThreshold !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.injRewardStakedRequirementThreshold);
        /* int64 trading_rewards_vesting_duration = 16; */
        if (message.tradingRewardsVestingDuration !== 0n)
            writer.tag(16, WireType.Varint).int64(message.tradingRewardsVestingDuration);
        /* string liquidator_reward_share_rate = 17; */
        if (message.liquidatorRewardShareRate !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.liquidatorRewardShareRate);
        /* cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18; */
        if (message.binaryOptionsMarketInstantListingFee)
            Coin.internalBinaryWrite(message.binaryOptionsMarketInstantListingFee, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19; */
        if (message.atomicMarketOrderAccessLevel !== 0)
            writer.tag(19, WireType.Varint).int32(message.atomicMarketOrderAccessLevel);
        /* string spot_atomic_market_order_fee_multiplier = 20; */
        if (message.spotAtomicMarketOrderFeeMultiplier !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.spotAtomicMarketOrderFeeMultiplier);
        /* string derivative_atomic_market_order_fee_multiplier = 21; */
        if (message.derivativeAtomicMarketOrderFeeMultiplier !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.derivativeAtomicMarketOrderFeeMultiplier);
        /* string binary_options_atomic_market_order_fee_multiplier = 22; */
        if (message.binaryOptionsAtomicMarketOrderFeeMultiplier !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.binaryOptionsAtomicMarketOrderFeeMultiplier);
        /* string minimal_protocol_fee_rate = 23; */
        if (message.minimalProtocolFeeRate !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.minimalProtocolFeeRate);
        /* bool is_instant_derivative_market_launch_enabled = 24; */
        if (message.isInstantDerivativeMarketLaunchEnabled !== false)
            writer.tag(24, WireType.Varint).bool(message.isInstantDerivativeMarketLaunchEnabled);
        /* int64 post_only_mode_height_threshold = 25; */
        if (message.postOnlyModeHeightThreshold !== 0n)
            writer.tag(25, WireType.Varint).int64(message.postOnlyModeHeightThreshold);
        /* int64 margin_decrease_price_timestamp_threshold_seconds = 26; */
        if (message.marginDecreasePriceTimestampThresholdSeconds !== 0n)
            writer.tag(26, WireType.Varint).int64(message.marginDecreasePriceTimestampThresholdSeconds);
        /* repeated string exchange_admins = 27; */
        for (let i = 0; i < message.exchangeAdmins.length; i++)
            writer.tag(27, WireType.LengthDelimited).string(message.exchangeAdmins[i]);
        /* string inj_auction_max_cap = 28; */
        if (message.injAuctionMaxCap !== "")
            writer.tag(28, WireType.LengthDelimited).string(message.injAuctionMaxCap);
        /* bool fixed_gas_enabled = 29; */
        if (message.fixedGasEnabled !== false)
            writer.tag(29, WireType.Varint).bool(message.fixedGasEnabled);
        /* bool emit_legacy_version_events = 30; */
        if (message.emitLegacyVersionEvents !== false)
            writer.tag(30, WireType.Varint).bool(message.emitLegacyVersionEvents);
        /* string default_reduce_margin_ratio = 31; */
        if (message.defaultReduceMarginRatio !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.defaultReduceMarginRatio);
        /* uint64 post_only_mode_blocks_amount = 33; */
        if (message.postOnlyModeBlocksAmount !== 0n)
            writer.tag(33, WireType.Varint).uint64(message.postOnlyModeBlocksAmount);
        /* string min_post_only_mode_downtime_duration = 34; */
        if (message.minPostOnlyModeDowntimeDuration !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.minPostOnlyModeDowntimeDuration);
        /* uint64 post_only_mode_blocks_amount_after_downtime = 35; */
        if (message.postOnlyModeBlocksAmountAfterDowntime !== 0n)
            writer.tag(35, WireType.Varint).uint64(message.postOnlyModeBlocksAmountAfterDowntime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.Params
 */
export const Params = new Params$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NextFundingTimestamp$Type extends MessageType<NextFundingTimestamp> {
    constructor() {
        super("injective.exchange.v2.NextFundingTimestamp", [
            { no: 1, name: "next_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<NextFundingTimestamp>): NextFundingTimestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nextTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<NextFundingTimestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NextFundingTimestamp): NextFundingTimestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 next_timestamp */ 1:
                    message.nextTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NextFundingTimestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 next_timestamp = 1; */
        if (message.nextTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.nextTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.NextFundingTimestamp
 */
export const NextFundingTimestamp = new NextFundingTimestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidPriceAndTOB$Type extends MessageType<MidPriceAndTOB> {
    constructor() {
        super("injective.exchange.v2.MidPriceAndTOB", [
            { no: 1, name: "mid_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<MidPriceAndTOB>): MidPriceAndTOB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.midPrice = "";
        message.bestBuyPrice = "";
        message.bestSellPrice = "";
        if (value !== undefined)
            reflectionMergePartial<MidPriceAndTOB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidPriceAndTOB): MidPriceAndTOB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mid_price */ 1:
                    message.midPrice = reader.string();
                    break;
                case /* string best_buy_price */ 2:
                    message.bestBuyPrice = reader.string();
                    break;
                case /* string best_sell_price */ 3:
                    message.bestSellPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidPriceAndTOB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mid_price = 1; */
        if (message.midPrice !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
        /* string best_buy_price = 2; */
        if (message.bestBuyPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
        /* string best_sell_price = 3; */
        if (message.bestSellPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MidPriceAndTOB
 */
export const MidPriceAndTOB = new MidPriceAndTOB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Deposit$Type extends MessageType<Deposit> {
    constructor() {
        super("injective.exchange.v2.Deposit", [
            { no: 1, name: "available_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "total_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Deposit>): Deposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.availableBalance = "";
        message.totalBalance = "";
        if (value !== undefined)
            reflectionMergePartial<Deposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Deposit): Deposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string available_balance */ 1:
                    message.availableBalance = reader.string();
                    break;
                case /* string total_balance */ 2:
                    message.totalBalance = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Deposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string available_balance = 1; */
        if (message.availableBalance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.availableBalance);
        /* string total_balance = 2; */
        if (message.totalBalance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.totalBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.Deposit
 */
export const Deposit = new Deposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountTradeNonce$Type extends MessageType<SubaccountTradeNonce> {
    constructor() {
        super("injective.exchange.v2.SubaccountTradeNonce", [
            { no: 1, name: "nonce", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountTradeNonce>): SubaccountTradeNonce {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0;
        if (value !== undefined)
            reflectionMergePartial<SubaccountTradeNonce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountTradeNonce): SubaccountTradeNonce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 nonce */ 1:
                    message.nonce = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountTradeNonce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 nonce = 1; */
        if (message.nonce !== 0)
            writer.tag(1, WireType.Varint).uint32(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountTradeNonce
 */
export const SubaccountTradeNonce = new SubaccountTradeNonce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrder$Type extends MessageType<SubaccountOrder> {
    constructor() {
        super("injective.exchange.v2.SubaccountOrder", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "isReduceOnly", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrder>): SubaccountOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.isReduceOnly = false;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrder): SubaccountOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* bool isReduceOnly */ 3:
                    message.isReduceOnly = reader.bool();
                    break;
                case /* string cid */ 4:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* bool isReduceOnly = 3; */
        if (message.isReduceOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.isReduceOnly);
        /* string cid = 4; */
        if (message.cid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountOrder
 */
export const SubaccountOrder = new SubaccountOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrderData$Type extends MessageType<SubaccountOrderData> {
    constructor() {
        super("injective.exchange.v2.SubaccountOrderData", [
            { no: 1, name: "order", kind: "message", T: () => SubaccountOrder },
            { no: 2, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrderData>): SubaccountOrderData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrderData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrderData): SubaccountOrderData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.SubaccountOrder order */ 1:
                    message.order = SubaccountOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* bytes order_hash */ 2:
                    message.orderHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrderData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.SubaccountOrder order = 1; */
        if (message.order)
            SubaccountOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes order_hash = 2; */
        if (message.orderHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.orderHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountOrderData
 */
export const SubaccountOrderData = new SubaccountOrderData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("injective.exchange.v2.Position", [
            { no: 1, name: "isLong", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLong = false;
        message.quantity = "";
        message.entryPrice = "";
        message.margin = "";
        message.cumulativeFundingEntry = "";
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isLong */ 1:
                    message.isLong = reader.bool();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 3:
                    message.entryPrice = reader.string();
                    break;
                case /* string margin */ 4:
                    message.margin = reader.string();
                    break;
                case /* string cumulative_funding_entry */ 5:
                    message.cumulativeFundingEntry = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isLong = 1; */
        if (message.isLong !== false)
            writer.tag(1, WireType.Varint).bool(message.isLong);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 3; */
        if (message.entryPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.entryPrice);
        /* string margin = 4; */
        if (message.margin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.margin);
        /* string cumulative_funding_entry = 5; */
        if (message.cumulativeFundingEntry !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Balance$Type extends MessageType<Balance> {
    constructor() {
        super("injective.exchange.v2.Balance", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deposits", kind: "message", T: () => Deposit }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<Balance>): Balance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<Balance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Balance): Balance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* injective.exchange.v2.Deposit deposits */ 3:
                    message.deposits = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposits);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Balance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* injective.exchange.v2.Deposit deposits = 3; */
        if (message.deposits)
            Deposit.internalBinaryWrite(message.deposits, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.Balance
 */
export const Balance = new Balance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativePosition$Type extends MessageType<DerivativePosition> {
    constructor() {
        super("injective.exchange.v2.DerivativePosition", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "position", kind: "message", T: () => Position }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<DerivativePosition>): DerivativePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativePosition): DerivativePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v2.Position position */ 3:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v2.Position position = 3; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DerivativePosition
 */
export const DerivativePosition = new DerivativePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketOrderIndicator$Type extends MessageType<MarketOrderIndicator> {
    constructor() {
        super("injective.exchange.v2.MarketOrderIndicator", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isBuy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MarketOrderIndicator>): MarketOrderIndicator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isBuy = false;
        if (value !== undefined)
            reflectionMergePartial<MarketOrderIndicator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketOrderIndicator): MarketOrderIndicator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool isBuy */ 2:
                    message.isBuy = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketOrderIndicator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool isBuy = 2; */
        if (message.isBuy !== false)
            writer.tag(2, WireType.Varint).bool(message.isBuy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MarketOrderIndicator
 */
export const MarketOrderIndicator = new MarketOrderIndicator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeLog$Type extends MessageType<TradeLog> {
    constructor() {
        super("injective.exchange.v2.TradeLog", [
            { no: 1, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.nullable": true } },
            { no: 7, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradeLog>): TradeLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = "";
        message.price = "";
        message.subaccountId = new Uint8Array(0);
        message.fee = "";
        message.orderHash = new Uint8Array(0);
        message.feeRecipientAddress = new Uint8Array(0);
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<TradeLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeLog): TradeLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string quantity */ 1:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* bytes subaccount_id */ 3:
                    message.subaccountId = reader.bytes();
                    break;
                case /* string fee */ 4:
                    message.fee = reader.string();
                    break;
                case /* bytes order_hash */ 5:
                    message.orderHash = reader.bytes();
                    break;
                case /* bytes fee_recipient_address */ 6:
                    message.feeRecipientAddress = reader.bytes();
                    break;
                case /* string cid */ 7:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string quantity = 1; */
        if (message.quantity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.quantity);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* bytes subaccount_id = 3; */
        if (message.subaccountId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.subaccountId);
        /* string fee = 4; */
        if (message.fee !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fee);
        /* bytes order_hash = 5; */
        if (message.orderHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
        /* bytes fee_recipient_address = 6; */
        if (message.feeRecipientAddress.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
        /* string cid = 7; */
        if (message.cid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradeLog
 */
export const TradeLog = new TradeLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionDelta$Type extends MessageType<PositionDelta> {
    constructor() {
        super("injective.exchange.v2.PositionDelta", [
            { no: 1, name: "is_long", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "execution_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "execution_margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "execution_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<PositionDelta>): PositionDelta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLong = false;
        message.executionQuantity = "";
        message.executionMargin = "";
        message.executionPrice = "";
        if (value !== undefined)
            reflectionMergePartial<PositionDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionDelta): PositionDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_long */ 1:
                    message.isLong = reader.bool();
                    break;
                case /* string execution_quantity */ 2:
                    message.executionQuantity = reader.string();
                    break;
                case /* string execution_margin */ 3:
                    message.executionMargin = reader.string();
                    break;
                case /* string execution_price */ 4:
                    message.executionPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_long = 1; */
        if (message.isLong !== false)
            writer.tag(1, WireType.Varint).bool(message.isLong);
        /* string execution_quantity = 2; */
        if (message.executionQuantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionQuantity);
        /* string execution_margin = 3; */
        if (message.executionMargin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionMargin);
        /* string execution_price = 4; */
        if (message.executionPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.executionPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PositionDelta
 */
export const PositionDelta = new PositionDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeTradeLog$Type extends MessageType<DerivativeTradeLog> {
    constructor() {
        super("injective.exchange.v2.DerivativeTradeLog", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "position_delta", kind: "message", T: () => PositionDelta },
            { no: 3, name: "payout", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.nullable": true } },
            { no: 7, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DerivativeTradeLog>): DerivativeTradeLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = new Uint8Array(0);
        message.payout = "";
        message.fee = "";
        message.orderHash = new Uint8Array(0);
        message.feeRecipientAddress = new Uint8Array(0);
        message.cid = "";
        message.pnl = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeTradeLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeTradeLog): DerivativeTradeLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes subaccount_id */ 1:
                    message.subaccountId = reader.bytes();
                    break;
                case /* injective.exchange.v2.PositionDelta position_delta */ 2:
                    message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
                    break;
                case /* string payout */ 3:
                    message.payout = reader.string();
                    break;
                case /* string fee */ 4:
                    message.fee = reader.string();
                    break;
                case /* bytes order_hash */ 5:
                    message.orderHash = reader.bytes();
                    break;
                case /* bytes fee_recipient_address */ 6:
                    message.feeRecipientAddress = reader.bytes();
                    break;
                case /* string cid */ 7:
                    message.cid = reader.string();
                    break;
                case /* string pnl */ 8:
                    message.pnl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeTradeLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes subaccount_id = 1; */
        if (message.subaccountId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
        /* injective.exchange.v2.PositionDelta position_delta = 2; */
        if (message.positionDelta)
            PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string payout = 3; */
        if (message.payout !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payout);
        /* string fee = 4; */
        if (message.fee !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fee);
        /* bytes order_hash = 5; */
        if (message.orderHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
        /* bytes fee_recipient_address = 6; */
        if (message.feeRecipientAddress.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
        /* string cid = 7; */
        if (message.cid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cid);
        /* string pnl = 8; */
        if (message.pnl !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.pnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DerivativeTradeLog
 */
export const DerivativeTradeLog = new DerivativeTradeLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountPosition$Type extends MessageType<SubaccountPosition> {
    constructor() {
        super("injective.exchange.v2.SubaccountPosition", [
            { no: 1, name: "position", kind: "message", T: () => Position },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountPosition>): SubaccountPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubaccountPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountPosition): SubaccountPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* bytes subaccount_id */ 2:
                    message.subaccountId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes subaccount_id = 2; */
        if (message.subaccountId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountPosition
 */
export const SubaccountPosition = new SubaccountPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountDeposit$Type extends MessageType<SubaccountDeposit> {
    constructor() {
        super("injective.exchange.v2.SubaccountDeposit", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "deposit", kind: "message", T: () => Deposit }
        ]);
    }
    create(value?: PartialMessage<SubaccountDeposit>): SubaccountDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubaccountDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountDeposit): SubaccountDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes subaccount_id */ 1:
                    message.subaccountId = reader.bytes();
                    break;
                case /* injective.exchange.v2.Deposit deposit */ 2:
                    message.deposit = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes subaccount_id = 1; */
        if (message.subaccountId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
        /* injective.exchange.v2.Deposit deposit = 2; */
        if (message.deposit)
            Deposit.internalBinaryWrite(message.deposit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountDeposit
 */
export const SubaccountDeposit = new SubaccountDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DepositUpdate$Type extends MessageType<DepositUpdate> {
    constructor() {
        super("injective.exchange.v2.DepositUpdate", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deposits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountDeposit }
        ]);
    }
    create(value?: PartialMessage<DepositUpdate>): DepositUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.deposits = [];
        if (value !== undefined)
            reflectionMergePartial<DepositUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DepositUpdate): DepositUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* repeated injective.exchange.v2.SubaccountDeposit deposits */ 2:
                    message.deposits.push(SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DepositUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* repeated injective.exchange.v2.SubaccountDeposit deposits = 2; */
        for (let i = 0; i < message.deposits.length; i++)
            SubaccountDeposit.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DepositUpdate
 */
export const DepositUpdate = new DepositUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsMultiplier$Type extends MessageType<PointsMultiplier> {
    constructor() {
        super("injective.exchange.v2.PointsMultiplier", [
            { no: 1, name: "maker_points_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "taker_points_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<PointsMultiplier>): PointsMultiplier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.makerPointsMultiplier = "";
        message.takerPointsMultiplier = "";
        if (value !== undefined)
            reflectionMergePartial<PointsMultiplier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsMultiplier): PointsMultiplier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string maker_points_multiplier */ 1:
                    message.makerPointsMultiplier = reader.string();
                    break;
                case /* string taker_points_multiplier */ 2:
                    message.takerPointsMultiplier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsMultiplier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string maker_points_multiplier = 1; */
        if (message.makerPointsMultiplier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.makerPointsMultiplier);
        /* string taker_points_multiplier = 2; */
        if (message.takerPointsMultiplier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.takerPointsMultiplier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PointsMultiplier
 */
export const PointsMultiplier = new PointsMultiplier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignBoostInfo$Type extends MessageType<TradingRewardCampaignBoostInfo> {
    constructor() {
        super("injective.exchange.v2.TradingRewardCampaignBoostInfo", [
            { no: 1, name: "boosted_spot_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spot_market_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } },
            { no: 3, name: "boosted_derivative_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "derivative_market_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<TradingRewardCampaignBoostInfo>): TradingRewardCampaignBoostInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boostedSpotMarketIds = [];
        message.spotMarketMultipliers = [];
        message.boostedDerivativeMarketIds = [];
        message.derivativeMarketMultipliers = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignBoostInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignBoostInfo): TradingRewardCampaignBoostInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string boosted_spot_market_ids */ 1:
                    message.boostedSpotMarketIds.push(reader.string());
                    break;
                case /* repeated injective.exchange.v2.PointsMultiplier spot_market_multipliers */ 2:
                    message.spotMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string boosted_derivative_market_ids */ 3:
                    message.boostedDerivativeMarketIds.push(reader.string());
                    break;
                case /* repeated injective.exchange.v2.PointsMultiplier derivative_market_multipliers */ 4:
                    message.derivativeMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignBoostInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string boosted_spot_market_ids = 1; */
        for (let i = 0; i < message.boostedSpotMarketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.boostedSpotMarketIds[i]);
        /* repeated injective.exchange.v2.PointsMultiplier spot_market_multipliers = 2; */
        for (let i = 0; i < message.spotMarketMultipliers.length; i++)
            PointsMultiplier.internalBinaryWrite(message.spotMarketMultipliers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string boosted_derivative_market_ids = 3; */
        for (let i = 0; i < message.boostedDerivativeMarketIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.boostedDerivativeMarketIds[i]);
        /* repeated injective.exchange.v2.PointsMultiplier derivative_market_multipliers = 4; */
        for (let i = 0; i < message.derivativeMarketMultipliers.length; i++)
            PointsMultiplier.internalBinaryWrite(message.derivativeMarketMultipliers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradingRewardCampaignBoostInfo
 */
export const TradingRewardCampaignBoostInfo = new TradingRewardCampaignBoostInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CampaignRewardPool$Type extends MessageType<CampaignRewardPool> {
    constructor() {
        super("injective.exchange.v2.CampaignRewardPool", [
            { no: 1, name: "start_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_campaign_rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<CampaignRewardPool>): CampaignRewardPool {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startTimestamp = 0n;
        message.maxCampaignRewards = [];
        if (value !== undefined)
            reflectionMergePartial<CampaignRewardPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CampaignRewardPool): CampaignRewardPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 start_timestamp */ 1:
                    message.startTimestamp = reader.int64().toBigInt();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin max_campaign_rewards */ 2:
                    message.maxCampaignRewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CampaignRewardPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 start_timestamp = 1; */
        if (message.startTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.startTimestamp);
        /* repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2; */
        for (let i = 0; i < message.maxCampaignRewards.length; i++)
            Coin.internalBinaryWrite(message.maxCampaignRewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.CampaignRewardPool
 */
export const CampaignRewardPool = new CampaignRewardPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignInfo$Type extends MessageType<TradingRewardCampaignInfo> {
    constructor() {
        super("injective.exchange.v2.TradingRewardCampaignInfo", [
            { no: 1, name: "campaign_duration_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "quote_denoms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "trading_reward_boost_info", kind: "message", T: () => TradingRewardCampaignBoostInfo },
            { no: 4, name: "disqualified_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradingRewardCampaignInfo>): TradingRewardCampaignInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.campaignDurationSeconds = 0n;
        message.quoteDenoms = [];
        message.disqualifiedMarketIds = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignInfo): TradingRewardCampaignInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 campaign_duration_seconds */ 1:
                    message.campaignDurationSeconds = reader.int64().toBigInt();
                    break;
                case /* repeated string quote_denoms */ 2:
                    message.quoteDenoms.push(reader.string());
                    break;
                case /* injective.exchange.v2.TradingRewardCampaignBoostInfo trading_reward_boost_info */ 3:
                    message.tradingRewardBoostInfo = TradingRewardCampaignBoostInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardBoostInfo);
                    break;
                case /* repeated string disqualified_market_ids */ 4:
                    message.disqualifiedMarketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 campaign_duration_seconds = 1; */
        if (message.campaignDurationSeconds !== 0n)
            writer.tag(1, WireType.Varint).int64(message.campaignDurationSeconds);
        /* repeated string quote_denoms = 2; */
        for (let i = 0; i < message.quoteDenoms.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.quoteDenoms[i]);
        /* injective.exchange.v2.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3; */
        if (message.tradingRewardBoostInfo)
            TradingRewardCampaignBoostInfo.internalBinaryWrite(message.tradingRewardBoostInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string disqualified_market_ids = 4; */
        for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradingRewardCampaignInfo
 */
export const TradingRewardCampaignInfo = new TradingRewardCampaignInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountTierInfo$Type extends MessageType<FeeDiscountTierInfo> {
    constructor() {
        super("injective.exchange.v2.FeeDiscountTierInfo", [
            { no: 1, name: "maker_discount_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "taker_discount_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "staked_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 4, name: "volume", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountTierInfo>): FeeDiscountTierInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.makerDiscountRate = "";
        message.takerDiscountRate = "";
        message.stakedAmount = "";
        message.volume = "";
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountTierInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountTierInfo): FeeDiscountTierInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string maker_discount_rate */ 1:
                    message.makerDiscountRate = reader.string();
                    break;
                case /* string taker_discount_rate */ 2:
                    message.takerDiscountRate = reader.string();
                    break;
                case /* string staked_amount */ 3:
                    message.stakedAmount = reader.string();
                    break;
                case /* string volume */ 4:
                    message.volume = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountTierInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string maker_discount_rate = 1; */
        if (message.makerDiscountRate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.makerDiscountRate);
        /* string taker_discount_rate = 2; */
        if (message.takerDiscountRate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.takerDiscountRate);
        /* string staked_amount = 3; */
        if (message.stakedAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stakedAmount);
        /* string volume = 4; */
        if (message.volume !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FeeDiscountTierInfo
 */
export const FeeDiscountTierInfo = new FeeDiscountTierInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountSchedule$Type extends MessageType<FeeDiscountSchedule> {
    constructor() {
        super("injective.exchange.v2.FeeDiscountSchedule", [
            { no: 1, name: "bucket_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bucket_duration", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "quote_denoms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tier_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeeDiscountTierInfo },
            { no: 5, name: "disqualified_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountSchedule>): FeeDiscountSchedule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketCount = 0n;
        message.bucketDuration = 0n;
        message.quoteDenoms = [];
        message.tierInfos = [];
        message.disqualifiedMarketIds = [];
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountSchedule): FeeDiscountSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 bucket_count */ 1:
                    message.bucketCount = reader.uint64().toBigInt();
                    break;
                case /* int64 bucket_duration */ 2:
                    message.bucketDuration = reader.int64().toBigInt();
                    break;
                case /* repeated string quote_denoms */ 3:
                    message.quoteDenoms.push(reader.string());
                    break;
                case /* repeated injective.exchange.v2.FeeDiscountTierInfo tier_infos */ 4:
                    message.tierInfos.push(FeeDiscountTierInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string disqualified_market_ids */ 5:
                    message.disqualifiedMarketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 bucket_count = 1; */
        if (message.bucketCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.bucketCount);
        /* int64 bucket_duration = 2; */
        if (message.bucketDuration !== 0n)
            writer.tag(2, WireType.Varint).int64(message.bucketDuration);
        /* repeated string quote_denoms = 3; */
        for (let i = 0; i < message.quoteDenoms.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenoms[i]);
        /* repeated injective.exchange.v2.FeeDiscountTierInfo tier_infos = 4; */
        for (let i = 0; i < message.tierInfos.length; i++)
            FeeDiscountTierInfo.internalBinaryWrite(message.tierInfos[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string disqualified_market_ids = 5; */
        for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FeeDiscountSchedule
 */
export const FeeDiscountSchedule = new FeeDiscountSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountTierTTL$Type extends MessageType<FeeDiscountTierTTL> {
    constructor() {
        super("injective.exchange.v2.FeeDiscountTierTTL", [
            { no: 1, name: "tier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ttl_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountTierTTL>): FeeDiscountTierTTL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tier = 0n;
        message.ttlTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountTierTTL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountTierTTL): FeeDiscountTierTTL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 tier */ 1:
                    message.tier = reader.uint64().toBigInt();
                    break;
                case /* int64 ttl_timestamp */ 2:
                    message.ttlTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountTierTTL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 tier = 1; */
        if (message.tier !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.tier);
        /* int64 ttl_timestamp = 2; */
        if (message.ttlTimestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.ttlTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FeeDiscountTierTTL
 */
export const FeeDiscountTierTTL = new FeeDiscountTierTTL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountRewards$Type extends MessageType<AccountRewards> {
    constructor() {
        super("injective.exchange.v2.AccountRewards", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<AccountRewards>): AccountRewards {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.rewards = [];
        if (value !== undefined)
            reflectionMergePartial<AccountRewards>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountRewards): AccountRewards {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin rewards */ 2:
                    message.rewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountRewards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* repeated cosmos.base.v1beta1.Coin rewards = 2; */
        for (let i = 0; i < message.rewards.length; i++)
            Coin.internalBinaryWrite(message.rewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.AccountRewards
 */
export const AccountRewards = new AccountRewards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeRecords$Type extends MessageType<TradeRecords> {
    constructor() {
        super("injective.exchange.v2.TradeRecords", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "latest_trade_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradeRecord }
        ]);
    }
    create(value?: PartialMessage<TradeRecords>): TradeRecords {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.latestTradeRecords = [];
        if (value !== undefined)
            reflectionMergePartial<TradeRecords>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeRecords): TradeRecords {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* repeated injective.exchange.v2.TradeRecord latest_trade_records */ 2:
                    message.latestTradeRecords.push(TradeRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeRecords, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* repeated injective.exchange.v2.TradeRecord latest_trade_records = 2; */
        for (let i = 0; i < message.latestTradeRecords.length; i++)
            TradeRecord.internalBinaryWrite(message.latestTradeRecords[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradeRecords
 */
export const TradeRecords = new TradeRecords$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountIDs$Type extends MessageType<SubaccountIDs> {
    constructor() {
        super("injective.exchange.v2.SubaccountIDs", [
            { no: 1, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountIDs>): SubaccountIDs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountIds = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountIDs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountIDs): SubaccountIDs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes subaccount_ids */ 1:
                    message.subaccountIds.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountIDs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes subaccount_ids = 1; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountIDs
 */
export const SubaccountIDs = new SubaccountIDs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeRecord$Type extends MessageType<TradeRecord> {
    constructor() {
        super("injective.exchange.v2.TradeRecord", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<TradeRecord>): TradeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        message.price = "";
        message.quantity = "";
        if (value !== undefined)
            reflectionMergePartial<TradeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeRecord): TradeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 3:
                    message.quantity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* string quantity = 3; */
        if (message.quantity !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradeRecord
 */
export const TradeRecord = new TradeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Level$Type extends MessageType<Level> {
    constructor() {
        super("injective.exchange.v2.Level", [
            { no: 1, name: "p", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "q", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Level>): Level {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.p = "";
        message.q = "";
        if (value !== undefined)
            reflectionMergePartial<Level>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Level): Level {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string p */ 1:
                    message.p = reader.string();
                    break;
                case /* string q */ 2:
                    message.q = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Level, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string p = 1; */
        if (message.p !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.p);
        /* string q = 2; */
        if (message.q !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.q);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.Level
 */
export const Level = new Level$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateSubaccountVolumeRecord$Type extends MessageType<AggregateSubaccountVolumeRecord> {
    constructor() {
        super("injective.exchange.v2.AggregateSubaccountVolumeRecord", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<AggregateSubaccountVolumeRecord>): AggregateSubaccountVolumeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketVolumes = [];
        if (value !== undefined)
            reflectionMergePartial<AggregateSubaccountVolumeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateSubaccountVolumeRecord): AggregateSubaccountVolumeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated injective.exchange.v2.MarketVolume market_volumes */ 2:
                    message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateSubaccountVolumeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated injective.exchange.v2.MarketVolume market_volumes = 2; */
        for (let i = 0; i < message.marketVolumes.length; i++)
            MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.AggregateSubaccountVolumeRecord
 */
export const AggregateSubaccountVolumeRecord = new AggregateSubaccountVolumeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateAccountVolumeRecord$Type extends MessageType<AggregateAccountVolumeRecord> {
    constructor() {
        super("injective.exchange.v2.AggregateAccountVolumeRecord", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<AggregateAccountVolumeRecord>): AggregateAccountVolumeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.marketVolumes = [];
        if (value !== undefined)
            reflectionMergePartial<AggregateAccountVolumeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateAccountVolumeRecord): AggregateAccountVolumeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* repeated injective.exchange.v2.MarketVolume market_volumes */ 2:
                    message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateAccountVolumeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* repeated injective.exchange.v2.MarketVolume market_volumes = 2; */
        for (let i = 0; i < message.marketVolumes.length; i++)
            MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.AggregateAccountVolumeRecord
 */
export const AggregateAccountVolumeRecord = new AggregateAccountVolumeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomDecimals$Type extends MessageType<DenomDecimals> {
    constructor() {
        super("injective.exchange.v2.DenomDecimals", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "decimals", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DenomDecimals>): DenomDecimals {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.decimals = 0n;
        if (value !== undefined)
            reflectionMergePartial<DenomDecimals>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomDecimals): DenomDecimals {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* uint64 decimals */ 2:
                    message.decimals = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomDecimals, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* uint64 decimals = 2; */
        if (message.decimals !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.decimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DenomDecimals
 */
export const DenomDecimals = new DenomDecimals$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrantAuthorization$Type extends MessageType<GrantAuthorization> {
    constructor() {
        super("injective.exchange.v2.GrantAuthorization", [
            { no: 1, name: "grantee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
        ]);
    }
    create(value?: PartialMessage<GrantAuthorization>): GrantAuthorization {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantee = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<GrantAuthorization>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrantAuthorization): GrantAuthorization {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grantee */ 1:
                    message.grantee = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GrantAuthorization, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grantee = 1; */
        if (message.grantee !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantee);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.GrantAuthorization
 */
export const GrantAuthorization = new GrantAuthorization$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveGrant$Type extends MessageType<ActiveGrant> {
    constructor() {
        super("injective.exchange.v2.ActiveGrant", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
        ]);
    }
    create(value?: PartialMessage<ActiveGrant>): ActiveGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<ActiveGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveGrant): ActiveGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.ActiveGrant
 */
export const ActiveGrant = new ActiveGrant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EffectiveGrant$Type extends MessageType<EffectiveGrant> {
    constructor() {
        super("injective.exchange.v2.EffectiveGrant", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "net_granted_stake", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 3, name: "is_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EffectiveGrant>): EffectiveGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        message.netGrantedStake = "";
        message.isValid = false;
        if (value !== undefined)
            reflectionMergePartial<EffectiveGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffectiveGrant): EffectiveGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                case /* string net_granted_stake */ 2:
                    message.netGrantedStake = reader.string();
                    break;
                case /* bool is_valid */ 3:
                    message.isValid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EffectiveGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        /* string net_granted_stake = 2; */
        if (message.netGrantedStake !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.netGrantedStake);
        /* bool is_valid = 3; */
        if (message.isValid !== false)
            writer.tag(3, WireType.Varint).bool(message.isValid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.EffectiveGrant
 */
export const EffectiveGrant = new EffectiveGrant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomMinNotional$Type extends MessageType<DenomMinNotional> {
    constructor() {
        super("injective.exchange.v2.DenomMinNotional", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DenomMinNotional>): DenomMinNotional {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<DenomMinNotional>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomMinNotional): DenomMinNotional {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string min_notional */ 2:
                    message.minNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomMinNotional, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string min_notional = 2; */
        if (message.minNotional !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.minNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DenomMinNotional
 */
export const DenomMinNotional = new DenomMinNotional$Type();
