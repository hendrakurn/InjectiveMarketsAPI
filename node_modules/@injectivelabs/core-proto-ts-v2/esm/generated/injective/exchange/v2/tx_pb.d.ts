// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v2/tx.proto" (package "injective.exchange.v2", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AtomicMarketOrderFeeMultiplierScheduleProposal } from "./proposal_pb";
import { FeeDiscountProposal } from "./proposal_pb";
import { TradingRewardPendingPointsUpdateProposal } from "./proposal_pb";
import { TradingRewardCampaignUpdateProposal } from "./proposal_pb";
import { ExchangeEnableProposal } from "./proposal_pb";
import { TradingRewardCampaignLaunchProposal } from "./proposal_pb";
import { MarketForcedSettlementProposal } from "./proposal_pb";
import { BinaryOptionsMarketParamUpdateProposal } from "./proposal_pb";
import { DerivativeMarketParamUpdateProposal } from "./proposal_pb";
import { SpotMarketParamUpdateProposal } from "./proposal_pb";
import { BatchCommunityPoolSpendProposal } from "./proposal_pb";
import { BinaryOptionsMarketLaunchProposal } from "./proposal_pb";
import { ExpiryFuturesMarketLaunchProposal } from "./proposal_pb";
import { PerpetualMarketLaunchProposal } from "./proposal_pb";
import { SpotMarketLaunchProposal } from "./proposal_pb";
import { BatchExchangeModificationProposal } from "./proposal_pb";
import { GrantAuthorization } from "./exchange_pb";
import { MarketStatus } from "./market_pb";
import { PositionDelta } from "./exchange_pb";
import { DerivativeOrder } from "./order_pb";
import { OracleType } from "../../oracle/v1beta1/oracle_pb";
import { SpotOrder } from "./order_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
import { Params } from "./exchange_pb";
import { OpenNotionalCap } from "./market_pb";
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateSpotMarket
 */
export interface MsgUpdateSpotMarket {
    /**
     * current admin address of the associated market
     *
     * @generated from protobuf field: string admin = 1
     */
    admin: string;
    /**
     * id of the market to be updated
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * (optional) updated ticker value
     *
     * @generated from protobuf field: string new_ticker = 3
     */
    newTicker: string;
    /**
     * (optional) updated min price tick size value (in human readable format)
     *
     * @generated from protobuf field: string new_min_price_tick_size = 4
     */
    newMinPriceTickSize: string;
    /**
     * (optional) updated min quantity tick size value (in human readable format)
     *
     * @generated from protobuf field: string new_min_quantity_tick_size = 5
     */
    newMinQuantityTickSize: string;
    /**
     * (optional) updated min notional (in human readable format)
     *
     * @generated from protobuf field: string new_min_notional = 6
     */
    newMinNotional: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateSpotMarketResponse
 */
export interface MsgUpdateSpotMarketResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateDerivativeMarket
 */
export interface MsgUpdateDerivativeMarket {
    /**
     * current admin address of the associated market
     *
     * @generated from protobuf field: string admin = 1
     */
    admin: string;
    /**
     * id of the market to be updated
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * (optional) updated value for ticker
     *
     * @generated from protobuf field: string new_ticker = 3
     */
    newTicker: string;
    /**
     * (optional) updated value for min_price_tick_size (in human readable format)
     *
     * @generated from protobuf field: string new_min_price_tick_size = 4
     */
    newMinPriceTickSize: string;
    /**
     * (optional) updated value min_quantity_tick_size (in human readable format)
     *
     * @generated from protobuf field: string new_min_quantity_tick_size = 5
     */
    newMinQuantityTickSize: string;
    /**
     * (optional) updated min notional (in human readable format)
     *
     * @generated from protobuf field: string new_min_notional = 6
     */
    newMinNotional: string;
    /**
     * (optional) updated value for initial_margin_ratio
     *
     * @generated from protobuf field: string new_initial_margin_ratio = 7
     */
    newInitialMarginRatio: string;
    /**
     * (optional) updated value for maintenance_margin_ratio
     *
     * @generated from protobuf field: string new_maintenance_margin_ratio = 8
     */
    newMaintenanceMarginRatio: string;
    /**
     * (optional) updated value for reduce_margin_ratio
     *
     * @generated from protobuf field: string new_reduce_margin_ratio = 9
     */
    newReduceMarginRatio: string;
    /**
     * (optional) updated value for open_notional_cap
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap new_open_notional_cap = 10
     */
    newOpenNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateDerivativeMarketResponse
 */
export interface MsgUpdateDerivativeMarketResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the exchange parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: injective.exchange.v2.Params params = 2
     */
    params?: Params;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgDeposit defines a SDK message for transferring coins from the sender's
 * bank balance into the subaccount's exchange deposits
 *
 * @generated from protobuf message injective.exchange.v2.MsgDeposit
 */
export interface MsgDeposit {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * (Optional) the subaccount ID to deposit funds into. If empty, the coin
     * will be deposited to the sender's default subaccount address.
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the amount of the deposit (in chain format)
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * MsgDepositResponse defines the Msg/Deposit response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgDepositResponse
 */
export interface MsgDepositResponse {
}
/**
 * MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's
 * deposits to the user's bank balance
 *
 * @generated from protobuf message injective.exchange.v2.MsgWithdraw
 */
export interface MsgWithdraw {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID to withdraw funds from
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the amount of the withdrawal (in chain format)
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * MsgWithdraw defines the Msg/Withdraw response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgWithdrawResponse
 */
export interface MsgWithdrawResponse {
}
/**
 * MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit
 * order.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateSpotLimitOrder
 */
export interface MsgCreateSpotLimitOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the order details
     *
     * @generated from protobuf field: injective.exchange.v2.SpotOrder order = 2
     */
    order?: SpotOrder;
}
/**
 * MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response
 * type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateSpotLimitOrderResponse
 */
export interface MsgCreateSpotLimitOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 2
     */
    cid: string;
}
/**
 * MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new batch
 * of spot limit orders.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCreateSpotLimitOrders
 */
export interface MsgBatchCreateSpotLimitOrders {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SpotOrder orders = 2
     */
    orders: SpotOrder[];
}
/**
 * MsgBatchCreateSpotLimitOrdersResponse defines the
 * Msg/BatchCreateSpotLimitOrders response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCreateSpotLimitOrdersResponse
 */
export interface MsgBatchCreateSpotLimitOrdersResponse {
    /**
     * @generated from protobuf field: repeated string order_hashes = 1
     */
    orderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_orders_cids = 2
     */
    createdOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_orders_cids = 3
     */
    failedOrdersCids: string[];
}
/**
 * MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot
 * market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantSpotMarketLaunch
 */
export interface MsgInstantSpotMarketLaunch {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Ticker for the spot market.
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * type of coin to use as the base currency
     *
     * @generated from protobuf field: string base_denom = 3
     */
    baseDenom: string;
    /**
     * type of coin to use as the quote currency
     *
     * @generated from protobuf field: string quote_denom = 4
     */
    quoteDenom: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price (in
     * human readable format)
     *
     * @generated from protobuf field: string min_price_tick_size = 5
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity (in human readable format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 6
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_notional = 7
     */
    minNotional: string;
    /**
     * base token decimals
     *
     * @generated from protobuf field: uint32 base_decimals = 8
     */
    baseDecimals: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 9
     */
    quoteDecimals: number;
}
/**
 * MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantSpotMarketLaunchResponse
 */
export interface MsgInstantSpotMarketLaunchResponse {
}
/**
 * MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new
 * perpetual futures market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantPerpetualMarketLaunch
 */
export interface MsgInstantPerpetualMarketLaunch {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Ticker for the derivative market.
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * type of coin to use as the base currency
     *
     * @generated from protobuf field: string quote_denom = 3
     */
    quoteDenom: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 4
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 5
     */
    oracleQuote: string;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 6
     */
    oracleScaleFactor: number;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 7
     */
    oracleType: OracleType;
    /**
     * maker_fee_rate defines the trade fee rate for makers on the perpetual
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 8
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the trade fee rate for takers on the perpetual
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 9
     */
    takerFeeRate: string;
    /**
     * initial_margin_ratio defines the initial margin ratio for the perpetual
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 10
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio for the
     * perpetual market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 11
     */
    maintenanceMarginRatio: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin (in human readable format)
     *
     * @generated from protobuf field: string min_price_tick_size = 12
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity (in human readable format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 13
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_notional = 14
     */
    minNotional: string;
    /**
     * reduce_margin_ratio defines the ratio of the margin that is reduced
     *
     * @generated from protobuf field: string reduce_margin_ratio = 15
     */
    reduceMarginRatio: string;
    /**
     * open_notional_cap defines the cap on the open notional
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 16
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * MsgInstantPerpetualMarketLaunchResponse defines the
 * Msg/InstantPerpetualMarketLaunchResponse response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantPerpetualMarketLaunchResponse
 */
export interface MsgInstantPerpetualMarketLaunchResponse {
}
/**
 * MsgInstantBinaryOptionsMarketLaunch defines a SDK message for creating a new
 * perpetual futures market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantBinaryOptionsMarketLaunch
 */
export interface MsgInstantBinaryOptionsMarketLaunch {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Ticker for the derivative contract.
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * Oracle symbol
     *
     * @generated from protobuf field: string oracle_symbol = 3
     */
    oracleSymbol: string;
    /**
     * Oracle Provider
     *
     * @generated from protobuf field: string oracle_provider = 4
     */
    oracleProvider: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 5
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 6
     */
    oracleScaleFactor: number;
    /**
     * maker_fee_rate defines the trade fee rate for makers on the perpetual
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 7
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the trade fee rate for takers on the perpetual
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 8
     */
    takerFeeRate: string;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 9
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 10
     */
    settlementTimestamp: bigint;
    /**
     * admin of the market
     *
     * @generated from protobuf field: string admin = 11
     */
    admin: string;
    /**
     * Address of the quote currency denomination for the binary options contract
     *
     * @generated from protobuf field: string quote_denom = 12
     */
    quoteDenom: string;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_price_tick_size = 13
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 14
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_notional = 15
     */
    minNotional: string;
    /**
     * open_notional_cap defines the cap on the open notional
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 16
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * MsgInstantBinaryOptionsMarketLaunchResponse defines the
 * Msg/InstantBinaryOptionsMarketLaunchResponse response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantBinaryOptionsMarketLaunchResponse
 */
export interface MsgInstantBinaryOptionsMarketLaunchResponse {
}
/**
 * MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a new
 * expiry futures market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantExpiryFuturesMarketLaunch
 */
export interface MsgInstantExpiryFuturesMarketLaunch {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Ticker for the derivative market.
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * type of coin to use as the quote currency
     *
     * @generated from protobuf field: string quote_denom = 3
     */
    quoteDenom: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 4
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 5
     */
    oracleQuote: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 6
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 7
     */
    oracleScaleFactor: number;
    /**
     * Expiration time of the market
     *
     * @generated from protobuf field: int64 expiry = 8
     */
    expiry: bigint;
    /**
     * maker_fee_rate defines the trade fee rate for makers on the expiry futures
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 9
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the trade fee rate for takers on the expiry futures
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 10
     */
    takerFeeRate: string;
    /**
     * initial_margin_ratio defines the initial margin ratio for the derivative
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 11
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio for the
     * derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 12
     */
    maintenanceMarginRatio: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 13
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 14
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 15
     */
    minNotional: string;
    /**
     * reduce_margin_ratio defines the ratio of the margin that is reduced
     *
     * @generated from protobuf field: string reduce_margin_ratio = 16
     */
    reduceMarginRatio: string;
    /**
     * open_notional_cap defines the cap on the open notional
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 17
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * MsgInstantExpiryFuturesMarketLaunchResponse defines the
 * Msg/InstantExpiryFuturesMarketLaunch response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgInstantExpiryFuturesMarketLaunchResponse
 */
export interface MsgInstantExpiryFuturesMarketLaunchResponse {
}
/**
 * MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market
 * order.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateSpotMarketOrder
 */
export interface MsgCreateSpotMarketOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the order details
     *
     * @generated from protobuf field: injective.exchange.v2.SpotOrder order = 2
     */
    order?: SpotOrder;
}
/**
 * MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateSpotMarketOrderResponse
 */
export interface MsgCreateSpotMarketOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.SpotMarketOrderResults results = 2
     */
    results?: SpotMarketOrderResults;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.SpotMarketOrderResults
 */
export interface SpotMarketOrderResults {
    /**
     * @generated from protobuf field: string quantity = 1
     */
    quantity: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * @generated from protobuf field: string fee = 3
     */
    fee: string;
}
/**
 * A Cosmos-SDK MsgCreateDerivativeLimitOrder
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateDerivativeLimitOrder
 */
export interface MsgCreateDerivativeLimitOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the order details
     *
     * @generated from protobuf field: injective.exchange.v2.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateDerivativeLimitOrderResponse defines the
 * Msg/CreateDerivativeMarketOrder response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateDerivativeLimitOrderResponse
 */
export interface MsgCreateDerivativeLimitOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 2
     */
    cid: string;
}
/**
 * A Cosmos-SDK MsgCreateBinaryOptionsLimitOrder
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateBinaryOptionsLimitOrder
 */
export interface MsgCreateBinaryOptionsLimitOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the order details
     *
     * @generated from protobuf field: injective.exchange.v2.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateBinaryOptionsLimitOrderResponse defines the
 * Msg/CreateBinaryOptionsLimitOrder response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateBinaryOptionsLimitOrderResponse
 */
export interface MsgCreateBinaryOptionsLimitOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 2
     */
    cid: string;
}
/**
 * A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCreateDerivativeLimitOrders
 */
export interface MsgBatchCreateDerivativeLimitOrders {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeOrder orders = 2
     */
    orders: DerivativeOrder[];
}
/**
 * MsgBatchCreateDerivativeLimitOrdersResponse defines the
 * Msg/BatchCreateDerivativeLimitOrders response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCreateDerivativeLimitOrdersResponse
 */
export interface MsgBatchCreateDerivativeLimitOrdersResponse {
    /**
     * @generated from protobuf field: repeated string order_hashes = 1
     */
    orderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_orders_cids = 2
     */
    createdOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_orders_cids = 3
     */
    failedOrdersCids: string[];
}
/**
 * MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelSpotOrder
 */
export interface MsgCancelSpotOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * the order hash (optional)
     *
     * @generated from protobuf field: string order_hash = 4
     */
    orderHash: string;
    /**
     * the client order ID (optional)
     *
     * @generated from protobuf field: string cid = 5
     */
    cid: string;
}
/**
 * MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelSpotOrderResponse
 */
export interface MsgCancelSpotOrderResponse {
}
/**
 * MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCancelSpotOrders
 */
export interface MsgBatchCancelSpotOrders {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.OrderData data = 2
     */
    data: OrderData[];
}
/**
 * MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCancelSpotOrdersResponse
 */
export interface MsgBatchCancelSpotOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool success = 1
     */
    success: boolean[];
}
/**
 * MsgBatchCancelBinaryOptionsOrders defines the
 * Msg/BatchCancelBinaryOptionsOrders response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCancelBinaryOptionsOrders
 */
export interface MsgBatchCancelBinaryOptionsOrders {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.OrderData data = 2
     */
    data: OrderData[];
}
/**
 * BatchCancelBinaryOptionsOrdersResponse defines the
 * Msg/BatchCancelBinaryOptionsOrders response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCancelBinaryOptionsOrdersResponse
 */
export interface MsgBatchCancelBinaryOptionsOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool success = 1
     */
    success: boolean[];
}
/**
 * MsgBatchUpdateOrders defines the Msg/BatchUpdateOrders response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchUpdateOrders
 */
export interface MsgBatchUpdateOrders {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * subaccount_id only used for the spot_market_ids_to_cancel_all and
     * derivative_market_ids_to_cancel_all (optional)
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the market IDs to cancel all spot orders for (optional)
     *
     * @generated from protobuf field: repeated string spot_market_ids_to_cancel_all = 3
     */
    spotMarketIdsToCancelAll: string[];
    /**
     * the market IDs to cancel all derivative orders for (optional)
     *
     * @generated from protobuf field: repeated string derivative_market_ids_to_cancel_all = 4
     */
    derivativeMarketIdsToCancelAll: string[];
    /**
     * the spot orders to cancel
     *
     * @generated from protobuf field: repeated injective.exchange.v2.OrderData spot_orders_to_cancel = 5
     */
    spotOrdersToCancel: OrderData[];
    /**
     * the derivative orders to cancel
     *
     * @generated from protobuf field: repeated injective.exchange.v2.OrderData derivative_orders_to_cancel = 6
     */
    derivativeOrdersToCancel: OrderData[];
    /**
     * the spot orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v2.SpotOrder spot_orders_to_create = 7
     */
    spotOrdersToCreate: SpotOrder[];
    /**
     * the derivative orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeOrder derivative_orders_to_create = 8
     */
    derivativeOrdersToCreate: DerivativeOrder[];
    /**
     * the binary options orders to cancel
     *
     * @generated from protobuf field: repeated injective.exchange.v2.OrderData binary_options_orders_to_cancel = 9
     */
    binaryOptionsOrdersToCancel: OrderData[];
    /**
     * the market IDs to cancel all binary options orders for (optional)
     *
     * @generated from protobuf field: repeated string binary_options_market_ids_to_cancel_all = 10
     */
    binaryOptionsMarketIdsToCancelAll: string[];
    /**
     * the binary options orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeOrder binary_options_orders_to_create = 11
     */
    binaryOptionsOrdersToCreate: DerivativeOrder[];
    /**
     * the spot market orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v2.SpotOrder spot_market_orders_to_create = 12
     */
    spotMarketOrdersToCreate: SpotOrder[];
    /**
     * the derivative market orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeOrder derivative_market_orders_to_create = 13
     */
    derivativeMarketOrdersToCreate: DerivativeOrder[];
    /**
     * the binary options market orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeOrder binary_options_market_orders_to_create = 14
     */
    binaryOptionsMarketOrdersToCreate: DerivativeOrder[];
}
/**
 * MsgBatchUpdateOrdersResponse defines the Msg/BatchUpdateOrders response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchUpdateOrdersResponse
 */
export interface MsgBatchUpdateOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool spot_cancel_success = 1
     */
    spotCancelSuccess: boolean[];
    /**
     * @generated from protobuf field: repeated bool derivative_cancel_success = 2
     */
    derivativeCancelSuccess: boolean[];
    /**
     * @generated from protobuf field: repeated string spot_order_hashes = 3
     */
    spotOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string derivative_order_hashes = 4
     */
    derivativeOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated bool binary_options_cancel_success = 5
     */
    binaryOptionsCancelSuccess: boolean[];
    /**
     * @generated from protobuf field: repeated string binary_options_order_hashes = 6
     */
    binaryOptionsOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_spot_orders_cids = 7
     */
    createdSpotOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_spot_orders_cids = 8
     */
    failedSpotOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string created_derivative_orders_cids = 9
     */
    createdDerivativeOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_derivative_orders_cids = 10
     */
    failedDerivativeOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string created_binary_options_orders_cids = 11
     */
    createdBinaryOptionsOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_binary_options_orders_cids = 12
     */
    failedBinaryOptionsOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string spot_market_order_hashes = 13
     */
    spotMarketOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_spot_market_orders_cids = 14
     */
    createdSpotMarketOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_spot_market_orders_cids = 15
     */
    failedSpotMarketOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string derivative_market_order_hashes = 16
     */
    derivativeMarketOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_derivative_market_orders_cids = 17
     */
    createdDerivativeMarketOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_derivative_market_orders_cids = 18
     */
    failedDerivativeMarketOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string binary_options_market_order_hashes = 19
     */
    binaryOptionsMarketOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_binary_options_market_orders_cids = 20
     */
    createdBinaryOptionsMarketOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_binary_options_market_orders_cids = 21
     */
    failedBinaryOptionsMarketOrdersCids: string[];
}
/**
 * A Cosmos-SDK MsgCreateDerivativeMarketOrder
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateDerivativeMarketOrder
 */
export interface MsgCreateDerivativeMarketOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the order details
     *
     * @generated from protobuf field: injective.exchange.v2.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateDerivativeMarketOrderResponse defines the
 * Msg/CreateDerivativeMarketOrder response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateDerivativeMarketOrderResponse
 */
export interface MsgCreateDerivativeMarketOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.DerivativeMarketOrderResults results = 2
     */
    results?: DerivativeMarketOrderResults;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.DerivativeMarketOrderResults
 */
export interface DerivativeMarketOrderResults {
    /**
     * @generated from protobuf field: string quantity = 1
     */
    quantity: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * @generated from protobuf field: string fee = 3
     */
    fee: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.PositionDelta position_delta = 4
     */
    positionDelta?: PositionDelta;
    /**
     * @generated from protobuf field: string payout = 5
     */
    payout: string;
}
/**
 * A Cosmos-SDK MsgCreateBinaryOptionsMarketOrder
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateBinaryOptionsMarketOrder
 */
export interface MsgCreateBinaryOptionsMarketOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the order details
     *
     * @generated from protobuf field: injective.exchange.v2.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateBinaryOptionsMarketOrderResponse defines the
 * Msg/CreateBinaryOptionsMarketOrder response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCreateBinaryOptionsMarketOrderResponse
 */
export interface MsgCreateBinaryOptionsMarketOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.DerivativeMarketOrderResults results = 2
     */
    results?: DerivativeMarketOrderResults;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
}
/**
 * MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelDerivativeOrder
 */
export interface MsgCancelDerivativeOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * the order hash (optional)
     *
     * @generated from protobuf field: string order_hash = 4
     */
    orderHash: string;
    /**
     * the order mask (bitwise combination of OrderMask enum values) (optional)
     *
     * @generated from protobuf field: int32 order_mask = 5
     */
    orderMask: number;
    /**
     * the client order ID (optional)
     *
     * @generated from protobuf field: string cid = 6
     */
    cid: string;
}
/**
 * MsgCancelDerivativeOrderResponse defines the
 * Msg/CancelDerivativeOrderResponse response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelDerivativeOrderResponse
 */
export interface MsgCancelDerivativeOrderResponse {
}
/**
 * MsgCancelBinaryOptionsOrder defines the Msg/CancelBinaryOptionsOrder response
 * type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelBinaryOptionsOrder
 */
export interface MsgCancelBinaryOptionsOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * the order hash (optional)
     *
     * @generated from protobuf field: string order_hash = 4
     */
    orderHash: string;
    /**
     * the order mask (bitwise combination of OrderMask enum values) (optional)
     *
     * @generated from protobuf field: int32 order_mask = 5
     */
    orderMask: number;
    /**
     * the client order ID (optional)
     *
     * @generated from protobuf field: string cid = 6
     */
    cid: string;
}
/**
 * MsgCancelBinaryOptionsOrderResponse defines the
 * Msg/CancelBinaryOptionsOrderResponse response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelBinaryOptionsOrderResponse
 */
export interface MsgCancelBinaryOptionsOrderResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.OrderData
 */
export interface OrderData {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the order hash (optional - either the order_hash or the cid should be
     * provided)
     *
     * @generated from protobuf field: string order_hash = 3
     */
    orderHash: string;
    /**
     * the order mask (bitwise combination of OrderMask enum values)
     *
     * @generated from protobuf field: int32 order_mask = 4
     */
    orderMask: number;
    /**
     * the client order ID (optional - either the order_hash or the cid should be
     * provided)
     *
     * @generated from protobuf field: string cid = 5
     */
    cid: string;
}
/**
 * MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCancelDerivativeOrders
 */
export interface MsgBatchCancelDerivativeOrders {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.OrderData data = 2
     */
    data: OrderData[];
}
/**
 * MsgBatchCancelDerivativeOrdersResponse defines the
 * Msg/CancelDerivativeOrderResponse response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgBatchCancelDerivativeOrdersResponse
 */
export interface MsgBatchCancelDerivativeOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool success = 1
     */
    success: boolean[];
}
/**
 * A Cosmos-SDK MsgSubaccountTransfer
 *
 * @generated from protobuf message injective.exchange.v2.MsgSubaccountTransfer
 */
export interface MsgSubaccountTransfer {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the source subaccount ID
     *
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * the destination subaccount ID
     *
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * the amount to transfer (in chain format)
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 4
     */
    amount?: Coin;
}
/**
 * MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response
 * type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgSubaccountTransferResponse
 */
export interface MsgSubaccountTransferResponse {
}
/**
 * A Cosmos-SDK MsgExternalTransfer
 *
 * @generated from protobuf message injective.exchange.v2.MsgExternalTransfer
 */
export interface MsgExternalTransfer {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the source subaccount ID
     *
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * the destination subaccount ID
     *
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * the amount to transfer (in chain format)
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 4
     */
    amount?: Coin;
}
/**
 * MsgExternalTransferResponse defines the Msg/ExternalTransfer response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgExternalTransferResponse
 */
export interface MsgExternalTransferResponse {
}
/**
 * A Cosmos-SDK MsgLiquidatePosition
 *
 * @generated from protobuf message injective.exchange.v2.MsgLiquidatePosition
 */
export interface MsgLiquidatePosition {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID the position belongs to
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the position's market ID
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * optional order to provide for liquidation
     *
     * @generated from protobuf field: injective.exchange.v2.DerivativeOrder order = 4
     */
    order?: DerivativeOrder;
}
/**
 * MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgLiquidatePositionResponse
 */
export interface MsgLiquidatePositionResponse {
}
/**
 * A Cosmos-SDK MsgOffsetPosition
 *
 * @generated from protobuf message injective.exchange.v2.MsgOffsetPosition
 */
export interface MsgOffsetPosition {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * @generated from protobuf field: repeated string offsetting_subaccount_ids = 4
     */
    offsettingSubaccountIds: string[];
}
/**
 * MsgOffsetPositionResponse defines the Msg/OffsetPosition
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgOffsetPositionResponse
 */
export interface MsgOffsetPositionResponse {
}
/**
 * A Cosmos-SDK MsgEmergencySettleMarket
 *
 * @generated from protobuf message injective.exchange.v2.MsgEmergencySettleMarket
 */
export interface MsgEmergencySettleMarket {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
}
/**
 * MsgEmergencySettleMarketResponse defines the Msg/EmergencySettleMarket
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgEmergencySettleMarketResponse
 */
export interface MsgEmergencySettleMarketResponse {
}
/**
 * A Cosmos-SDK MsgIncreasePositionMargin
 *
 * @generated from protobuf message injective.exchange.v2.MsgIncreasePositionMargin
 */
export interface MsgIncreasePositionMargin {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID sending the funds
     *
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * the subaccount ID the position belongs to
     *
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
    /**
     * amount defines the amount of margin to add to the position (in human
     * readable format)
     *
     * @generated from protobuf field: string amount = 5
     */
    amount: string;
}
/**
 * MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgIncreasePositionMarginResponse
 */
export interface MsgIncreasePositionMarginResponse {
}
/**
 * A Cosmos-SDK MsgDecreasePositionMargin
 *
 * @generated from protobuf message injective.exchange.v2.MsgDecreasePositionMargin
 */
export interface MsgDecreasePositionMargin {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID the position belongs to
     *
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * the destination subaccount ID
     *
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
    /**
     * amount defines the amount of margin to withdraw from the position (in human
     * readable format)
     *
     * @generated from protobuf field: string amount = 5
     */
    amount: string;
}
/**
 * MsgDecreasePositionMarginResponse defines the Msg/MsgDecreasePositionMargin
 * response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgDecreasePositionMarginResponse
 */
export interface MsgDecreasePositionMarginResponse {
}
/**
 * MsgPrivilegedExecuteContract defines the Msg/Exec message type
 *
 * @generated from protobuf message injective.exchange.v2.MsgPrivilegedExecuteContract
 */
export interface MsgPrivilegedExecuteContract {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * funds defines the user's bank coins used to fund the execution (e.g.
     * 100inj).
     *
     * @generated from protobuf field: string funds = 2
     */
    funds: string;
    /**
     * contract_address defines the contract address to execute
     *
     * @generated from protobuf field: string contract_address = 3
     */
    contractAddress: string;
    /**
     * data defines the call data used when executing the contract
     *
     * @generated from protobuf field: string data = 4
     */
    data: string;
}
/**
 * MsgPrivilegedExecuteContractResponse defines the Msg/Exec response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgPrivilegedExecuteContractResponse
 */
export interface MsgPrivilegedExecuteContractResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds_diff = 1
     */
    fundsDiff: Coin[];
}
/**
 * A Cosmos-SDK MsgRewardsOptOut
 *
 * @generated from protobuf message injective.exchange.v2.MsgRewardsOptOut
 */
export interface MsgRewardsOptOut {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
}
/**
 * MsgRewardsOptOutResponse defines the Msg/RewardsOptOut response type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgRewardsOptOutResponse
 */
export interface MsgRewardsOptOutResponse {
}
/**
 * A Cosmos-SDK MsgReclaimLockedFunds
 *
 * @generated from protobuf message injective.exchange.v2.MsgReclaimLockedFunds
 */
export interface MsgReclaimLockedFunds {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: bytes lockedAccountPubKey = 2
     */
    lockedAccountPubKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes signature = 3
     */
    signature: Uint8Array;
}
/**
 * MsgReclaimLockedFundsResponse defines the Msg/ReclaimLockedFunds response
 * type.
 *
 * @generated from protobuf message injective.exchange.v2.MsgReclaimLockedFundsResponse
 */
export interface MsgReclaimLockedFundsResponse {
}
/**
 * MsgSignData defines an arbitrary, general-purpose, off-chain message
 *
 * @generated from protobuf message injective.exchange.v2.MsgSignData
 */
export interface MsgSignData {
    /**
     * Signer is the sdk.AccAddress of the message signer
     *
     * @generated from protobuf field: bytes Signer = 1
     */
    signer: Uint8Array;
    /**
     * Data represents the raw bytes of the content that is signed (text, json,
     * etc)
     *
     * @generated from protobuf field: bytes Data = 2
     */
    data: Uint8Array;
}
/**
 * MsgSignDoc defines an arbitrary, general-purpose, off-chain message
 *
 * @generated from protobuf message injective.exchange.v2.MsgSignDoc
 */
export interface MsgSignDoc {
    /**
     * @generated from protobuf field: string sign_type = 1
     */
    signType: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.MsgSignData value = 2
     */
    value?: MsgSignData;
}
/**
 * MsgAdminUpdateBinaryOptionsMarket is used by the market Admin to operate the
 * market
 *
 * @generated from protobuf message injective.exchange.v2.MsgAdminUpdateBinaryOptionsMarket
 */
export interface MsgAdminUpdateBinaryOptionsMarket {
    /**
     * The sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * The market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * new price at which market will be settled
     *
     * @generated from protobuf field: string settlement_price = 3
     */
    settlementPrice: string;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 4
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 5
     */
    settlementTimestamp: bigint;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v2.MarketStatus status = 6
     */
    status: MarketStatus;
}
/**
 * MsgAdminUpdateBinaryOptionsMarketResponse is the response for
 * AdminUpdateBinaryOptionsMarket rpc method
 *
 * @generated from protobuf message injective.exchange.v2.MsgAdminUpdateBinaryOptionsMarketResponse
 */
export interface MsgAdminUpdateBinaryOptionsMarketResponse {
}
/**
 * MsgAuthorizeStakeGrants grants stakes to grantees.
 *
 * @generated from protobuf message injective.exchange.v2.MsgAuthorizeStakeGrants
 */
export interface MsgAuthorizeStakeGrants {
    /**
     * Injective address of the stake granter
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * list of stake grants to authorize (mandatory)
     *
     * @generated from protobuf field: repeated injective.exchange.v2.GrantAuthorization grants = 2
     */
    grants: GrantAuthorization[];
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgAuthorizeStakeGrantsResponse
 */
export interface MsgAuthorizeStakeGrantsResponse {
}
/**
 * MsgActivateStakeGrant allows a grantee to activate a stake grant.
 *
 * @generated from protobuf message injective.exchange.v2.MsgActivateStakeGrant
 */
export interface MsgActivateStakeGrant {
    /**
     * Injective address of the stake grantee
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Injective address of the stake granter
     *
     * @generated from protobuf field: string granter = 2
     */
    granter: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgActivateStakeGrantResponse
 */
export interface MsgActivateStakeGrantResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBatchExchangeModification
 */
export interface MsgBatchExchangeModification {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.BatchExchangeModificationProposal proposal = 2
     */
    proposal?: BatchExchangeModificationProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBatchExchangeModificationResponse
 */
export interface MsgBatchExchangeModificationResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgSpotMarketLaunch
 */
export interface MsgSpotMarketLaunch {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.SpotMarketLaunchProposal proposal = 2
     */
    proposal?: SpotMarketLaunchProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgSpotMarketLaunchResponse
 */
export interface MsgSpotMarketLaunchResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgPerpetualMarketLaunch
 */
export interface MsgPerpetualMarketLaunch {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.PerpetualMarketLaunchProposal proposal = 2
     */
    proposal?: PerpetualMarketLaunchProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgPerpetualMarketLaunchResponse
 */
export interface MsgPerpetualMarketLaunchResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgExpiryFuturesMarketLaunch
 */
export interface MsgExpiryFuturesMarketLaunch {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.ExpiryFuturesMarketLaunchProposal proposal = 2
     */
    proposal?: ExpiryFuturesMarketLaunchProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgExpiryFuturesMarketLaunchResponse
 */
export interface MsgExpiryFuturesMarketLaunchResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBinaryOptionsMarketLaunch
 */
export interface MsgBinaryOptionsMarketLaunch {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.BinaryOptionsMarketLaunchProposal proposal = 2
     */
    proposal?: BinaryOptionsMarketLaunchProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBinaryOptionsMarketLaunchResponse
 */
export interface MsgBinaryOptionsMarketLaunchResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBatchCommunityPoolSpend
 */
export interface MsgBatchCommunityPoolSpend {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.BatchCommunityPoolSpendProposal proposal = 2
     */
    proposal?: BatchCommunityPoolSpendProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBatchCommunityPoolSpendResponse
 */
export interface MsgBatchCommunityPoolSpendResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgSpotMarketParamUpdate
 */
export interface MsgSpotMarketParamUpdate {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.SpotMarketParamUpdateProposal proposal = 2
     */
    proposal?: SpotMarketParamUpdateProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgSpotMarketParamUpdateResponse
 */
export interface MsgSpotMarketParamUpdateResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgDerivativeMarketParamUpdate
 */
export interface MsgDerivativeMarketParamUpdate {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.DerivativeMarketParamUpdateProposal proposal = 2
     */
    proposal?: DerivativeMarketParamUpdateProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgDerivativeMarketParamUpdateResponse
 */
export interface MsgDerivativeMarketParamUpdateResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBinaryOptionsMarketParamUpdate
 */
export interface MsgBinaryOptionsMarketParamUpdate {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal proposal = 2
     */
    proposal?: BinaryOptionsMarketParamUpdateProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgBinaryOptionsMarketParamUpdateResponse
 */
export interface MsgBinaryOptionsMarketParamUpdateResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgMarketForcedSettlement
 */
export interface MsgMarketForcedSettlement {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.MarketForcedSettlementProposal proposal = 2
     */
    proposal?: MarketForcedSettlementProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgMarketForcedSettlementResponse
 */
export interface MsgMarketForcedSettlementResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgTradingRewardCampaignLaunch
 */
export interface MsgTradingRewardCampaignLaunch {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignLaunchProposal proposal = 2
     */
    proposal?: TradingRewardCampaignLaunchProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgTradingRewardCampaignLaunchResponse
 */
export interface MsgTradingRewardCampaignLaunchResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgExchangeEnable
 */
export interface MsgExchangeEnable {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.ExchangeEnableProposal proposal = 2
     */
    proposal?: ExchangeEnableProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgExchangeEnableResponse
 */
export interface MsgExchangeEnableResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgTradingRewardCampaignUpdate
 */
export interface MsgTradingRewardCampaignUpdate {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignUpdateProposal proposal = 2
     */
    proposal?: TradingRewardCampaignUpdateProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgTradingRewardCampaignUpdateResponse
 */
export interface MsgTradingRewardCampaignUpdateResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgTradingRewardPendingPointsUpdate
 */
export interface MsgTradingRewardPendingPointsUpdate {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.TradingRewardPendingPointsUpdateProposal proposal = 2
     */
    proposal?: TradingRewardPendingPointsUpdateProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgTradingRewardPendingPointsUpdateResponse
 */
export interface MsgTradingRewardPendingPointsUpdateResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgFeeDiscount
 */
export interface MsgFeeDiscount {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountProposal proposal = 2
     */
    proposal?: FeeDiscountProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgFeeDiscountResponse
 */
export interface MsgFeeDiscountResponse {
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgAtomicMarketOrderFeeMultiplierSchedule
 */
export interface MsgAtomicMarketOrderFeeMultiplierSchedule {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.AtomicMarketOrderFeeMultiplierScheduleProposal proposal = 2
     */
    proposal?: AtomicMarketOrderFeeMultiplierScheduleProposal;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgAtomicMarketOrderFeeMultiplierScheduleResponse
 */
export interface MsgAtomicMarketOrderFeeMultiplierScheduleResponse {
}
/**
 * MsgCancelPostOnlyMode defines a message for canceling post-only mode
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelPostOnlyMode
 */
export interface MsgCancelPostOnlyMode {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
}
/**
 * MsgCancelPostOnlyModeResponse defines the response for MsgCancelPostOnlyMode
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelPostOnlyModeResponse
 */
export interface MsgCancelPostOnlyModeResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateSpotMarket$Type extends MessageType<MsgUpdateSpotMarket> {
    constructor() {
        super("injective.exchange.v2.MsgUpdateSpotMarket", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "new_min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "new_min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "new_min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.equal": false, "amino.name": "exchange/MsgUpdateSpotMarket", "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateSpotMarket>): MsgUpdateSpotMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.admin = "";
        message.marketId = "";
        message.newTicker = "";
        message.newMinPriceTickSize = "";
        message.newMinQuantityTickSize = "";
        message.newMinNotional = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateSpotMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateSpotMarket): MsgUpdateSpotMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string new_ticker */ 3:
                    message.newTicker = reader.string();
                    break;
                case /* string new_min_price_tick_size */ 4:
                    message.newMinPriceTickSize = reader.string();
                    break;
                case /* string new_min_quantity_tick_size */ 5:
                    message.newMinQuantityTickSize = reader.string();
                    break;
                case /* string new_min_notional */ 6:
                    message.newMinNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateSpotMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string new_ticker = 3; */
        if (message.newTicker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newTicker);
        /* string new_min_price_tick_size = 4; */
        if (message.newMinPriceTickSize !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.newMinPriceTickSize);
        /* string new_min_quantity_tick_size = 5; */
        if (message.newMinQuantityTickSize !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.newMinQuantityTickSize);
        /* string new_min_notional = 6; */
        if (message.newMinNotional !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.newMinNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateSpotMarket
 */
export const MsgUpdateSpotMarket = new MsgUpdateSpotMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateSpotMarketResponse$Type extends MessageType<MsgUpdateSpotMarketResponse> {
    constructor() {
        super("injective.exchange.v2.MsgUpdateSpotMarketResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateSpotMarketResponse>): MsgUpdateSpotMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateSpotMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateSpotMarketResponse): MsgUpdateSpotMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateSpotMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateSpotMarketResponse
 */
export const MsgUpdateSpotMarketResponse = new MsgUpdateSpotMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateDerivativeMarket$Type extends MessageType<MsgUpdateDerivativeMarket> {
    constructor() {
        super("injective.exchange.v2.MsgUpdateDerivativeMarket", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "new_min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "new_min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "new_min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "new_initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "new_maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "new_reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "new_open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgUpdateDerivativeMarket", "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateDerivativeMarket>): MsgUpdateDerivativeMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.admin = "";
        message.marketId = "";
        message.newTicker = "";
        message.newMinPriceTickSize = "";
        message.newMinQuantityTickSize = "";
        message.newMinNotional = "";
        message.newInitialMarginRatio = "";
        message.newMaintenanceMarginRatio = "";
        message.newReduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateDerivativeMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateDerivativeMarket): MsgUpdateDerivativeMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string new_ticker */ 3:
                    message.newTicker = reader.string();
                    break;
                case /* string new_min_price_tick_size */ 4:
                    message.newMinPriceTickSize = reader.string();
                    break;
                case /* string new_min_quantity_tick_size */ 5:
                    message.newMinQuantityTickSize = reader.string();
                    break;
                case /* string new_min_notional */ 6:
                    message.newMinNotional = reader.string();
                    break;
                case /* string new_initial_margin_ratio */ 7:
                    message.newInitialMarginRatio = reader.string();
                    break;
                case /* string new_maintenance_margin_ratio */ 8:
                    message.newMaintenanceMarginRatio = reader.string();
                    break;
                case /* string new_reduce_margin_ratio */ 9:
                    message.newReduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap new_open_notional_cap */ 10:
                    message.newOpenNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.newOpenNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateDerivativeMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string new_ticker = 3; */
        if (message.newTicker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newTicker);
        /* string new_min_price_tick_size = 4; */
        if (message.newMinPriceTickSize !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.newMinPriceTickSize);
        /* string new_min_quantity_tick_size = 5; */
        if (message.newMinQuantityTickSize !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.newMinQuantityTickSize);
        /* string new_min_notional = 6; */
        if (message.newMinNotional !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.newMinNotional);
        /* string new_initial_margin_ratio = 7; */
        if (message.newInitialMarginRatio !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.newInitialMarginRatio);
        /* string new_maintenance_margin_ratio = 8; */
        if (message.newMaintenanceMarginRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.newMaintenanceMarginRatio);
        /* string new_reduce_margin_ratio = 9; */
        if (message.newReduceMarginRatio !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.newReduceMarginRatio);
        /* injective.exchange.v2.OpenNotionalCap new_open_notional_cap = 10; */
        if (message.newOpenNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.newOpenNotionalCap, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateDerivativeMarket
 */
export const MsgUpdateDerivativeMarket = new MsgUpdateDerivativeMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateDerivativeMarketResponse$Type extends MessageType<MsgUpdateDerivativeMarketResponse> {
    constructor() {
        super("injective.exchange.v2.MsgUpdateDerivativeMarketResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateDerivativeMarketResponse>): MsgUpdateDerivativeMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateDerivativeMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateDerivativeMarketResponse): MsgUpdateDerivativeMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateDerivativeMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateDerivativeMarketResponse
 */
export const MsgUpdateDerivativeMarketResponse = new MsgUpdateDerivativeMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("injective.exchange.v2.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "exchange/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* injective.exchange.v2.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* injective.exchange.v2.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("injective.exchange.v2.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDeposit$Type extends MessageType<MsgDeposit> {
    constructor() {
        super("injective.exchange.v2.MsgDeposit", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgDeposit", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgDeposit>): MsgDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDeposit): MsgDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgDeposit
 */
export const MsgDeposit = new MsgDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositResponse$Type extends MessageType<MsgDepositResponse> {
    constructor() {
        super("injective.exchange.v2.MsgDepositResponse", []);
    }
    create(value?: PartialMessage<MsgDepositResponse>): MsgDepositResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgDepositResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositResponse): MsgDepositResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDepositResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgDepositResponse
 */
export const MsgDepositResponse = new MsgDepositResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdraw$Type extends MessageType<MsgWithdraw> {
    constructor() {
        super("injective.exchange.v2.MsgWithdraw", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgWithdraw", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgWithdraw>): MsgWithdraw {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgWithdraw>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdraw): MsgWithdraw {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdraw, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgWithdraw
 */
export const MsgWithdraw = new MsgWithdraw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawResponse$Type extends MessageType<MsgWithdrawResponse> {
    constructor() {
        super("injective.exchange.v2.MsgWithdrawResponse", []);
    }
    create(value?: PartialMessage<MsgWithdrawResponse>): MsgWithdrawResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawResponse): MsgWithdrawResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgWithdrawResponse
 */
export const MsgWithdrawResponse = new MsgWithdrawResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotLimitOrder$Type extends MessageType<MsgCreateSpotLimitOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCreateSpotLimitOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => SpotOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgCreateSpotLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateSpotLimitOrder>): MsgCreateSpotLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotLimitOrder): MsgCreateSpotLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.SpotOrder order */ 2:
                    message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.SpotOrder order = 2; */
        if (message.order)
            SpotOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateSpotLimitOrder
 */
export const MsgCreateSpotLimitOrder = new MsgCreateSpotLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotLimitOrderResponse$Type extends MessageType<MsgCreateSpotLimitOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCreateSpotLimitOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateSpotLimitOrderResponse>): MsgCreateSpotLimitOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotLimitOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotLimitOrderResponse): MsgCreateSpotLimitOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 2:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotLimitOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 2; */
        if (message.cid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateSpotLimitOrderResponse
 */
export const MsgCreateSpotLimitOrderResponse = new MsgCreateSpotLimitOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateSpotLimitOrders$Type extends MessageType<MsgBatchCreateSpotLimitOrders> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCreateSpotLimitOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBatchCreateSpotLimitOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCreateSpotLimitOrders>): MsgBatchCreateSpotLimitOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateSpotLimitOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateSpotLimitOrders): MsgBatchCreateSpotLimitOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v2.SpotOrder orders */ 2:
                    message.orders.push(SpotOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateSpotLimitOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v2.SpotOrder orders = 2; */
        for (let i = 0; i < message.orders.length; i++)
            SpotOrder.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCreateSpotLimitOrders
 */
export const MsgBatchCreateSpotLimitOrders = new MsgBatchCreateSpotLimitOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateSpotLimitOrdersResponse$Type extends MessageType<MsgBatchCreateSpotLimitOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCreateSpotLimitOrdersResponse", [
            { no: 1, name: "order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "failed_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCreateSpotLimitOrdersResponse>): MsgBatchCreateSpotLimitOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHashes = [];
        message.createdOrdersCids = [];
        message.failedOrdersCids = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateSpotLimitOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateSpotLimitOrdersResponse): MsgBatchCreateSpotLimitOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string order_hashes */ 1:
                    message.orderHashes.push(reader.string());
                    break;
                case /* repeated string created_orders_cids */ 2:
                    message.createdOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_orders_cids */ 3:
                    message.failedOrdersCids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateSpotLimitOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string order_hashes = 1; */
        for (let i = 0; i < message.orderHashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.orderHashes[i]);
        /* repeated string created_orders_cids = 2; */
        for (let i = 0; i < message.createdOrdersCids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.createdOrdersCids[i]);
        /* repeated string failed_orders_cids = 3; */
        for (let i = 0; i < message.failedOrdersCids.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.failedOrdersCids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCreateSpotLimitOrdersResponse
 */
export const MsgBatchCreateSpotLimitOrdersResponse = new MsgBatchCreateSpotLimitOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantSpotMarketLaunch$Type extends MessageType<MsgInstantSpotMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgInstantSpotMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "base_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "base_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantSpotMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantSpotMarketLaunch>): MsgInstantSpotMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.baseDenom = "";
        message.quoteDenom = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.baseDecimals = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<MsgInstantSpotMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantSpotMarketLaunch): MsgInstantSpotMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string base_denom */ 3:
                    message.baseDenom = reader.string();
                    break;
                case /* string quote_denom */ 4:
                    message.quoteDenom = reader.string();
                    break;
                case /* string min_price_tick_size */ 5:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 6:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 7:
                    message.minNotional = reader.string();
                    break;
                case /* uint32 base_decimals */ 8:
                    message.baseDecimals = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 9:
                    message.quoteDecimals = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantSpotMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string base_denom = 3; */
        if (message.baseDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.baseDenom);
        /* string quote_denom = 4; */
        if (message.quoteDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
        /* string min_price_tick_size = 5; */
        if (message.minPriceTickSize !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 6; */
        if (message.minQuantityTickSize !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 7; */
        if (message.minNotional !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.minNotional);
        /* uint32 base_decimals = 8; */
        if (message.baseDecimals !== 0)
            writer.tag(8, WireType.Varint).uint32(message.baseDecimals);
        /* uint32 quote_decimals = 9; */
        if (message.quoteDecimals !== 0)
            writer.tag(9, WireType.Varint).uint32(message.quoteDecimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantSpotMarketLaunch
 */
export const MsgInstantSpotMarketLaunch = new MsgInstantSpotMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantSpotMarketLaunchResponse$Type extends MessageType<MsgInstantSpotMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgInstantSpotMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantSpotMarketLaunchResponse>): MsgInstantSpotMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantSpotMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantSpotMarketLaunchResponse): MsgInstantSpotMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantSpotMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantSpotMarketLaunchResponse
 */
export const MsgInstantSpotMarketLaunchResponse = new MsgInstantSpotMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantPerpetualMarketLaunch$Type extends MessageType<MsgInstantPerpetualMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgInstantPerpetualMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 8, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantPerpetualMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantPerpetualMarketLaunch>): MsgInstantPerpetualMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.quoteDenom = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleScaleFactor = 0;
        message.oracleType = 0;
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<MsgInstantPerpetualMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantPerpetualMarketLaunch): MsgInstantPerpetualMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string quote_denom */ 3:
                    message.quoteDenom = reader.string();
                    break;
                case /* string oracle_base */ 4:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 5:
                    message.oracleQuote = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 6:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 7:
                    message.oracleType = reader.int32();
                    break;
                case /* string maker_fee_rate */ 8:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 9:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string initial_margin_ratio */ 10:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 11:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string min_price_tick_size */ 12:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 13:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 14:
                    message.minNotional = reader.string();
                    break;
                case /* string reduce_margin_ratio */ 15:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 16:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantPerpetualMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string quote_denom = 3; */
        if (message.quoteDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
        /* string oracle_base = 4; */
        if (message.oracleBase !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 5; */
        if (message.oracleQuote !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
        /* uint32 oracle_scale_factor = 6; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(6, WireType.Varint).uint32(message.oracleScaleFactor);
        /* injective.oracle.v1beta1.OracleType oracle_type = 7; */
        if (message.oracleType !== 0)
            writer.tag(7, WireType.Varint).int32(message.oracleType);
        /* string maker_fee_rate = 8; */
        if (message.makerFeeRate !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 9; */
        if (message.takerFeeRate !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string initial_margin_ratio = 10; */
        if (message.initialMarginRatio !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 11; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string min_price_tick_size = 12; */
        if (message.minPriceTickSize !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 13; */
        if (message.minQuantityTickSize !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 14; */
        if (message.minNotional !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minNotional);
        /* string reduce_margin_ratio = 15; */
        if (message.reduceMarginRatio !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 16; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantPerpetualMarketLaunch
 */
export const MsgInstantPerpetualMarketLaunch = new MsgInstantPerpetualMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantPerpetualMarketLaunchResponse$Type extends MessageType<MsgInstantPerpetualMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgInstantPerpetualMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantPerpetualMarketLaunchResponse>): MsgInstantPerpetualMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantPerpetualMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantPerpetualMarketLaunchResponse): MsgInstantPerpetualMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantPerpetualMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantPerpetualMarketLaunchResponse
 */
export const MsgInstantPerpetualMarketLaunchResponse = new MsgInstantPerpetualMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantBinaryOptionsMarketLaunch$Type extends MessageType<MsgInstantBinaryOptionsMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgInstantBinaryOptionsMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 6, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantBinaryOptionsMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantBinaryOptionsMarketLaunch>): MsgInstantBinaryOptionsMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.oracleSymbol = "";
        message.oracleProvider = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.admin = "";
        message.quoteDenom = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<MsgInstantBinaryOptionsMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantBinaryOptionsMarketLaunch): MsgInstantBinaryOptionsMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_symbol */ 3:
                    message.oracleSymbol = reader.string();
                    break;
                case /* string oracle_provider */ 4:
                    message.oracleProvider = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 5:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 6:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* string maker_fee_rate */ 7:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 8:
                    message.takerFeeRate = reader.string();
                    break;
                case /* int64 expiration_timestamp */ 9:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 10:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* string admin */ 11:
                    message.admin = reader.string();
                    break;
                case /* string quote_denom */ 12:
                    message.quoteDenom = reader.string();
                    break;
                case /* string min_price_tick_size */ 13:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 14:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 15:
                    message.minNotional = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 16:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantBinaryOptionsMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_symbol = 3; */
        if (message.oracleSymbol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oracleSymbol);
        /* string oracle_provider = 4; */
        if (message.oracleProvider !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleProvider);
        /* injective.oracle.v1beta1.OracleType oracle_type = 5; */
        if (message.oracleType !== 0)
            writer.tag(5, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 6; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(6, WireType.Varint).uint32(message.oracleScaleFactor);
        /* string maker_fee_rate = 7; */
        if (message.makerFeeRate !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 8; */
        if (message.takerFeeRate !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.takerFeeRate);
        /* int64 expiration_timestamp = 9; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(9, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 10; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(10, WireType.Varint).int64(message.settlementTimestamp);
        /* string admin = 11; */
        if (message.admin !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.admin);
        /* string quote_denom = 12; */
        if (message.quoteDenom !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.quoteDenom);
        /* string min_price_tick_size = 13; */
        if (message.minPriceTickSize !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 14; */
        if (message.minQuantityTickSize !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 15; */
        if (message.minNotional !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 16; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantBinaryOptionsMarketLaunch
 */
export const MsgInstantBinaryOptionsMarketLaunch = new MsgInstantBinaryOptionsMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantBinaryOptionsMarketLaunchResponse$Type extends MessageType<MsgInstantBinaryOptionsMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgInstantBinaryOptionsMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantBinaryOptionsMarketLaunchResponse>): MsgInstantBinaryOptionsMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantBinaryOptionsMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantBinaryOptionsMarketLaunchResponse): MsgInstantBinaryOptionsMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantBinaryOptionsMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantBinaryOptionsMarketLaunchResponse
 */
export const MsgInstantBinaryOptionsMarketLaunchResponse = new MsgInstantBinaryOptionsMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantExpiryFuturesMarketLaunch$Type extends MessageType<MsgInstantExpiryFuturesMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgInstantExpiryFuturesMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "expiry", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantExpiryFuturesMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantExpiryFuturesMarketLaunch>): MsgInstantExpiryFuturesMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.quoteDenom = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.expiry = 0n;
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<MsgInstantExpiryFuturesMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantExpiryFuturesMarketLaunch): MsgInstantExpiryFuturesMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string quote_denom */ 3:
                    message.quoteDenom = reader.string();
                    break;
                case /* string oracle_base */ 4:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 5:
                    message.oracleQuote = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 6:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 7:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* int64 expiry */ 8:
                    message.expiry = reader.int64().toBigInt();
                    break;
                case /* string maker_fee_rate */ 9:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 10:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string initial_margin_ratio */ 11:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 12:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string min_price_tick_size */ 13:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 14:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 15:
                    message.minNotional = reader.string();
                    break;
                case /* string reduce_margin_ratio */ 16:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 17:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantExpiryFuturesMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string quote_denom = 3; */
        if (message.quoteDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
        /* string oracle_base = 4; */
        if (message.oracleBase !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 5; */
        if (message.oracleQuote !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
        /* injective.oracle.v1beta1.OracleType oracle_type = 6; */
        if (message.oracleType !== 0)
            writer.tag(6, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 7; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
        /* int64 expiry = 8; */
        if (message.expiry !== 0n)
            writer.tag(8, WireType.Varint).int64(message.expiry);
        /* string maker_fee_rate = 9; */
        if (message.makerFeeRate !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 10; */
        if (message.takerFeeRate !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string initial_margin_ratio = 11; */
        if (message.initialMarginRatio !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 12; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string min_price_tick_size = 13; */
        if (message.minPriceTickSize !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 14; */
        if (message.minQuantityTickSize !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 15; */
        if (message.minNotional !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
        /* string reduce_margin_ratio = 16; */
        if (message.reduceMarginRatio !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 17; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantExpiryFuturesMarketLaunch
 */
export const MsgInstantExpiryFuturesMarketLaunch = new MsgInstantExpiryFuturesMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantExpiryFuturesMarketLaunchResponse$Type extends MessageType<MsgInstantExpiryFuturesMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgInstantExpiryFuturesMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantExpiryFuturesMarketLaunchResponse>): MsgInstantExpiryFuturesMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantExpiryFuturesMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantExpiryFuturesMarketLaunchResponse): MsgInstantExpiryFuturesMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantExpiryFuturesMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgInstantExpiryFuturesMarketLaunchResponse
 */
export const MsgInstantExpiryFuturesMarketLaunchResponse = new MsgInstantExpiryFuturesMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotMarketOrder$Type extends MessageType<MsgCreateSpotMarketOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCreateSpotMarketOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => SpotOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgCreateSpotMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateSpotMarketOrder>): MsgCreateSpotMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotMarketOrder): MsgCreateSpotMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.SpotOrder order */ 2:
                    message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.SpotOrder order = 2; */
        if (message.order)
            SpotOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateSpotMarketOrder
 */
export const MsgCreateSpotMarketOrder = new MsgCreateSpotMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotMarketOrderResponse$Type extends MessageType<MsgCreateSpotMarketOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCreateSpotMarketOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", T: () => SpotMarketOrderResults, options: { "gogoproto.nullable": true } },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateSpotMarketOrderResponse>): MsgCreateSpotMarketOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotMarketOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotMarketOrderResponse): MsgCreateSpotMarketOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* injective.exchange.v2.SpotMarketOrderResults results */ 2:
                    message.results = SpotMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotMarketOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* injective.exchange.v2.SpotMarketOrderResults results = 2; */
        if (message.results)
            SpotMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateSpotMarketOrderResponse
 */
export const MsgCreateSpotMarketOrderResponse = new MsgCreateSpotMarketOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketOrderResults$Type extends MessageType<SpotMarketOrderResults> {
    constructor() {
        super("injective.exchange.v2.SpotMarketOrderResults", [
            { no: 1, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<SpotMarketOrderResults>): SpotMarketOrderResults {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = "";
        message.price = "";
        message.fee = "";
        if (value !== undefined)
            reflectionMergePartial<SpotMarketOrderResults>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketOrderResults): SpotMarketOrderResults {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string quantity */ 1:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* string fee */ 3:
                    message.fee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketOrderResults, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string quantity = 1; */
        if (message.quantity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.quantity);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* string fee = 3; */
        if (message.fee !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SpotMarketOrderResults
 */
export const SpotMarketOrderResults = new SpotMarketOrderResults$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeLimitOrder$Type extends MessageType<MsgCreateDerivativeLimitOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCreateDerivativeLimitOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateDerivativeLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateDerivativeLimitOrder>): MsgCreateDerivativeLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeLimitOrder): MsgCreateDerivativeLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateDerivativeLimitOrder
 */
export const MsgCreateDerivativeLimitOrder = new MsgCreateDerivativeLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeLimitOrderResponse$Type extends MessageType<MsgCreateDerivativeLimitOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCreateDerivativeLimitOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateDerivativeLimitOrderResponse>): MsgCreateDerivativeLimitOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeLimitOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeLimitOrderResponse): MsgCreateDerivativeLimitOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 2:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeLimitOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 2; */
        if (message.cid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateDerivativeLimitOrderResponse
 */
export const MsgCreateDerivativeLimitOrderResponse = new MsgCreateDerivativeLimitOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsLimitOrder$Type extends MessageType<MsgCreateBinaryOptionsLimitOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCreateBinaryOptionsLimitOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateBinaryOptionsLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsLimitOrder>): MsgCreateBinaryOptionsLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsLimitOrder): MsgCreateBinaryOptionsLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateBinaryOptionsLimitOrder
 */
export const MsgCreateBinaryOptionsLimitOrder = new MsgCreateBinaryOptionsLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsLimitOrderResponse$Type extends MessageType<MsgCreateBinaryOptionsLimitOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCreateBinaryOptionsLimitOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsLimitOrderResponse>): MsgCreateBinaryOptionsLimitOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsLimitOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsLimitOrderResponse): MsgCreateBinaryOptionsLimitOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 2:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsLimitOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 2; */
        if (message.cid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateBinaryOptionsLimitOrderResponse
 */
export const MsgCreateBinaryOptionsLimitOrderResponse = new MsgCreateBinaryOptionsLimitOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateDerivativeLimitOrders$Type extends MessageType<MsgBatchCreateDerivativeLimitOrders> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCreateDerivativeLimitOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCreateDerivativeLimitOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCreateDerivativeLimitOrders>): MsgBatchCreateDerivativeLimitOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateDerivativeLimitOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateDerivativeLimitOrders): MsgBatchCreateDerivativeLimitOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v2.DerivativeOrder orders */ 2:
                    message.orders.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateDerivativeLimitOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v2.DerivativeOrder orders = 2; */
        for (let i = 0; i < message.orders.length; i++)
            DerivativeOrder.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCreateDerivativeLimitOrders
 */
export const MsgBatchCreateDerivativeLimitOrders = new MsgBatchCreateDerivativeLimitOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateDerivativeLimitOrdersResponse$Type extends MessageType<MsgBatchCreateDerivativeLimitOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCreateDerivativeLimitOrdersResponse", [
            { no: 1, name: "order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "failed_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCreateDerivativeLimitOrdersResponse>): MsgBatchCreateDerivativeLimitOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHashes = [];
        message.createdOrdersCids = [];
        message.failedOrdersCids = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateDerivativeLimitOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateDerivativeLimitOrdersResponse): MsgBatchCreateDerivativeLimitOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string order_hashes */ 1:
                    message.orderHashes.push(reader.string());
                    break;
                case /* repeated string created_orders_cids */ 2:
                    message.createdOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_orders_cids */ 3:
                    message.failedOrdersCids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateDerivativeLimitOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string order_hashes = 1; */
        for (let i = 0; i < message.orderHashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.orderHashes[i]);
        /* repeated string created_orders_cids = 2; */
        for (let i = 0; i < message.createdOrdersCids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.createdOrdersCids[i]);
        /* repeated string failed_orders_cids = 3; */
        for (let i = 0; i < message.failedOrdersCids.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.failedOrdersCids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCreateDerivativeLimitOrdersResponse
 */
export const MsgBatchCreateDerivativeLimitOrdersResponse = new MsgBatchCreateDerivativeLimitOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelSpotOrder$Type extends MessageType<MsgCancelSpotOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCancelSpotOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelSpotOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelSpotOrder>): MsgCancelSpotOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelSpotOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelSpotOrder): MsgCancelSpotOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 4:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 5:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelSpotOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 4; */
        if (message.orderHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 5; */
        if (message.cid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelSpotOrder
 */
export const MsgCancelSpotOrder = new MsgCancelSpotOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelSpotOrderResponse$Type extends MessageType<MsgCancelSpotOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCancelSpotOrderResponse", []);
    }
    create(value?: PartialMessage<MsgCancelSpotOrderResponse>): MsgCancelSpotOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelSpotOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelSpotOrderResponse): MsgCancelSpotOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelSpotOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelSpotOrderResponse
 */
export const MsgCancelSpotOrderResponse = new MsgCancelSpotOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelSpotOrders$Type extends MessageType<MsgBatchCancelSpotOrders> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCancelSpotOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelSpotOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCancelSpotOrders>): MsgBatchCancelSpotOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelSpotOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelSpotOrders): MsgBatchCancelSpotOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v2.OrderData data */ 2:
                    message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelSpotOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v2.OrderData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCancelSpotOrders
 */
export const MsgBatchCancelSpotOrders = new MsgBatchCancelSpotOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelSpotOrdersResponse$Type extends MessageType<MsgBatchCancelSpotOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCancelSpotOrdersResponse", [
            { no: 1, name: "success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCancelSpotOrdersResponse>): MsgBatchCancelSpotOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelSpotOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelSpotOrdersResponse): MsgBatchCancelSpotOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.success.push(reader.bool());
                    else
                        message.success.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelSpotOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool success = 1; */
        if (message.success.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.success.length; i++)
                writer.bool(message.success[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCancelSpotOrdersResponse
 */
export const MsgBatchCancelSpotOrdersResponse = new MsgBatchCancelSpotOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelBinaryOptionsOrders$Type extends MessageType<MsgBatchCancelBinaryOptionsOrders> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCancelBinaryOptionsOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelBinaryOptionsOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCancelBinaryOptionsOrders>): MsgBatchCancelBinaryOptionsOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelBinaryOptionsOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelBinaryOptionsOrders): MsgBatchCancelBinaryOptionsOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v2.OrderData data */ 2:
                    message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelBinaryOptionsOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v2.OrderData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCancelBinaryOptionsOrders
 */
export const MsgBatchCancelBinaryOptionsOrders = new MsgBatchCancelBinaryOptionsOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelBinaryOptionsOrdersResponse$Type extends MessageType<MsgBatchCancelBinaryOptionsOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCancelBinaryOptionsOrdersResponse", [
            { no: 1, name: "success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCancelBinaryOptionsOrdersResponse>): MsgBatchCancelBinaryOptionsOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelBinaryOptionsOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelBinaryOptionsOrdersResponse): MsgBatchCancelBinaryOptionsOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.success.push(reader.bool());
                    else
                        message.success.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelBinaryOptionsOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool success = 1; */
        if (message.success.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.success.length; i++)
                writer.bool(message.success[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCancelBinaryOptionsOrdersResponse
 */
export const MsgBatchCancelBinaryOptionsOrdersResponse = new MsgBatchCancelBinaryOptionsOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchUpdateOrders$Type extends MessageType<MsgBatchUpdateOrders> {
    constructor() {
        super("injective.exchange.v2.MsgBatchUpdateOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spot_market_ids_to_cancel_all", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "derivative_market_ids_to_cancel_all", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "spot_orders_to_cancel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": true } },
            { no: 6, name: "derivative_orders_to_cancel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": true } },
            { no: 7, name: "spot_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrder, options: { "gogoproto.nullable": true } },
            { no: 8, name: "derivative_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } },
            { no: 9, name: "binary_options_orders_to_cancel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": true } },
            { no: 10, name: "binary_options_market_ids_to_cancel_all", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "binary_options_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } },
            { no: 12, name: "spot_market_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrder, options: { "gogoproto.nullable": true } },
            { no: 13, name: "derivative_market_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } },
            { no: 14, name: "binary_options_market_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchUpdateOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchUpdateOrders>): MsgBatchUpdateOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        message.spotMarketIdsToCancelAll = [];
        message.derivativeMarketIdsToCancelAll = [];
        message.spotOrdersToCancel = [];
        message.derivativeOrdersToCancel = [];
        message.spotOrdersToCreate = [];
        message.derivativeOrdersToCreate = [];
        message.binaryOptionsOrdersToCancel = [];
        message.binaryOptionsMarketIdsToCancelAll = [];
        message.binaryOptionsOrdersToCreate = [];
        message.spotMarketOrdersToCreate = [];
        message.derivativeMarketOrdersToCreate = [];
        message.binaryOptionsMarketOrdersToCreate = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchUpdateOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchUpdateOrders): MsgBatchUpdateOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated string spot_market_ids_to_cancel_all */ 3:
                    message.spotMarketIdsToCancelAll.push(reader.string());
                    break;
                case /* repeated string derivative_market_ids_to_cancel_all */ 4:
                    message.derivativeMarketIdsToCancelAll.push(reader.string());
                    break;
                case /* repeated injective.exchange.v2.OrderData spot_orders_to_cancel */ 5:
                    message.spotOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.OrderData derivative_orders_to_cancel */ 6:
                    message.derivativeOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.SpotOrder spot_orders_to_create */ 7:
                    message.spotOrdersToCreate.push(SpotOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativeOrder derivative_orders_to_create */ 8:
                    message.derivativeOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.OrderData binary_options_orders_to_cancel */ 9:
                    message.binaryOptionsOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string binary_options_market_ids_to_cancel_all */ 10:
                    message.binaryOptionsMarketIdsToCancelAll.push(reader.string());
                    break;
                case /* repeated injective.exchange.v2.DerivativeOrder binary_options_orders_to_create */ 11:
                    message.binaryOptionsOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.SpotOrder spot_market_orders_to_create */ 12:
                    message.spotMarketOrdersToCreate.push(SpotOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativeOrder derivative_market_orders_to_create */ 13:
                    message.derivativeMarketOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativeOrder binary_options_market_orders_to_create */ 14:
                    message.binaryOptionsMarketOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchUpdateOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated string spot_market_ids_to_cancel_all = 3; */
        for (let i = 0; i < message.spotMarketIdsToCancelAll.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.spotMarketIdsToCancelAll[i]);
        /* repeated string derivative_market_ids_to_cancel_all = 4; */
        for (let i = 0; i < message.derivativeMarketIdsToCancelAll.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.derivativeMarketIdsToCancelAll[i]);
        /* repeated injective.exchange.v2.OrderData spot_orders_to_cancel = 5; */
        for (let i = 0; i < message.spotOrdersToCancel.length; i++)
            OrderData.internalBinaryWrite(message.spotOrdersToCancel[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.OrderData derivative_orders_to_cancel = 6; */
        for (let i = 0; i < message.derivativeOrdersToCancel.length; i++)
            OrderData.internalBinaryWrite(message.derivativeOrdersToCancel[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.SpotOrder spot_orders_to_create = 7; */
        for (let i = 0; i < message.spotOrdersToCreate.length; i++)
            SpotOrder.internalBinaryWrite(message.spotOrdersToCreate[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativeOrder derivative_orders_to_create = 8; */
        for (let i = 0; i < message.derivativeOrdersToCreate.length; i++)
            DerivativeOrder.internalBinaryWrite(message.derivativeOrdersToCreate[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.OrderData binary_options_orders_to_cancel = 9; */
        for (let i = 0; i < message.binaryOptionsOrdersToCancel.length; i++)
            OrderData.internalBinaryWrite(message.binaryOptionsOrdersToCancel[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string binary_options_market_ids_to_cancel_all = 10; */
        for (let i = 0; i < message.binaryOptionsMarketIdsToCancelAll.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.binaryOptionsMarketIdsToCancelAll[i]);
        /* repeated injective.exchange.v2.DerivativeOrder binary_options_orders_to_create = 11; */
        for (let i = 0; i < message.binaryOptionsOrdersToCreate.length; i++)
            DerivativeOrder.internalBinaryWrite(message.binaryOptionsOrdersToCreate[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.SpotOrder spot_market_orders_to_create = 12; */
        for (let i = 0; i < message.spotMarketOrdersToCreate.length; i++)
            SpotOrder.internalBinaryWrite(message.spotMarketOrdersToCreate[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativeOrder derivative_market_orders_to_create = 13; */
        for (let i = 0; i < message.derivativeMarketOrdersToCreate.length; i++)
            DerivativeOrder.internalBinaryWrite(message.derivativeMarketOrdersToCreate[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativeOrder binary_options_market_orders_to_create = 14; */
        for (let i = 0; i < message.binaryOptionsMarketOrdersToCreate.length; i++)
            DerivativeOrder.internalBinaryWrite(message.binaryOptionsMarketOrdersToCreate[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchUpdateOrders
 */
export const MsgBatchUpdateOrders = new MsgBatchUpdateOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchUpdateOrdersResponse$Type extends MessageType<MsgBatchUpdateOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchUpdateOrdersResponse", [
            { no: 1, name: "spot_cancel_success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "derivative_cancel_success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "spot_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "derivative_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "binary_options_cancel_success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "binary_options_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_spot_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "failed_spot_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "created_derivative_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "failed_derivative_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "created_binary_options_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "failed_binary_options_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "spot_market_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "created_spot_market_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "failed_spot_market_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "derivative_market_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "created_derivative_market_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "failed_derivative_market_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "binary_options_market_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "created_binary_options_market_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "failed_binary_options_market_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchUpdateOrdersResponse>): MsgBatchUpdateOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spotCancelSuccess = [];
        message.derivativeCancelSuccess = [];
        message.spotOrderHashes = [];
        message.derivativeOrderHashes = [];
        message.binaryOptionsCancelSuccess = [];
        message.binaryOptionsOrderHashes = [];
        message.createdSpotOrdersCids = [];
        message.failedSpotOrdersCids = [];
        message.createdDerivativeOrdersCids = [];
        message.failedDerivativeOrdersCids = [];
        message.createdBinaryOptionsOrdersCids = [];
        message.failedBinaryOptionsOrdersCids = [];
        message.spotMarketOrderHashes = [];
        message.createdSpotMarketOrdersCids = [];
        message.failedSpotMarketOrdersCids = [];
        message.derivativeMarketOrderHashes = [];
        message.createdDerivativeMarketOrdersCids = [];
        message.failedDerivativeMarketOrdersCids = [];
        message.binaryOptionsMarketOrderHashes = [];
        message.createdBinaryOptionsMarketOrdersCids = [];
        message.failedBinaryOptionsMarketOrdersCids = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchUpdateOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchUpdateOrdersResponse): MsgBatchUpdateOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool spot_cancel_success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.spotCancelSuccess.push(reader.bool());
                    else
                        message.spotCancelSuccess.push(reader.bool());
                    break;
                case /* repeated bool derivative_cancel_success */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.derivativeCancelSuccess.push(reader.bool());
                    else
                        message.derivativeCancelSuccess.push(reader.bool());
                    break;
                case /* repeated string spot_order_hashes */ 3:
                    message.spotOrderHashes.push(reader.string());
                    break;
                case /* repeated string derivative_order_hashes */ 4:
                    message.derivativeOrderHashes.push(reader.string());
                    break;
                case /* repeated bool binary_options_cancel_success */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.binaryOptionsCancelSuccess.push(reader.bool());
                    else
                        message.binaryOptionsCancelSuccess.push(reader.bool());
                    break;
                case /* repeated string binary_options_order_hashes */ 6:
                    message.binaryOptionsOrderHashes.push(reader.string());
                    break;
                case /* repeated string created_spot_orders_cids */ 7:
                    message.createdSpotOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_spot_orders_cids */ 8:
                    message.failedSpotOrdersCids.push(reader.string());
                    break;
                case /* repeated string created_derivative_orders_cids */ 9:
                    message.createdDerivativeOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_derivative_orders_cids */ 10:
                    message.failedDerivativeOrdersCids.push(reader.string());
                    break;
                case /* repeated string created_binary_options_orders_cids */ 11:
                    message.createdBinaryOptionsOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_binary_options_orders_cids */ 12:
                    message.failedBinaryOptionsOrdersCids.push(reader.string());
                    break;
                case /* repeated string spot_market_order_hashes */ 13:
                    message.spotMarketOrderHashes.push(reader.string());
                    break;
                case /* repeated string created_spot_market_orders_cids */ 14:
                    message.createdSpotMarketOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_spot_market_orders_cids */ 15:
                    message.failedSpotMarketOrdersCids.push(reader.string());
                    break;
                case /* repeated string derivative_market_order_hashes */ 16:
                    message.derivativeMarketOrderHashes.push(reader.string());
                    break;
                case /* repeated string created_derivative_market_orders_cids */ 17:
                    message.createdDerivativeMarketOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_derivative_market_orders_cids */ 18:
                    message.failedDerivativeMarketOrdersCids.push(reader.string());
                    break;
                case /* repeated string binary_options_market_order_hashes */ 19:
                    message.binaryOptionsMarketOrderHashes.push(reader.string());
                    break;
                case /* repeated string created_binary_options_market_orders_cids */ 20:
                    message.createdBinaryOptionsMarketOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_binary_options_market_orders_cids */ 21:
                    message.failedBinaryOptionsMarketOrdersCids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchUpdateOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool spot_cancel_success = 1; */
        if (message.spotCancelSuccess.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.spotCancelSuccess.length; i++)
                writer.bool(message.spotCancelSuccess[i]);
            writer.join();
        }
        /* repeated bool derivative_cancel_success = 2; */
        if (message.derivativeCancelSuccess.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.derivativeCancelSuccess.length; i++)
                writer.bool(message.derivativeCancelSuccess[i]);
            writer.join();
        }
        /* repeated string spot_order_hashes = 3; */
        for (let i = 0; i < message.spotOrderHashes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.spotOrderHashes[i]);
        /* repeated string derivative_order_hashes = 4; */
        for (let i = 0; i < message.derivativeOrderHashes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.derivativeOrderHashes[i]);
        /* repeated bool binary_options_cancel_success = 5; */
        if (message.binaryOptionsCancelSuccess.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.binaryOptionsCancelSuccess.length; i++)
                writer.bool(message.binaryOptionsCancelSuccess[i]);
            writer.join();
        }
        /* repeated string binary_options_order_hashes = 6; */
        for (let i = 0; i < message.binaryOptionsOrderHashes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.binaryOptionsOrderHashes[i]);
        /* repeated string created_spot_orders_cids = 7; */
        for (let i = 0; i < message.createdSpotOrdersCids.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.createdSpotOrdersCids[i]);
        /* repeated string failed_spot_orders_cids = 8; */
        for (let i = 0; i < message.failedSpotOrdersCids.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.failedSpotOrdersCids[i]);
        /* repeated string created_derivative_orders_cids = 9; */
        for (let i = 0; i < message.createdDerivativeOrdersCids.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.createdDerivativeOrdersCids[i]);
        /* repeated string failed_derivative_orders_cids = 10; */
        for (let i = 0; i < message.failedDerivativeOrdersCids.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.failedDerivativeOrdersCids[i]);
        /* repeated string created_binary_options_orders_cids = 11; */
        for (let i = 0; i < message.createdBinaryOptionsOrdersCids.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.createdBinaryOptionsOrdersCids[i]);
        /* repeated string failed_binary_options_orders_cids = 12; */
        for (let i = 0; i < message.failedBinaryOptionsOrdersCids.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.failedBinaryOptionsOrdersCids[i]);
        /* repeated string spot_market_order_hashes = 13; */
        for (let i = 0; i < message.spotMarketOrderHashes.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.spotMarketOrderHashes[i]);
        /* repeated string created_spot_market_orders_cids = 14; */
        for (let i = 0; i < message.createdSpotMarketOrdersCids.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.createdSpotMarketOrdersCids[i]);
        /* repeated string failed_spot_market_orders_cids = 15; */
        for (let i = 0; i < message.failedSpotMarketOrdersCids.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.failedSpotMarketOrdersCids[i]);
        /* repeated string derivative_market_order_hashes = 16; */
        for (let i = 0; i < message.derivativeMarketOrderHashes.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.derivativeMarketOrderHashes[i]);
        /* repeated string created_derivative_market_orders_cids = 17; */
        for (let i = 0; i < message.createdDerivativeMarketOrdersCids.length; i++)
            writer.tag(17, WireType.LengthDelimited).string(message.createdDerivativeMarketOrdersCids[i]);
        /* repeated string failed_derivative_market_orders_cids = 18; */
        for (let i = 0; i < message.failedDerivativeMarketOrdersCids.length; i++)
            writer.tag(18, WireType.LengthDelimited).string(message.failedDerivativeMarketOrdersCids[i]);
        /* repeated string binary_options_market_order_hashes = 19; */
        for (let i = 0; i < message.binaryOptionsMarketOrderHashes.length; i++)
            writer.tag(19, WireType.LengthDelimited).string(message.binaryOptionsMarketOrderHashes[i]);
        /* repeated string created_binary_options_market_orders_cids = 20; */
        for (let i = 0; i < message.createdBinaryOptionsMarketOrdersCids.length; i++)
            writer.tag(20, WireType.LengthDelimited).string(message.createdBinaryOptionsMarketOrdersCids[i]);
        /* repeated string failed_binary_options_market_orders_cids = 21; */
        for (let i = 0; i < message.failedBinaryOptionsMarketOrdersCids.length; i++)
            writer.tag(21, WireType.LengthDelimited).string(message.failedBinaryOptionsMarketOrdersCids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchUpdateOrdersResponse
 */
export const MsgBatchUpdateOrdersResponse = new MsgBatchUpdateOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeMarketOrder$Type extends MessageType<MsgCreateDerivativeMarketOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCreateDerivativeMarketOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateDerivativeMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateDerivativeMarketOrder>): MsgCreateDerivativeMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeMarketOrder): MsgCreateDerivativeMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateDerivativeMarketOrder
 */
export const MsgCreateDerivativeMarketOrder = new MsgCreateDerivativeMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeMarketOrderResponse$Type extends MessageType<MsgCreateDerivativeMarketOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCreateDerivativeMarketOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", T: () => DerivativeMarketOrderResults, options: { "gogoproto.nullable": true } },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateDerivativeMarketOrderResponse>): MsgCreateDerivativeMarketOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeMarketOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeMarketOrderResponse): MsgCreateDerivativeMarketOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeMarketOrderResults results */ 2:
                    message.results = DerivativeMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeMarketOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* injective.exchange.v2.DerivativeMarketOrderResults results = 2; */
        if (message.results)
            DerivativeMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateDerivativeMarketOrderResponse
 */
export const MsgCreateDerivativeMarketOrderResponse = new MsgCreateDerivativeMarketOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketOrderResults$Type extends MessageType<DerivativeMarketOrderResults> {
    constructor() {
        super("injective.exchange.v2.DerivativeMarketOrderResults", [
            { no: 1, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "position_delta", kind: "message", T: () => PositionDelta, options: { "gogoproto.nullable": false } },
            { no: 5, name: "payout", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<DerivativeMarketOrderResults>): DerivativeMarketOrderResults {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = "";
        message.price = "";
        message.fee = "";
        message.payout = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketOrderResults>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketOrderResults): DerivativeMarketOrderResults {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string quantity */ 1:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* string fee */ 3:
                    message.fee = reader.string();
                    break;
                case /* injective.exchange.v2.PositionDelta position_delta */ 4:
                    message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
                    break;
                case /* string payout */ 5:
                    message.payout = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketOrderResults, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string quantity = 1; */
        if (message.quantity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.quantity);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* string fee = 3; */
        if (message.fee !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fee);
        /* injective.exchange.v2.PositionDelta position_delta = 4; */
        if (message.positionDelta)
            PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string payout = 5; */
        if (message.payout !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.payout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DerivativeMarketOrderResults
 */
export const DerivativeMarketOrderResults = new DerivativeMarketOrderResults$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsMarketOrder$Type extends MessageType<MsgCreateBinaryOptionsMarketOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCreateBinaryOptionsMarketOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateBinaryOptionsMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsMarketOrder>): MsgCreateBinaryOptionsMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsMarketOrder): MsgCreateBinaryOptionsMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateBinaryOptionsMarketOrder
 */
export const MsgCreateBinaryOptionsMarketOrder = new MsgCreateBinaryOptionsMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsMarketOrderResponse$Type extends MessageType<MsgCreateBinaryOptionsMarketOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCreateBinaryOptionsMarketOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", T: () => DerivativeMarketOrderResults, options: { "gogoproto.nullable": true } },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsMarketOrderResponse>): MsgCreateBinaryOptionsMarketOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsMarketOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsMarketOrderResponse): MsgCreateBinaryOptionsMarketOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeMarketOrderResults results */ 2:
                    message.results = DerivativeMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsMarketOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* injective.exchange.v2.DerivativeMarketOrderResults results = 2; */
        if (message.results)
            DerivativeMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCreateBinaryOptionsMarketOrderResponse
 */
export const MsgCreateBinaryOptionsMarketOrderResponse = new MsgCreateBinaryOptionsMarketOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelDerivativeOrder$Type extends MessageType<MsgCancelDerivativeOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCancelDerivativeOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "order_mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelDerivativeOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelDerivativeOrder>): MsgCancelDerivativeOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.orderMask = 0;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelDerivativeOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelDerivativeOrder): MsgCancelDerivativeOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 4:
                    message.orderHash = reader.string();
                    break;
                case /* int32 order_mask */ 5:
                    message.orderMask = reader.int32();
                    break;
                case /* string cid */ 6:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelDerivativeOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 4; */
        if (message.orderHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
        /* int32 order_mask = 5; */
        if (message.orderMask !== 0)
            writer.tag(5, WireType.Varint).int32(message.orderMask);
        /* string cid = 6; */
        if (message.cid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelDerivativeOrder
 */
export const MsgCancelDerivativeOrder = new MsgCancelDerivativeOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelDerivativeOrderResponse$Type extends MessageType<MsgCancelDerivativeOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCancelDerivativeOrderResponse", []);
    }
    create(value?: PartialMessage<MsgCancelDerivativeOrderResponse>): MsgCancelDerivativeOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelDerivativeOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelDerivativeOrderResponse): MsgCancelDerivativeOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelDerivativeOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelDerivativeOrderResponse
 */
export const MsgCancelDerivativeOrderResponse = new MsgCancelDerivativeOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelBinaryOptionsOrder$Type extends MessageType<MsgCancelBinaryOptionsOrder> {
    constructor() {
        super("injective.exchange.v2.MsgCancelBinaryOptionsOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "order_mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelBinaryOptionsOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelBinaryOptionsOrder>): MsgCancelBinaryOptionsOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.orderMask = 0;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelBinaryOptionsOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelBinaryOptionsOrder): MsgCancelBinaryOptionsOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 4:
                    message.orderHash = reader.string();
                    break;
                case /* int32 order_mask */ 5:
                    message.orderMask = reader.int32();
                    break;
                case /* string cid */ 6:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelBinaryOptionsOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 4; */
        if (message.orderHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
        /* int32 order_mask = 5; */
        if (message.orderMask !== 0)
            writer.tag(5, WireType.Varint).int32(message.orderMask);
        /* string cid = 6; */
        if (message.cid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelBinaryOptionsOrder
 */
export const MsgCancelBinaryOptionsOrder = new MsgCancelBinaryOptionsOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelBinaryOptionsOrderResponse$Type extends MessageType<MsgCancelBinaryOptionsOrderResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCancelBinaryOptionsOrderResponse", []);
    }
    create(value?: PartialMessage<MsgCancelBinaryOptionsOrderResponse>): MsgCancelBinaryOptionsOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelBinaryOptionsOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelBinaryOptionsOrderResponse): MsgCancelBinaryOptionsOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelBinaryOptionsOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelBinaryOptionsOrderResponse
 */
export const MsgCancelBinaryOptionsOrderResponse = new MsgCancelBinaryOptionsOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderData$Type extends MessageType<OrderData> {
    constructor() {
        super("injective.exchange.v2.OrderData", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderData>): OrderData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.orderMask = 0;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<OrderData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderData): OrderData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 3:
                    message.orderHash = reader.string();
                    break;
                case /* int32 order_mask */ 4:
                    message.orderMask = reader.int32();
                    break;
                case /* string cid */ 5:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 3; */
        if (message.orderHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.orderHash);
        /* int32 order_mask = 4; */
        if (message.orderMask !== 0)
            writer.tag(4, WireType.Varint).int32(message.orderMask);
        /* string cid = 5; */
        if (message.cid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OrderData
 */
export const OrderData = new OrderData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelDerivativeOrders$Type extends MessageType<MsgBatchCancelDerivativeOrders> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCancelDerivativeOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelDerivativeOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCancelDerivativeOrders>): MsgBatchCancelDerivativeOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelDerivativeOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelDerivativeOrders): MsgBatchCancelDerivativeOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v2.OrderData data */ 2:
                    message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelDerivativeOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v2.OrderData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCancelDerivativeOrders
 */
export const MsgBatchCancelDerivativeOrders = new MsgBatchCancelDerivativeOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelDerivativeOrdersResponse$Type extends MessageType<MsgBatchCancelDerivativeOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCancelDerivativeOrdersResponse", [
            { no: 1, name: "success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCancelDerivativeOrdersResponse>): MsgBatchCancelDerivativeOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelDerivativeOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelDerivativeOrdersResponse): MsgBatchCancelDerivativeOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.success.push(reader.bool());
                    else
                        message.success.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelDerivativeOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool success = 1; */
        if (message.success.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.success.length; i++)
                writer.bool(message.success[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCancelDerivativeOrdersResponse
 */
export const MsgBatchCancelDerivativeOrdersResponse = new MsgBatchCancelDerivativeOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubaccountTransfer$Type extends MessageType<MsgSubaccountTransfer> {
    constructor() {
        super("injective.exchange.v2.MsgSubaccountTransfer", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "exchange/MsgSubaccountTransfer", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgSubaccountTransfer>): MsgSubaccountTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSubaccountTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubaccountTransfer): MsgSubaccountTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 4:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubaccountTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* cosmos.base.v1beta1.Coin amount = 4; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSubaccountTransfer
 */
export const MsgSubaccountTransfer = new MsgSubaccountTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubaccountTransferResponse$Type extends MessageType<MsgSubaccountTransferResponse> {
    constructor() {
        super("injective.exchange.v2.MsgSubaccountTransferResponse", []);
    }
    create(value?: PartialMessage<MsgSubaccountTransferResponse>): MsgSubaccountTransferResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSubaccountTransferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubaccountTransferResponse): MsgSubaccountTransferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubaccountTransferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSubaccountTransferResponse
 */
export const MsgSubaccountTransferResponse = new MsgSubaccountTransferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExternalTransfer$Type extends MessageType<MsgExternalTransfer> {
    constructor() {
        super("injective.exchange.v2.MsgExternalTransfer", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "exchange/MsgExternalTransfer", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgExternalTransfer>): MsgExternalTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgExternalTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExternalTransfer): MsgExternalTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 4:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExternalTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* cosmos.base.v1beta1.Coin amount = 4; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgExternalTransfer
 */
export const MsgExternalTransfer = new MsgExternalTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExternalTransferResponse$Type extends MessageType<MsgExternalTransferResponse> {
    constructor() {
        super("injective.exchange.v2.MsgExternalTransferResponse", []);
    }
    create(value?: PartialMessage<MsgExternalTransferResponse>): MsgExternalTransferResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgExternalTransferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExternalTransferResponse): MsgExternalTransferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExternalTransferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgExternalTransferResponse
 */
export const MsgExternalTransferResponse = new MsgExternalTransferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLiquidatePosition$Type extends MessageType<MsgLiquidatePosition> {
    constructor() {
        super("injective.exchange.v2.MsgLiquidatePosition", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": true } }
        ], { "amino.name": "exchange/MsgLiquidatePosition", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgLiquidatePosition>): MsgLiquidatePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgLiquidatePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLiquidatePosition): MsgLiquidatePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeOrder order */ 4:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgLiquidatePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v2.DerivativeOrder order = 4; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgLiquidatePosition
 */
export const MsgLiquidatePosition = new MsgLiquidatePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLiquidatePositionResponse$Type extends MessageType<MsgLiquidatePositionResponse> {
    constructor() {
        super("injective.exchange.v2.MsgLiquidatePositionResponse", []);
    }
    create(value?: PartialMessage<MsgLiquidatePositionResponse>): MsgLiquidatePositionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgLiquidatePositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLiquidatePositionResponse): MsgLiquidatePositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgLiquidatePositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgLiquidatePositionResponse
 */
export const MsgLiquidatePositionResponse = new MsgLiquidatePositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgOffsetPosition$Type extends MessageType<MsgOffsetPosition> {
    constructor() {
        super("injective.exchange.v2.MsgOffsetPosition", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "offsetting_subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "exchange/MsgOffsetPosition", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgOffsetPosition>): MsgOffsetPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        message.marketId = "";
        message.offsettingSubaccountIds = [];
        if (value !== undefined)
            reflectionMergePartial<MsgOffsetPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgOffsetPosition): MsgOffsetPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* repeated string offsetting_subaccount_ids */ 4:
                    message.offsettingSubaccountIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgOffsetPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* repeated string offsetting_subaccount_ids = 4; */
        for (let i = 0; i < message.offsettingSubaccountIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.offsettingSubaccountIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgOffsetPosition
 */
export const MsgOffsetPosition = new MsgOffsetPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgOffsetPositionResponse$Type extends MessageType<MsgOffsetPositionResponse> {
    constructor() {
        super("injective.exchange.v2.MsgOffsetPositionResponse", []);
    }
    create(value?: PartialMessage<MsgOffsetPositionResponse>): MsgOffsetPositionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgOffsetPositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgOffsetPositionResponse): MsgOffsetPositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgOffsetPositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgOffsetPositionResponse
 */
export const MsgOffsetPositionResponse = new MsgOffsetPositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgEmergencySettleMarket$Type extends MessageType<MsgEmergencySettleMarket> {
    constructor() {
        super("injective.exchange.v2.MsgEmergencySettleMarket", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "exchange/MsgEmergencySettleMarket", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgEmergencySettleMarket>): MsgEmergencySettleMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgEmergencySettleMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgEmergencySettleMarket): MsgEmergencySettleMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgEmergencySettleMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgEmergencySettleMarket
 */
export const MsgEmergencySettleMarket = new MsgEmergencySettleMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgEmergencySettleMarketResponse$Type extends MessageType<MsgEmergencySettleMarketResponse> {
    constructor() {
        super("injective.exchange.v2.MsgEmergencySettleMarketResponse", []);
    }
    create(value?: PartialMessage<MsgEmergencySettleMarketResponse>): MsgEmergencySettleMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgEmergencySettleMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgEmergencySettleMarketResponse): MsgEmergencySettleMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgEmergencySettleMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgEmergencySettleMarketResponse
 */
export const MsgEmergencySettleMarketResponse = new MsgEmergencySettleMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgIncreasePositionMargin$Type extends MessageType<MsgIncreasePositionMargin> {
    constructor() {
        super("injective.exchange.v2.MsgIncreasePositionMargin", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "amino.name": "exchange/MsgIncreasePositionMargin", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgIncreasePositionMargin>): MsgIncreasePositionMargin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        message.marketId = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<MsgIncreasePositionMargin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgIncreasePositionMargin): MsgIncreasePositionMargin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgIncreasePositionMargin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgIncreasePositionMargin
 */
export const MsgIncreasePositionMargin = new MsgIncreasePositionMargin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgIncreasePositionMarginResponse$Type extends MessageType<MsgIncreasePositionMarginResponse> {
    constructor() {
        super("injective.exchange.v2.MsgIncreasePositionMarginResponse", []);
    }
    create(value?: PartialMessage<MsgIncreasePositionMarginResponse>): MsgIncreasePositionMarginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgIncreasePositionMarginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgIncreasePositionMarginResponse): MsgIncreasePositionMarginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgIncreasePositionMarginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgIncreasePositionMarginResponse
 */
export const MsgIncreasePositionMarginResponse = new MsgIncreasePositionMarginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDecreasePositionMargin$Type extends MessageType<MsgDecreasePositionMargin> {
    constructor() {
        super("injective.exchange.v2.MsgDecreasePositionMargin", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "amino.name": "exchange/MsgDecreasePositionMargin", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgDecreasePositionMargin>): MsgDecreasePositionMargin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        message.marketId = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<MsgDecreasePositionMargin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDecreasePositionMargin): MsgDecreasePositionMargin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDecreasePositionMargin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgDecreasePositionMargin
 */
export const MsgDecreasePositionMargin = new MsgDecreasePositionMargin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDecreasePositionMarginResponse$Type extends MessageType<MsgDecreasePositionMarginResponse> {
    constructor() {
        super("injective.exchange.v2.MsgDecreasePositionMarginResponse", []);
    }
    create(value?: PartialMessage<MsgDecreasePositionMarginResponse>): MsgDecreasePositionMarginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgDecreasePositionMarginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDecreasePositionMarginResponse): MsgDecreasePositionMarginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDecreasePositionMarginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgDecreasePositionMarginResponse
 */
export const MsgDecreasePositionMarginResponse = new MsgDecreasePositionMarginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPrivilegedExecuteContract$Type extends MessageType<MsgPrivilegedExecuteContract> {
    constructor() {
        super("injective.exchange.v2.MsgPrivilegedExecuteContract", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "funds", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgPrivilegedExecuteContract", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgPrivilegedExecuteContract>): MsgPrivilegedExecuteContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.funds = "";
        message.contractAddress = "";
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<MsgPrivilegedExecuteContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPrivilegedExecuteContract): MsgPrivilegedExecuteContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string funds */ 2:
                    message.funds = reader.string();
                    break;
                case /* string contract_address */ 3:
                    message.contractAddress = reader.string();
                    break;
                case /* string data */ 4:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPrivilegedExecuteContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string funds = 2; */
        if (message.funds !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.funds);
        /* string contract_address = 3; */
        if (message.contractAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contractAddress);
        /* string data = 4; */
        if (message.data !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgPrivilegedExecuteContract
 */
export const MsgPrivilegedExecuteContract = new MsgPrivilegedExecuteContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPrivilegedExecuteContractResponse$Type extends MessageType<MsgPrivilegedExecuteContractResponse> {
    constructor() {
        super("injective.exchange.v2.MsgPrivilegedExecuteContractResponse", [
            { no: 1, name: "funds_diff", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgPrivilegedExecuteContractResponse>): MsgPrivilegedExecuteContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fundsDiff = [];
        if (value !== undefined)
            reflectionMergePartial<MsgPrivilegedExecuteContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPrivilegedExecuteContractResponse): MsgPrivilegedExecuteContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin funds_diff */ 1:
                    message.fundsDiff.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPrivilegedExecuteContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin funds_diff = 1; */
        for (let i = 0; i < message.fundsDiff.length; i++)
            Coin.internalBinaryWrite(message.fundsDiff[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgPrivilegedExecuteContractResponse
 */
export const MsgPrivilegedExecuteContractResponse = new MsgPrivilegedExecuteContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRewardsOptOut$Type extends MessageType<MsgRewardsOptOut> {
    constructor() {
        super("injective.exchange.v2.MsgRewardsOptOut", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgRewardsOptOut", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRewardsOptOut>): MsgRewardsOptOut {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgRewardsOptOut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRewardsOptOut): MsgRewardsOptOut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRewardsOptOut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgRewardsOptOut
 */
export const MsgRewardsOptOut = new MsgRewardsOptOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRewardsOptOutResponse$Type extends MessageType<MsgRewardsOptOutResponse> {
    constructor() {
        super("injective.exchange.v2.MsgRewardsOptOutResponse", []);
    }
    create(value?: PartialMessage<MsgRewardsOptOutResponse>): MsgRewardsOptOutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRewardsOptOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRewardsOptOutResponse): MsgRewardsOptOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRewardsOptOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgRewardsOptOutResponse
 */
export const MsgRewardsOptOutResponse = new MsgRewardsOptOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgReclaimLockedFunds$Type extends MessageType<MsgReclaimLockedFunds> {
    constructor() {
        super("injective.exchange.v2.MsgReclaimLockedFunds", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "lockedAccountPubKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "amino.name": "exchange/MsgReclaimLockedFunds", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgReclaimLockedFunds>): MsgReclaimLockedFunds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.lockedAccountPubKey = new Uint8Array(0);
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgReclaimLockedFunds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgReclaimLockedFunds): MsgReclaimLockedFunds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* bytes lockedAccountPubKey */ 2:
                    message.lockedAccountPubKey = reader.bytes();
                    break;
                case /* bytes signature */ 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgReclaimLockedFunds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* bytes lockedAccountPubKey = 2; */
        if (message.lockedAccountPubKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.lockedAccountPubKey);
        /* bytes signature = 3; */
        if (message.signature.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgReclaimLockedFunds
 */
export const MsgReclaimLockedFunds = new MsgReclaimLockedFunds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgReclaimLockedFundsResponse$Type extends MessageType<MsgReclaimLockedFundsResponse> {
    constructor() {
        super("injective.exchange.v2.MsgReclaimLockedFundsResponse", []);
    }
    create(value?: PartialMessage<MsgReclaimLockedFundsResponse>): MsgReclaimLockedFundsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgReclaimLockedFundsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgReclaimLockedFundsResponse): MsgReclaimLockedFundsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgReclaimLockedFundsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgReclaimLockedFundsResponse
 */
export const MsgReclaimLockedFundsResponse = new MsgReclaimLockedFundsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSignData$Type extends MessageType<MsgSignData> {
    constructor() {
        super("injective.exchange.v2.MsgSignData", [
            { no: 1, name: "Signer", kind: "scalar", jsonName: "Signer", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "signer", "gogoproto.casttype": "github.com/cosmos/cosmos-sdk/types.AccAddress" } },
            { no: 2, name: "Data", kind: "scalar", jsonName: "Data", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "data" } }
        ]);
    }
    create(value?: PartialMessage<MsgSignData>): MsgSignData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signer = new Uint8Array(0);
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgSignData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSignData): MsgSignData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes Signer */ 1:
                    message.signer = reader.bytes();
                    break;
                case /* bytes Data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSignData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes Signer = 1; */
        if (message.signer.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signer);
        /* bytes Data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSignData
 */
export const MsgSignData = new MsgSignData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSignDoc$Type extends MessageType<MsgSignDoc> {
    constructor() {
        super("injective.exchange.v2.MsgSignDoc", [
            { no: 1, name: "sign_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "value", kind: "message", T: () => MsgSignData, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<MsgSignDoc>): MsgSignDoc {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signType = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSignDoc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSignDoc): MsgSignDoc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sign_type */ 1:
                    message.signType = reader.string();
                    break;
                case /* injective.exchange.v2.MsgSignData value */ 2:
                    message.value = MsgSignData.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSignDoc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sign_type = 1; */
        if (message.signType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signType);
        /* injective.exchange.v2.MsgSignData value = 2; */
        if (message.value)
            MsgSignData.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSignDoc
 */
export const MsgSignDoc = new MsgSignDoc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAdminUpdateBinaryOptionsMarket$Type extends MessageType<MsgAdminUpdateBinaryOptionsMarket> {
    constructor() {
        super("injective.exchange.v2.MsgAdminUpdateBinaryOptionsMarket", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] }
        ], { "amino.name": "exchange/MsgAdminUpdateBinaryOptionsMarket", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgAdminUpdateBinaryOptionsMarket>): MsgAdminUpdateBinaryOptionsMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.settlementPrice = "";
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<MsgAdminUpdateBinaryOptionsMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAdminUpdateBinaryOptionsMarket): MsgAdminUpdateBinaryOptionsMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string settlement_price */ 3:
                    message.settlementPrice = reader.string();
                    break;
                case /* int64 expiration_timestamp */ 4:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 5:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* injective.exchange.v2.MarketStatus status */ 6:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAdminUpdateBinaryOptionsMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string settlement_price = 3; */
        if (message.settlementPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.settlementPrice);
        /* int64 expiration_timestamp = 4; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 5; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(5, WireType.Varint).int64(message.settlementTimestamp);
        /* injective.exchange.v2.MarketStatus status = 6; */
        if (message.status !== 0)
            writer.tag(6, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgAdminUpdateBinaryOptionsMarket
 */
export const MsgAdminUpdateBinaryOptionsMarket = new MsgAdminUpdateBinaryOptionsMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAdminUpdateBinaryOptionsMarketResponse$Type extends MessageType<MsgAdminUpdateBinaryOptionsMarketResponse> {
    constructor() {
        super("injective.exchange.v2.MsgAdminUpdateBinaryOptionsMarketResponse", []);
    }
    create(value?: PartialMessage<MsgAdminUpdateBinaryOptionsMarketResponse>): MsgAdminUpdateBinaryOptionsMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgAdminUpdateBinaryOptionsMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAdminUpdateBinaryOptionsMarketResponse): MsgAdminUpdateBinaryOptionsMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAdminUpdateBinaryOptionsMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgAdminUpdateBinaryOptionsMarketResponse
 */
export const MsgAdminUpdateBinaryOptionsMarketResponse = new MsgAdminUpdateBinaryOptionsMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAuthorizeStakeGrants$Type extends MessageType<MsgAuthorizeStakeGrants> {
    constructor() {
        super("injective.exchange.v2.MsgAuthorizeStakeGrants", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grants", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GrantAuthorization }
        ], { "amino.name": "exchange/MsgAuthorizeStakeGrants", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgAuthorizeStakeGrants>): MsgAuthorizeStakeGrants {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.grants = [];
        if (value !== undefined)
            reflectionMergePartial<MsgAuthorizeStakeGrants>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAuthorizeStakeGrants): MsgAuthorizeStakeGrants {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v2.GrantAuthorization grants */ 2:
                    message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAuthorizeStakeGrants, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v2.GrantAuthorization grants = 2; */
        for (let i = 0; i < message.grants.length; i++)
            GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgAuthorizeStakeGrants
 */
export const MsgAuthorizeStakeGrants = new MsgAuthorizeStakeGrants$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAuthorizeStakeGrantsResponse$Type extends MessageType<MsgAuthorizeStakeGrantsResponse> {
    constructor() {
        super("injective.exchange.v2.MsgAuthorizeStakeGrantsResponse", []);
    }
    create(value?: PartialMessage<MsgAuthorizeStakeGrantsResponse>): MsgAuthorizeStakeGrantsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgAuthorizeStakeGrantsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAuthorizeStakeGrantsResponse): MsgAuthorizeStakeGrantsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAuthorizeStakeGrantsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgAuthorizeStakeGrantsResponse
 */
export const MsgAuthorizeStakeGrantsResponse = new MsgAuthorizeStakeGrantsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgActivateStakeGrant$Type extends MessageType<MsgActivateStakeGrant> {
    constructor() {
        super("injective.exchange.v2.MsgActivateStakeGrant", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "exchange/MsgActivateStakeGrant", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgActivateStakeGrant>): MsgActivateStakeGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.granter = "";
        if (value !== undefined)
            reflectionMergePartial<MsgActivateStakeGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgActivateStakeGrant): MsgActivateStakeGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string granter */ 2:
                    message.granter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgActivateStakeGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string granter = 2; */
        if (message.granter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.granter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgActivateStakeGrant
 */
export const MsgActivateStakeGrant = new MsgActivateStakeGrant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgActivateStakeGrantResponse$Type extends MessageType<MsgActivateStakeGrantResponse> {
    constructor() {
        super("injective.exchange.v2.MsgActivateStakeGrantResponse", []);
    }
    create(value?: PartialMessage<MsgActivateStakeGrantResponse>): MsgActivateStakeGrantResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgActivateStakeGrantResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgActivateStakeGrantResponse): MsgActivateStakeGrantResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgActivateStakeGrantResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgActivateStakeGrantResponse
 */
export const MsgActivateStakeGrantResponse = new MsgActivateStakeGrantResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchExchangeModification$Type extends MessageType<MsgBatchExchangeModification> {
    constructor() {
        super("injective.exchange.v2.MsgBatchExchangeModification", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => BatchExchangeModificationProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBatchExchangeModification", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchExchangeModification>): MsgBatchExchangeModification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgBatchExchangeModification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchExchangeModification): MsgBatchExchangeModification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.BatchExchangeModificationProposal proposal */ 2:
                    message.proposal = BatchExchangeModificationProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchExchangeModification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.BatchExchangeModificationProposal proposal = 2; */
        if (message.proposal)
            BatchExchangeModificationProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchExchangeModification
 */
export const MsgBatchExchangeModification = new MsgBatchExchangeModification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchExchangeModificationResponse$Type extends MessageType<MsgBatchExchangeModificationResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchExchangeModificationResponse", []);
    }
    create(value?: PartialMessage<MsgBatchExchangeModificationResponse>): MsgBatchExchangeModificationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgBatchExchangeModificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchExchangeModificationResponse): MsgBatchExchangeModificationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchExchangeModificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchExchangeModificationResponse
 */
export const MsgBatchExchangeModificationResponse = new MsgBatchExchangeModificationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSpotMarketLaunch$Type extends MessageType<MsgSpotMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgSpotMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => SpotMarketLaunchProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgSpotMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgSpotMarketLaunch>): MsgSpotMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSpotMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSpotMarketLaunch): MsgSpotMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.SpotMarketLaunchProposal proposal */ 2:
                    message.proposal = SpotMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSpotMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.SpotMarketLaunchProposal proposal = 2; */
        if (message.proposal)
            SpotMarketLaunchProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSpotMarketLaunch
 */
export const MsgSpotMarketLaunch = new MsgSpotMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSpotMarketLaunchResponse$Type extends MessageType<MsgSpotMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgSpotMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgSpotMarketLaunchResponse>): MsgSpotMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSpotMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSpotMarketLaunchResponse): MsgSpotMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSpotMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSpotMarketLaunchResponse
 */
export const MsgSpotMarketLaunchResponse = new MsgSpotMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPerpetualMarketLaunch$Type extends MessageType<MsgPerpetualMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgPerpetualMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => PerpetualMarketLaunchProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgPerpetualMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgPerpetualMarketLaunch>): MsgPerpetualMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgPerpetualMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPerpetualMarketLaunch): MsgPerpetualMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.PerpetualMarketLaunchProposal proposal */ 2:
                    message.proposal = PerpetualMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPerpetualMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.PerpetualMarketLaunchProposal proposal = 2; */
        if (message.proposal)
            PerpetualMarketLaunchProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgPerpetualMarketLaunch
 */
export const MsgPerpetualMarketLaunch = new MsgPerpetualMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPerpetualMarketLaunchResponse$Type extends MessageType<MsgPerpetualMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgPerpetualMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgPerpetualMarketLaunchResponse>): MsgPerpetualMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgPerpetualMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPerpetualMarketLaunchResponse): MsgPerpetualMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPerpetualMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgPerpetualMarketLaunchResponse
 */
export const MsgPerpetualMarketLaunchResponse = new MsgPerpetualMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExpiryFuturesMarketLaunch$Type extends MessageType<MsgExpiryFuturesMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgExpiryFuturesMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => ExpiryFuturesMarketLaunchProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgExpiryFuturesMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgExpiryFuturesMarketLaunch>): MsgExpiryFuturesMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgExpiryFuturesMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExpiryFuturesMarketLaunch): MsgExpiryFuturesMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.ExpiryFuturesMarketLaunchProposal proposal */ 2:
                    message.proposal = ExpiryFuturesMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExpiryFuturesMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.ExpiryFuturesMarketLaunchProposal proposal = 2; */
        if (message.proposal)
            ExpiryFuturesMarketLaunchProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgExpiryFuturesMarketLaunch
 */
export const MsgExpiryFuturesMarketLaunch = new MsgExpiryFuturesMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExpiryFuturesMarketLaunchResponse$Type extends MessageType<MsgExpiryFuturesMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgExpiryFuturesMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgExpiryFuturesMarketLaunchResponse>): MsgExpiryFuturesMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgExpiryFuturesMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExpiryFuturesMarketLaunchResponse): MsgExpiryFuturesMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExpiryFuturesMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgExpiryFuturesMarketLaunchResponse
 */
export const MsgExpiryFuturesMarketLaunchResponse = new MsgExpiryFuturesMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBinaryOptionsMarketLaunch$Type extends MessageType<MsgBinaryOptionsMarketLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgBinaryOptionsMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => BinaryOptionsMarketLaunchProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBinaryOptionsMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBinaryOptionsMarketLaunch>): MsgBinaryOptionsMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgBinaryOptionsMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBinaryOptionsMarketLaunch): MsgBinaryOptionsMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.BinaryOptionsMarketLaunchProposal proposal */ 2:
                    message.proposal = BinaryOptionsMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBinaryOptionsMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.BinaryOptionsMarketLaunchProposal proposal = 2; */
        if (message.proposal)
            BinaryOptionsMarketLaunchProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBinaryOptionsMarketLaunch
 */
export const MsgBinaryOptionsMarketLaunch = new MsgBinaryOptionsMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBinaryOptionsMarketLaunchResponse$Type extends MessageType<MsgBinaryOptionsMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBinaryOptionsMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgBinaryOptionsMarketLaunchResponse>): MsgBinaryOptionsMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgBinaryOptionsMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBinaryOptionsMarketLaunchResponse): MsgBinaryOptionsMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBinaryOptionsMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBinaryOptionsMarketLaunchResponse
 */
export const MsgBinaryOptionsMarketLaunchResponse = new MsgBinaryOptionsMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCommunityPoolSpend$Type extends MessageType<MsgBatchCommunityPoolSpend> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCommunityPoolSpend", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => BatchCommunityPoolSpendProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBatchCommunityPoolSpend", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCommunityPoolSpend>): MsgBatchCommunityPoolSpend {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCommunityPoolSpend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCommunityPoolSpend): MsgBatchCommunityPoolSpend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.BatchCommunityPoolSpendProposal proposal */ 2:
                    message.proposal = BatchCommunityPoolSpendProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCommunityPoolSpend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.BatchCommunityPoolSpendProposal proposal = 2; */
        if (message.proposal)
            BatchCommunityPoolSpendProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCommunityPoolSpend
 */
export const MsgBatchCommunityPoolSpend = new MsgBatchCommunityPoolSpend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCommunityPoolSpendResponse$Type extends MessageType<MsgBatchCommunityPoolSpendResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBatchCommunityPoolSpendResponse", []);
    }
    create(value?: PartialMessage<MsgBatchCommunityPoolSpendResponse>): MsgBatchCommunityPoolSpendResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCommunityPoolSpendResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCommunityPoolSpendResponse): MsgBatchCommunityPoolSpendResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCommunityPoolSpendResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBatchCommunityPoolSpendResponse
 */
export const MsgBatchCommunityPoolSpendResponse = new MsgBatchCommunityPoolSpendResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSpotMarketParamUpdate$Type extends MessageType<MsgSpotMarketParamUpdate> {
    constructor() {
        super("injective.exchange.v2.MsgSpotMarketParamUpdate", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => SpotMarketParamUpdateProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgSpotMarketParamUpdate", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgSpotMarketParamUpdate>): MsgSpotMarketParamUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSpotMarketParamUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSpotMarketParamUpdate): MsgSpotMarketParamUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.SpotMarketParamUpdateProposal proposal */ 2:
                    message.proposal = SpotMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSpotMarketParamUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.SpotMarketParamUpdateProposal proposal = 2; */
        if (message.proposal)
            SpotMarketParamUpdateProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSpotMarketParamUpdate
 */
export const MsgSpotMarketParamUpdate = new MsgSpotMarketParamUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSpotMarketParamUpdateResponse$Type extends MessageType<MsgSpotMarketParamUpdateResponse> {
    constructor() {
        super("injective.exchange.v2.MsgSpotMarketParamUpdateResponse", []);
    }
    create(value?: PartialMessage<MsgSpotMarketParamUpdateResponse>): MsgSpotMarketParamUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSpotMarketParamUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSpotMarketParamUpdateResponse): MsgSpotMarketParamUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSpotMarketParamUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgSpotMarketParamUpdateResponse
 */
export const MsgSpotMarketParamUpdateResponse = new MsgSpotMarketParamUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDerivativeMarketParamUpdate$Type extends MessageType<MsgDerivativeMarketParamUpdate> {
    constructor() {
        super("injective.exchange.v2.MsgDerivativeMarketParamUpdate", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => DerivativeMarketParamUpdateProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgDerivativeMarketParamUpdate", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgDerivativeMarketParamUpdate>): MsgDerivativeMarketParamUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgDerivativeMarketParamUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDerivativeMarketParamUpdate): MsgDerivativeMarketParamUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.DerivativeMarketParamUpdateProposal proposal */ 2:
                    message.proposal = DerivativeMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDerivativeMarketParamUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.DerivativeMarketParamUpdateProposal proposal = 2; */
        if (message.proposal)
            DerivativeMarketParamUpdateProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgDerivativeMarketParamUpdate
 */
export const MsgDerivativeMarketParamUpdate = new MsgDerivativeMarketParamUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDerivativeMarketParamUpdateResponse$Type extends MessageType<MsgDerivativeMarketParamUpdateResponse> {
    constructor() {
        super("injective.exchange.v2.MsgDerivativeMarketParamUpdateResponse", []);
    }
    create(value?: PartialMessage<MsgDerivativeMarketParamUpdateResponse>): MsgDerivativeMarketParamUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgDerivativeMarketParamUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDerivativeMarketParamUpdateResponse): MsgDerivativeMarketParamUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDerivativeMarketParamUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgDerivativeMarketParamUpdateResponse
 */
export const MsgDerivativeMarketParamUpdateResponse = new MsgDerivativeMarketParamUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBinaryOptionsMarketParamUpdate$Type extends MessageType<MsgBinaryOptionsMarketParamUpdate> {
    constructor() {
        super("injective.exchange.v2.MsgBinaryOptionsMarketParamUpdate", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => BinaryOptionsMarketParamUpdateProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBinaryOptionsMarketParamUpdate", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBinaryOptionsMarketParamUpdate>): MsgBinaryOptionsMarketParamUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgBinaryOptionsMarketParamUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBinaryOptionsMarketParamUpdate): MsgBinaryOptionsMarketParamUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal proposal */ 2:
                    message.proposal = BinaryOptionsMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBinaryOptionsMarketParamUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal proposal = 2; */
        if (message.proposal)
            BinaryOptionsMarketParamUpdateProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBinaryOptionsMarketParamUpdate
 */
export const MsgBinaryOptionsMarketParamUpdate = new MsgBinaryOptionsMarketParamUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBinaryOptionsMarketParamUpdateResponse$Type extends MessageType<MsgBinaryOptionsMarketParamUpdateResponse> {
    constructor() {
        super("injective.exchange.v2.MsgBinaryOptionsMarketParamUpdateResponse", []);
    }
    create(value?: PartialMessage<MsgBinaryOptionsMarketParamUpdateResponse>): MsgBinaryOptionsMarketParamUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgBinaryOptionsMarketParamUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBinaryOptionsMarketParamUpdateResponse): MsgBinaryOptionsMarketParamUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBinaryOptionsMarketParamUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgBinaryOptionsMarketParamUpdateResponse
 */
export const MsgBinaryOptionsMarketParamUpdateResponse = new MsgBinaryOptionsMarketParamUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgMarketForcedSettlement$Type extends MessageType<MsgMarketForcedSettlement> {
    constructor() {
        super("injective.exchange.v2.MsgMarketForcedSettlement", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => MarketForcedSettlementProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgMarketForcedSettlement", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgMarketForcedSettlement>): MsgMarketForcedSettlement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgMarketForcedSettlement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMarketForcedSettlement): MsgMarketForcedSettlement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.MarketForcedSettlementProposal proposal */ 2:
                    message.proposal = MarketForcedSettlementProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMarketForcedSettlement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.MarketForcedSettlementProposal proposal = 2; */
        if (message.proposal)
            MarketForcedSettlementProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgMarketForcedSettlement
 */
export const MsgMarketForcedSettlement = new MsgMarketForcedSettlement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgMarketForcedSettlementResponse$Type extends MessageType<MsgMarketForcedSettlementResponse> {
    constructor() {
        super("injective.exchange.v2.MsgMarketForcedSettlementResponse", []);
    }
    create(value?: PartialMessage<MsgMarketForcedSettlementResponse>): MsgMarketForcedSettlementResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgMarketForcedSettlementResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMarketForcedSettlementResponse): MsgMarketForcedSettlementResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMarketForcedSettlementResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgMarketForcedSettlementResponse
 */
export const MsgMarketForcedSettlementResponse = new MsgMarketForcedSettlementResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgTradingRewardCampaignLaunch$Type extends MessageType<MsgTradingRewardCampaignLaunch> {
    constructor() {
        super("injective.exchange.v2.MsgTradingRewardCampaignLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => TradingRewardCampaignLaunchProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgTradingRewardCampaignLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgTradingRewardCampaignLaunch>): MsgTradingRewardCampaignLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgTradingRewardCampaignLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgTradingRewardCampaignLaunch): MsgTradingRewardCampaignLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.TradingRewardCampaignLaunchProposal proposal */ 2:
                    message.proposal = TradingRewardCampaignLaunchProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgTradingRewardCampaignLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.TradingRewardCampaignLaunchProposal proposal = 2; */
        if (message.proposal)
            TradingRewardCampaignLaunchProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgTradingRewardCampaignLaunch
 */
export const MsgTradingRewardCampaignLaunch = new MsgTradingRewardCampaignLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgTradingRewardCampaignLaunchResponse$Type extends MessageType<MsgTradingRewardCampaignLaunchResponse> {
    constructor() {
        super("injective.exchange.v2.MsgTradingRewardCampaignLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgTradingRewardCampaignLaunchResponse>): MsgTradingRewardCampaignLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgTradingRewardCampaignLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgTradingRewardCampaignLaunchResponse): MsgTradingRewardCampaignLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgTradingRewardCampaignLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgTradingRewardCampaignLaunchResponse
 */
export const MsgTradingRewardCampaignLaunchResponse = new MsgTradingRewardCampaignLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExchangeEnable$Type extends MessageType<MsgExchangeEnable> {
    constructor() {
        super("injective.exchange.v2.MsgExchangeEnable", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => ExchangeEnableProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgExchangeEnable", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgExchangeEnable>): MsgExchangeEnable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgExchangeEnable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExchangeEnable): MsgExchangeEnable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.ExchangeEnableProposal proposal */ 2:
                    message.proposal = ExchangeEnableProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExchangeEnable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.ExchangeEnableProposal proposal = 2; */
        if (message.proposal)
            ExchangeEnableProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgExchangeEnable
 */
export const MsgExchangeEnable = new MsgExchangeEnable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExchangeEnableResponse$Type extends MessageType<MsgExchangeEnableResponse> {
    constructor() {
        super("injective.exchange.v2.MsgExchangeEnableResponse", []);
    }
    create(value?: PartialMessage<MsgExchangeEnableResponse>): MsgExchangeEnableResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgExchangeEnableResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExchangeEnableResponse): MsgExchangeEnableResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExchangeEnableResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgExchangeEnableResponse
 */
export const MsgExchangeEnableResponse = new MsgExchangeEnableResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgTradingRewardCampaignUpdate$Type extends MessageType<MsgTradingRewardCampaignUpdate> {
    constructor() {
        super("injective.exchange.v2.MsgTradingRewardCampaignUpdate", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => TradingRewardCampaignUpdateProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgTradingRewardCampaignUpdate", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgTradingRewardCampaignUpdate>): MsgTradingRewardCampaignUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgTradingRewardCampaignUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgTradingRewardCampaignUpdate): MsgTradingRewardCampaignUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.TradingRewardCampaignUpdateProposal proposal */ 2:
                    message.proposal = TradingRewardCampaignUpdateProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgTradingRewardCampaignUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.TradingRewardCampaignUpdateProposal proposal = 2; */
        if (message.proposal)
            TradingRewardCampaignUpdateProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgTradingRewardCampaignUpdate
 */
export const MsgTradingRewardCampaignUpdate = new MsgTradingRewardCampaignUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgTradingRewardCampaignUpdateResponse$Type extends MessageType<MsgTradingRewardCampaignUpdateResponse> {
    constructor() {
        super("injective.exchange.v2.MsgTradingRewardCampaignUpdateResponse", []);
    }
    create(value?: PartialMessage<MsgTradingRewardCampaignUpdateResponse>): MsgTradingRewardCampaignUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgTradingRewardCampaignUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgTradingRewardCampaignUpdateResponse): MsgTradingRewardCampaignUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgTradingRewardCampaignUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgTradingRewardCampaignUpdateResponse
 */
export const MsgTradingRewardCampaignUpdateResponse = new MsgTradingRewardCampaignUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgTradingRewardPendingPointsUpdate$Type extends MessageType<MsgTradingRewardPendingPointsUpdate> {
    constructor() {
        super("injective.exchange.v2.MsgTradingRewardPendingPointsUpdate", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => TradingRewardPendingPointsUpdateProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgTradingRewardPendingPointsUpdate", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgTradingRewardPendingPointsUpdate>): MsgTradingRewardPendingPointsUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgTradingRewardPendingPointsUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgTradingRewardPendingPointsUpdate): MsgTradingRewardPendingPointsUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.TradingRewardPendingPointsUpdateProposal proposal */ 2:
                    message.proposal = TradingRewardPendingPointsUpdateProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgTradingRewardPendingPointsUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.TradingRewardPendingPointsUpdateProposal proposal = 2; */
        if (message.proposal)
            TradingRewardPendingPointsUpdateProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgTradingRewardPendingPointsUpdate
 */
export const MsgTradingRewardPendingPointsUpdate = new MsgTradingRewardPendingPointsUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgTradingRewardPendingPointsUpdateResponse$Type extends MessageType<MsgTradingRewardPendingPointsUpdateResponse> {
    constructor() {
        super("injective.exchange.v2.MsgTradingRewardPendingPointsUpdateResponse", []);
    }
    create(value?: PartialMessage<MsgTradingRewardPendingPointsUpdateResponse>): MsgTradingRewardPendingPointsUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgTradingRewardPendingPointsUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgTradingRewardPendingPointsUpdateResponse): MsgTradingRewardPendingPointsUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgTradingRewardPendingPointsUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgTradingRewardPendingPointsUpdateResponse
 */
export const MsgTradingRewardPendingPointsUpdateResponse = new MsgTradingRewardPendingPointsUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgFeeDiscount$Type extends MessageType<MsgFeeDiscount> {
    constructor() {
        super("injective.exchange.v2.MsgFeeDiscount", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => FeeDiscountProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgFeeDiscount", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgFeeDiscount>): MsgFeeDiscount {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgFeeDiscount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgFeeDiscount): MsgFeeDiscount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.FeeDiscountProposal proposal */ 2:
                    message.proposal = FeeDiscountProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgFeeDiscount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.FeeDiscountProposal proposal = 2; */
        if (message.proposal)
            FeeDiscountProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgFeeDiscount
 */
export const MsgFeeDiscount = new MsgFeeDiscount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgFeeDiscountResponse$Type extends MessageType<MsgFeeDiscountResponse> {
    constructor() {
        super("injective.exchange.v2.MsgFeeDiscountResponse", []);
    }
    create(value?: PartialMessage<MsgFeeDiscountResponse>): MsgFeeDiscountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgFeeDiscountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgFeeDiscountResponse): MsgFeeDiscountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgFeeDiscountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgFeeDiscountResponse
 */
export const MsgFeeDiscountResponse = new MsgFeeDiscountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAtomicMarketOrderFeeMultiplierSchedule$Type extends MessageType<MsgAtomicMarketOrderFeeMultiplierSchedule> {
    constructor() {
        super("injective.exchange.v2.MsgAtomicMarketOrderFeeMultiplierSchedule", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => AtomicMarketOrderFeeMultiplierScheduleProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgAtomicMarketOrderFeeMultiplierSchedule", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgAtomicMarketOrderFeeMultiplierSchedule>): MsgAtomicMarketOrderFeeMultiplierSchedule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgAtomicMarketOrderFeeMultiplierSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAtomicMarketOrderFeeMultiplierSchedule): MsgAtomicMarketOrderFeeMultiplierSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v2.AtomicMarketOrderFeeMultiplierScheduleProposal proposal */ 2:
                    message.proposal = AtomicMarketOrderFeeMultiplierScheduleProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAtomicMarketOrderFeeMultiplierSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v2.AtomicMarketOrderFeeMultiplierScheduleProposal proposal = 2; */
        if (message.proposal)
            AtomicMarketOrderFeeMultiplierScheduleProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgAtomicMarketOrderFeeMultiplierSchedule
 */
export const MsgAtomicMarketOrderFeeMultiplierSchedule = new MsgAtomicMarketOrderFeeMultiplierSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAtomicMarketOrderFeeMultiplierScheduleResponse$Type extends MessageType<MsgAtomicMarketOrderFeeMultiplierScheduleResponse> {
    constructor() {
        super("injective.exchange.v2.MsgAtomicMarketOrderFeeMultiplierScheduleResponse", []);
    }
    create(value?: PartialMessage<MsgAtomicMarketOrderFeeMultiplierScheduleResponse>): MsgAtomicMarketOrderFeeMultiplierScheduleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgAtomicMarketOrderFeeMultiplierScheduleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAtomicMarketOrderFeeMultiplierScheduleResponse): MsgAtomicMarketOrderFeeMultiplierScheduleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAtomicMarketOrderFeeMultiplierScheduleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgAtomicMarketOrderFeeMultiplierScheduleResponse
 */
export const MsgAtomicMarketOrderFeeMultiplierScheduleResponse = new MsgAtomicMarketOrderFeeMultiplierScheduleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelPostOnlyMode$Type extends MessageType<MsgCancelPostOnlyMode> {
    constructor() {
        super("injective.exchange.v2.MsgCancelPostOnlyMode", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "exchange/MsgCancelPostOnlyMode", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelPostOnlyMode>): MsgCancelPostOnlyMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelPostOnlyMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelPostOnlyMode): MsgCancelPostOnlyMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelPostOnlyMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelPostOnlyMode
 */
export const MsgCancelPostOnlyMode = new MsgCancelPostOnlyMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelPostOnlyModeResponse$Type extends MessageType<MsgCancelPostOnlyModeResponse> {
    constructor() {
        super("injective.exchange.v2.MsgCancelPostOnlyModeResponse", []);
    }
    create(value?: PartialMessage<MsgCancelPostOnlyModeResponse>): MsgCancelPostOnlyModeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelPostOnlyModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelPostOnlyModeResponse): MsgCancelPostOnlyModeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelPostOnlyModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelPostOnlyModeResponse
 */
export const MsgCancelPostOnlyModeResponse = new MsgCancelPostOnlyModeResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.exchange.v2.Msg
 */
export const Msg = new ServiceType("injective.exchange.v2.Msg", [
    { name: "Deposit", options: {}, I: MsgDeposit, O: MsgDepositResponse },
    { name: "Withdraw", options: {}, I: MsgWithdraw, O: MsgWithdrawResponse },
    { name: "InstantSpotMarketLaunch", options: {}, I: MsgInstantSpotMarketLaunch, O: MsgInstantSpotMarketLaunchResponse },
    { name: "InstantPerpetualMarketLaunch", options: {}, I: MsgInstantPerpetualMarketLaunch, O: MsgInstantPerpetualMarketLaunchResponse },
    { name: "InstantExpiryFuturesMarketLaunch", options: {}, I: MsgInstantExpiryFuturesMarketLaunch, O: MsgInstantExpiryFuturesMarketLaunchResponse },
    { name: "CreateSpotLimitOrder", options: {}, I: MsgCreateSpotLimitOrder, O: MsgCreateSpotLimitOrderResponse },
    { name: "BatchCreateSpotLimitOrders", options: {}, I: MsgBatchCreateSpotLimitOrders, O: MsgBatchCreateSpotLimitOrdersResponse },
    { name: "CreateSpotMarketOrder", options: {}, I: MsgCreateSpotMarketOrder, O: MsgCreateSpotMarketOrderResponse },
    { name: "CancelSpotOrder", options: {}, I: MsgCancelSpotOrder, O: MsgCancelSpotOrderResponse },
    { name: "BatchCancelSpotOrders", options: {}, I: MsgBatchCancelSpotOrders, O: MsgBatchCancelSpotOrdersResponse },
    { name: "BatchUpdateOrders", options: {}, I: MsgBatchUpdateOrders, O: MsgBatchUpdateOrdersResponse },
    { name: "PrivilegedExecuteContract", options: {}, I: MsgPrivilegedExecuteContract, O: MsgPrivilegedExecuteContractResponse },
    { name: "CreateDerivativeLimitOrder", options: {}, I: MsgCreateDerivativeLimitOrder, O: MsgCreateDerivativeLimitOrderResponse },
    { name: "BatchCreateDerivativeLimitOrders", options: {}, I: MsgBatchCreateDerivativeLimitOrders, O: MsgBatchCreateDerivativeLimitOrdersResponse },
    { name: "CreateDerivativeMarketOrder", options: {}, I: MsgCreateDerivativeMarketOrder, O: MsgCreateDerivativeMarketOrderResponse },
    { name: "CancelDerivativeOrder", options: {}, I: MsgCancelDerivativeOrder, O: MsgCancelDerivativeOrderResponse },
    { name: "BatchCancelDerivativeOrders", options: {}, I: MsgBatchCancelDerivativeOrders, O: MsgBatchCancelDerivativeOrdersResponse },
    { name: "InstantBinaryOptionsMarketLaunch", options: {}, I: MsgInstantBinaryOptionsMarketLaunch, O: MsgInstantBinaryOptionsMarketLaunchResponse },
    { name: "CreateBinaryOptionsLimitOrder", options: {}, I: MsgCreateBinaryOptionsLimitOrder, O: MsgCreateBinaryOptionsLimitOrderResponse },
    { name: "CreateBinaryOptionsMarketOrder", options: {}, I: MsgCreateBinaryOptionsMarketOrder, O: MsgCreateBinaryOptionsMarketOrderResponse },
    { name: "CancelBinaryOptionsOrder", options: {}, I: MsgCancelBinaryOptionsOrder, O: MsgCancelBinaryOptionsOrderResponse },
    { name: "BatchCancelBinaryOptionsOrders", options: {}, I: MsgBatchCancelBinaryOptionsOrders, O: MsgBatchCancelBinaryOptionsOrdersResponse },
    { name: "SubaccountTransfer", options: {}, I: MsgSubaccountTransfer, O: MsgSubaccountTransferResponse },
    { name: "ExternalTransfer", options: {}, I: MsgExternalTransfer, O: MsgExternalTransferResponse },
    { name: "LiquidatePosition", options: {}, I: MsgLiquidatePosition, O: MsgLiquidatePositionResponse },
    { name: "EmergencySettleMarket", options: {}, I: MsgEmergencySettleMarket, O: MsgEmergencySettleMarketResponse },
    { name: "OffsetPosition", options: {}, I: MsgOffsetPosition, O: MsgOffsetPositionResponse },
    { name: "IncreasePositionMargin", options: {}, I: MsgIncreasePositionMargin, O: MsgIncreasePositionMarginResponse },
    { name: "DecreasePositionMargin", options: {}, I: MsgDecreasePositionMargin, O: MsgDecreasePositionMarginResponse },
    { name: "RewardsOptOut", options: {}, I: MsgRewardsOptOut, O: MsgRewardsOptOutResponse },
    { name: "AdminUpdateBinaryOptionsMarket", options: {}, I: MsgAdminUpdateBinaryOptionsMarket, O: MsgAdminUpdateBinaryOptionsMarketResponse },
    { name: "UpdateParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse },
    { name: "UpdateSpotMarket", options: {}, I: MsgUpdateSpotMarket, O: MsgUpdateSpotMarketResponse },
    { name: "UpdateDerivativeMarket", options: {}, I: MsgUpdateDerivativeMarket, O: MsgUpdateDerivativeMarketResponse },
    { name: "AuthorizeStakeGrants", options: {}, I: MsgAuthorizeStakeGrants, O: MsgAuthorizeStakeGrantsResponse },
    { name: "ActivateStakeGrant", options: {}, I: MsgActivateStakeGrant, O: MsgActivateStakeGrantResponse },
    { name: "BatchExchangeModification", options: {}, I: MsgBatchExchangeModification, O: MsgBatchExchangeModificationResponse },
    { name: "LaunchSpotMarket", options: {}, I: MsgSpotMarketLaunch, O: MsgSpotMarketLaunchResponse },
    { name: "LaunchPerpetualMarket", options: {}, I: MsgPerpetualMarketLaunch, O: MsgPerpetualMarketLaunchResponse },
    { name: "LaunchExpiryFuturesMarket", options: {}, I: MsgExpiryFuturesMarketLaunch, O: MsgExpiryFuturesMarketLaunchResponse },
    { name: "LaunchBinaryOptionsMarket", options: {}, I: MsgBinaryOptionsMarketLaunch, O: MsgBinaryOptionsMarketLaunchResponse },
    { name: "BatchSpendCommunityPool", options: {}, I: MsgBatchCommunityPoolSpend, O: MsgBatchCommunityPoolSpendResponse },
    { name: "SpotMarketParamUpdate", options: {}, I: MsgSpotMarketParamUpdate, O: MsgSpotMarketParamUpdateResponse },
    { name: "DerivativeMarketParamUpdate", options: {}, I: MsgDerivativeMarketParamUpdate, O: MsgDerivativeMarketParamUpdateResponse },
    { name: "BinaryOptionsMarketParamUpdate", options: {}, I: MsgBinaryOptionsMarketParamUpdate, O: MsgBinaryOptionsMarketParamUpdateResponse },
    { name: "ForceSettleMarket", options: {}, I: MsgMarketForcedSettlement, O: MsgMarketForcedSettlementResponse },
    { name: "LaunchTradingRewardCampaign", options: {}, I: MsgTradingRewardCampaignLaunch, O: MsgTradingRewardCampaignLaunchResponse },
    { name: "EnableExchange", options: {}, I: MsgExchangeEnable, O: MsgExchangeEnableResponse },
    { name: "UpdateTradingRewardCampaign", options: {}, I: MsgTradingRewardCampaignUpdate, O: MsgTradingRewardCampaignUpdateResponse },
    { name: "UpdateTradingRewardPendingPoints", options: {}, I: MsgTradingRewardPendingPointsUpdate, O: MsgTradingRewardPendingPointsUpdateResponse },
    { name: "UpdateFeeDiscount", options: {}, I: MsgFeeDiscount, O: MsgFeeDiscountResponse },
    { name: "UpdateAtomicMarketOrderFeeMultiplierSchedule", options: {}, I: MsgAtomicMarketOrderFeeMultiplierSchedule, O: MsgAtomicMarketOrderFeeMultiplierScheduleResponse },
    { name: "CancelPostOnlyMode", options: {}, I: MsgCancelPostOnlyMode, O: MsgCancelPostOnlyModeResponse }
], { "cosmos.msg.v1.service": true });
