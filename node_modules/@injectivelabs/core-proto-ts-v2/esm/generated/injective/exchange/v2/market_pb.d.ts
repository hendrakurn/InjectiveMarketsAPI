// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v2/market.proto" (package "injective.exchange.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { OracleType } from "../../oracle/v1beta1/oracle_pb";
/**
 * @generated from protobuf message injective.exchange.v2.OpenNotionalCap
 */
export interface OpenNotionalCap {
    /**
     * @generated from protobuf oneof: cap
     */
    cap: {
        oneofKind: "uncapped";
        /**
         * @generated from protobuf field: injective.exchange.v2.OpenNotionalCapUncapped uncapped = 1
         */
        uncapped: OpenNotionalCapUncapped;
    } | {
        oneofKind: "capped";
        /**
         * @generated from protobuf field: injective.exchange.v2.OpenNotionalCapCapped capped = 2
         */
        capped: OpenNotionalCapCapped;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message injective.exchange.v2.OpenNotionalCapUncapped
 */
export interface OpenNotionalCapUncapped {
}
/**
 * @generated from protobuf message injective.exchange.v2.OpenNotionalCapCapped
 */
export interface OpenNotionalCapCapped {
    /**
     * @generated from protobuf field: string value = 1
     */
    value: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.MarketFeeMultiplier
 */
export interface MarketFeeMultiplier {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string fee_multiplier = 2
     */
    feeMultiplier: string;
}
/**
 * An object describing trade pair of two assets.
 *
 * @generated from protobuf message injective.exchange.v2.SpotMarket
 */
export interface SpotMarket {
    /**
     * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
     * asset.
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Coin denom used for the base asset
     *
     * @generated from protobuf field: string base_denom = 2
     */
    baseDenom: string;
    /**
     * Coin used for the quote asset
     *
     * @generated from protobuf field: string quote_denom = 3
     */
    quoteDenom: string;
    /**
     * maker_fee_rate defines the fee percentage makers pay when trading
     *
     * @generated from protobuf field: string maker_fee_rate = 4
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the fee percentage takers pay when trading
     *
     * @generated from protobuf field: string taker_fee_rate = 5
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 6
     */
    relayerFeeShareRate: string;
    /**
     * Unique market ID.
     *
     * @generated from protobuf field: string market_id = 7
     */
    marketId: string;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v2.MarketStatus status = 8
     */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price required
     * for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_price_tick_size = 9
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 10
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_notional = 11
     */
    minNotional: string;
    /**
     * current market admin
     *
     * @generated from protobuf field: string admin = 12
     */
    admin: string;
    /**
     * level of admin permissions
     *
     * @generated from protobuf field: uint32 admin_permissions = 13
     */
    adminPermissions: number;
    /**
     * base token decimals
     *
     * @generated from protobuf field: uint32 base_decimals = 14
     */
    baseDecimals: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 15
     */
    quoteDecimals: number;
}
/**
 * An object describing a binary options market in Injective Protocol.
 *
 * @generated from protobuf message injective.exchange.v2.BinaryOptionsMarket
 */
export interface BinaryOptionsMarket {
    /**
     * Ticker for the derivative contract.
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Oracle symbol
     *
     * @generated from protobuf field: string oracle_symbol = 2
     */
    oracleSymbol: string;
    /**
     * Oracle Provider
     *
     * @generated from protobuf field: string oracle_provider = 3
     */
    oracleProvider: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 5
     */
    oracleScaleFactor: number;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 6
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 7
     */
    settlementTimestamp: bigint;
    /**
     * admin of the market
     *
     * @generated from protobuf field: string admin = 8
     */
    admin: string;
    /**
     * Address of the quote currency denomination for the binary options contract
     *
     * @generated from protobuf field: string quote_denom = 9
     */
    quoteDenom: string;
    /**
     * Unique market ID.
     *
     * @generated from protobuf field: string market_id = 10
     */
    marketId: string;
    /**
     * maker_fee_rate defines the maker fee rate of a binary options market
     *
     * @generated from protobuf field: string maker_fee_rate = 11
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the taker fee rate of a derivative market
     *
     * @generated from protobuf field: string taker_fee_rate = 12
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 13
     */
    relayerFeeShareRate: string;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v2.MarketStatus status = 14
     */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_price_tick_size = 15
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 16
     */
    minQuantityTickSize: string;
    /**
     * settlement_price defines the settlement price of the binary options market
     * (in human readable format)
     *
     * @generated from protobuf field: string settlement_price = 17
     */
    settlementPrice: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_notional = 18
     */
    minNotional: string;
    /**
     * level of admin permissions
     *
     * @generated from protobuf field: uint32 admin_permissions = 19
     */
    adminPermissions: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 20
     */
    quoteDecimals: number;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 21
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * An object describing a derivative market in the Injective Futures Protocol.
 *
 * @generated from protobuf message injective.exchange.v2.DerivativeMarket
 */
export interface DerivativeMarket {
    /**
     * Ticker for the derivative contract.
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 2
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 3
     */
    oracleQuote: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 5
     */
    oracleScaleFactor: number;
    /**
     * Address of the quote currency denomination for the derivative contract
     *
     * @generated from protobuf field: string quote_denom = 6
     */
    quoteDenom: string;
    /**
     * Unique market ID.
     *
     * @generated from protobuf field: string market_id = 7
     */
    marketId: string;
    /**
     * initial_margin_ratio defines the initial margin ratio of a derivative
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 8
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio of a
     * derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 9
     */
    maintenanceMarginRatio: string;
    /**
     * maker_fee_rate defines the maker fee rate of a derivative market
     *
     * @generated from protobuf field: string maker_fee_rate = 10
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the taker fee rate of a derivative market
     *
     * @generated from protobuf field: string taker_fee_rate = 11
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 12
     */
    relayerFeeShareRate: string;
    /**
     * true if the market is a perpetual market. false if the market is an expiry
     * futures market
     *
     * @generated from protobuf field: bool isPerpetual = 13
     */
    isPerpetual: boolean;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v2.MarketStatus status = 14
     */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_price_tick_size = 15
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 16
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     *
     * @generated from protobuf field: string min_notional = 17
     */
    minNotional: string;
    /**
     * current market admin
     *
     * @generated from protobuf field: string admin = 18
     */
    admin: string;
    /**
     * level of admin permissions
     *
     * @generated from protobuf field: uint32 admin_permissions = 19
     */
    adminPermissions: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 20
     */
    quoteDecimals: number;
    /**
     * reduce_margin_ratio defines the ratio of the margin that is reduced
     *
     * @generated from protobuf field: string reduce_margin_ratio = 21
     */
    reduceMarginRatio: string;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 22
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective.exchange.v2.DerivativeMarketSettlementInfo
 */
export interface DerivativeMarketSettlementInfo {
    /**
     * market ID.
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * settlement_price defines the settlement price
     *
     * @generated from protobuf field: string settlement_price = 2
     */
    settlementPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.MarketVolume
 */
export interface MarketVolume {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the market volume
     *
     * @generated from protobuf field: injective.exchange.v2.VolumeRecord volume = 2
     */
    volume?: VolumeRecord;
}
/**
 * @generated from protobuf message injective.exchange.v2.VolumeRecord
 */
export interface VolumeRecord {
    /**
     * the market's maker volume (in human readable format)
     *
     * @generated from protobuf field: string maker_volume = 1
     */
    makerVolume: string;
    /**
     * the market's taker volume (in human readable format)
     *
     * @generated from protobuf field: string taker_volume = 2
     */
    takerVolume: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.ExpiryFuturesMarketInfoState
 */
export interface ExpiryFuturesMarketInfoState {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.ExpiryFuturesMarketInfo market_info = 2
     */
    marketInfo?: ExpiryFuturesMarketInfo;
}
/**
 * @generated from protobuf message injective.exchange.v2.PerpetualMarketFundingState
 */
export interface PerpetualMarketFundingState {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.PerpetualMarketFunding funding = 2
     */
    funding?: PerpetualMarketFunding;
}
/**
 * @generated from protobuf message injective.exchange.v2.ExpiryFuturesMarketInfo
 */
export interface ExpiryFuturesMarketInfo {
    /**
     * market ID.
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * expiration_timestamp defines the expiration time for a time expiry futures
     * market.
     *
     * @generated from protobuf field: int64 expiration_timestamp = 2
     */
    expirationTimestamp: bigint;
    /**
     * expiration_twap_start_timestamp defines the start time of the TWAP
     * calculation window
     *
     * @generated from protobuf field: int64 twap_start_timestamp = 3
     */
    twapStartTimestamp: bigint;
    /**
     * expiration_twap_start_price_cumulative defines the cumulative price for the
     * start of the TWAP window (in human readable format)
     * Deprecated: For correctly calculating the expiration price using TWAP, we
     * need to keep the cumulative price at the start of TWAP calculation
     * separately for the base asset and the quote asset. Use
     * expiration_twap_start_base_cumulative_price and
     * expiration_twap_start_quote_cumulative_price instead.
     *
     * @deprecated
     * @generated from protobuf field: string expiration_twap_start_price_cumulative = 4 [deprecated = true]
     */
    expirationTwapStartPriceCumulative: string;
    /**
     * settlement_price defines the settlement price for a time expiry futures
     * market (in human readable format)
     *
     * @generated from protobuf field: string settlement_price = 5
     */
    settlementPrice: string;
    /**
     * expiration_twap_start_base_cumulative_price defines the cumulative price
     * for the base asset at the start of the TWAP calculation window (in human
     * readable format)
     *
     * @generated from protobuf field: string expiration_twap_start_base_cumulative_price = 6
     */
    expirationTwapStartBaseCumulativePrice: string;
    /**
     * expiration_twap_start_quote_cumulative_price defines the cumulative price
     * for the quote asset at the start of the TWAP calculation window (in human
     * readable format)
     *
     * @generated from protobuf field: string expiration_twap_start_quote_cumulative_price = 7
     */
    expirationTwapStartQuoteCumulativePrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.PerpetualMarketInfo
 */
export interface PerpetualMarketInfo {
    /**
     * market ID.
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * hourly_funding_rate_cap defines the maximum absolute value of the hourly
     * funding rate
     *
     * @generated from protobuf field: string hourly_funding_rate_cap = 2
     */
    hourlyFundingRateCap: string;
    /**
     * hourly_interest_rate defines the hourly interest rate
     *
     * @generated from protobuf field: string hourly_interest_rate = 3
     */
    hourlyInterestRate: string;
    /**
     * next_funding_timestamp defines the next funding timestamp in seconds of a
     * perpetual market
     *
     * @generated from protobuf field: int64 next_funding_timestamp = 4
     */
    nextFundingTimestamp: bigint;
    /**
     * funding_interval defines the next funding interval in seconds of a
     * perpetual market.
     *
     * @generated from protobuf field: int64 funding_interval = 5
     */
    fundingInterval: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.PerpetualMarketFunding
 */
export interface PerpetualMarketFunding {
    /**
     * cumulative_funding defines the cumulative funding of a perpetual market.
     *
     * @generated from protobuf field: string cumulative_funding = 1
     */
    cumulativeFunding: string;
    /**
     * cumulative_price defines the running time-integral of the perp premium
     * ((VWAP - mark_price) / mark_price) i.e., sum(premium * seconds)
     * used to compute the intervalâ€™s average premium for funding
     *
     * @generated from protobuf field: string cumulative_price = 2
     */
    cumulativePrice: string;
    /**
     * the last funding timestamp in seconds
     *
     * @generated from protobuf field: int64 last_timestamp = 3
     */
    lastTimestamp: bigint;
}
/**
 * @generated from protobuf enum injective.exchange.v2.MarketStatus
 */
export enum MarketStatus {
    /**
     * @generated from protobuf enum value: Unspecified = 0;
     */
    Unspecified = 0,
    /**
     * @generated from protobuf enum value: Active = 1;
     */
    Active = 1,
    /**
     * @generated from protobuf enum value: Paused = 2;
     */
    Paused = 2,
    /**
     * @generated from protobuf enum value: Demolished = 3;
     */
    Demolished = 3,
    /**
     * @generated from protobuf enum value: Expired = 4;
     */
    Expired = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class OpenNotionalCap$Type extends MessageType<OpenNotionalCap> {
    constructor() {
        super("injective.exchange.v2.OpenNotionalCap", [
            { no: 1, name: "uncapped", kind: "message", oneof: "cap", T: () => OpenNotionalCapUncapped, options: { "amino.oneof_name": "injective.exchange.v2.OpenNotionalCapUncapped" } },
            { no: 2, name: "capped", kind: "message", oneof: "cap", T: () => OpenNotionalCapCapped, options: { "amino.oneof_name": "injective.exchange.v2.OpenNotionalCapCapped" } }
        ]);
    }
    create(value?: PartialMessage<OpenNotionalCap>): OpenNotionalCap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cap = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OpenNotionalCap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenNotionalCap): OpenNotionalCap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.OpenNotionalCapUncapped uncapped */ 1:
                    message.cap = {
                        oneofKind: "uncapped",
                        uncapped: OpenNotionalCapUncapped.internalBinaryRead(reader, reader.uint32(), options, (message.cap as any).uncapped)
                    };
                    break;
                case /* injective.exchange.v2.OpenNotionalCapCapped capped */ 2:
                    message.cap = {
                        oneofKind: "capped",
                        capped: OpenNotionalCapCapped.internalBinaryRead(reader, reader.uint32(), options, (message.cap as any).capped)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenNotionalCap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.OpenNotionalCapUncapped uncapped = 1; */
        if (message.cap.oneofKind === "uncapped")
            OpenNotionalCapUncapped.internalBinaryWrite(message.cap.uncapped, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.OpenNotionalCapCapped capped = 2; */
        if (message.cap.oneofKind === "capped")
            OpenNotionalCapCapped.internalBinaryWrite(message.cap.capped, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OpenNotionalCap
 */
export const OpenNotionalCap = new OpenNotionalCap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenNotionalCapUncapped$Type extends MessageType<OpenNotionalCapUncapped> {
    constructor() {
        super("injective.exchange.v2.OpenNotionalCapUncapped", []);
    }
    create(value?: PartialMessage<OpenNotionalCapUncapped>): OpenNotionalCapUncapped {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OpenNotionalCapUncapped>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenNotionalCapUncapped): OpenNotionalCapUncapped {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenNotionalCapUncapped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OpenNotionalCapUncapped
 */
export const OpenNotionalCapUncapped = new OpenNotionalCapUncapped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenNotionalCapCapped$Type extends MessageType<OpenNotionalCapCapped> {
    constructor() {
        super("injective.exchange.v2.OpenNotionalCapCapped", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<OpenNotionalCapCapped>): OpenNotionalCapCapped {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<OpenNotionalCapCapped>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenNotionalCapCapped): OpenNotionalCapCapped {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenNotionalCapCapped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OpenNotionalCapCapped
 */
export const OpenNotionalCapCapped = new OpenNotionalCapCapped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketFeeMultiplier$Type extends MessageType<MarketFeeMultiplier> {
    constructor() {
        super("injective.exchange.v2.MarketFeeMultiplier", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<MarketFeeMultiplier>): MarketFeeMultiplier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.feeMultiplier = "";
        if (value !== undefined)
            reflectionMergePartial<MarketFeeMultiplier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketFeeMultiplier): MarketFeeMultiplier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string fee_multiplier */ 2:
                    message.feeMultiplier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketFeeMultiplier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string fee_multiplier = 2; */
        if (message.feeMultiplier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.feeMultiplier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MarketFeeMultiplier
 */
export const MarketFeeMultiplier = new MarketFeeMultiplier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarket$Type extends MessageType<SpotMarket> {
    constructor() {
        super("injective.exchange.v2.SpotMarket", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "base_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
            { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "base_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpotMarket>): SpotMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.baseDenom = "";
        message.quoteDenom = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.marketId = "";
        message.status = 0;
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.admin = "";
        message.adminPermissions = 0;
        message.baseDecimals = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<SpotMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarket): SpotMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string base_denom */ 2:
                    message.baseDenom = reader.string();
                    break;
                case /* string quote_denom */ 3:
                    message.quoteDenom = reader.string();
                    break;
                case /* string maker_fee_rate */ 4:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 5:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 6:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* string market_id */ 7:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v2.MarketStatus status */ 8:
                    message.status = reader.int32();
                    break;
                case /* string min_price_tick_size */ 9:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 10:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 11:
                    message.minNotional = reader.string();
                    break;
                case /* string admin */ 12:
                    message.admin = reader.string();
                    break;
                case /* uint32 admin_permissions */ 13:
                    message.adminPermissions = reader.uint32();
                    break;
                case /* uint32 base_decimals */ 14:
                    message.baseDecimals = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 15:
                    message.quoteDecimals = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string base_denom = 2; */
        if (message.baseDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.baseDenom);
        /* string quote_denom = 3; */
        if (message.quoteDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
        /* string maker_fee_rate = 4; */
        if (message.makerFeeRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 5; */
        if (message.takerFeeRate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 6; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* string market_id = 7; */
        if (message.marketId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v2.MarketStatus status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        /* string min_price_tick_size = 9; */
        if (message.minPriceTickSize !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 10; */
        if (message.minQuantityTickSize !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 11; */
        if (message.minNotional !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.minNotional);
        /* string admin = 12; */
        if (message.admin !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.admin);
        /* uint32 admin_permissions = 13; */
        if (message.adminPermissions !== 0)
            writer.tag(13, WireType.Varint).uint32(message.adminPermissions);
        /* uint32 base_decimals = 14; */
        if (message.baseDecimals !== 0)
            writer.tag(14, WireType.Varint).uint32(message.baseDecimals);
        /* uint32 quote_decimals = 15; */
        if (message.quoteDecimals !== 0)
            writer.tag(15, WireType.Varint).uint32(message.quoteDecimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SpotMarket
 */
export const SpotMarket = new SpotMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarket$Type extends MessageType<BinaryOptionsMarket> {
    constructor() {
        super("injective.exchange.v2.BinaryOptionsMarket", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "oracle_symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
            { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 18, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 19, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<BinaryOptionsMarket>): BinaryOptionsMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.oracleSymbol = "";
        message.oracleProvider = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.admin = "";
        message.quoteDenom = "";
        message.marketId = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.status = 0;
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.settlementPrice = "";
        message.minNotional = "";
        message.adminPermissions = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarket): BinaryOptionsMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_symbol */ 2:
                    message.oracleSymbol = reader.string();
                    break;
                case /* string oracle_provider */ 3:
                    message.oracleProvider = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 4:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 5:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* int64 expiration_timestamp */ 6:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 7:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* string admin */ 8:
                    message.admin = reader.string();
                    break;
                case /* string quote_denom */ 9:
                    message.quoteDenom = reader.string();
                    break;
                case /* string market_id */ 10:
                    message.marketId = reader.string();
                    break;
                case /* string maker_fee_rate */ 11:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 12:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 13:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* injective.exchange.v2.MarketStatus status */ 14:
                    message.status = reader.int32();
                    break;
                case /* string min_price_tick_size */ 15:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 16:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string settlement_price */ 17:
                    message.settlementPrice = reader.string();
                    break;
                case /* string min_notional */ 18:
                    message.minNotional = reader.string();
                    break;
                case /* uint32 admin_permissions */ 19:
                    message.adminPermissions = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 20:
                    message.quoteDecimals = reader.uint32();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 21:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_symbol = 2; */
        if (message.oracleSymbol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oracleSymbol);
        /* string oracle_provider = 3; */
        if (message.oracleProvider !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oracleProvider);
        /* injective.oracle.v1beta1.OracleType oracle_type = 4; */
        if (message.oracleType !== 0)
            writer.tag(4, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 5; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
        /* int64 expiration_timestamp = 6; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(6, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 7; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(7, WireType.Varint).int64(message.settlementTimestamp);
        /* string admin = 8; */
        if (message.admin !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.admin);
        /* string quote_denom = 9; */
        if (message.quoteDenom !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.quoteDenom);
        /* string market_id = 10; */
        if (message.marketId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.marketId);
        /* string maker_fee_rate = 11; */
        if (message.makerFeeRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 12; */
        if (message.takerFeeRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 13; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* injective.exchange.v2.MarketStatus status = 14; */
        if (message.status !== 0)
            writer.tag(14, WireType.Varint).int32(message.status);
        /* string min_price_tick_size = 15; */
        if (message.minPriceTickSize !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 16; */
        if (message.minQuantityTickSize !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string settlement_price = 17; */
        if (message.settlementPrice !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.settlementPrice);
        /* string min_notional = 18; */
        if (message.minNotional !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.minNotional);
        /* uint32 admin_permissions = 19; */
        if (message.adminPermissions !== 0)
            writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
        /* uint32 quote_decimals = 20; */
        if (message.quoteDecimals !== 0)
            writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 21; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.BinaryOptionsMarket
 */
export const BinaryOptionsMarket = new BinaryOptionsMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarket$Type extends MessageType<DerivativeMarket> {
    constructor() {
        super("injective.exchange.v2.DerivativeMarket", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "isPerpetual", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
            { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 18, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 22, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<DerivativeMarket>): DerivativeMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.quoteDenom = "";
        message.marketId = "";
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.isPerpetual = false;
        message.status = 0;
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.admin = "";
        message.adminPermissions = 0;
        message.quoteDecimals = 0;
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarket): DerivativeMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_base */ 2:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 3:
                    message.oracleQuote = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 4:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 5:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* string quote_denom */ 6:
                    message.quoteDenom = reader.string();
                    break;
                case /* string market_id */ 7:
                    message.marketId = reader.string();
                    break;
                case /* string initial_margin_ratio */ 8:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 9:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string maker_fee_rate */ 10:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 11:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 12:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* bool isPerpetual */ 13:
                    message.isPerpetual = reader.bool();
                    break;
                case /* injective.exchange.v2.MarketStatus status */ 14:
                    message.status = reader.int32();
                    break;
                case /* string min_price_tick_size */ 15:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 16:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 17:
                    message.minNotional = reader.string();
                    break;
                case /* string admin */ 18:
                    message.admin = reader.string();
                    break;
                case /* uint32 admin_permissions */ 19:
                    message.adminPermissions = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 20:
                    message.quoteDecimals = reader.uint32();
                    break;
                case /* string reduce_margin_ratio */ 21:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */ 22:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_base = 2; */
        if (message.oracleBase !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 3; */
        if (message.oracleQuote !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oracleQuote);
        /* injective.oracle.v1beta1.OracleType oracle_type = 4; */
        if (message.oracleType !== 0)
            writer.tag(4, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 5; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
        /* string quote_denom = 6; */
        if (message.quoteDenom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
        /* string market_id = 7; */
        if (message.marketId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.marketId);
        /* string initial_margin_ratio = 8; */
        if (message.initialMarginRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 9; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string maker_fee_rate = 10; */
        if (message.makerFeeRate !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 11; */
        if (message.takerFeeRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 12; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* bool isPerpetual = 13; */
        if (message.isPerpetual !== false)
            writer.tag(13, WireType.Varint).bool(message.isPerpetual);
        /* injective.exchange.v2.MarketStatus status = 14; */
        if (message.status !== 0)
            writer.tag(14, WireType.Varint).int32(message.status);
        /* string min_price_tick_size = 15; */
        if (message.minPriceTickSize !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 16; */
        if (message.minQuantityTickSize !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 17; */
        if (message.minNotional !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.minNotional);
        /* string admin = 18; */
        if (message.admin !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.admin);
        /* uint32 admin_permissions = 19; */
        if (message.adminPermissions !== 0)
            writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
        /* uint32 quote_decimals = 20; */
        if (message.quoteDecimals !== 0)
            writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
        /* string reduce_margin_ratio = 21; */
        if (message.reduceMarginRatio !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective.exchange.v2.OpenNotionalCap open_notional_cap = 22; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DerivativeMarket
 */
export const DerivativeMarket = new DerivativeMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketSettlementInfo$Type extends MessageType<DerivativeMarketSettlementInfo> {
    constructor() {
        super("injective.exchange.v2.DerivativeMarketSettlementInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketSettlementInfo>): DerivativeMarketSettlementInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.settlementPrice = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketSettlementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketSettlementInfo): DerivativeMarketSettlementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string settlement_price */ 2:
                    message.settlementPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketSettlementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string settlement_price = 2; */
        if (message.settlementPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settlementPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.DerivativeMarketSettlementInfo
 */
export const DerivativeMarketSettlementInfo = new DerivativeMarketSettlementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketVolume$Type extends MessageType<MarketVolume> {
    constructor() {
        super("injective.exchange.v2.MarketVolume", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "volume", kind: "message", T: () => VolumeRecord, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<MarketVolume>): MarketVolume {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MarketVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketVolume): MarketVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v2.VolumeRecord volume */ 2:
                    message.volume = VolumeRecord.internalBinaryRead(reader, reader.uint32(), options, message.volume);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v2.VolumeRecord volume = 2; */
        if (message.volume)
            VolumeRecord.internalBinaryWrite(message.volume, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MarketVolume
 */
export const MarketVolume = new MarketVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolumeRecord$Type extends MessageType<VolumeRecord> {
    constructor() {
        super("injective.exchange.v2.VolumeRecord", [
            { no: 1, name: "maker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "taker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<VolumeRecord>): VolumeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.makerVolume = "";
        message.takerVolume = "";
        if (value !== undefined)
            reflectionMergePartial<VolumeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolumeRecord): VolumeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string maker_volume */ 1:
                    message.makerVolume = reader.string();
                    break;
                case /* string taker_volume */ 2:
                    message.takerVolume = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolumeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string maker_volume = 1; */
        if (message.makerVolume !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.makerVolume);
        /* string taker_volume = 2; */
        if (message.takerVolume !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.takerVolume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.VolumeRecord
 */
export const VolumeRecord = new VolumeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpiryFuturesMarketInfoState$Type extends MessageType<ExpiryFuturesMarketInfoState> {
    constructor() {
        super("injective.exchange.v2.ExpiryFuturesMarketInfoState", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_info", kind: "message", T: () => ExpiryFuturesMarketInfo }
        ]);
    }
    create(value?: PartialMessage<ExpiryFuturesMarketInfoState>): ExpiryFuturesMarketInfoState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<ExpiryFuturesMarketInfoState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpiryFuturesMarketInfoState): ExpiryFuturesMarketInfoState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v2.ExpiryFuturesMarketInfo market_info */ 2:
                    message.marketInfo = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.marketInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpiryFuturesMarketInfoState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v2.ExpiryFuturesMarketInfo market_info = 2; */
        if (message.marketInfo)
            ExpiryFuturesMarketInfo.internalBinaryWrite(message.marketInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.ExpiryFuturesMarketInfoState
 */
export const ExpiryFuturesMarketInfoState = new ExpiryFuturesMarketInfoState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketFundingState$Type extends MessageType<PerpetualMarketFundingState> {
    constructor() {
        super("injective.exchange.v2.PerpetualMarketFundingState", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "funding", kind: "message", T: () => PerpetualMarketFunding }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketFundingState>): PerpetualMarketFundingState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketFundingState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketFundingState): PerpetualMarketFundingState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v2.PerpetualMarketFunding funding */ 2:
                    message.funding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.funding);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketFundingState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v2.PerpetualMarketFunding funding = 2; */
        if (message.funding)
            PerpetualMarketFunding.internalBinaryWrite(message.funding, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PerpetualMarketFundingState
 */
export const PerpetualMarketFundingState = new PerpetualMarketFundingState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpiryFuturesMarketInfo$Type extends MessageType<ExpiryFuturesMarketInfo> {
    constructor() {
        super("injective.exchange.v2.ExpiryFuturesMarketInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "twap_start_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "expiration_twap_start_price_cumulative", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "expiration_twap_start_base_cumulative_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "expiration_twap_start_quote_cumulative_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.expirationTimestamp = 0n;
        message.twapStartTimestamp = 0n;
        message.expirationTwapStartPriceCumulative = "";
        message.settlementPrice = "";
        message.expirationTwapStartBaseCumulativePrice = "";
        message.expirationTwapStartQuoteCumulativePrice = "";
        if (value !== undefined)
            reflectionMergePartial<ExpiryFuturesMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpiryFuturesMarketInfo): ExpiryFuturesMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* int64 expiration_timestamp */ 2:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 twap_start_timestamp */ 3:
                    message.twapStartTimestamp = reader.int64().toBigInt();
                    break;
                case /* string expiration_twap_start_price_cumulative = 4 [deprecated = true] */ 4:
                    message.expirationTwapStartPriceCumulative = reader.string();
                    break;
                case /* string settlement_price */ 5:
                    message.settlementPrice = reader.string();
                    break;
                case /* string expiration_twap_start_base_cumulative_price */ 6:
                    message.expirationTwapStartBaseCumulativePrice = reader.string();
                    break;
                case /* string expiration_twap_start_quote_cumulative_price */ 7:
                    message.expirationTwapStartQuoteCumulativePrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpiryFuturesMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* int64 expiration_timestamp = 2; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 twap_start_timestamp = 3; */
        if (message.twapStartTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.twapStartTimestamp);
        /* string expiration_twap_start_price_cumulative = 4 [deprecated = true]; */
        if (message.expirationTwapStartPriceCumulative !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.expirationTwapStartPriceCumulative);
        /* string settlement_price = 5; */
        if (message.settlementPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.settlementPrice);
        /* string expiration_twap_start_base_cumulative_price = 6; */
        if (message.expirationTwapStartBaseCumulativePrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.expirationTwapStartBaseCumulativePrice);
        /* string expiration_twap_start_quote_cumulative_price = 7; */
        if (message.expirationTwapStartQuoteCumulativePrice !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.expirationTwapStartQuoteCumulativePrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.ExpiryFuturesMarketInfo
 */
export const ExpiryFuturesMarketInfo = new ExpiryFuturesMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketInfo$Type extends MessageType<PerpetualMarketInfo> {
    constructor() {
        super("injective.exchange.v2.PerpetualMarketInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hourly_funding_rate_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "hourly_interest_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "next_funding_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "funding_interval", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketInfo>): PerpetualMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.hourlyFundingRateCap = "";
        message.hourlyInterestRate = "";
        message.nextFundingTimestamp = 0n;
        message.fundingInterval = 0n;
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketInfo): PerpetualMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string hourly_funding_rate_cap */ 2:
                    message.hourlyFundingRateCap = reader.string();
                    break;
                case /* string hourly_interest_rate */ 3:
                    message.hourlyInterestRate = reader.string();
                    break;
                case /* int64 next_funding_timestamp */ 4:
                    message.nextFundingTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 funding_interval */ 5:
                    message.fundingInterval = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string hourly_funding_rate_cap = 2; */
        if (message.hourlyFundingRateCap !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
        /* string hourly_interest_rate = 3; */
        if (message.hourlyInterestRate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hourlyInterestRate);
        /* int64 next_funding_timestamp = 4; */
        if (message.nextFundingTimestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.nextFundingTimestamp);
        /* int64 funding_interval = 5; */
        if (message.fundingInterval !== 0n)
            writer.tag(5, WireType.Varint).int64(message.fundingInterval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PerpetualMarketInfo
 */
export const PerpetualMarketInfo = new PerpetualMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketFunding$Type extends MessageType<PerpetualMarketFunding> {
    constructor() {
        super("injective.exchange.v2.PerpetualMarketFunding", [
            { no: 1, name: "cumulative_funding", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "last_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketFunding>): PerpetualMarketFunding {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cumulativeFunding = "";
        message.cumulativePrice = "";
        message.lastTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketFunding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketFunding): PerpetualMarketFunding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cumulative_funding */ 1:
                    message.cumulativeFunding = reader.string();
                    break;
                case /* string cumulative_price */ 2:
                    message.cumulativePrice = reader.string();
                    break;
                case /* int64 last_timestamp */ 3:
                    message.lastTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketFunding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cumulative_funding = 1; */
        if (message.cumulativeFunding !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cumulativeFunding);
        /* string cumulative_price = 2; */
        if (message.cumulativePrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
        /* int64 last_timestamp = 3; */
        if (message.lastTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.lastTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PerpetualMarketFunding
 */
export const PerpetualMarketFunding = new PerpetualMarketFunding$Type();
