import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DenomMinNotional } from "./exchange_pb.js";
import { MarketFeeMultiplier } from "./market_pb.js";
import { CommunityPoolSpendProposal } from "../../../cosmos/distribution/v1beta1/distribution_pb.js";
import { FeeDiscountSchedule } from "./exchange_pb.js";
import { CampaignRewardPool } from "./exchange_pb.js";
import { TradingRewardCampaignInfo } from "./exchange_pb.js";
import { DenomDecimals } from "./exchange_pb.js";
import { OpenNotionalCap } from "./market_pb.js";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";
import { MarketStatus } from "./market_pb.js";
var ExchangeType = /* @__PURE__ */ ((ExchangeType2) => {
  ExchangeType2[ExchangeType2["EXCHANGE_UNSPECIFIED"] = 0] = "EXCHANGE_UNSPECIFIED";
  ExchangeType2[ExchangeType2["SPOT"] = 1] = "SPOT";
  ExchangeType2[ExchangeType2["DERIVATIVES"] = 2] = "DERIVATIVES";
  return ExchangeType2;
})(ExchangeType || {});
class SpotMarketParamUpdateProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SpotMarketParamUpdateProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 9, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
      { no: 10, name: "ticker", kind: "scalar", T: 9, options: { "gogoproto.nullable": true } },
      { no: 11, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "admin_info", kind: "message", T: () => AdminInfo },
      {
        no: 13,
        name: "base_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 14,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/SpotMarketParamUpdateProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.marketId = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.status = 0;
    message.ticker = "";
    message.minNotional = "";
    message.baseDecimals = 0;
    message.quoteDecimals = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string maker_fee_rate */
        4:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        5:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        6:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* string min_price_tick_size */
        7:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        8:
          message.minQuantityTickSize = reader.string();
          break;
        case /* injective.exchange.v2.MarketStatus status */
        9:
          message.status = reader.int32();
          break;
        case /* string ticker */
        10:
          message.ticker = reader.string();
          break;
        case /* string min_notional */
        11:
          message.minNotional = reader.string();
          break;
        case /* injective.exchange.v2.AdminInfo admin_info */
        12:
          message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
          break;
        case /* uint32 base_decimals */
        13:
          message.baseDecimals = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        14:
          message.quoteDecimals = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.makerFeeRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.minPriceTickSize !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.status !== 0)
      writer.tag(9, WireType.Varint).int32(message.status);
    if (message.ticker !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.ticker);
    if (message.minNotional !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminInfo)
      AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.baseDecimals !== 0)
      writer.tag(13, WireType.Varint).uint32(message.baseDecimals);
    if (message.quoteDecimals !== 0)
      writer.tag(14, WireType.Varint).uint32(message.quoteDecimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketParamUpdateProposal = new SpotMarketParamUpdateProposal$Type();
class ExchangeEnableProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.ExchangeEnableProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "exchangeType", kind: "enum", T: () => ["injective.exchange.v2.ExchangeType", ExchangeType] }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/ExchangeEnableProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.exchangeType = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* injective.exchange.v2.ExchangeType exchangeType */
        3:
          message.exchangeType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.exchangeType !== 0)
      writer.tag(3, WireType.Varint).int32(message.exchangeType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExchangeEnableProposal = new ExchangeEnableProposal$Type();
class BatchExchangeModificationProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.BatchExchangeModificationProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "spot_market_param_update_proposals", kind: "message", repeat: 2, T: () => SpotMarketParamUpdateProposal },
      { no: 4, name: "derivative_market_param_update_proposals", kind: "message", repeat: 2, T: () => DerivativeMarketParamUpdateProposal },
      { no: 5, name: "spot_market_launch_proposals", kind: "message", repeat: 2, T: () => SpotMarketLaunchProposal },
      { no: 6, name: "perpetual_market_launch_proposals", kind: "message", repeat: 2, T: () => PerpetualMarketLaunchProposal },
      { no: 7, name: "expiry_futures_market_launch_proposals", kind: "message", repeat: 2, T: () => ExpiryFuturesMarketLaunchProposal },
      { no: 8, name: "trading_reward_campaign_update_proposal", kind: "message", T: () => TradingRewardCampaignUpdateProposal },
      { no: 9, name: "binary_options_market_launch_proposals", kind: "message", repeat: 2, T: () => BinaryOptionsMarketLaunchProposal },
      { no: 10, name: "binary_options_param_update_proposals", kind: "message", repeat: 2, T: () => BinaryOptionsMarketParamUpdateProposal },
      { no: 11, name: "auction_exchange_transfer_denom_decimals_update_proposal", kind: "message", T: () => UpdateAuctionExchangeTransferDenomDecimalsProposal },
      { no: 12, name: "fee_discount_proposal", kind: "message", T: () => FeeDiscountProposal },
      { no: 13, name: "market_forced_settlement_proposals", kind: "message", repeat: 2, T: () => MarketForcedSettlementProposal },
      { no: 14, name: "denom_min_notional_proposal", kind: "message", T: () => DenomMinNotionalProposal }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BatchExchangeModificationProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.spotMarketParamUpdateProposals = [];
    message.derivativeMarketParamUpdateProposals = [];
    message.spotMarketLaunchProposals = [];
    message.perpetualMarketLaunchProposals = [];
    message.expiryFuturesMarketLaunchProposals = [];
    message.binaryOptionsMarketLaunchProposals = [];
    message.binaryOptionsParamUpdateProposals = [];
    message.marketForcedSettlementProposals = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* repeated injective.exchange.v2.SpotMarketParamUpdateProposal spot_market_param_update_proposals */
        3:
          message.spotMarketParamUpdateProposals.push(SpotMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals */
        4:
          message.derivativeMarketParamUpdateProposals.push(DerivativeMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.SpotMarketLaunchProposal spot_market_launch_proposals */
        5:
          message.spotMarketLaunchProposals.push(SpotMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.PerpetualMarketLaunchProposal perpetual_market_launch_proposals */
        6:
          message.perpetualMarketLaunchProposals.push(PerpetualMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals */
        7:
          message.expiryFuturesMarketLaunchProposals.push(ExpiryFuturesMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective.exchange.v2.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal */
        8:
          message.tradingRewardCampaignUpdateProposal = TradingRewardCampaignUpdateProposal.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardCampaignUpdateProposal);
          break;
        case /* repeated injective.exchange.v2.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals */
        9:
          message.binaryOptionsMarketLaunchProposals.push(BinaryOptionsMarketLaunchProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals */
        10:
          message.binaryOptionsParamUpdateProposals.push(BinaryOptionsMarketParamUpdateProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal auction_exchange_transfer_denom_decimals_update_proposal */
        11:
          message.auctionExchangeTransferDenomDecimalsUpdateProposal = UpdateAuctionExchangeTransferDenomDecimalsProposal.internalBinaryRead(reader, reader.uint32(), options, message.auctionExchangeTransferDenomDecimalsUpdateProposal);
          break;
        case /* injective.exchange.v2.FeeDiscountProposal fee_discount_proposal */
        12:
          message.feeDiscountProposal = FeeDiscountProposal.internalBinaryRead(reader, reader.uint32(), options, message.feeDiscountProposal);
          break;
        case /* repeated injective.exchange.v2.MarketForcedSettlementProposal market_forced_settlement_proposals */
        13:
          message.marketForcedSettlementProposals.push(MarketForcedSettlementProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective.exchange.v2.DenomMinNotionalProposal denom_min_notional_proposal */
        14:
          message.denomMinNotionalProposal = DenomMinNotionalProposal.internalBinaryRead(reader, reader.uint32(), options, message.denomMinNotionalProposal);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    for (let i = 0; i < message.spotMarketParamUpdateProposals.length; i++)
      SpotMarketParamUpdateProposal.internalBinaryWrite(message.spotMarketParamUpdateProposals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeMarketParamUpdateProposals.length; i++)
      DerivativeMarketParamUpdateProposal.internalBinaryWrite(message.derivativeMarketParamUpdateProposals[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.spotMarketLaunchProposals.length; i++)
      SpotMarketLaunchProposal.internalBinaryWrite(message.spotMarketLaunchProposals[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.perpetualMarketLaunchProposals.length; i++)
      PerpetualMarketLaunchProposal.internalBinaryWrite(message.perpetualMarketLaunchProposals[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.expiryFuturesMarketLaunchProposals.length; i++)
      ExpiryFuturesMarketLaunchProposal.internalBinaryWrite(message.expiryFuturesMarketLaunchProposals[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.tradingRewardCampaignUpdateProposal)
      TradingRewardCampaignUpdateProposal.internalBinaryWrite(message.tradingRewardCampaignUpdateProposal, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.binaryOptionsMarketLaunchProposals.length; i++)
      BinaryOptionsMarketLaunchProposal.internalBinaryWrite(message.binaryOptionsMarketLaunchProposals[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.binaryOptionsParamUpdateProposals.length; i++)
      BinaryOptionsMarketParamUpdateProposal.internalBinaryWrite(message.binaryOptionsParamUpdateProposals[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    if (message.auctionExchangeTransferDenomDecimalsUpdateProposal)
      UpdateAuctionExchangeTransferDenomDecimalsProposal.internalBinaryWrite(message.auctionExchangeTransferDenomDecimalsUpdateProposal, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.feeDiscountProposal)
      FeeDiscountProposal.internalBinaryWrite(message.feeDiscountProposal, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.marketForcedSettlementProposals.length; i++)
      MarketForcedSettlementProposal.internalBinaryWrite(message.marketForcedSettlementProposals[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.denomMinNotionalProposal)
      DenomMinNotionalProposal.internalBinaryWrite(message.denomMinNotionalProposal, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchExchangeModificationProposal = new BatchExchangeModificationProposal$Type();
class SpotMarketLaunchProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SpotMarketLaunchProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "base_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 9, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "admin_info", kind: "message", T: () => AdminInfo },
      {
        no: 14,
        name: "base_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 15,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/SpotMarketLaunchProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.ticker = "";
    message.baseDenom = "";
    message.quoteDenom = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.minNotional = "";
    message.baseDecimals = 0;
    message.quoteDecimals = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string ticker */
        3:
          message.ticker = reader.string();
          break;
        case /* string base_denom */
        4:
          message.baseDenom = reader.string();
          break;
        case /* string quote_denom */
        5:
          message.quoteDenom = reader.string();
          break;
        case /* string min_price_tick_size */
        6:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        7:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string maker_fee_rate */
        8:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        9:
          message.takerFeeRate = reader.string();
          break;
        case /* string min_notional */
        10:
          message.minNotional = reader.string();
          break;
        case /* injective.exchange.v2.AdminInfo admin_info */
        11:
          message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
          break;
        case /* uint32 base_decimals */
        14:
          message.baseDecimals = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        15:
          message.quoteDecimals = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.ticker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ticker);
    if (message.baseDenom !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.baseDenom);
    if (message.quoteDenom !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.minPriceTickSize !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.makerFeeRate !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.minNotional !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminInfo)
      AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.baseDecimals !== 0)
      writer.tag(14, WireType.Varint).uint32(message.baseDecimals);
    if (message.quoteDecimals !== 0)
      writer.tag(15, WireType.Varint).uint32(message.quoteDecimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketLaunchProposal = new SpotMarketLaunchProposal$Type();
class PerpetualMarketLaunchProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PerpetualMarketLaunchProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 8, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      { no: 9, name: "initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 15, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 16, name: "admin_info", kind: "message", T: () => AdminInfo },
      { no: 17, name: "reduce_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 18, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/PerpetualMarketLaunchProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.ticker = "";
    message.quoteDenom = "";
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleScaleFactor = 0;
    message.oracleType = 0;
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.reduceMarginRatio = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string ticker */
        3:
          message.ticker = reader.string();
          break;
        case /* string quote_denom */
        4:
          message.quoteDenom = reader.string();
          break;
        case /* string oracle_base */
        5:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        6:
          message.oracleQuote = reader.string();
          break;
        case /* uint32 oracle_scale_factor */
        7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        8:
          message.oracleType = reader.int32();
          break;
        case /* string initial_margin_ratio */
        9:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        10:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string maker_fee_rate */
        11:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        12:
          message.takerFeeRate = reader.string();
          break;
        case /* string min_price_tick_size */
        13:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        14:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        15:
          message.minNotional = reader.string();
          break;
        case /* injective.exchange.v2.AdminInfo admin_info */
        16:
          message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
          break;
        case /* string reduce_margin_ratio */
        17:
          message.reduceMarginRatio = reader.string();
          break;
        case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */
        18:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.ticker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ticker);
    if (message.quoteDenom !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.oracleBase !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleScaleFactor !== 0)
      writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.oracleType !== 0)
      writer.tag(8, WireType.Varint).int32(message.oracleType);
    if (message.initialMarginRatio !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.makerFeeRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.minPriceTickSize !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminInfo)
      AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.reduceMarginRatio !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.reduceMarginRatio);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketLaunchProposal = new PerpetualMarketLaunchProposal$Type();
class BinaryOptionsMarketLaunchProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.BinaryOptionsMarketLaunchProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "oracle_symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "oracle_provider",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 7,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "settlement_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 15, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 16, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 17,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 18, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BinaryOptionsMarketLaunchProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.ticker = "";
    message.oracleSymbol = "";
    message.oracleProvider = "";
    message.oracleType = 0;
    message.oracleScaleFactor = 0;
    message.expirationTimestamp = 0n;
    message.settlementTimestamp = 0n;
    message.admin = "";
    message.quoteDenom = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.adminPermissions = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string ticker */
        3:
          message.ticker = reader.string();
          break;
        case /* string oracle_symbol */
        4:
          message.oracleSymbol = reader.string();
          break;
        case /* string oracle_provider */
        5:
          message.oracleProvider = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        6:
          message.oracleType = reader.int32();
          break;
        case /* uint32 oracle_scale_factor */
        7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* int64 expiration_timestamp */
        8:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 settlement_timestamp */
        9:
          message.settlementTimestamp = reader.int64().toBigInt();
          break;
        case /* string admin */
        10:
          message.admin = reader.string();
          break;
        case /* string quote_denom */
        11:
          message.quoteDenom = reader.string();
          break;
        case /* string maker_fee_rate */
        12:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        13:
          message.takerFeeRate = reader.string();
          break;
        case /* string min_price_tick_size */
        14:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        15:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        16:
          message.minNotional = reader.string();
          break;
        case /* uint32 admin_permissions */
        17:
          message.adminPermissions = reader.uint32();
          break;
        case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */
        18:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.ticker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleSymbol !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.oracleSymbol);
    if (message.oracleProvider !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.oracleProvider);
    if (message.oracleType !== 0)
      writer.tag(6, WireType.Varint).int32(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.expirationTimestamp !== 0n)
      writer.tag(8, WireType.Varint).int64(message.expirationTimestamp);
    if (message.settlementTimestamp !== 0n)
      writer.tag(9, WireType.Varint).int64(message.settlementTimestamp);
    if (message.admin !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.admin);
    if (message.quoteDenom !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.makerFeeRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.minPriceTickSize !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminPermissions !== 0)
      writer.tag(17, WireType.Varint).uint32(message.adminPermissions);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarketLaunchProposal = new BinaryOptionsMarketLaunchProposal$Type();
class ExpiryFuturesMarketLaunchProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.ExpiryFuturesMarketLaunchProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 8, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 9,
        name: "expiry",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 10, name: "initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 15, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 16, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 17, name: "admin_info", kind: "message", T: () => AdminInfo },
      { no: 18, name: "reduce_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 19, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/ExpiryFuturesMarketLaunchProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.ticker = "";
    message.quoteDenom = "";
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleScaleFactor = 0;
    message.oracleType = 0;
    message.expiry = 0n;
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.reduceMarginRatio = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string ticker */
        3:
          message.ticker = reader.string();
          break;
        case /* string quote_denom */
        4:
          message.quoteDenom = reader.string();
          break;
        case /* string oracle_base */
        5:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        6:
          message.oracleQuote = reader.string();
          break;
        case /* uint32 oracle_scale_factor */
        7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        8:
          message.oracleType = reader.int32();
          break;
        case /* int64 expiry */
        9:
          message.expiry = reader.int64().toBigInt();
          break;
        case /* string initial_margin_ratio */
        10:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        11:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string maker_fee_rate */
        12:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        13:
          message.takerFeeRate = reader.string();
          break;
        case /* string min_price_tick_size */
        14:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        15:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        16:
          message.minNotional = reader.string();
          break;
        case /* injective.exchange.v2.AdminInfo admin_info */
        17:
          message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
          break;
        case /* string reduce_margin_ratio */
        18:
          message.reduceMarginRatio = reader.string();
          break;
        case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */
        19:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.ticker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ticker);
    if (message.quoteDenom !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.oracleBase !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleScaleFactor !== 0)
      writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.oracleType !== 0)
      writer.tag(8, WireType.Varint).int32(message.oracleType);
    if (message.expiry !== 0n)
      writer.tag(9, WireType.Varint).int64(message.expiry);
    if (message.initialMarginRatio !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.makerFeeRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.minPriceTickSize !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminInfo)
      AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.reduceMarginRatio !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.reduceMarginRatio);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExpiryFuturesMarketLaunchProposal = new ExpiryFuturesMarketLaunchProposal$Type();
class DerivativeMarketParamUpdateProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeMarketParamUpdateProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "HourlyInterestRate", kind: "scalar", jsonName: "HourlyInterestRate", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "HourlyFundingRateCap", kind: "scalar", jsonName: "HourlyFundingRateCap", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
      { no: 14, name: "oracle_params", kind: "message", T: () => OracleParams },
      { no: 15, name: "ticker", kind: "scalar", T: 9, options: { "gogoproto.nullable": true } },
      { no: 16, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 17, name: "admin_info", kind: "message", T: () => AdminInfo },
      { no: 18, name: "reduce_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 19, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": true } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/DerivativeMarketParamUpdateProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.marketId = "";
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.hourlyInterestRate = "";
    message.hourlyFundingRateCap = "";
    message.status = 0;
    message.ticker = "";
    message.minNotional = "";
    message.reduceMarginRatio = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string initial_margin_ratio */
        4:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        5:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string maker_fee_rate */
        6:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        7:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        8:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* string min_price_tick_size */
        9:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        10:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string HourlyInterestRate */
        11:
          message.hourlyInterestRate = reader.string();
          break;
        case /* string HourlyFundingRateCap */
        12:
          message.hourlyFundingRateCap = reader.string();
          break;
        case /* injective.exchange.v2.MarketStatus status */
        13:
          message.status = reader.int32();
          break;
        case /* injective.exchange.v2.OracleParams oracle_params */
        14:
          message.oracleParams = OracleParams.internalBinaryRead(reader, reader.uint32(), options, message.oracleParams);
          break;
        case /* string ticker */
        15:
          message.ticker = reader.string();
          break;
        case /* string min_notional */
        16:
          message.minNotional = reader.string();
          break;
        case /* injective.exchange.v2.AdminInfo admin_info */
        17:
          message.adminInfo = AdminInfo.internalBinaryRead(reader, reader.uint32(), options, message.adminInfo);
          break;
        case /* string reduce_margin_ratio */
        18:
          message.reduceMarginRatio = reader.string();
          break;
        case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */
        19:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.initialMarginRatio !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.makerFeeRate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.minPriceTickSize !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.hourlyInterestRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.hourlyInterestRate);
    if (message.hourlyFundingRateCap !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
    if (message.status !== 0)
      writer.tag(13, WireType.Varint).int32(message.status);
    if (message.oracleParams)
      OracleParams.internalBinaryWrite(message.oracleParams, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.ticker !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.ticker);
    if (message.minNotional !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminInfo)
      AdminInfo.internalBinaryWrite(message.adminInfo, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.reduceMarginRatio !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.reduceMarginRatio);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketParamUpdateProposal = new DerivativeMarketParamUpdateProposal$Type();
class AdminInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.AdminInfo", [
      {
        no: 1,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.admin = "";
    message.adminPermissions = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string admin */
        1:
          message.admin = reader.string();
          break;
        case /* uint32 admin_permissions */
        2:
          message.adminPermissions = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.admin !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.admin);
    if (message.adminPermissions !== 0)
      writer.tag(2, WireType.Varint).uint32(message.adminPermissions);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AdminInfo = new AdminInfo$Type();
class MarketForcedSettlementProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MarketForcedSettlementProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/MarketForcedSettlementProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.marketId = "";
    message.settlementPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string settlement_price */
        4:
          message.settlementPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.settlementPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.settlementPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketForcedSettlementProposal = new MarketForcedSettlementProposal$Type();
class UpdateAuctionExchangeTransferDenomDecimalsProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.UpdateAuctionExchangeTransferDenomDecimalsProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "denom_decimals", kind: "message", repeat: 2, T: () => DenomDecimals }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/UpdateAuctionExchangeTransferDenomDecimalsProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.denomDecimals = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* repeated injective.exchange.v2.DenomDecimals denom_decimals */
        3:
          message.denomDecimals.push(DenomDecimals.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    for (let i = 0; i < message.denomDecimals.length; i++)
      DenomDecimals.internalBinaryWrite(message.denomDecimals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const UpdateAuctionExchangeTransferDenomDecimalsProposal = new UpdateAuctionExchangeTransferDenomDecimalsProposal$Type();
class BinaryOptionsMarketParamUpdateProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.BinaryOptionsMarketParamUpdateProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 9,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "settlement_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 11, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 12,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 13, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
      { no: 14, name: "oracle_params", kind: "message", T: () => ProviderOracleParams },
      { no: 15, name: "ticker", kind: "scalar", T: 9, options: { "gogoproto.nullable": true } },
      { no: 16, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 17, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": true } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BinaryOptionsMarketParamUpdateProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.marketId = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.expirationTimestamp = 0n;
    message.settlementTimestamp = 0n;
    message.settlementPrice = "";
    message.admin = "";
    message.status = 0;
    message.ticker = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* string maker_fee_rate */
        4:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        5:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        6:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* string min_price_tick_size */
        7:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        8:
          message.minQuantityTickSize = reader.string();
          break;
        case /* int64 expiration_timestamp */
        9:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 settlement_timestamp */
        10:
          message.settlementTimestamp = reader.int64().toBigInt();
          break;
        case /* string settlement_price */
        11:
          message.settlementPrice = reader.string();
          break;
        case /* string admin */
        12:
          message.admin = reader.string();
          break;
        case /* injective.exchange.v2.MarketStatus status */
        13:
          message.status = reader.int32();
          break;
        case /* injective.exchange.v2.ProviderOracleParams oracle_params */
        14:
          message.oracleParams = ProviderOracleParams.internalBinaryRead(reader, reader.uint32(), options, message.oracleParams);
          break;
        case /* string ticker */
        15:
          message.ticker = reader.string();
          break;
        case /* string min_notional */
        16:
          message.minNotional = reader.string();
          break;
        case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */
        17:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.makerFeeRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.minPriceTickSize !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.expirationTimestamp !== 0n)
      writer.tag(9, WireType.Varint).int64(message.expirationTimestamp);
    if (message.settlementTimestamp !== 0n)
      writer.tag(10, WireType.Varint).int64(message.settlementTimestamp);
    if (message.settlementPrice !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.settlementPrice);
    if (message.admin !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.admin);
    if (message.status !== 0)
      writer.tag(13, WireType.Varint).int32(message.status);
    if (message.oracleParams)
      ProviderOracleParams.internalBinaryWrite(message.oracleParams, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.ticker !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.ticker);
    if (message.minNotional !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minNotional);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarketParamUpdateProposal = new BinaryOptionsMarketParamUpdateProposal$Type();
class ProviderOracleParams$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.ProviderOracleParams", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "provider",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = "";
    message.provider = "";
    message.oracleScaleFactor = 0;
    message.oracleType = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string symbol */
        1:
          message.symbol = reader.string();
          break;
        case /* string provider */
        2:
          message.provider = reader.string();
          break;
        case /* uint32 oracle_scale_factor */
        3:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        4:
          message.oracleType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.symbol !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.symbol);
    if (message.provider !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.provider);
    if (message.oracleScaleFactor !== 0)
      writer.tag(3, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.oracleType !== 0)
      writer.tag(4, WireType.Varint).int32(message.oracleType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProviderOracleParams = new ProviderOracleParams$Type();
class OracleParams$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OracleParams", [
      {
        no: 1,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleScaleFactor = 0;
    message.oracleType = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string oracle_base */
        1:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        2:
          message.oracleQuote = reader.string();
          break;
        case /* uint32 oracle_scale_factor */
        3:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        4:
          message.oracleType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.oracleBase !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleScaleFactor !== 0)
      writer.tag(3, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.oracleType !== 0)
      writer.tag(4, WireType.Varint).int32(message.oracleType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OracleParams = new OracleParams$Type();
class TradingRewardCampaignLaunchProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradingRewardCampaignLaunchProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
      { no: 4, name: "campaign_reward_pools", kind: "message", repeat: 2, T: () => CampaignRewardPool }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/TradingRewardCampaignLaunchProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.campaignRewardPools = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* injective.exchange.v2.TradingRewardCampaignInfo campaign_info */
        3:
          message.campaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.campaignInfo);
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools */
        4:
          message.campaignRewardPools.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.campaignInfo)
      TradingRewardCampaignInfo.internalBinaryWrite(message.campaignInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.campaignRewardPools.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.campaignRewardPools[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignLaunchProposal = new TradingRewardCampaignLaunchProposal$Type();
class TradingRewardCampaignUpdateProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradingRewardCampaignUpdateProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
      { no: 4, name: "campaign_reward_pools_additions", kind: "message", repeat: 2, T: () => CampaignRewardPool },
      { no: 5, name: "campaign_reward_pools_updates", kind: "message", repeat: 2, T: () => CampaignRewardPool }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/TradingRewardCampaignUpdateProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.campaignRewardPoolsAdditions = [];
    message.campaignRewardPoolsUpdates = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* injective.exchange.v2.TradingRewardCampaignInfo campaign_info */
        3:
          message.campaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.campaignInfo);
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_additions */
        4:
          message.campaignRewardPoolsAdditions.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools_updates */
        5:
          message.campaignRewardPoolsUpdates.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.campaignInfo)
      TradingRewardCampaignInfo.internalBinaryWrite(message.campaignInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.campaignRewardPoolsAdditions.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.campaignRewardPoolsAdditions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.campaignRewardPoolsUpdates.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.campaignRewardPoolsUpdates[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignUpdateProposal = new TradingRewardCampaignUpdateProposal$Type();
class RewardPointUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.RewardPointUpdate", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 12, name: "new_points", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.newPoints = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* string new_points */
        12:
          message.newPoints = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.newPoints !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.newPoints);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RewardPointUpdate = new RewardPointUpdate$Type();
class TradingRewardPendingPointsUpdateProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradingRewardPendingPointsUpdateProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "pending_pool_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "reward_point_updates", kind: "message", repeat: 2, T: () => RewardPointUpdate }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/TradingRewardPendingPointsUpdateProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.pendingPoolTimestamp = 0n;
    message.rewardPointUpdates = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* int64 pending_pool_timestamp */
        3:
          message.pendingPoolTimestamp = reader.int64().toBigInt();
          break;
        case /* repeated injective.exchange.v2.RewardPointUpdate reward_point_updates */
        4:
          message.rewardPointUpdates.push(RewardPointUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.pendingPoolTimestamp !== 0n)
      writer.tag(3, WireType.Varint).int64(message.pendingPoolTimestamp);
    for (let i = 0; i < message.rewardPointUpdates.length; i++)
      RewardPointUpdate.internalBinaryWrite(message.rewardPointUpdates[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardPendingPointsUpdateProposal = new TradingRewardPendingPointsUpdateProposal$Type();
class FeeDiscountProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FeeDiscountProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "schedule", kind: "message", T: () => FeeDiscountSchedule }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/FeeDiscountProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* injective.exchange.v2.FeeDiscountSchedule schedule */
        3:
          message.schedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.schedule);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    if (message.schedule)
      FeeDiscountSchedule.internalBinaryWrite(message.schedule, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountProposal = new FeeDiscountProposal$Type();
class BatchCommunityPoolSpendProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.BatchCommunityPoolSpendProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "proposals", kind: "message", repeat: 2, T: () => CommunityPoolSpendProposal }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/BatchCommunityPoolSpendProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.proposals = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* repeated cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals */
        3:
          message.proposals.push(CommunityPoolSpendProposal.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    for (let i = 0; i < message.proposals.length; i++)
      CommunityPoolSpendProposal.internalBinaryWrite(message.proposals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchCommunityPoolSpendProposal = new BatchCommunityPoolSpendProposal$Type();
class AtomicMarketOrderFeeMultiplierScheduleProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.AtomicMarketOrderFeeMultiplierScheduleProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "market_fee_multipliers", kind: "message", repeat: 2, T: () => MarketFeeMultiplier }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/AtomicMarketOrderFeeMultiplierScheduleProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.marketFeeMultipliers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers */
        3:
          message.marketFeeMultipliers.push(MarketFeeMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    for (let i = 0; i < message.marketFeeMultipliers.length; i++)
      MarketFeeMultiplier.internalBinaryWrite(message.marketFeeMultipliers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AtomicMarketOrderFeeMultiplierScheduleProposal = new AtomicMarketOrderFeeMultiplierScheduleProposal$Type();
class DenomMinNotionalProposal$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DenomMinNotionalProposal", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "denom_min_notionals", kind: "message", repeat: 2, T: () => DenomMinNotional }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "exchange/DenomMinNotionalProposal" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.title = "";
    message.description = "";
    message.denomMinNotionals = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */
        1:
          message.title = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals */
        3:
          message.denomMinNotionals.push(DenomMinNotional.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    for (let i = 0; i < message.denomMinNotionals.length; i++)
      DenomMinNotional.internalBinaryWrite(message.denomMinNotionals[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomMinNotionalProposal = new DenomMinNotionalProposal$Type();
export {
  AdminInfo,
  AtomicMarketOrderFeeMultiplierScheduleProposal,
  BatchCommunityPoolSpendProposal,
  BatchExchangeModificationProposal,
  BinaryOptionsMarketLaunchProposal,
  BinaryOptionsMarketParamUpdateProposal,
  DenomMinNotionalProposal,
  DerivativeMarketParamUpdateProposal,
  ExchangeEnableProposal,
  ExchangeType,
  ExpiryFuturesMarketLaunchProposal,
  FeeDiscountProposal,
  MarketForcedSettlementProposal,
  OracleParams,
  PerpetualMarketLaunchProposal,
  ProviderOracleParams,
  RewardPointUpdate,
  SpotMarketLaunchProposal,
  SpotMarketParamUpdateProposal,
  TradingRewardCampaignLaunchProposal,
  TradingRewardCampaignUpdateProposal,
  TradingRewardPendingPointsUpdateProposal,
  UpdateAuctionExchangeTransferDenomDecimalsProposal
};
