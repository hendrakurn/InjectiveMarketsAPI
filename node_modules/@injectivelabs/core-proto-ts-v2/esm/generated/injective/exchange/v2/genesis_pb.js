import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ActiveGrant } from "./exchange_pb.js";
import { GrantAuthorization } from "./exchange_pb.js";
import { SubaccountTradeNonce } from "./exchange_pb.js";
import { FeeDiscountTierTTL } from "./exchange_pb.js";
import { DenomMinNotional } from "./exchange_pb.js";
import { MarketVolume } from "./market_pb.js";
import { AggregateSubaccountVolumeRecord } from "./exchange_pb.js";
import { MarketFeeMultiplier } from "./market_pb.js";
import { ConditionalDerivativeOrderBook } from "./orderbook_pb.js";
import { DenomDecimals } from "./exchange_pb.js";
import { BinaryOptionsMarket } from "./market_pb.js";
import { TradeRecords } from "./exchange_pb.js";
import { FeeDiscountSchedule } from "./exchange_pb.js";
import { CampaignRewardPool } from "./exchange_pb.js";
import { TradingRewardCampaignInfo } from "./exchange_pb.js";
import { DerivativeMarketSettlementInfo } from "./market_pb.js";
import { PerpetualMarketFundingState } from "./market_pb.js";
import { PerpetualMarketInfo } from "./market_pb.js";
import { ExpiryFuturesMarketInfoState } from "./market_pb.js";
import { DerivativePosition } from "./exchange_pb.js";
import { Balance } from "./exchange_pb.js";
import { DerivativeOrderBook } from "./orderbook_pb.js";
import { SpotOrderBook } from "./orderbook_pb.js";
import { DerivativeMarket } from "./market_pb.js";
import { SpotMarket } from "./market_pb.js";
import { Params } from "./exchange_pb.js";
class GenesisState$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.GenesisState", [
      { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } },
      { no: 2, name: "spot_markets", kind: "message", repeat: 2, T: () => SpotMarket },
      { no: 3, name: "derivative_markets", kind: "message", repeat: 2, T: () => DerivativeMarket },
      { no: 4, name: "spot_orderbook", kind: "message", repeat: 2, T: () => SpotOrderBook, options: { "gogoproto.nullable": false } },
      { no: 5, name: "derivative_orderbook", kind: "message", repeat: 2, T: () => DerivativeOrderBook, options: { "gogoproto.nullable": false } },
      { no: 6, name: "balances", kind: "message", repeat: 2, T: () => Balance, options: { "gogoproto.nullable": false } },
      { no: 7, name: "positions", kind: "message", repeat: 2, T: () => DerivativePosition, options: { "gogoproto.nullable": false } },
      { no: 8, name: "subaccount_trade_nonces", kind: "message", repeat: 2, T: () => SubaccountNonce, options: { "gogoproto.nullable": false } },
      { no: 9, name: "expiry_futures_market_info_state", kind: "message", repeat: 2, T: () => ExpiryFuturesMarketInfoState, options: { "gogoproto.nullable": false } },
      { no: 10, name: "perpetual_market_info", kind: "message", repeat: 2, T: () => PerpetualMarketInfo, options: { "gogoproto.nullable": false } },
      { no: 11, name: "perpetual_market_funding_state", kind: "message", repeat: 2, T: () => PerpetualMarketFundingState, options: { "gogoproto.nullable": false } },
      { no: 12, name: "derivative_market_settlement_scheduled", kind: "message", repeat: 2, T: () => DerivativeMarketSettlementInfo, options: { "gogoproto.nullable": false } },
      {
        no: 13,
        name: "is_spot_exchange_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 14,
        name: "is_derivatives_exchange_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 15, name: "trading_reward_campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
      { no: 16, name: "trading_reward_pool_campaign_schedule", kind: "message", repeat: 2, T: () => CampaignRewardPool },
      { no: 17, name: "trading_reward_campaign_account_points", kind: "message", repeat: 2, T: () => TradingRewardCampaignAccountPoints },
      { no: 18, name: "fee_discount_schedule", kind: "message", T: () => FeeDiscountSchedule },
      { no: 19, name: "fee_discount_account_tier_ttl", kind: "message", repeat: 2, T: () => FeeDiscountAccountTierTTL },
      { no: 20, name: "fee_discount_bucket_volume_accounts", kind: "message", repeat: 2, T: () => FeeDiscountBucketVolumeAccounts },
      {
        no: 21,
        name: "is_first_fee_cycle_finished",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 22, name: "pending_trading_reward_pool_campaign_schedule", kind: "message", repeat: 2, T: () => CampaignRewardPool },
      { no: 23, name: "pending_trading_reward_campaign_account_points", kind: "message", repeat: 2, T: () => TradingRewardCampaignAccountPendingPoints },
      {
        no: 24,
        name: "rewards_opt_out_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 25, name: "historical_trade_records", kind: "message", repeat: 2, T: () => TradeRecords },
      { no: 26, name: "binary_options_markets", kind: "message", repeat: 2, T: () => BinaryOptionsMarket },
      {
        no: 27,
        name: "binary_options_market_ids_scheduled_for_settlement",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 28,
        name: "spot_market_ids_scheduled_to_force_close",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 29, name: "auction_exchange_transfer_denom_decimals", kind: "message", repeat: 2, T: () => DenomDecimals, options: { "gogoproto.nullable": false } },
      { no: 30, name: "conditional_derivative_orderbooks", kind: "message", repeat: 2, T: () => ConditionalDerivativeOrderBook },
      { no: 31, name: "market_fee_multipliers", kind: "message", repeat: 2, T: () => MarketFeeMultiplier },
      { no: 32, name: "orderbook_sequences", kind: "message", repeat: 2, T: () => OrderbookSequence },
      { no: 33, name: "subaccount_volumes", kind: "message", repeat: 2, T: () => AggregateSubaccountVolumeRecord },
      { no: 34, name: "market_volumes", kind: "message", repeat: 2, T: () => MarketVolume },
      { no: 35, name: "grant_authorizations", kind: "message", repeat: 2, T: () => FullGrantAuthorizations },
      { no: 36, name: "active_grants", kind: "message", repeat: 2, T: () => FullActiveGrant },
      { no: 37, name: "denom_min_notionals", kind: "message", repeat: 2, T: () => DenomMinNotional }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.spotMarkets = [];
    message.derivativeMarkets = [];
    message.spotOrderbook = [];
    message.derivativeOrderbook = [];
    message.balances = [];
    message.positions = [];
    message.subaccountTradeNonces = [];
    message.expiryFuturesMarketInfoState = [];
    message.perpetualMarketInfo = [];
    message.perpetualMarketFundingState = [];
    message.derivativeMarketSettlementScheduled = [];
    message.isSpotExchangeEnabled = false;
    message.isDerivativesExchangeEnabled = false;
    message.tradingRewardPoolCampaignSchedule = [];
    message.tradingRewardCampaignAccountPoints = [];
    message.feeDiscountAccountTierTtl = [];
    message.feeDiscountBucketVolumeAccounts = [];
    message.isFirstFeeCycleFinished = false;
    message.pendingTradingRewardPoolCampaignSchedule = [];
    message.pendingTradingRewardCampaignAccountPoints = [];
    message.rewardsOptOutAddresses = [];
    message.historicalTradeRecords = [];
    message.binaryOptionsMarkets = [];
    message.binaryOptionsMarketIdsScheduledForSettlement = [];
    message.spotMarketIdsScheduledToForceClose = [];
    message.auctionExchangeTransferDenomDecimals = [];
    message.conditionalDerivativeOrderbooks = [];
    message.marketFeeMultipliers = [];
    message.orderbookSequences = [];
    message.subaccountVolumes = [];
    message.marketVolumes = [];
    message.grantAuthorizations = [];
    message.activeGrants = [];
    message.denomMinNotionals = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.Params params */
        1:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        case /* repeated injective.exchange.v2.SpotMarket spot_markets */
        2:
          message.spotMarkets.push(SpotMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DerivativeMarket derivative_markets */
        3:
          message.derivativeMarkets.push(DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.SpotOrderBook spot_orderbook */
        4:
          message.spotOrderbook.push(SpotOrderBook.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DerivativeOrderBook derivative_orderbook */
        5:
          message.derivativeOrderbook.push(DerivativeOrderBook.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.Balance balances */
        6:
          message.balances.push(Balance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DerivativePosition positions */
        7:
          message.positions.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.SubaccountNonce subaccount_trade_nonces */
        8:
          message.subaccountTradeNonces.push(SubaccountNonce.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.ExpiryFuturesMarketInfoState expiry_futures_market_info_state */
        9:
          message.expiryFuturesMarketInfoState.push(ExpiryFuturesMarketInfoState.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.PerpetualMarketInfo perpetual_market_info */
        10:
          message.perpetualMarketInfo.push(PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.PerpetualMarketFundingState perpetual_market_funding_state */
        11:
          message.perpetualMarketFundingState.push(PerpetualMarketFundingState.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled */
        12:
          message.derivativeMarketSettlementScheduled.push(DerivativeMarketSettlementInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bool is_spot_exchange_enabled */
        13:
          message.isSpotExchangeEnabled = reader.bool();
          break;
        case /* bool is_derivatives_exchange_enabled */
        14:
          message.isDerivativesExchangeEnabled = reader.bool();
          break;
        case /* injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info */
        15:
          message.tradingRewardCampaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardCampaignInfo);
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule */
        16:
          message.tradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points */
        17:
          message.tradingRewardCampaignAccountPoints.push(TradingRewardCampaignAccountPoints.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule */
        18:
          message.feeDiscountSchedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.feeDiscountSchedule);
          break;
        case /* repeated injective.exchange.v2.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl */
        19:
          message.feeDiscountAccountTierTtl.push(FeeDiscountAccountTierTTL.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts */
        20:
          message.feeDiscountBucketVolumeAccounts.push(FeeDiscountBucketVolumeAccounts.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bool is_first_fee_cycle_finished */
        21:
          message.isFirstFeeCycleFinished = reader.bool();
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule */
        22:
          message.pendingTradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points */
        23:
          message.pendingTradingRewardCampaignAccountPoints.push(TradingRewardCampaignAccountPendingPoints.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string rewards_opt_out_addresses */
        24:
          message.rewardsOptOutAddresses.push(reader.string());
          break;
        case /* repeated injective.exchange.v2.TradeRecords historical_trade_records */
        25:
          message.historicalTradeRecords.push(TradeRecords.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.BinaryOptionsMarket binary_options_markets */
        26:
          message.binaryOptionsMarkets.push(BinaryOptionsMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string binary_options_market_ids_scheduled_for_settlement */
        27:
          message.binaryOptionsMarketIdsScheduledForSettlement.push(reader.string());
          break;
        case /* repeated string spot_market_ids_scheduled_to_force_close */
        28:
          message.spotMarketIdsScheduledToForceClose.push(reader.string());
          break;
        case /* repeated injective.exchange.v2.DenomDecimals auction_exchange_transfer_denom_decimals */
        29:
          message.auctionExchangeTransferDenomDecimals.push(DenomDecimals.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.ConditionalDerivativeOrderBook conditional_derivative_orderbooks */
        30:
          message.conditionalDerivativeOrderbooks.push(ConditionalDerivativeOrderBook.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers */
        31:
          message.marketFeeMultipliers.push(MarketFeeMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.OrderbookSequence orderbook_sequences */
        32:
          message.orderbookSequences.push(OrderbookSequence.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.AggregateSubaccountVolumeRecord subaccount_volumes */
        33:
          message.subaccountVolumes.push(AggregateSubaccountVolumeRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.MarketVolume market_volumes */
        34:
          message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.FullGrantAuthorizations grant_authorizations */
        35:
          message.grantAuthorizations.push(FullGrantAuthorizations.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.FullActiveGrant active_grants */
        36:
          message.activeGrants.push(FullActiveGrant.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals */
        37:
          message.denomMinNotionals.push(DenomMinNotional.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.spotMarkets.length; i++)
      SpotMarket.internalBinaryWrite(message.spotMarkets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeMarkets.length; i++)
      DerivativeMarket.internalBinaryWrite(message.derivativeMarkets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.spotOrderbook.length; i++)
      SpotOrderBook.internalBinaryWrite(message.spotOrderbook[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeOrderbook.length; i++)
      DerivativeOrderBook.internalBinaryWrite(message.derivativeOrderbook[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.balances.length; i++)
      Balance.internalBinaryWrite(message.balances[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.positions.length; i++)
      DerivativePosition.internalBinaryWrite(message.positions[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.subaccountTradeNonces.length; i++)
      SubaccountNonce.internalBinaryWrite(message.subaccountTradeNonces[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.expiryFuturesMarketInfoState.length; i++)
      ExpiryFuturesMarketInfoState.internalBinaryWrite(message.expiryFuturesMarketInfoState[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.perpetualMarketInfo.length; i++)
      PerpetualMarketInfo.internalBinaryWrite(message.perpetualMarketInfo[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.perpetualMarketFundingState.length; i++)
      PerpetualMarketFundingState.internalBinaryWrite(message.perpetualMarketFundingState[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeMarketSettlementScheduled.length; i++)
      DerivativeMarketSettlementInfo.internalBinaryWrite(message.derivativeMarketSettlementScheduled[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.isSpotExchangeEnabled !== false)
      writer.tag(13, WireType.Varint).bool(message.isSpotExchangeEnabled);
    if (message.isDerivativesExchangeEnabled !== false)
      writer.tag(14, WireType.Varint).bool(message.isDerivativesExchangeEnabled);
    if (message.tradingRewardCampaignInfo)
      TradingRewardCampaignInfo.internalBinaryWrite(message.tradingRewardCampaignInfo, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.tradingRewardPoolCampaignSchedule.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.tradingRewardPoolCampaignSchedule[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.tradingRewardCampaignAccountPoints.length; i++)
      TradingRewardCampaignAccountPoints.internalBinaryWrite(message.tradingRewardCampaignAccountPoints[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.feeDiscountSchedule)
      FeeDiscountSchedule.internalBinaryWrite(message.feeDiscountSchedule, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.feeDiscountAccountTierTtl.length; i++)
      FeeDiscountAccountTierTTL.internalBinaryWrite(message.feeDiscountAccountTierTtl[i], writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.feeDiscountBucketVolumeAccounts.length; i++)
      FeeDiscountBucketVolumeAccounts.internalBinaryWrite(message.feeDiscountBucketVolumeAccounts[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    if (message.isFirstFeeCycleFinished !== false)
      writer.tag(21, WireType.Varint).bool(message.isFirstFeeCycleFinished);
    for (let i = 0; i < message.pendingTradingRewardPoolCampaignSchedule.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.pendingTradingRewardPoolCampaignSchedule[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.pendingTradingRewardCampaignAccountPoints.length; i++)
      TradingRewardCampaignAccountPendingPoints.internalBinaryWrite(message.pendingTradingRewardCampaignAccountPoints[i], writer.tag(23, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.rewardsOptOutAddresses.length; i++)
      writer.tag(24, WireType.LengthDelimited).string(message.rewardsOptOutAddresses[i]);
    for (let i = 0; i < message.historicalTradeRecords.length; i++)
      TradeRecords.internalBinaryWrite(message.historicalTradeRecords[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.binaryOptionsMarkets.length; i++)
      BinaryOptionsMarket.internalBinaryWrite(message.binaryOptionsMarkets[i], writer.tag(26, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.binaryOptionsMarketIdsScheduledForSettlement.length; i++)
      writer.tag(27, WireType.LengthDelimited).string(message.binaryOptionsMarketIdsScheduledForSettlement[i]);
    for (let i = 0; i < message.spotMarketIdsScheduledToForceClose.length; i++)
      writer.tag(28, WireType.LengthDelimited).string(message.spotMarketIdsScheduledToForceClose[i]);
    for (let i = 0; i < message.auctionExchangeTransferDenomDecimals.length; i++)
      DenomDecimals.internalBinaryWrite(message.auctionExchangeTransferDenomDecimals[i], writer.tag(29, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.conditionalDerivativeOrderbooks.length; i++)
      ConditionalDerivativeOrderBook.internalBinaryWrite(message.conditionalDerivativeOrderbooks[i], writer.tag(30, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.marketFeeMultipliers.length; i++)
      MarketFeeMultiplier.internalBinaryWrite(message.marketFeeMultipliers[i], writer.tag(31, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.orderbookSequences.length; i++)
      OrderbookSequence.internalBinaryWrite(message.orderbookSequences[i], writer.tag(32, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.subaccountVolumes.length; i++)
      AggregateSubaccountVolumeRecord.internalBinaryWrite(message.subaccountVolumes[i], writer.tag(33, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.marketVolumes.length; i++)
      MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(34, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.grantAuthorizations.length; i++)
      FullGrantAuthorizations.internalBinaryWrite(message.grantAuthorizations[i], writer.tag(35, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.activeGrants.length; i++)
      FullActiveGrant.internalBinaryWrite(message.activeGrants[i], writer.tag(36, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.denomMinNotionals.length; i++)
      DenomMinNotional.internalBinaryWrite(message.denomMinNotionals[i], writer.tag(37, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GenesisState = new GenesisState$Type();
class OrderbookSequence$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OrderbookSequence", [
      {
        no: 1,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sequence = 0n;
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 sequence */
        1:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sequence !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.sequence);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookSequence = new OrderbookSequence$Type();
class FeeDiscountAccountTierTTL$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FeeDiscountAccountTierTTL", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tier_ttl", kind: "message", T: () => FeeDiscountTierTTL }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* injective.exchange.v2.FeeDiscountTierTTL tier_ttl */
        2:
          message.tierTtl = FeeDiscountTierTTL.internalBinaryRead(reader, reader.uint32(), options, message.tierTtl);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.tierTtl)
      FeeDiscountTierTTL.internalBinaryWrite(message.tierTtl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountAccountTierTTL = new FeeDiscountAccountTierTTL$Type();
class FeeDiscountBucketVolumeAccounts$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FeeDiscountBucketVolumeAccounts", [
      {
        no: 1,
        name: "bucket_start_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "account_volume", kind: "message", repeat: 2, T: () => AccountVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketStartTimestamp = 0n;
    message.accountVolume = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 bucket_start_timestamp */
        1:
          message.bucketStartTimestamp = reader.int64().toBigInt();
          break;
        case /* repeated injective.exchange.v2.AccountVolume account_volume */
        2:
          message.accountVolume.push(AccountVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bucketStartTimestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.bucketStartTimestamp);
    for (let i = 0; i < message.accountVolume.length; i++)
      AccountVolume.internalBinaryWrite(message.accountVolume[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountBucketVolumeAccounts = new FeeDiscountBucketVolumeAccounts$Type();
class AccountVolume$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.AccountVolume", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "volume", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.volume = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string volume */
        2:
          message.volume = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.volume !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.volume);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountVolume = new AccountVolume$Type();
class TradingRewardCampaignAccountPoints$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradingRewardCampaignAccountPoints", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "points", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.points = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* string points */
        2:
          message.points = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    if (message.points !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.points);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignAccountPoints = new TradingRewardCampaignAccountPoints$Type();
class TradingRewardCampaignAccountPendingPoints$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradingRewardCampaignAccountPendingPoints", [
      {
        no: 1,
        name: "reward_pool_start_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "account_points", kind: "message", repeat: 2, T: () => TradingRewardCampaignAccountPoints }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rewardPoolStartTimestamp = 0n;
    message.accountPoints = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 reward_pool_start_timestamp */
        1:
          message.rewardPoolStartTimestamp = reader.int64().toBigInt();
          break;
        case /* repeated injective.exchange.v2.TradingRewardCampaignAccountPoints account_points */
        2:
          message.accountPoints.push(TradingRewardCampaignAccountPoints.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rewardPoolStartTimestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.rewardPoolStartTimestamp);
    for (let i = 0; i < message.accountPoints.length; i++)
      TradingRewardCampaignAccountPoints.internalBinaryWrite(message.accountPoints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignAccountPendingPoints = new TradingRewardCampaignAccountPendingPoints$Type();
class SubaccountNonce$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountNonce", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "subaccount_trade_nonce", kind: "message", T: () => SubaccountTradeNonce, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* injective.exchange.v2.SubaccountTradeNonce subaccount_trade_nonce */
        2:
          message.subaccountTradeNonce = SubaccountTradeNonce.internalBinaryRead(reader, reader.uint32(), options, message.subaccountTradeNonce);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.subaccountTradeNonce)
      SubaccountTradeNonce.internalBinaryWrite(message.subaccountTradeNonce, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountNonce = new SubaccountNonce$Type();
class FullGrantAuthorizations$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FullGrantAuthorizations", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "total_grant_amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 3,
        name: "last_delegations_checked_time",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "grants", kind: "message", repeat: 2, T: () => GrantAuthorization }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    message.totalGrantAmount = "";
    message.lastDelegationsCheckedTime = 0n;
    message.grants = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        case /* string total_grant_amount */
        2:
          message.totalGrantAmount = reader.string();
          break;
        case /* int64 last_delegations_checked_time */
        3:
          message.lastDelegationsCheckedTime = reader.int64().toBigInt();
          break;
        case /* repeated injective.exchange.v2.GrantAuthorization grants */
        4:
          message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    if (message.totalGrantAmount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.totalGrantAmount);
    if (message.lastDelegationsCheckedTime !== 0n)
      writer.tag(3, WireType.Varint).int64(message.lastDelegationsCheckedTime);
    for (let i = 0; i < message.grants.length; i++)
      GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FullGrantAuthorizations = new FullGrantAuthorizations$Type();
class FullActiveGrant$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FullActiveGrant", [
      {
        no: 1,
        name: "grantee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "active_grant", kind: "message", T: () => ActiveGrant }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.grantee = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string grantee */
        1:
          message.grantee = reader.string();
          break;
        case /* injective.exchange.v2.ActiveGrant active_grant */
        2:
          message.activeGrant = ActiveGrant.internalBinaryRead(reader, reader.uint32(), options, message.activeGrant);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.grantee !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.grantee);
    if (message.activeGrant)
      ActiveGrant.internalBinaryWrite(message.activeGrant, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FullActiveGrant = new FullActiveGrant$Type();
export {
  AccountVolume,
  FeeDiscountAccountTierTTL,
  FeeDiscountBucketVolumeAccounts,
  FullActiveGrant,
  FullGrantAuthorizations,
  GenesisState,
  OrderbookSequence,
  SubaccountNonce,
  TradingRewardCampaignAccountPendingPoints,
  TradingRewardCampaignAccountPoints
};
