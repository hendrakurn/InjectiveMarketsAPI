import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DenomMinNotional } from "./exchange_pb.js";
import { GrantAuthorization } from "./exchange_pb.js";
import { EffectiveGrant } from "./exchange_pb.js";
import { ActiveGrant } from "./exchange_pb.js";
import { BinaryOptionsMarket } from "./market_pb.js";
import { TradeRecord } from "./exchange_pb.js";
import { MetadataStatistics } from "../../oracle/v1beta1/oracle_pb.js";
import { TradeRecords } from "./exchange_pb.js";
import { FeeDiscountSchedule } from "./exchange_pb.js";
import { FeeDiscountTierTTL } from "./exchange_pb.js";
import { FeeDiscountTierInfo } from "./exchange_pb.js";
import { CampaignRewardPool } from "./exchange_pb.js";
import { TradingRewardCampaignInfo } from "./exchange_pb.js";
import { GenesisState } from "./genesis_pb.js";
import { Position } from "./exchange_pb.js";
import { DerivativePosition } from "./exchange_pb.js";
import { ExpiryFuturesMarketInfo } from "./market_pb.js";
import { DerivativeMarket } from "./market_pb.js";
import { PerpetualMarketFunding } from "./market_pb.js";
import { PerpetualMarketInfo } from "./market_pb.js";
import { MidPriceAndTOB } from "./exchange_pb.js";
import { Level } from "./exchange_pb.js";
import { SpotMarket } from "./market_pb.js";
import { DenomDecimals } from "./exchange_pb.js";
import { VolumeRecord } from "./market_pb.js";
import { AggregateAccountVolumeRecord } from "./exchange_pb.js";
import { MarketVolume } from "./market_pb.js";
import { Balance } from "./exchange_pb.js";
import { Deposit } from "./exchange_pb.js";
import { Params } from "./exchange_pb.js";
import { SubaccountOrderbookMetadata } from "./orderbook_pb.js";
import { SubaccountOrderData } from "./exchange_pb.js";
var OrderSide = /* @__PURE__ */ ((OrderSide2) => {
  OrderSide2[OrderSide2["Side_Unspecified"] = 0] = "Side_Unspecified";
  OrderSide2[OrderSide2["Buy"] = 1] = "Buy";
  OrderSide2[OrderSide2["Sell"] = 2] = "Sell";
  return OrderSide2;
})(OrderSide || {});
var CancellationStrategy = /* @__PURE__ */ ((CancellationStrategy2) => {
  CancellationStrategy2[CancellationStrategy2["UnspecifiedOrder"] = 0] = "UnspecifiedOrder";
  CancellationStrategy2[CancellationStrategy2["FromWorstToBest"] = 1] = "FromWorstToBest";
  CancellationStrategy2[CancellationStrategy2["FromBestToWorst"] = 2] = "FromBestToWorst";
  return CancellationStrategy2;
})(CancellationStrategy || {});
class Subaccount$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.Subaccount", [
      {
        no: 1,
        name: "trader",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_nonce",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trader = "";
    message.subaccountNonce = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string trader */
        1:
          message.trader = reader.string();
          break;
        case /* uint32 subaccount_nonce */
        2:
          message.subaccountNonce = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.trader !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.trader);
    if (message.subaccountNonce !== 0)
      writer.tag(2, WireType.Varint).uint32(message.subaccountNonce);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Subaccount = new Subaccount$Type();
class QuerySubaccountOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountOrdersRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountOrdersRequest = new QuerySubaccountOrdersRequest$Type();
class QuerySubaccountOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountOrdersResponse", [
      { no: 1, name: "buy_orders", kind: "message", repeat: 2, T: () => SubaccountOrderData },
      { no: 2, name: "sell_orders", kind: "message", repeat: 2, T: () => SubaccountOrderData }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.buyOrders = [];
    message.sellOrders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.SubaccountOrderData buy_orders */
        1:
          message.buyOrders.push(SubaccountOrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.SubaccountOrderData sell_orders */
        2:
          message.sellOrders.push(SubaccountOrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.buyOrders.length; i++)
      SubaccountOrderData.internalBinaryWrite(message.buyOrders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellOrders.length; i++)
      SubaccountOrderData.internalBinaryWrite(message.sellOrders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountOrdersResponse = new QuerySubaccountOrdersResponse$Type();
class SubaccountOrderbookMetadataWithMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SubaccountOrderbookMetadataWithMarket", [
      { no: 1, name: "metadata", kind: "message", T: () => SubaccountOrderbookMetadata },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "isBuy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isBuy = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.SubaccountOrderbookMetadata metadata */
        1:
          message.metadata = SubaccountOrderbookMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* bool isBuy */
        3:
          message.isBuy = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.metadata)
      SubaccountOrderbookMetadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.isBuy !== false)
      writer.tag(3, WireType.Varint).bool(message.isBuy);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrderbookMetadataWithMarket = new SubaccountOrderbookMetadataWithMarket$Type();
class QueryExchangeParamsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryExchangeParamsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryExchangeParamsRequest = new QueryExchangeParamsRequest$Type();
class QueryExchangeParamsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryExchangeParamsResponse", [
      { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.Params params */
        1:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryExchangeParamsResponse = new QueryExchangeParamsResponse$Type();
class QuerySubaccountDepositsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountDepositsRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "subaccount", kind: "message", T: () => Subaccount, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* injective.exchange.v2.Subaccount subaccount */
        2:
          message.subaccount = Subaccount.internalBinaryRead(reader, reader.uint32(), options, message.subaccount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.subaccount)
      Subaccount.internalBinaryWrite(message.subaccount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountDepositsRequest = new QuerySubaccountDepositsRequest$Type();
class QuerySubaccountDepositsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountDepositsResponse", [
      { no: 1, name: "deposits", kind: "map", K: 9, V: { kind: "message", T: () => Deposit } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.deposits = {};
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, injective.exchange.v2.Deposit> deposits */
        1:
          this.binaryReadMap1(message.deposits, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap1(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = Deposit.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error("unknown map entry field for injective.exchange.v2.QuerySubaccountDepositsResponse.deposits");
      }
    }
    map[key ?? ""] = val ?? Deposit.create();
  }
  internalBinaryWrite(message, writer, options) {
    for (let k of globalThis.Object.keys(message.deposits)) {
      writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      Deposit.internalBinaryWrite(message.deposits[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountDepositsResponse = new QuerySubaccountDepositsResponse$Type();
class QueryExchangeBalancesRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryExchangeBalancesRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryExchangeBalancesRequest = new QueryExchangeBalancesRequest$Type();
class QueryExchangeBalancesResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryExchangeBalancesResponse", [
      { no: 1, name: "balances", kind: "message", repeat: 2, T: () => Balance, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.Balance balances */
        1:
          message.balances.push(Balance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balances.length; i++)
      Balance.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryExchangeBalancesResponse = new QueryExchangeBalancesResponse$Type();
class QueryAggregateVolumeRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateVolumeRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateVolumeRequest = new QueryAggregateVolumeRequest$Type();
class QueryAggregateVolumeResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateVolumeResponse", [
      { no: 1, name: "aggregate_volumes", kind: "message", repeat: 2, T: () => MarketVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.aggregateVolumes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.MarketVolume aggregate_volumes */
        1:
          message.aggregateVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.aggregateVolumes.length; i++)
      MarketVolume.internalBinaryWrite(message.aggregateVolumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateVolumeResponse = new QueryAggregateVolumeResponse$Type();
class QueryAggregateVolumesRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateVolumesRequest", [
      {
        no: 1,
        name: "accounts",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accounts = [];
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string accounts */
        1:
          message.accounts.push(reader.string());
          break;
        case /* repeated string market_ids */
        2:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accounts.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateVolumesRequest = new QueryAggregateVolumesRequest$Type();
class QueryAggregateVolumesResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateVolumesResponse", [
      { no: 1, name: "aggregate_account_volumes", kind: "message", repeat: 2, T: () => AggregateAccountVolumeRecord },
      { no: 2, name: "aggregate_market_volumes", kind: "message", repeat: 2, T: () => MarketVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.aggregateAccountVolumes = [];
    message.aggregateMarketVolumes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.AggregateAccountVolumeRecord aggregate_account_volumes */
        1:
          message.aggregateAccountVolumes.push(AggregateAccountVolumeRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.MarketVolume aggregate_market_volumes */
        2:
          message.aggregateMarketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.aggregateAccountVolumes.length; i++)
      AggregateAccountVolumeRecord.internalBinaryWrite(message.aggregateAccountVolumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.aggregateMarketVolumes.length; i++)
      MarketVolume.internalBinaryWrite(message.aggregateMarketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateVolumesResponse = new QueryAggregateVolumesResponse$Type();
class QueryAggregateMarketVolumeRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateMarketVolumeRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateMarketVolumeRequest = new QueryAggregateMarketVolumeRequest$Type();
class QueryAggregateMarketVolumeResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateMarketVolumeResponse", [
      { no: 1, name: "volume", kind: "message", T: () => VolumeRecord, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.VolumeRecord volume */
        1:
          message.volume = VolumeRecord.internalBinaryRead(reader, reader.uint32(), options, message.volume);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.volume)
      VolumeRecord.internalBinaryWrite(message.volume, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateMarketVolumeResponse = new QueryAggregateMarketVolumeResponse$Type();
class QueryAuctionExchangeTransferDenomDecimalRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAuctionExchangeTransferDenomDecimalRequest = new QueryAuctionExchangeTransferDenomDecimalRequest$Type();
class QueryAuctionExchangeTransferDenomDecimalResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalResponse", [
      {
        no: 1,
        name: "decimal",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.decimal = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 decimal */
        1:
          message.decimal = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.decimal !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.decimal);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAuctionExchangeTransferDenomDecimalResponse = new QueryAuctionExchangeTransferDenomDecimalResponse$Type();
class QueryAuctionExchangeTransferDenomDecimalsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsRequest", [
      {
        no: 1,
        name: "denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denoms = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string denoms */
        1:
          message.denoms.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.denoms.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.denoms[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAuctionExchangeTransferDenomDecimalsRequest = new QueryAuctionExchangeTransferDenomDecimalsRequest$Type();
class QueryAuctionExchangeTransferDenomDecimalsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsResponse", [
      { no: 1, name: "denom_decimals", kind: "message", repeat: 2, T: () => DenomDecimals, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denomDecimals = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.DenomDecimals denom_decimals */
        1:
          message.denomDecimals.push(DenomDecimals.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.denomDecimals.length; i++)
      DenomDecimals.internalBinaryWrite(message.denomDecimals[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAuctionExchangeTransferDenomDecimalsResponse = new QueryAuctionExchangeTransferDenomDecimalsResponse$Type();
class QueryAggregateMarketVolumesRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateMarketVolumesRequest", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateMarketVolumesRequest = new QueryAggregateMarketVolumesRequest$Type();
class QueryAggregateMarketVolumesResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAggregateMarketVolumesResponse", [
      { no: 1, name: "volumes", kind: "message", repeat: 2, T: () => MarketVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.volumes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.MarketVolume volumes */
        1:
          message.volumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.volumes.length; i++)
      MarketVolume.internalBinaryWrite(message.volumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAggregateMarketVolumesResponse = new QueryAggregateMarketVolumesResponse$Type();
class QuerySubaccountDepositRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountDepositRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountDepositRequest = new QuerySubaccountDepositRequest$Type();
class QuerySubaccountDepositResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountDepositResponse", [
      { no: 1, name: "deposits", kind: "message", T: () => Deposit }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.Deposit deposits */
        1:
          message.deposits = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposits);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.deposits)
      Deposit.internalBinaryWrite(message.deposits, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountDepositResponse = new QuerySubaccountDepositResponse$Type();
class QuerySpotMarketsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotMarketsRequest", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        case /* repeated string market_ids */
        2:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotMarketsRequest = new QuerySpotMarketsRequest$Type();
class QuerySpotMarketsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotMarketsResponse", [
      { no: 1, name: "markets", kind: "message", repeat: 2, T: () => SpotMarket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.SpotMarket markets */
        1:
          message.markets.push(SpotMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.markets.length; i++)
      SpotMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotMarketsResponse = new QuerySpotMarketsResponse$Type();
class QuerySpotMarketRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotMarketRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotMarketRequest = new QuerySpotMarketRequest$Type();
class QuerySpotMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotMarketResponse", [
      { no: 1, name: "market", kind: "message", T: () => SpotMarket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.SpotMarket market */
        1:
          message.market = SpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      SpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotMarketResponse = new QuerySpotMarketResponse$Type();
class QuerySpotOrderbookRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotOrderbookRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "order_side", kind: "enum", T: () => ["injective.exchange.v2.OrderSide", OrderSide] },
      { no: 4, name: "limit_cumulative_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "limit_cumulative_quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.limit = 0n;
    message.orderSide = 0;
    message.limitCumulativeNotional = "";
    message.limitCumulativeQuantity = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* uint64 limit */
        2:
          message.limit = reader.uint64().toBigInt();
          break;
        case /* injective.exchange.v2.OrderSide order_side */
        3:
          message.orderSide = reader.int32();
          break;
        case /* string limit_cumulative_notional */
        4:
          message.limitCumulativeNotional = reader.string();
          break;
        case /* string limit_cumulative_quantity */
        5:
          message.limitCumulativeQuantity = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.limit !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.limit);
    if (message.orderSide !== 0)
      writer.tag(3, WireType.Varint).int32(message.orderSide);
    if (message.limitCumulativeNotional !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.limitCumulativeNotional);
    if (message.limitCumulativeQuantity !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.limitCumulativeQuantity);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotOrderbookRequest = new QuerySpotOrderbookRequest$Type();
class QuerySpotOrderbookResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotOrderbookResponse", [
      { no: 1, name: "buys_price_level", kind: "message", repeat: 2, T: () => Level },
      { no: 2, name: "sells_price_level", kind: "message", repeat: 2, T: () => Level },
      {
        no: 3,
        name: "seq",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.buysPriceLevel = [];
    message.sellsPriceLevel = [];
    message.seq = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.Level buys_price_level */
        1:
          message.buysPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.Level sells_price_level */
        2:
          message.sellsPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 seq */
        3:
          message.seq = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.buysPriceLevel.length; i++)
      Level.internalBinaryWrite(message.buysPriceLevel[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellsPriceLevel.length; i++)
      Level.internalBinaryWrite(message.sellsPriceLevel[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.seq !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.seq);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotOrderbookResponse = new QuerySpotOrderbookResponse$Type();
class FullSpotMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FullSpotMarket", [
      { no: 1, name: "market", kind: "message", T: () => SpotMarket },
      { no: 2, name: "mid_price_and_tob", kind: "message", T: () => MidPriceAndTOB, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.SpotMarket market */
        1:
          message.market = SpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        case /* injective.exchange.v2.MidPriceAndTOB mid_price_and_tob */
        2:
          message.midPriceAndTob = MidPriceAndTOB.internalBinaryRead(reader, reader.uint32(), options, message.midPriceAndTob);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      SpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.midPriceAndTob)
      MidPriceAndTOB.internalBinaryWrite(message.midPriceAndTob, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FullSpotMarket = new FullSpotMarket$Type();
class QueryFullSpotMarketsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullSpotMarketsRequest", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "with_mid_price_and_tob",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    message.marketIds = [];
    message.withMidPriceAndTob = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        case /* repeated string market_ids */
        2:
          message.marketIds.push(reader.string());
          break;
        case /* bool with_mid_price_and_tob */
        3:
          message.withMidPriceAndTob = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.withMidPriceAndTob !== false)
      writer.tag(3, WireType.Varint).bool(message.withMidPriceAndTob);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullSpotMarketsRequest = new QueryFullSpotMarketsRequest$Type();
class QueryFullSpotMarketsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullSpotMarketsResponse", [
      { no: 1, name: "markets", kind: "message", repeat: 2, T: () => FullSpotMarket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.FullSpotMarket markets */
        1:
          message.markets.push(FullSpotMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.markets.length; i++)
      FullSpotMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullSpotMarketsResponse = new QueryFullSpotMarketsResponse$Type();
class QueryFullSpotMarketRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullSpotMarketRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "with_mid_price_and_tob",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.withMidPriceAndTob = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool with_mid_price_and_tob */
        2:
          message.withMidPriceAndTob = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.withMidPriceAndTob !== false)
      writer.tag(2, WireType.Varint).bool(message.withMidPriceAndTob);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullSpotMarketRequest = new QueryFullSpotMarketRequest$Type();
class QueryFullSpotMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullSpotMarketResponse", [
      { no: 1, name: "market", kind: "message", T: () => FullSpotMarket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.FullSpotMarket market */
        1:
          message.market = FullSpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      FullSpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullSpotMarketResponse = new QueryFullSpotMarketResponse$Type();
class QuerySpotOrdersByHashesRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotOrdersByHashesRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.orderHashes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* repeated string order_hashes */
        3:
          message.orderHashes.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.orderHashes.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.orderHashes[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotOrdersByHashesRequest = new QuerySpotOrdersByHashesRequest$Type();
class QuerySpotOrdersByHashesResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotOrdersByHashesResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => TrimmedSpotLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders */
        1:
          message.orders.push(TrimmedSpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      TrimmedSpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotOrdersByHashesResponse = new QuerySpotOrdersByHashesResponse$Type();
class QueryTraderSpotOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderSpotOrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderSpotOrdersRequest = new QueryTraderSpotOrdersRequest$Type();
class QueryAccountAddressSpotOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAccountAddressSpotOrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.accountAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAccountAddressSpotOrdersRequest = new QueryAccountAddressSpotOrdersRequest$Type();
class TrimmedSpotLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TrimmedSpotLimitOrder", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "fillable", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 4,
        name: "isBuy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.fillable = "";
    message.isBuy = false;
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* string fillable */
        3:
          message.fillable = reader.string();
          break;
        case /* bool isBuy */
        4:
          message.isBuy = reader.bool();
          break;
        case /* string order_hash */
        5:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        6:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.fillable !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.fillable);
    if (message.isBuy !== false)
      writer.tag(4, WireType.Varint).bool(message.isBuy);
    if (message.orderHash !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TrimmedSpotLimitOrder = new TrimmedSpotLimitOrder$Type();
class QueryTraderSpotOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderSpotOrdersResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => TrimmedSpotLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders */
        1:
          message.orders.push(TrimmedSpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      TrimmedSpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderSpotOrdersResponse = new QueryTraderSpotOrdersResponse$Type();
class QueryAccountAddressSpotOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAccountAddressSpotOrdersResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => TrimmedSpotLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders */
        1:
          message.orders.push(TrimmedSpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      TrimmedSpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAccountAddressSpotOrdersResponse = new QueryAccountAddressSpotOrdersResponse$Type();
class QuerySpotMidPriceAndTOBRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotMidPriceAndTOBRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotMidPriceAndTOBRequest = new QuerySpotMidPriceAndTOBRequest$Type();
class QuerySpotMidPriceAndTOBResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySpotMidPriceAndTOBResponse", [
      { no: 1, name: "mid_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "best_buy_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "best_sell_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.midPrice = "";
    message.bestBuyPrice = "";
    message.bestSellPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string mid_price */
        1:
          message.midPrice = reader.string();
          break;
        case /* string best_buy_price */
        2:
          message.bestBuyPrice = reader.string();
          break;
        case /* string best_sell_price */
        3:
          message.bestSellPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.midPrice !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
    if (message.bestBuyPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
    if (message.bestSellPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySpotMidPriceAndTOBResponse = new QuerySpotMidPriceAndTOBResponse$Type();
class QueryDerivativeMidPriceAndTOBRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMidPriceAndTOBRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMidPriceAndTOBRequest = new QueryDerivativeMidPriceAndTOBRequest$Type();
class QueryDerivativeMidPriceAndTOBResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMidPriceAndTOBResponse", [
      { no: 1, name: "mid_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "best_buy_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "best_sell_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.midPrice = "";
    message.bestBuyPrice = "";
    message.bestSellPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string mid_price */
        1:
          message.midPrice = reader.string();
          break;
        case /* string best_buy_price */
        2:
          message.bestBuyPrice = reader.string();
          break;
        case /* string best_sell_price */
        3:
          message.bestSellPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.midPrice !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
    if (message.bestBuyPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
    if (message.bestSellPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMidPriceAndTOBResponse = new QueryDerivativeMidPriceAndTOBResponse$Type();
class QueryDerivativeOrderbookRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeOrderbookRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "limit_cumulative_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.limit = 0n;
    message.limitCumulativeNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* uint64 limit */
        2:
          message.limit = reader.uint64().toBigInt();
          break;
        case /* string limit_cumulative_notional */
        3:
          message.limitCumulativeNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.limit !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.limit);
    if (message.limitCumulativeNotional !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.limitCumulativeNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeOrderbookRequest = new QueryDerivativeOrderbookRequest$Type();
class QueryDerivativeOrderbookResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeOrderbookResponse", [
      { no: 1, name: "buys_price_level", kind: "message", repeat: 2, T: () => Level },
      { no: 2, name: "sells_price_level", kind: "message", repeat: 2, T: () => Level },
      {
        no: 3,
        name: "seq",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.buysPriceLevel = [];
    message.sellsPriceLevel = [];
    message.seq = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.Level buys_price_level */
        1:
          message.buysPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.Level sells_price_level */
        2:
          message.sellsPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 seq */
        3:
          message.seq = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.buysPriceLevel.length; i++)
      Level.internalBinaryWrite(message.buysPriceLevel[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellsPriceLevel.length; i++)
      Level.internalBinaryWrite(message.sellsPriceLevel[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.seq !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.seq);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeOrderbookResponse = new QueryDerivativeOrderbookResponse$Type();
class QueryTraderSpotOrdersToCancelUpToAmountRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderSpotOrdersToCancelUpToAmountRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "base_amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "quote_amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "strategy", kind: "enum", T: () => ["injective.exchange.v2.CancellationStrategy", CancellationStrategy] },
      { no: 6, name: "reference_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.baseAmount = "";
    message.quoteAmount = "";
    message.strategy = 0;
    message.referencePrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string base_amount */
        3:
          message.baseAmount = reader.string();
          break;
        case /* string quote_amount */
        4:
          message.quoteAmount = reader.string();
          break;
        case /* injective.exchange.v2.CancellationStrategy strategy */
        5:
          message.strategy = reader.int32();
          break;
        case /* string reference_price */
        6:
          message.referencePrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.baseAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.baseAmount);
    if (message.quoteAmount !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quoteAmount);
    if (message.strategy !== 0)
      writer.tag(5, WireType.Varint).int32(message.strategy);
    if (message.referencePrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.referencePrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderSpotOrdersToCancelUpToAmountRequest = new QueryTraderSpotOrdersToCancelUpToAmountRequest$Type();
class QueryTraderDerivativeOrdersToCancelUpToAmountRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderDerivativeOrdersToCancelUpToAmountRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "quote_amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "strategy", kind: "enum", T: () => ["injective.exchange.v2.CancellationStrategy", CancellationStrategy] },
      { no: 5, name: "reference_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.quoteAmount = "";
    message.strategy = 0;
    message.referencePrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string quote_amount */
        3:
          message.quoteAmount = reader.string();
          break;
        case /* injective.exchange.v2.CancellationStrategy strategy */
        4:
          message.strategy = reader.int32();
          break;
        case /* string reference_price */
        5:
          message.referencePrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.quoteAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quoteAmount);
    if (message.strategy !== 0)
      writer.tag(4, WireType.Varint).int32(message.strategy);
    if (message.referencePrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.referencePrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderDerivativeOrdersToCancelUpToAmountRequest = new QueryTraderDerivativeOrdersToCancelUpToAmountRequest$Type();
class QueryTraderDerivativeOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderDerivativeOrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderDerivativeOrdersRequest = new QueryTraderDerivativeOrdersRequest$Type();
class QueryAccountAddressDerivativeOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAccountAddressDerivativeOrdersRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.accountAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAccountAddressDerivativeOrdersRequest = new QueryAccountAddressDerivativeOrdersRequest$Type();
class TrimmedDerivativeLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TrimmedDerivativeLimitOrder", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "fillable", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "isBuy", kind: "scalar", T: 8, options: { "gogoproto.jsontag": "isBuy" } },
      {
        no: 6,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.margin = "";
    message.fillable = "";
    message.isBuy = false;
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* string margin */
        3:
          message.margin = reader.string();
          break;
        case /* string fillable */
        4:
          message.fillable = reader.string();
          break;
        case /* bool isBuy */
        5:
          message.isBuy = reader.bool();
          break;
        case /* string order_hash */
        6:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        7:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.margin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.margin);
    if (message.fillable !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fillable);
    if (message.isBuy !== false)
      writer.tag(5, WireType.Varint).bool(message.isBuy);
    if (message.orderHash !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TrimmedDerivativeLimitOrder = new TrimmedDerivativeLimitOrder$Type();
class QueryTraderDerivativeOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderDerivativeOrdersResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => TrimmedDerivativeLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders */
        1:
          message.orders.push(TrimmedDerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      TrimmedDerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderDerivativeOrdersResponse = new QueryTraderDerivativeOrdersResponse$Type();
class QueryAccountAddressDerivativeOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryAccountAddressDerivativeOrdersResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => TrimmedDerivativeLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders */
        1:
          message.orders.push(TrimmedDerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      TrimmedDerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAccountAddressDerivativeOrdersResponse = new QueryAccountAddressDerivativeOrdersResponse$Type();
class QueryDerivativeOrdersByHashesRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeOrdersByHashesRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.orderHashes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* repeated string order_hashes */
        3:
          message.orderHashes.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.orderHashes.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.orderHashes[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeOrdersByHashesRequest = new QueryDerivativeOrdersByHashesRequest$Type();
class QueryDerivativeOrdersByHashesResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeOrdersByHashesResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => TrimmedDerivativeLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders */
        1:
          message.orders.push(TrimmedDerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      TrimmedDerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeOrdersByHashesResponse = new QueryDerivativeOrdersByHashesResponse$Type();
class QueryDerivativeMarketsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMarketsRequest", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "with_mid_price_and_tob",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    message.marketIds = [];
    message.withMidPriceAndTob = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        case /* repeated string market_ids */
        2:
          message.marketIds.push(reader.string());
          break;
        case /* bool with_mid_price_and_tob */
        3:
          message.withMidPriceAndTob = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
    if (message.withMidPriceAndTob !== false)
      writer.tag(3, WireType.Varint).bool(message.withMidPriceAndTob);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMarketsRequest = new QueryDerivativeMarketsRequest$Type();
class PriceLevel$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PriceLevel", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceLevel = new PriceLevel$Type();
class PerpetualMarketState$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PerpetualMarketState", [
      { no: 1, name: "market_info", kind: "message", T: () => PerpetualMarketInfo },
      { no: 2, name: "funding_info", kind: "message", T: () => PerpetualMarketFunding }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.PerpetualMarketInfo market_info */
        1:
          message.marketInfo = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.marketInfo);
          break;
        case /* injective.exchange.v2.PerpetualMarketFunding funding_info */
        2:
          message.fundingInfo = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.fundingInfo);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketInfo)
      PerpetualMarketInfo.internalBinaryWrite(message.marketInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.fundingInfo)
      PerpetualMarketFunding.internalBinaryWrite(message.fundingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketState = new PerpetualMarketState$Type();
class FullDerivativeMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.FullDerivativeMarket", [
      { no: 1, name: "market", kind: "message", T: () => DerivativeMarket },
      { no: 2, name: "perpetual_info", kind: "message", oneof: "info", T: () => PerpetualMarketState },
      { no: 3, name: "futures_info", kind: "message", oneof: "info", T: () => ExpiryFuturesMarketInfo },
      { no: 4, name: "mark_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "mid_price_and_tob", kind: "message", T: () => MidPriceAndTOB, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.info = { oneofKind: void 0 };
    message.markPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.DerivativeMarket market */
        1:
          message.market = DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        case /* injective.exchange.v2.PerpetualMarketState perpetual_info */
        2:
          message.info = {
            oneofKind: "perpetualInfo",
            perpetualInfo: PerpetualMarketState.internalBinaryRead(reader, reader.uint32(), options, message.info.perpetualInfo)
          };
          break;
        case /* injective.exchange.v2.ExpiryFuturesMarketInfo futures_info */
        3:
          message.info = {
            oneofKind: "futuresInfo",
            futuresInfo: ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.info.futuresInfo)
          };
          break;
        case /* string mark_price */
        4:
          message.markPrice = reader.string();
          break;
        case /* injective.exchange.v2.MidPriceAndTOB mid_price_and_tob */
        5:
          message.midPriceAndTob = MidPriceAndTOB.internalBinaryRead(reader, reader.uint32(), options, message.midPriceAndTob);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      DerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.info.oneofKind === "perpetualInfo")
      PerpetualMarketState.internalBinaryWrite(message.info.perpetualInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.info.oneofKind === "futuresInfo")
      ExpiryFuturesMarketInfo.internalBinaryWrite(message.info.futuresInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.markPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.markPrice);
    if (message.midPriceAndTob)
      MidPriceAndTOB.internalBinaryWrite(message.midPriceAndTob, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FullDerivativeMarket = new FullDerivativeMarket$Type();
class QueryDerivativeMarketsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMarketsResponse", [
      { no: 1, name: "markets", kind: "message", repeat: 2, T: () => FullDerivativeMarket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.FullDerivativeMarket markets */
        1:
          message.markets.push(FullDerivativeMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.markets.length; i++)
      FullDerivativeMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMarketsResponse = new QueryDerivativeMarketsResponse$Type();
class QueryDerivativeMarketRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMarketRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMarketRequest = new QueryDerivativeMarketRequest$Type();
class QueryDerivativeMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMarketResponse", [
      { no: 1, name: "market", kind: "message", T: () => FullDerivativeMarket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.FullDerivativeMarket market */
        1:
          message.market = FullDerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      FullDerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMarketResponse = new QueryDerivativeMarketResponse$Type();
class QueryDerivativeMarketAddressRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMarketAddressRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMarketAddressRequest = new QueryDerivativeMarketAddressRequest$Type();
class QueryDerivativeMarketAddressResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDerivativeMarketAddressResponse", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDerivativeMarketAddressResponse = new QueryDerivativeMarketAddressResponse$Type();
class QuerySubaccountTradeNonceRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountTradeNonceRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountTradeNonceRequest = new QuerySubaccountTradeNonceRequest$Type();
class QueryPositionsInMarketRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPositionsInMarketRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPositionsInMarketRequest = new QueryPositionsInMarketRequest$Type();
class QueryPositionsInMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPositionsInMarketResponse", [
      { no: 1, name: "state", kind: "message", repeat: 2, T: () => DerivativePosition, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.state = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.DerivativePosition state */
        1:
          message.state.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.state.length; i++)
      DerivativePosition.internalBinaryWrite(message.state[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPositionsInMarketResponse = new QueryPositionsInMarketResponse$Type();
class QuerySubaccountPositionsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountPositionsRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountPositionsRequest = new QuerySubaccountPositionsRequest$Type();
class QuerySubaccountPositionInMarketRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountPositionInMarketRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountPositionInMarketRequest = new QuerySubaccountPositionInMarketRequest$Type();
class QuerySubaccountEffectivePositionInMarketRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountEffectivePositionInMarketRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountEffectivePositionInMarketRequest = new QuerySubaccountEffectivePositionInMarketRequest$Type();
class QuerySubaccountOrderMetadataRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountOrderMetadataRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountOrderMetadataRequest = new QuerySubaccountOrderMetadataRequest$Type();
class QuerySubaccountPositionsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountPositionsResponse", [
      { no: 1, name: "state", kind: "message", repeat: 2, T: () => DerivativePosition, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.state = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.DerivativePosition state */
        1:
          message.state.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.state.length; i++)
      DerivativePosition.internalBinaryWrite(message.state[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountPositionsResponse = new QuerySubaccountPositionsResponse$Type();
class QuerySubaccountPositionInMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountPositionInMarketResponse", [
      { no: 1, name: "state", kind: "message", T: () => Position, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.Position state */
        1:
          message.state = Position.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state)
      Position.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountPositionInMarketResponse = new QuerySubaccountPositionInMarketResponse$Type();
class EffectivePosition$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EffectivePosition", [
      {
        no: 1,
        name: "is_long",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "entry_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "effective_margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.isLong = false;
    message.quantity = "";
    message.entryPrice = "";
    message.effectiveMargin = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool is_long */
        1:
          message.isLong = reader.bool();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        3:
          message.entryPrice = reader.string();
          break;
        case /* string effective_margin */
        4:
          message.effectiveMargin = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.isLong !== false)
      writer.tag(1, WireType.Varint).bool(message.isLong);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.entryPrice);
    if (message.effectiveMargin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.effectiveMargin);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EffectivePosition = new EffectivePosition$Type();
class QuerySubaccountEffectivePositionInMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountEffectivePositionInMarketResponse", [
      { no: 1, name: "state", kind: "message", T: () => EffectivePosition, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.EffectivePosition state */
        1:
          message.state = EffectivePosition.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state)
      EffectivePosition.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountEffectivePositionInMarketResponse = new QuerySubaccountEffectivePositionInMarketResponse$Type();
class QueryPerpetualMarketInfoRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPerpetualMarketInfoRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPerpetualMarketInfoRequest = new QueryPerpetualMarketInfoRequest$Type();
class QueryPerpetualMarketInfoResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPerpetualMarketInfoResponse", [
      { no: 1, name: "info", kind: "message", T: () => PerpetualMarketInfo, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.PerpetualMarketInfo info */
        1:
          message.info = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.info)
      PerpetualMarketInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPerpetualMarketInfoResponse = new QueryPerpetualMarketInfoResponse$Type();
class QueryExpiryFuturesMarketInfoRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryExpiryFuturesMarketInfoRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryExpiryFuturesMarketInfoRequest = new QueryExpiryFuturesMarketInfoRequest$Type();
class QueryExpiryFuturesMarketInfoResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryExpiryFuturesMarketInfoResponse", [
      { no: 1, name: "info", kind: "message", T: () => ExpiryFuturesMarketInfo, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.ExpiryFuturesMarketInfo info */
        1:
          message.info = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.info)
      ExpiryFuturesMarketInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryExpiryFuturesMarketInfoResponse = new QueryExpiryFuturesMarketInfoResponse$Type();
class QueryPerpetualMarketFundingRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPerpetualMarketFundingRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPerpetualMarketFundingRequest = new QueryPerpetualMarketFundingRequest$Type();
class QueryPerpetualMarketFundingResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPerpetualMarketFundingResponse", [
      { no: 1, name: "state", kind: "message", T: () => PerpetualMarketFunding, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.PerpetualMarketFunding state */
        1:
          message.state = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state)
      PerpetualMarketFunding.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPerpetualMarketFundingResponse = new QueryPerpetualMarketFundingResponse$Type();
class QuerySubaccountOrderMetadataResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountOrderMetadataResponse", [
      { no: 1, name: "metadata", kind: "message", repeat: 2, T: () => SubaccountOrderbookMetadataWithMarket, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.metadata = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.SubaccountOrderbookMetadataWithMarket metadata */
        1:
          message.metadata.push(SubaccountOrderbookMetadataWithMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.metadata.length; i++)
      SubaccountOrderbookMetadataWithMarket.internalBinaryWrite(message.metadata[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountOrderMetadataResponse = new QuerySubaccountOrderMetadataResponse$Type();
class QuerySubaccountTradeNonceResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QuerySubaccountTradeNonceResponse", [
      {
        no: 1,
        name: "nonce",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.nonce = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 nonce */
        1:
          message.nonce = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.nonce !== 0)
      writer.tag(1, WireType.Varint).uint32(message.nonce);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuerySubaccountTradeNonceResponse = new QuerySubaccountTradeNonceResponse$Type();
class QueryModuleStateRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryModuleStateRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryModuleStateRequest = new QueryModuleStateRequest$Type();
class QueryModuleStateResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryModuleStateResponse", [
      { no: 1, name: "state", kind: "message", T: () => GenesisState }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.GenesisState state */
        1:
          message.state = GenesisState.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state)
      GenesisState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryModuleStateResponse = new QueryModuleStateResponse$Type();
class QueryPositionsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPositionsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPositionsRequest = new QueryPositionsRequest$Type();
class QueryPositionsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryPositionsResponse", [
      { no: 1, name: "state", kind: "message", repeat: 2, T: () => DerivativePosition, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.state = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.DerivativePosition state */
        1:
          message.state.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.state.length; i++)
      DerivativePosition.internalBinaryWrite(message.state[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPositionsResponse = new QueryPositionsResponse$Type();
class QueryTradeRewardPointsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTradeRewardPointsRequest", [
      {
        no: 1,
        name: "accounts",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pending_pool_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accounts = [];
    message.pendingPoolTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string accounts */
        1:
          message.accounts.push(reader.string());
          break;
        case /* int64 pending_pool_timestamp */
        2:
          message.pendingPoolTimestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accounts.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
    if (message.pendingPoolTimestamp !== 0n)
      writer.tag(2, WireType.Varint).int64(message.pendingPoolTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTradeRewardPointsRequest = new QueryTradeRewardPointsRequest$Type();
class QueryTradeRewardPointsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTradeRewardPointsResponse", [
      { no: 1, name: "account_trade_reward_points", kind: "scalar", repeat: 2, T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountTradeRewardPoints = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string account_trade_reward_points */
        1:
          message.accountTradeRewardPoints.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accountTradeRewardPoints.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accountTradeRewardPoints[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTradeRewardPointsResponse = new QueryTradeRewardPointsResponse$Type();
class QueryTradeRewardCampaignRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTradeRewardCampaignRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTradeRewardCampaignRequest = new QueryTradeRewardCampaignRequest$Type();
class QueryTradeRewardCampaignResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTradeRewardCampaignResponse", [
      { no: 1, name: "trading_reward_campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
      { no: 2, name: "trading_reward_pool_campaign_schedule", kind: "message", repeat: 2, T: () => CampaignRewardPool },
      { no: 3, name: "total_trade_reward_points", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "pending_trading_reward_pool_campaign_schedule", kind: "message", repeat: 2, T: () => CampaignRewardPool },
      { no: 5, name: "pending_total_trade_reward_points", kind: "scalar", repeat: 2, T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tradingRewardPoolCampaignSchedule = [];
    message.totalTradeRewardPoints = "";
    message.pendingTradingRewardPoolCampaignSchedule = [];
    message.pendingTotalTradeRewardPoints = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info */
        1:
          message.tradingRewardCampaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardCampaignInfo);
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule */
        2:
          message.tradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string total_trade_reward_points */
        3:
          message.totalTradeRewardPoints = reader.string();
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule */
        4:
          message.pendingTradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string pending_total_trade_reward_points */
        5:
          message.pendingTotalTradeRewardPoints.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tradingRewardCampaignInfo)
      TradingRewardCampaignInfo.internalBinaryWrite(message.tradingRewardCampaignInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.tradingRewardPoolCampaignSchedule.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.tradingRewardPoolCampaignSchedule[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.totalTradeRewardPoints !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.totalTradeRewardPoints);
    for (let i = 0; i < message.pendingTradingRewardPoolCampaignSchedule.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.pendingTradingRewardPoolCampaignSchedule[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.pendingTotalTradeRewardPoints.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.pendingTotalTradeRewardPoints[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTradeRewardCampaignResponse = new QueryTradeRewardCampaignResponse$Type();
class QueryIsOptedOutOfRewardsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryIsOptedOutOfRewardsRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryIsOptedOutOfRewardsRequest = new QueryIsOptedOutOfRewardsRequest$Type();
class QueryIsOptedOutOfRewardsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryIsOptedOutOfRewardsResponse", [
      {
        no: 1,
        name: "is_opted_out",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.isOptedOut = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool is_opted_out */
        1:
          message.isOptedOut = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.isOptedOut !== false)
      writer.tag(1, WireType.Varint).bool(message.isOptedOut);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryIsOptedOutOfRewardsResponse = new QueryIsOptedOutOfRewardsResponse$Type();
class QueryOptedOutOfRewardsAccountsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryOptedOutOfRewardsAccountsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryOptedOutOfRewardsAccountsRequest = new QueryOptedOutOfRewardsAccountsRequest$Type();
class QueryOptedOutOfRewardsAccountsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryOptedOutOfRewardsAccountsResponse", [
      {
        no: 1,
        name: "accounts",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accounts = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string accounts */
        1:
          message.accounts.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accounts.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryOptedOutOfRewardsAccountsResponse = new QueryOptedOutOfRewardsAccountsResponse$Type();
class QueryFeeDiscountAccountInfoRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFeeDiscountAccountInfoRequest", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFeeDiscountAccountInfoRequest = new QueryFeeDiscountAccountInfoRequest$Type();
class QueryFeeDiscountAccountInfoResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFeeDiscountAccountInfoResponse", [
      {
        no: 1,
        name: "tier_level",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "account_info", kind: "message", T: () => FeeDiscountTierInfo },
      { no: 3, name: "account_ttl", kind: "message", T: () => FeeDiscountTierTTL }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tierLevel = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 tier_level */
        1:
          message.tierLevel = reader.uint64().toBigInt();
          break;
        case /* injective.exchange.v2.FeeDiscountTierInfo account_info */
        2:
          message.accountInfo = FeeDiscountTierInfo.internalBinaryRead(reader, reader.uint32(), options, message.accountInfo);
          break;
        case /* injective.exchange.v2.FeeDiscountTierTTL account_ttl */
        3:
          message.accountTtl = FeeDiscountTierTTL.internalBinaryRead(reader, reader.uint32(), options, message.accountTtl);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tierLevel !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.tierLevel);
    if (message.accountInfo)
      FeeDiscountTierInfo.internalBinaryWrite(message.accountInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.accountTtl)
      FeeDiscountTierTTL.internalBinaryWrite(message.accountTtl, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFeeDiscountAccountInfoResponse = new QueryFeeDiscountAccountInfoResponse$Type();
class QueryFeeDiscountScheduleRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFeeDiscountScheduleRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFeeDiscountScheduleRequest = new QueryFeeDiscountScheduleRequest$Type();
class QueryFeeDiscountScheduleResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFeeDiscountScheduleResponse", [
      { no: 1, name: "fee_discount_schedule", kind: "message", T: () => FeeDiscountSchedule }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule */
        1:
          message.feeDiscountSchedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.feeDiscountSchedule);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feeDiscountSchedule)
      FeeDiscountSchedule.internalBinaryWrite(message.feeDiscountSchedule, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFeeDiscountScheduleResponse = new QueryFeeDiscountScheduleResponse$Type();
class QueryBalanceMismatchesRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryBalanceMismatchesRequest", [
      {
        no: 1,
        name: "dust_factor",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.dustFactor = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 dust_factor */
        1:
          message.dustFactor = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.dustFactor !== 0n)
      writer.tag(1, WireType.Varint).int64(message.dustFactor);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceMismatchesRequest = new QueryBalanceMismatchesRequest$Type();
class BalanceMismatch$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.BalanceMismatch", [
      {
        no: 1,
        name: "subaccountId",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "available", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "total", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "balance_hold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "expected_total", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "difference", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denom = "";
    message.available = "";
    message.total = "";
    message.balanceHold = "";
    message.expectedTotal = "";
    message.difference = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccountId */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        case /* string available */
        3:
          message.available = reader.string();
          break;
        case /* string total */
        4:
          message.total = reader.string();
          break;
        case /* string balance_hold */
        5:
          message.balanceHold = reader.string();
          break;
        case /* string expected_total */
        6:
          message.expectedTotal = reader.string();
          break;
        case /* string difference */
        7:
          message.difference = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    if (message.available !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.available);
    if (message.total !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.total);
    if (message.balanceHold !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.balanceHold);
    if (message.expectedTotal !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.expectedTotal);
    if (message.difference !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.difference);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BalanceMismatch = new BalanceMismatch$Type();
class QueryBalanceMismatchesResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryBalanceMismatchesResponse", [
      { no: 1, name: "balance_mismatches", kind: "message", repeat: 2, T: () => BalanceMismatch }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balanceMismatches = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.BalanceMismatch balance_mismatches */
        1:
          message.balanceMismatches.push(BalanceMismatch.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balanceMismatches.length; i++)
      BalanceMismatch.internalBinaryWrite(message.balanceMismatches[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceMismatchesResponse = new QueryBalanceMismatchesResponse$Type();
class QueryBalanceWithBalanceHoldsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryBalanceWithBalanceHoldsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceWithBalanceHoldsRequest = new QueryBalanceWithBalanceHoldsRequest$Type();
class BalanceWithMarginHold$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.BalanceWithMarginHold", [
      {
        no: 1,
        name: "subaccountId",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "available", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "total", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "balance_hold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.denom = "";
    message.available = "";
    message.total = "";
    message.balanceHold = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccountId */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        case /* string available */
        3:
          message.available = reader.string();
          break;
        case /* string total */
        4:
          message.total = reader.string();
          break;
        case /* string balance_hold */
        5:
          message.balanceHold = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    if (message.available !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.available);
    if (message.total !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.total);
    if (message.balanceHold !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.balanceHold);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BalanceWithMarginHold = new BalanceWithMarginHold$Type();
class QueryBalanceWithBalanceHoldsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryBalanceWithBalanceHoldsResponse", [
      { no: 1, name: "balance_with_balance_holds", kind: "message", repeat: 2, T: () => BalanceWithMarginHold }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balanceWithBalanceHolds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.BalanceWithMarginHold balance_with_balance_holds */
        1:
          message.balanceWithBalanceHolds.push(BalanceWithMarginHold.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balanceWithBalanceHolds.length; i++)
      BalanceWithMarginHold.internalBinaryWrite(message.balanceWithBalanceHolds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceWithBalanceHoldsResponse = new QueryBalanceWithBalanceHoldsResponse$Type();
class QueryFeeDiscountTierStatisticsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFeeDiscountTierStatisticsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFeeDiscountTierStatisticsRequest = new QueryFeeDiscountTierStatisticsRequest$Type();
class TierStatistic$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TierStatistic", [
      {
        no: 1,
        name: "tier",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tier = 0n;
    message.count = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 tier */
        1:
          message.tier = reader.uint64().toBigInt();
          break;
        case /* uint64 count */
        2:
          message.count = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tier !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.tier);
    if (message.count !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.count);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TierStatistic = new TierStatistic$Type();
class QueryFeeDiscountTierStatisticsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFeeDiscountTierStatisticsResponse", [
      { no: 1, name: "statistics", kind: "message", repeat: 2, T: () => TierStatistic }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.statistics = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TierStatistic statistics */
        1:
          message.statistics.push(TierStatistic.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.statistics.length; i++)
      TierStatistic.internalBinaryWrite(message.statistics[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFeeDiscountTierStatisticsResponse = new QueryFeeDiscountTierStatisticsResponse$Type();
class MitoVaultInfosRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MitoVaultInfosRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MitoVaultInfosRequest = new MitoVaultInfosRequest$Type();
class MitoVaultInfosResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MitoVaultInfosResponse", [
      {
        no: 1,
        name: "master_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "derivative_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "spot_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "cw20_addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.masterAddresses = [];
    message.derivativeAddresses = [];
    message.spotAddresses = [];
    message.cw20Addresses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string master_addresses */
        1:
          message.masterAddresses.push(reader.string());
          break;
        case /* repeated string derivative_addresses */
        2:
          message.derivativeAddresses.push(reader.string());
          break;
        case /* repeated string spot_addresses */
        3:
          message.spotAddresses.push(reader.string());
          break;
        case /* repeated string cw20_addresses */
        4:
          message.cw20Addresses.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.masterAddresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.masterAddresses[i]);
    for (let i = 0; i < message.derivativeAddresses.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.derivativeAddresses[i]);
    for (let i = 0; i < message.spotAddresses.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.spotAddresses[i]);
    for (let i = 0; i < message.cw20Addresses.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.cw20Addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MitoVaultInfosResponse = new MitoVaultInfosResponse$Type();
class QueryMarketIDFromVaultRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketIDFromVaultRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketIDFromVaultRequest = new QueryMarketIDFromVaultRequest$Type();
class QueryMarketIDFromVaultResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketIDFromVaultResponse", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketIDFromVaultResponse = new QueryMarketIDFromVaultResponse$Type();
class QueryHistoricalTradeRecordsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryHistoricalTradeRecordsRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryHistoricalTradeRecordsRequest = new QueryHistoricalTradeRecordsRequest$Type();
class QueryHistoricalTradeRecordsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryHistoricalTradeRecordsResponse", [
      { no: 1, name: "trade_records", kind: "message", repeat: 2, T: () => TradeRecords }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tradeRecords = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TradeRecords trade_records */
        1:
          message.tradeRecords.push(TradeRecords.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.tradeRecords.length; i++)
      TradeRecords.internalBinaryWrite(message.tradeRecords[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryHistoricalTradeRecordsResponse = new QueryHistoricalTradeRecordsResponse$Type();
class TradeHistoryOptions$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TradeHistoryOptions", [
      {
        no: 1,
        name: "trade_grouping_sec",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "max_age",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "include_raw_history",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "include_metadata",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tradeGroupingSec = 0n;
    message.maxAge = 0n;
    message.includeRawHistory = false;
    message.includeMetadata = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 trade_grouping_sec */
        1:
          message.tradeGroupingSec = reader.uint64().toBigInt();
          break;
        case /* uint64 max_age */
        2:
          message.maxAge = reader.uint64().toBigInt();
          break;
        case /* bool include_raw_history */
        4:
          message.includeRawHistory = reader.bool();
          break;
        case /* bool include_metadata */
        5:
          message.includeMetadata = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tradeGroupingSec !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.tradeGroupingSec);
    if (message.maxAge !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.maxAge);
    if (message.includeRawHistory !== false)
      writer.tag(4, WireType.Varint).bool(message.includeRawHistory);
    if (message.includeMetadata !== false)
      writer.tag(5, WireType.Varint).bool(message.includeMetadata);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeHistoryOptions = new TradeHistoryOptions$Type();
class QueryMarketVolatilityRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketVolatilityRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "trade_history_options", kind: "message", T: () => TradeHistoryOptions }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.TradeHistoryOptions trade_history_options */
        2:
          message.tradeHistoryOptions = TradeHistoryOptions.internalBinaryRead(reader, reader.uint32(), options, message.tradeHistoryOptions);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.tradeHistoryOptions)
      TradeHistoryOptions.internalBinaryWrite(message.tradeHistoryOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketVolatilityRequest = new QueryMarketVolatilityRequest$Type();
class QueryMarketVolatilityResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketVolatilityResponse", [
      { no: 1, name: "volatility", kind: "scalar", T: 9, options: { "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "history_metadata", kind: "message", T: () => MetadataStatistics },
      { no: 3, name: "raw_history", kind: "message", repeat: 2, T: () => TradeRecord }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.volatility = "";
    message.rawHistory = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string volatility */
        1:
          message.volatility = reader.string();
          break;
        case /* injective.oracle.v1beta1.MetadataStatistics history_metadata */
        2:
          message.historyMetadata = MetadataStatistics.internalBinaryRead(reader, reader.uint32(), options, message.historyMetadata);
          break;
        case /* repeated injective.exchange.v2.TradeRecord raw_history */
        3:
          message.rawHistory.push(TradeRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.volatility !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.volatility);
    if (message.historyMetadata)
      MetadataStatistics.internalBinaryWrite(message.historyMetadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.rawHistory.length; i++)
      TradeRecord.internalBinaryWrite(message.rawHistory[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketVolatilityResponse = new QueryMarketVolatilityResponse$Type();
class QueryBinaryMarketsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryBinaryMarketsRequest", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBinaryMarketsRequest = new QueryBinaryMarketsRequest$Type();
class QueryBinaryMarketsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryBinaryMarketsResponse", [
      { no: 1, name: "markets", kind: "message", repeat: 2, T: () => BinaryOptionsMarket }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.markets = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.BinaryOptionsMarket markets */
        1:
          message.markets.push(BinaryOptionsMarket.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.markets.length; i++)
      BinaryOptionsMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBinaryMarketsResponse = new QueryBinaryMarketsResponse$Type();
class QueryTraderDerivativeConditionalOrdersRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderDerivativeConditionalOrdersRequest", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderDerivativeConditionalOrdersRequest = new QueryTraderDerivativeConditionalOrdersRequest$Type();
class TrimmedDerivativeConditionalOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TrimmedDerivativeConditionalOrder", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "triggerPrice", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "isBuy", kind: "scalar", T: 8, options: { "gogoproto.jsontag": "isBuy" } },
      { no: 6, name: "isLimit", kind: "scalar", T: 8, options: { "gogoproto.jsontag": "isLimit" } },
      {
        no: 7,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.margin = "";
    message.triggerPrice = "";
    message.isBuy = false;
    message.isLimit = false;
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* string margin */
        3:
          message.margin = reader.string();
          break;
        case /* string triggerPrice */
        4:
          message.triggerPrice = reader.string();
          break;
        case /* bool isBuy */
        5:
          message.isBuy = reader.bool();
          break;
        case /* bool isLimit */
        6:
          message.isLimit = reader.bool();
          break;
        case /* string order_hash */
        7:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        8:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.margin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.margin);
    if (message.triggerPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.isBuy !== false)
      writer.tag(5, WireType.Varint).bool(message.isBuy);
    if (message.isLimit !== false)
      writer.tag(6, WireType.Varint).bool(message.isLimit);
    if (message.orderHash !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TrimmedDerivativeConditionalOrder = new TrimmedDerivativeConditionalOrder$Type();
class QueryTraderDerivativeConditionalOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryTraderDerivativeConditionalOrdersResponse", [
      { no: 1, name: "orders", kind: "message", repeat: 2, T: () => TrimmedDerivativeConditionalOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedDerivativeConditionalOrder orders */
        1:
          message.orders.push(TrimmedDerivativeConditionalOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orders.length; i++)
      TrimmedDerivativeConditionalOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraderDerivativeConditionalOrdersResponse = new QueryTraderDerivativeConditionalOrdersResponse$Type();
class QueryFullSpotOrderbookRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullSpotOrderbookRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullSpotOrderbookRequest = new QueryFullSpotOrderbookRequest$Type();
class QueryFullSpotOrderbookResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullSpotOrderbookResponse", [
      { no: 1, name: "Bids", kind: "message", jsonName: "Bids", repeat: 2, T: () => TrimmedLimitOrder },
      { no: 2, name: "Asks", kind: "message", jsonName: "Asks", repeat: 2, T: () => TrimmedLimitOrder },
      {
        no: 3,
        name: "seq",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bids = [];
    message.asks = [];
    message.seq = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedLimitOrder Bids */
        1:
          message.bids.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.TrimmedLimitOrder Asks */
        2:
          message.asks.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 seq */
        3:
          message.seq = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.bids.length; i++)
      TrimmedLimitOrder.internalBinaryWrite(message.bids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.asks.length; i++)
      TrimmedLimitOrder.internalBinaryWrite(message.asks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.seq !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.seq);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullSpotOrderbookResponse = new QueryFullSpotOrderbookResponse$Type();
class QueryFullDerivativeOrderbookRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullDerivativeOrderbookRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullDerivativeOrderbookRequest = new QueryFullDerivativeOrderbookRequest$Type();
class QueryFullDerivativeOrderbookResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryFullDerivativeOrderbookResponse", [
      { no: 1, name: "Bids", kind: "message", jsonName: "Bids", repeat: 2, T: () => TrimmedLimitOrder },
      { no: 2, name: "Asks", kind: "message", jsonName: "Asks", repeat: 2, T: () => TrimmedLimitOrder },
      {
        no: 3,
        name: "seq",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bids = [];
    message.asks = [];
    message.seq = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.TrimmedLimitOrder Bids */
        1:
          message.bids.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.TrimmedLimitOrder Asks */
        2:
          message.asks.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 seq */
        3:
          message.seq = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.bids.length; i++)
      TrimmedLimitOrder.internalBinaryWrite(message.bids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.asks.length; i++)
      TrimmedLimitOrder.internalBinaryWrite(message.asks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.seq !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.seq);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryFullDerivativeOrderbookResponse = new QueryFullDerivativeOrderbookResponse$Type();
class TrimmedLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.TrimmedLimitOrder", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.orderHash = "";
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* string order_hash */
        3:
          message.orderHash = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.orderHash !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.orderHash);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TrimmedLimitOrder = new TrimmedLimitOrder$Type();
class QueryMarketAtomicExecutionFeeMultiplierRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketAtomicExecutionFeeMultiplierRequest = new QueryMarketAtomicExecutionFeeMultiplierRequest$Type();
class QueryMarketAtomicExecutionFeeMultiplierResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierResponse", [
      { no: 1, name: "multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.multiplier = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string multiplier */
        1:
          message.multiplier = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.multiplier !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.multiplier);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketAtomicExecutionFeeMultiplierResponse = new QueryMarketAtomicExecutionFeeMultiplierResponse$Type();
class QueryActiveStakeGrantRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryActiveStakeGrantRequest", [
      {
        no: 1,
        name: "grantee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.grantee = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string grantee */
        1:
          message.grantee = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.grantee !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.grantee);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryActiveStakeGrantRequest = new QueryActiveStakeGrantRequest$Type();
class QueryActiveStakeGrantResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryActiveStakeGrantResponse", [
      { no: 1, name: "grant", kind: "message", T: () => ActiveGrant },
      { no: 2, name: "effective_grant", kind: "message", T: () => EffectiveGrant }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.ActiveGrant grant */
        1:
          message.grant = ActiveGrant.internalBinaryRead(reader, reader.uint32(), options, message.grant);
          break;
        case /* injective.exchange.v2.EffectiveGrant effective_grant */
        2:
          message.effectiveGrant = EffectiveGrant.internalBinaryRead(reader, reader.uint32(), options, message.effectiveGrant);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.grant)
      ActiveGrant.internalBinaryWrite(message.grant, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.effectiveGrant)
      EffectiveGrant.internalBinaryWrite(message.effectiveGrant, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryActiveStakeGrantResponse = new QueryActiveStakeGrantResponse$Type();
class QueryGrantAuthorizationRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryGrantAuthorizationRequest", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "grantee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    message.grantee = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        case /* string grantee */
        2:
          message.grantee = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    if (message.grantee !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.grantee);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryGrantAuthorizationRequest = new QueryGrantAuthorizationRequest$Type();
class QueryGrantAuthorizationResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryGrantAuthorizationResponse", [
      { no: 1, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string amount */
        1:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.amount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryGrantAuthorizationResponse = new QueryGrantAuthorizationResponse$Type();
class QueryGrantAuthorizationsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryGrantAuthorizationsRequest", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryGrantAuthorizationsRequest = new QueryGrantAuthorizationsRequest$Type();
class QueryGrantAuthorizationsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryGrantAuthorizationsResponse", [
      { no: 1, name: "total_grant_amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      { no: 2, name: "grants", kind: "message", repeat: 2, T: () => GrantAuthorization }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.totalGrantAmount = "";
    message.grants = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string total_grant_amount */
        1:
          message.totalGrantAmount = reader.string();
          break;
        case /* repeated injective.exchange.v2.GrantAuthorization grants */
        2:
          message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalGrantAmount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.totalGrantAmount);
    for (let i = 0; i < message.grants.length; i++)
      GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryGrantAuthorizationsResponse = new QueryGrantAuthorizationsResponse$Type();
class QueryMarketBalanceRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketBalanceRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketBalanceRequest = new QueryMarketBalanceRequest$Type();
class QueryMarketBalanceResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketBalanceResponse", [
      { no: 1, name: "balance", kind: "message", T: () => MarketBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.MarketBalance balance */
        1:
          message.balance = MarketBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance)
      MarketBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketBalanceResponse = new QueryMarketBalanceResponse$Type();
class QueryMarketBalancesRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketBalancesRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketBalancesRequest = new QueryMarketBalancesRequest$Type();
class QueryMarketBalancesResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryMarketBalancesResponse", [
      { no: 1, name: "balances", kind: "message", repeat: 2, T: () => MarketBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.MarketBalance balances */
        1:
          message.balances.push(MarketBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balances.length; i++)
      MarketBalance.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryMarketBalancesResponse = new QueryMarketBalancesResponse$Type();
class MarketBalance$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MarketBalance", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "balance", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.balance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string balance */
        2:
          message.balance = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.balance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.balance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketBalance = new MarketBalance$Type();
class QueryDenomMinNotionalRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDenomMinNotionalRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMinNotionalRequest = new QueryDenomMinNotionalRequest$Type();
class QueryDenomMinNotionalResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDenomMinNotionalResponse", [
      { no: 1, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string amount */
        1:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.amount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMinNotionalResponse = new QueryDenomMinNotionalResponse$Type();
class QueryDenomMinNotionalsRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDenomMinNotionalsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMinNotionalsRequest = new QueryDenomMinNotionalsRequest$Type();
class QueryDenomMinNotionalsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryDenomMinNotionalsResponse", [
      { no: 1, name: "denom_min_notionals", kind: "message", repeat: 2, T: () => DenomMinNotional }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denomMinNotionals = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals */
        1:
          message.denomMinNotionals.push(DenomMinNotional.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.denomMinNotionals.length; i++)
      DenomMinNotional.internalBinaryWrite(message.denomMinNotionals[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryDenomMinNotionalsResponse = new QueryDenomMinNotionalsResponse$Type();
class OpenInterest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OpenInterest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "balance", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.balance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string balance */
        2:
          message.balance = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.balance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.balance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenInterest = new OpenInterest$Type();
class QueryOpenInterestRequest$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryOpenInterestRequest", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryOpenInterestRequest = new QueryOpenInterestRequest$Type();
class QueryOpenInterestResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.QueryOpenInterestResponse", [
      { no: 1, name: "amount", kind: "message", T: () => OpenInterest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.OpenInterest amount */
        1:
          message.amount = OpenInterest.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.amount)
      OpenInterest.internalBinaryWrite(message.amount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryOpenInterestResponse = new QueryOpenInterestResponse$Type();
const Query = new ServiceType("injective.exchange.v2.Query", [
  { name: "L3DerivativeOrderBook", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/L3OrderBook/{market_id}" } }, I: QueryFullDerivativeOrderbookRequest, O: QueryFullDerivativeOrderbookResponse },
  { name: "L3SpotOrderBook", options: { "google.api.http": { get: "/injective/exchange/v2/spot/L3OrderBook/{market_id}" } }, I: QueryFullSpotOrderbookRequest, O: QueryFullSpotOrderbookResponse },
  { name: "QueryExchangeParams", options: { "google.api.http": { get: "/injective/exchange/v2/exchangeParams" } }, I: QueryExchangeParamsRequest, O: QueryExchangeParamsResponse },
  { name: "SubaccountDeposits", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/subaccountDeposits" } }, I: QuerySubaccountDepositsRequest, O: QuerySubaccountDepositsResponse },
  { name: "SubaccountDeposit", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/subaccountDeposit" } }, I: QuerySubaccountDepositRequest, O: QuerySubaccountDepositResponse },
  { name: "ExchangeBalances", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/exchangeBalances" } }, I: QueryExchangeBalancesRequest, O: QueryExchangeBalancesResponse },
  { name: "AggregateVolume", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateVolume/{account}" } }, I: QueryAggregateVolumeRequest, O: QueryAggregateVolumeResponse },
  { name: "AggregateVolumes", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateVolumes" } }, I: QueryAggregateVolumesRequest, O: QueryAggregateVolumesResponse },
  { name: "AggregateMarketVolume", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateMarketVolume/{market_id}" } }, I: QueryAggregateMarketVolumeRequest, O: QueryAggregateMarketVolumeResponse },
  { name: "AggregateMarketVolumes", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateMarketVolumes" } }, I: QueryAggregateMarketVolumesRequest, O: QueryAggregateMarketVolumesResponse },
  { name: "AuctionExchangeTransferDenomDecimal", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/auction_exchange_transfer_denom_decimal/{denom}" } }, I: QueryAuctionExchangeTransferDenomDecimalRequest, O: QueryAuctionExchangeTransferDenomDecimalResponse },
  { name: "AuctionExchangeTransferDenomDecimals", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/auction_exchange_transfer_denom_decimals" } }, I: QueryAuctionExchangeTransferDenomDecimalsRequest, O: QueryAuctionExchangeTransferDenomDecimalsResponse },
  { name: "SpotMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/spot/markets" } }, I: QuerySpotMarketsRequest, O: QuerySpotMarketsResponse },
  { name: "SpotMarket", options: { "google.api.http": { get: "/injective/exchange/v2/spot/markets/{market_id}" } }, I: QuerySpotMarketRequest, O: QuerySpotMarketResponse },
  { name: "FullSpotMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/spot/full_markets" } }, I: QueryFullSpotMarketsRequest, O: QueryFullSpotMarketsResponse },
  { name: "FullSpotMarket", options: { "google.api.http": { get: "/injective/exchange/v2/spot/full_market/{market_id}" } }, I: QueryFullSpotMarketRequest, O: QueryFullSpotMarketResponse },
  { name: "SpotOrderbook", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orderbook/{market_id}" } }, I: QuerySpotOrderbookRequest, O: QuerySpotOrderbookResponse },
  { name: "TraderSpotOrders", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orders/{market_id}/{subaccount_id}" } }, I: QueryTraderSpotOrdersRequest, O: QueryTraderSpotOrdersResponse },
  { name: "AccountAddressSpotOrders", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orders/{market_id}/account/{account_address}" } }, I: QueryAccountAddressSpotOrdersRequest, O: QueryAccountAddressSpotOrdersResponse },
  { name: "SpotOrdersByHashes", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orders_by_hashes/{market_id}/{subaccount_id}" } }, I: QuerySpotOrdersByHashesRequest, O: QuerySpotOrdersByHashesResponse },
  { name: "SubaccountOrders", options: { "google.api.http": { get: "/injective/exchange/v2/orders/{subaccount_id}" } }, I: QuerySubaccountOrdersRequest, O: QuerySubaccountOrdersResponse },
  { name: "TraderSpotTransientOrders", options: { "google.api.http": { get: "/injective/exchange/v2/spot/transient_orders/{market_id}/{subaccount_id}" } }, I: QueryTraderSpotOrdersRequest, O: QueryTraderSpotOrdersResponse },
  { name: "SpotMidPriceAndTOB", options: { "google.api.http": { get: "/injective/exchange/v2/spot/mid_price_and_tob/{market_id}" } }, I: QuerySpotMidPriceAndTOBRequest, O: QuerySpotMidPriceAndTOBResponse },
  { name: "DerivativeMidPriceAndTOB", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/mid_price_and_tob/{market_id}" } }, I: QueryDerivativeMidPriceAndTOBRequest, O: QueryDerivativeMidPriceAndTOBResponse },
  { name: "DerivativeOrderbook", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orderbook/{market_id}" } }, I: QueryDerivativeOrderbookRequest, O: QueryDerivativeOrderbookResponse },
  { name: "TraderDerivativeOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders/{market_id}/{subaccount_id}" } }, I: QueryTraderDerivativeOrdersRequest, O: QueryTraderDerivativeOrdersResponse },
  { name: "AccountAddressDerivativeOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders/{market_id}/account/{account_address}" } }, I: QueryAccountAddressDerivativeOrdersRequest, O: QueryAccountAddressDerivativeOrdersResponse },
  { name: "DerivativeOrdersByHashes", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders_by_hashes/{market_id}/{subaccount_id}" } }, I: QueryDerivativeOrdersByHashesRequest, O: QueryDerivativeOrdersByHashesResponse },
  { name: "TraderDerivativeTransientOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/transient_orders/{market_id}/{subaccount_id}" } }, I: QueryTraderDerivativeOrdersRequest, O: QueryTraderDerivativeOrdersResponse },
  { name: "DerivativeMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/markets" } }, I: QueryDerivativeMarketsRequest, O: QueryDerivativeMarketsResponse },
  { name: "DerivativeMarket", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/markets/{market_id}" } }, I: QueryDerivativeMarketRequest, O: QueryDerivativeMarketResponse },
  { name: "DerivativeMarketAddress", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/market_address/{market_id}" } }, I: QueryDerivativeMarketAddressRequest, O: QueryDerivativeMarketAddressResponse },
  { name: "SubaccountTradeNonce", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/{subaccount_id}" } }, I: QuerySubaccountTradeNonceRequest, O: QuerySubaccountTradeNonceResponse },
  { name: "ExchangeModuleState", options: { "google.api.http": { get: "/injective/exchange/v2/module_state" } }, I: QueryModuleStateRequest, O: QueryModuleStateResponse },
  { name: "Positions", options: { "google.api.http": { get: "/injective/exchange/v2/positions" } }, I: QueryPositionsRequest, O: QueryPositionsResponse },
  { name: "PositionsInMarket", options: { "google.api.http": { get: "/injective/exchange/v2/positions_in_market/{market_id}" } }, I: QueryPositionsInMarketRequest, O: QueryPositionsInMarketResponse },
  { name: "SubaccountPositions", options: { "google.api.http": { get: "/injective/exchange/v2/subaccount_positions/{subaccount_id}" } }, I: QuerySubaccountPositionsRequest, O: QuerySubaccountPositionsResponse },
  { name: "SubaccountPositionInMarket", options: { "google.api.http": { get: "/injective/exchange/v2/positions/{subaccount_id}/{market_id}" } }, I: QuerySubaccountPositionInMarketRequest, O: QuerySubaccountPositionInMarketResponse },
  { name: "SubaccountEffectivePositionInMarket", options: { "google.api.http": { get: "/injective/exchange/v2/effective_positions/{subaccount_id}/{market_id}" } }, I: QuerySubaccountEffectivePositionInMarketRequest, O: QuerySubaccountEffectivePositionInMarketResponse },
  { name: "PerpetualMarketInfo", options: { "google.api.http": { get: "/injective/exchange/v2/perpetual_market_info/{market_id}" } }, I: QueryPerpetualMarketInfoRequest, O: QueryPerpetualMarketInfoResponse },
  { name: "ExpiryFuturesMarketInfo", options: { "google.api.http": { get: "/injective/exchange/v2/expiry_market_info/{market_id}" } }, I: QueryExpiryFuturesMarketInfoRequest, O: QueryExpiryFuturesMarketInfoResponse },
  { name: "PerpetualMarketFunding", options: { "google.api.http": { get: "/injective/exchange/v2/perpetual_market_funding/{market_id}" } }, I: QueryPerpetualMarketFundingRequest, O: QueryPerpetualMarketFundingResponse },
  { name: "SubaccountOrderMetadata", options: { "google.api.http": { get: "/injective/exchange/v2/order_metadata/{subaccount_id}" } }, I: QuerySubaccountOrderMetadataRequest, O: QuerySubaccountOrderMetadataResponse },
  { name: "TradeRewardPoints", options: { "google.api.http": { get: "/injective/exchange/v2/trade_reward_points" } }, I: QueryTradeRewardPointsRequest, O: QueryTradeRewardPointsResponse },
  { name: "PendingTradeRewardPoints", options: { "google.api.http": { get: "/injective/exchange/v2/pending_trade_reward_points" } }, I: QueryTradeRewardPointsRequest, O: QueryTradeRewardPointsResponse },
  { name: "TradeRewardCampaign", options: { "google.api.http": { get: "/injective/exchange/v2/trade_reward_campaign" } }, I: QueryTradeRewardCampaignRequest, O: QueryTradeRewardCampaignResponse },
  { name: "FeeDiscountAccountInfo", options: { "google.api.http": { get: "/injective/exchange/v2/fee_discount_account_info/{account}" } }, I: QueryFeeDiscountAccountInfoRequest, O: QueryFeeDiscountAccountInfoResponse },
  { name: "FeeDiscountSchedule", options: { "google.api.http": { get: "/injective/exchange/v2/fee_discount_schedule" } }, I: QueryFeeDiscountScheduleRequest, O: QueryFeeDiscountScheduleResponse },
  { name: "BalanceMismatches", options: { "google.api.http": { get: "/injective/exchange/v2/balance_mismatches/{dust_factor}" } }, I: QueryBalanceMismatchesRequest, O: QueryBalanceMismatchesResponse },
  { name: "BalanceWithBalanceHolds", options: { "google.api.http": { get: "/injective/exchange/v2/balances_with_balance_holds" } }, I: QueryBalanceWithBalanceHoldsRequest, O: QueryBalanceWithBalanceHoldsResponse },
  { name: "FeeDiscountTierStatistics", options: { "google.api.http": { get: "/injective/exchange/v2/fee_discount_tier_stats" } }, I: QueryFeeDiscountTierStatisticsRequest, O: QueryFeeDiscountTierStatisticsResponse },
  { name: "MitoVaultInfos", options: { "google.api.http": { get: "/injective/exchange/v2/mito_vault_infos" } }, I: MitoVaultInfosRequest, O: MitoVaultInfosResponse },
  { name: "QueryMarketIDFromVault", options: { "google.api.http": { get: "/injective/exchange/v2/vault_market_id/{vault_address}" } }, I: QueryMarketIDFromVaultRequest, O: QueryMarketIDFromVaultResponse },
  { name: "HistoricalTradeRecords", options: { "google.api.http": { get: "/injective/exchange/v2/historical_trade_records" } }, I: QueryHistoricalTradeRecordsRequest, O: QueryHistoricalTradeRecordsResponse },
  { name: "IsOptedOutOfRewards", options: { "google.api.http": { get: "/injective/exchange/v2/is_opted_out_of_rewards/{account}" } }, I: QueryIsOptedOutOfRewardsRequest, O: QueryIsOptedOutOfRewardsResponse },
  { name: "OptedOutOfRewardsAccounts", options: { "google.api.http": { get: "/injective/exchange/v2/opted_out_of_rewards_accounts" } }, I: QueryOptedOutOfRewardsAccountsRequest, O: QueryOptedOutOfRewardsAccountsResponse },
  { name: "MarketVolatility", options: { "google.api.http": { get: "/injective/exchange/v2/market_volatility/{market_id}" } }, I: QueryMarketVolatilityRequest, O: QueryMarketVolatilityResponse },
  { name: "BinaryOptionsMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/binary_options/markets" } }, I: QueryBinaryMarketsRequest, O: QueryBinaryMarketsResponse },
  { name: "TraderDerivativeConditionalOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders/conditional/{market_id}/{subaccount_id}" } }, I: QueryTraderDerivativeConditionalOrdersRequest, O: QueryTraderDerivativeConditionalOrdersResponse },
  { name: "MarketAtomicExecutionFeeMultiplier", options: { "google.api.http": { get: "/injective/exchange/v2/atomic_order_fee_multiplier" } }, I: QueryMarketAtomicExecutionFeeMultiplierRequest, O: QueryMarketAtomicExecutionFeeMultiplierResponse },
  { name: "ActiveStakeGrant", options: { "google.api.http": { get: "/injective/exchange/v2/active_stake_grant/{grantee}" } }, I: QueryActiveStakeGrantRequest, O: QueryActiveStakeGrantResponse },
  { name: "GrantAuthorization", options: { "google.api.http": { get: "/injective/exchange/v2/grant_authorization/{granter}/{grantee}" } }, I: QueryGrantAuthorizationRequest, O: QueryGrantAuthorizationResponse },
  { name: "GrantAuthorizations", options: { "google.api.http": { get: "/injective/exchange/v2/grant_authorizations/{granter}" } }, I: QueryGrantAuthorizationsRequest, O: QueryGrantAuthorizationsResponse },
  { name: "MarketBalance", options: { "google.api.http": { get: "/injective/exchange/v2/market_balance/{market_id}" } }, I: QueryMarketBalanceRequest, O: QueryMarketBalanceResponse },
  { name: "MarketBalances", options: { "google.api.http": { get: "/injective/exchange/v2/market_balances" } }, I: QueryMarketBalancesRequest, O: QueryMarketBalancesResponse },
  { name: "DenomMinNotional", options: { "google.api.http": { get: "/injective/exchange/v2/denom_min_notional/{denom}" } }, I: QueryDenomMinNotionalRequest, O: QueryDenomMinNotionalResponse },
  { name: "DenomMinNotionals", options: { "google.api.http": { get: "/injective/exchange/v2/denom_min_notionals" } }, I: QueryDenomMinNotionalsRequest, O: QueryDenomMinNotionalsResponse },
  { name: "OpenInterest", options: { "google.api.http": { get: "/injective/exchange/v2/open_interest" } }, I: QueryOpenInterestRequest, O: QueryOpenInterestResponse }
]);
export {
  BalanceMismatch,
  BalanceWithMarginHold,
  CancellationStrategy,
  EffectivePosition,
  FullDerivativeMarket,
  FullSpotMarket,
  MarketBalance,
  MitoVaultInfosRequest,
  MitoVaultInfosResponse,
  OpenInterest,
  OrderSide,
  PerpetualMarketState,
  PriceLevel,
  Query,
  QueryAccountAddressDerivativeOrdersRequest,
  QueryAccountAddressDerivativeOrdersResponse,
  QueryAccountAddressSpotOrdersRequest,
  QueryAccountAddressSpotOrdersResponse,
  QueryActiveStakeGrantRequest,
  QueryActiveStakeGrantResponse,
  QueryAggregateMarketVolumeRequest,
  QueryAggregateMarketVolumeResponse,
  QueryAggregateMarketVolumesRequest,
  QueryAggregateMarketVolumesResponse,
  QueryAggregateVolumeRequest,
  QueryAggregateVolumeResponse,
  QueryAggregateVolumesRequest,
  QueryAggregateVolumesResponse,
  QueryAuctionExchangeTransferDenomDecimalRequest,
  QueryAuctionExchangeTransferDenomDecimalResponse,
  QueryAuctionExchangeTransferDenomDecimalsRequest,
  QueryAuctionExchangeTransferDenomDecimalsResponse,
  QueryBalanceMismatchesRequest,
  QueryBalanceMismatchesResponse,
  QueryBalanceWithBalanceHoldsRequest,
  QueryBalanceWithBalanceHoldsResponse,
  QueryBinaryMarketsRequest,
  QueryBinaryMarketsResponse,
  QueryDenomMinNotionalRequest,
  QueryDenomMinNotionalResponse,
  QueryDenomMinNotionalsRequest,
  QueryDenomMinNotionalsResponse,
  QueryDerivativeMarketAddressRequest,
  QueryDerivativeMarketAddressResponse,
  QueryDerivativeMarketRequest,
  QueryDerivativeMarketResponse,
  QueryDerivativeMarketsRequest,
  QueryDerivativeMarketsResponse,
  QueryDerivativeMidPriceAndTOBRequest,
  QueryDerivativeMidPriceAndTOBResponse,
  QueryDerivativeOrderbookRequest,
  QueryDerivativeOrderbookResponse,
  QueryDerivativeOrdersByHashesRequest,
  QueryDerivativeOrdersByHashesResponse,
  QueryExchangeBalancesRequest,
  QueryExchangeBalancesResponse,
  QueryExchangeParamsRequest,
  QueryExchangeParamsResponse,
  QueryExpiryFuturesMarketInfoRequest,
  QueryExpiryFuturesMarketInfoResponse,
  QueryFeeDiscountAccountInfoRequest,
  QueryFeeDiscountAccountInfoResponse,
  QueryFeeDiscountScheduleRequest,
  QueryFeeDiscountScheduleResponse,
  QueryFeeDiscountTierStatisticsRequest,
  QueryFeeDiscountTierStatisticsResponse,
  QueryFullDerivativeOrderbookRequest,
  QueryFullDerivativeOrderbookResponse,
  QueryFullSpotMarketRequest,
  QueryFullSpotMarketResponse,
  QueryFullSpotMarketsRequest,
  QueryFullSpotMarketsResponse,
  QueryFullSpotOrderbookRequest,
  QueryFullSpotOrderbookResponse,
  QueryGrantAuthorizationRequest,
  QueryGrantAuthorizationResponse,
  QueryGrantAuthorizationsRequest,
  QueryGrantAuthorizationsResponse,
  QueryHistoricalTradeRecordsRequest,
  QueryHistoricalTradeRecordsResponse,
  QueryIsOptedOutOfRewardsRequest,
  QueryIsOptedOutOfRewardsResponse,
  QueryMarketAtomicExecutionFeeMultiplierRequest,
  QueryMarketAtomicExecutionFeeMultiplierResponse,
  QueryMarketBalanceRequest,
  QueryMarketBalanceResponse,
  QueryMarketBalancesRequest,
  QueryMarketBalancesResponse,
  QueryMarketIDFromVaultRequest,
  QueryMarketIDFromVaultResponse,
  QueryMarketVolatilityRequest,
  QueryMarketVolatilityResponse,
  QueryModuleStateRequest,
  QueryModuleStateResponse,
  QueryOpenInterestRequest,
  QueryOpenInterestResponse,
  QueryOptedOutOfRewardsAccountsRequest,
  QueryOptedOutOfRewardsAccountsResponse,
  QueryPerpetualMarketFundingRequest,
  QueryPerpetualMarketFundingResponse,
  QueryPerpetualMarketInfoRequest,
  QueryPerpetualMarketInfoResponse,
  QueryPositionsInMarketRequest,
  QueryPositionsInMarketResponse,
  QueryPositionsRequest,
  QueryPositionsResponse,
  QuerySpotMarketRequest,
  QuerySpotMarketResponse,
  QuerySpotMarketsRequest,
  QuerySpotMarketsResponse,
  QuerySpotMidPriceAndTOBRequest,
  QuerySpotMidPriceAndTOBResponse,
  QuerySpotOrderbookRequest,
  QuerySpotOrderbookResponse,
  QuerySpotOrdersByHashesRequest,
  QuerySpotOrdersByHashesResponse,
  QuerySubaccountDepositRequest,
  QuerySubaccountDepositResponse,
  QuerySubaccountDepositsRequest,
  QuerySubaccountDepositsResponse,
  QuerySubaccountEffectivePositionInMarketRequest,
  QuerySubaccountEffectivePositionInMarketResponse,
  QuerySubaccountOrderMetadataRequest,
  QuerySubaccountOrderMetadataResponse,
  QuerySubaccountOrdersRequest,
  QuerySubaccountOrdersResponse,
  QuerySubaccountPositionInMarketRequest,
  QuerySubaccountPositionInMarketResponse,
  QuerySubaccountPositionsRequest,
  QuerySubaccountPositionsResponse,
  QuerySubaccountTradeNonceRequest,
  QuerySubaccountTradeNonceResponse,
  QueryTradeRewardCampaignRequest,
  QueryTradeRewardCampaignResponse,
  QueryTradeRewardPointsRequest,
  QueryTradeRewardPointsResponse,
  QueryTraderDerivativeConditionalOrdersRequest,
  QueryTraderDerivativeConditionalOrdersResponse,
  QueryTraderDerivativeOrdersRequest,
  QueryTraderDerivativeOrdersResponse,
  QueryTraderDerivativeOrdersToCancelUpToAmountRequest,
  QueryTraderSpotOrdersRequest,
  QueryTraderSpotOrdersResponse,
  QueryTraderSpotOrdersToCancelUpToAmountRequest,
  Subaccount,
  SubaccountOrderbookMetadataWithMarket,
  TierStatistic,
  TradeHistoryOptions,
  TrimmedDerivativeConditionalOrder,
  TrimmedDerivativeLimitOrder,
  TrimmedLimitOrder,
  TrimmedSpotLimitOrder
};
