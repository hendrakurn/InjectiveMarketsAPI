import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DerivativePosition } from "./exchange_pb.js";
import { GrantAuthorization } from "./exchange_pb.js";
import { Level } from "./exchange_pb.js";
import { MarketFeeMultiplier } from "./market_pb.js";
import { DerivativeOrder } from "./order_pb.js";
import { AccountRewards } from "./exchange_pb.js";
import { CampaignRewardPool } from "./exchange_pb.js";
import { TradingRewardCampaignInfo } from "./exchange_pb.js";
import { FeeDiscountSchedule } from "./exchange_pb.js";
import { DerivativeMarketOrder } from "./order_pb.js";
import { DepositUpdate } from "./exchange_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { ExpiryFuturesMarketInfo } from "./market_pb.js";
import { PerpetualMarketFunding } from "./market_pb.js";
import { PerpetualMarketInfo } from "./market_pb.js";
import { DerivativeMarket } from "./market_pb.js";
import { SpotMarket } from "./market_pb.js";
import { DerivativeLimitOrder } from "./order_pb.js";
import { SpotLimitOrder } from "./order_pb.js";
import { BinaryOptionsMarket } from "./market_pb.js";
import { SubaccountPosition } from "./exchange_pb.js";
import { DerivativeTradeLog } from "./exchange_pb.js";
import { TradeLog } from "./exchange_pb.js";
import { ExecutionType } from "./exchange_pb.js";
class EventBatchSpotExecution$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventBatchSpotExecution", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "is_buy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 3, name: "executionType", kind: "enum", T: () => ["injective.exchange.v2.ExecutionType", ExecutionType] },
      { no: 4, name: "trades", kind: "message", repeat: 2, T: () => TradeLog }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isBuy = false;
    message.executionType = 0;
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool is_buy */
        2:
          message.isBuy = reader.bool();
          break;
        case /* injective.exchange.v2.ExecutionType executionType */
        3:
          message.executionType = reader.int32();
          break;
        case /* repeated injective.exchange.v2.TradeLog trades */
        4:
          message.trades.push(TradeLog.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isBuy !== false)
      writer.tag(2, WireType.Varint).bool(message.isBuy);
    if (message.executionType !== 0)
      writer.tag(3, WireType.Varint).int32(message.executionType);
    for (let i = 0; i < message.trades.length; i++)
      TradeLog.internalBinaryWrite(message.trades[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventBatchSpotExecution = new EventBatchSpotExecution$Type();
class EventBatchDerivativeExecution$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventBatchDerivativeExecution", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "is_buy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "is_liquidation",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "cumulative_funding", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "executionType", kind: "enum", T: () => ["injective.exchange.v2.ExecutionType", ExecutionType] },
      { no: 6, name: "trades", kind: "message", repeat: 2, T: () => DerivativeTradeLog }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isBuy = false;
    message.isLiquidation = false;
    message.cumulativeFunding = "";
    message.executionType = 0;
    message.trades = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool is_buy */
        2:
          message.isBuy = reader.bool();
          break;
        case /* bool is_liquidation */
        3:
          message.isLiquidation = reader.bool();
          break;
        case /* string cumulative_funding */
        4:
          message.cumulativeFunding = reader.string();
          break;
        case /* injective.exchange.v2.ExecutionType executionType */
        5:
          message.executionType = reader.int32();
          break;
        case /* repeated injective.exchange.v2.DerivativeTradeLog trades */
        6:
          message.trades.push(DerivativeTradeLog.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isBuy !== false)
      writer.tag(2, WireType.Varint).bool(message.isBuy);
    if (message.isLiquidation !== false)
      writer.tag(3, WireType.Varint).bool(message.isLiquidation);
    if (message.cumulativeFunding !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.cumulativeFunding);
    if (message.executionType !== 0)
      writer.tag(5, WireType.Varint).int32(message.executionType);
    for (let i = 0; i < message.trades.length; i++)
      DerivativeTradeLog.internalBinaryWrite(message.trades[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventBatchDerivativeExecution = new EventBatchDerivativeExecution$Type();
class EventLostFundsFromLiquidation$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventLostFundsFromLiquidation", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "lost_funds_from_available_during_payout", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "lost_funds_from_order_cancels", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = new Uint8Array(0);
    message.lostFundsFromAvailableDuringPayout = "";
    message.lostFundsFromOrderCancels = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bytes subaccount_id */
        2:
          message.subaccountId = reader.bytes();
          break;
        case /* string lost_funds_from_available_during_payout */
        3:
          message.lostFundsFromAvailableDuringPayout = reader.string();
          break;
        case /* string lost_funds_from_order_cancels */
        4:
          message.lostFundsFromOrderCancels = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.lostFundsFromAvailableDuringPayout !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.lostFundsFromAvailableDuringPayout);
    if (message.lostFundsFromOrderCancels !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.lostFundsFromOrderCancels);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventLostFundsFromLiquidation = new EventLostFundsFromLiquidation$Type();
class EventBatchDerivativePosition$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventBatchDerivativePosition", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "positions", kind: "message", repeat: 2, T: () => SubaccountPosition }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.positions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v2.SubaccountPosition positions */
        2:
          message.positions.push(SubaccountPosition.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.positions.length; i++)
      SubaccountPosition.internalBinaryWrite(message.positions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventBatchDerivativePosition = new EventBatchDerivativePosition$Type();
class EventDerivativeMarketPaused$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventDerivativeMarketPaused", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "settle_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "total_missing_funds",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "missing_funds_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.settlePrice = "";
    message.totalMissingFunds = "";
    message.missingFundsRate = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string settle_price */
        2:
          message.settlePrice = reader.string();
          break;
        case /* string total_missing_funds */
        3:
          message.totalMissingFunds = reader.string();
          break;
        case /* string missing_funds_rate */
        4:
          message.missingFundsRate = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.settlePrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.settlePrice);
    if (message.totalMissingFunds !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.totalMissingFunds);
    if (message.missingFundsRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.missingFundsRate);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventDerivativeMarketPaused = new EventDerivativeMarketPaused$Type();
class EventSettledMarketBalance$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventSettledMarketBalance", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventSettledMarketBalance = new EventSettledMarketBalance$Type();
class EventNotSettledMarketBalance$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventNotSettledMarketBalance", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventNotSettledMarketBalance = new EventNotSettledMarketBalance$Type();
class EventMarketBeyondBankruptcy$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventMarketBeyondBankruptcy", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "settle_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "missing_market_funds",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.settlePrice = "";
    message.missingMarketFunds = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string settle_price */
        2:
          message.settlePrice = reader.string();
          break;
        case /* string missing_market_funds */
        3:
          message.missingMarketFunds = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.settlePrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.settlePrice);
    if (message.missingMarketFunds !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.missingMarketFunds);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventMarketBeyondBankruptcy = new EventMarketBeyondBankruptcy$Type();
class EventAllPositionsHaircut$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventAllPositionsHaircut", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "settle_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "missing_funds_rate",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.settlePrice = "";
    message.missingFundsRate = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string settle_price */
        2:
          message.settlePrice = reader.string();
          break;
        case /* string missing_funds_rate */
        3:
          message.missingFundsRate = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.settlePrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.settlePrice);
    if (message.missingFundsRate !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.missingFundsRate);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventAllPositionsHaircut = new EventAllPositionsHaircut$Type();
class EventBinaryOptionsMarketUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventBinaryOptionsMarketUpdate", [
      { no: 1, name: "market", kind: "message", T: () => BinaryOptionsMarket, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.BinaryOptionsMarket market */
        1:
          message.market = BinaryOptionsMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      BinaryOptionsMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventBinaryOptionsMarketUpdate = new EventBinaryOptionsMarketUpdate$Type();
class EventNewSpotOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventNewSpotOrders", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "buy_orders", kind: "message", repeat: 2, T: () => SpotLimitOrder },
      { no: 3, name: "sell_orders", kind: "message", repeat: 2, T: () => SpotLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.buyOrders = [];
    message.sellOrders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v2.SpotLimitOrder buy_orders */
        2:
          message.buyOrders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.SpotLimitOrder sell_orders */
        3:
          message.sellOrders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.buyOrders.length; i++)
      SpotLimitOrder.internalBinaryWrite(message.buyOrders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellOrders.length; i++)
      SpotLimitOrder.internalBinaryWrite(message.sellOrders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventNewSpotOrders = new EventNewSpotOrders$Type();
class EventNewDerivativeOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventNewDerivativeOrders", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "buy_orders", kind: "message", repeat: 2, T: () => DerivativeLimitOrder },
      { no: 3, name: "sell_orders", kind: "message", repeat: 2, T: () => DerivativeLimitOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.buyOrders = [];
    message.sellOrders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v2.DerivativeLimitOrder buy_orders */
        2:
          message.buyOrders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DerivativeLimitOrder sell_orders */
        3:
          message.sellOrders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.buyOrders.length; i++)
      DerivativeLimitOrder.internalBinaryWrite(message.buyOrders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellOrders.length; i++)
      DerivativeLimitOrder.internalBinaryWrite(message.sellOrders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventNewDerivativeOrders = new EventNewDerivativeOrders$Type();
class EventCancelSpotOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventCancelSpotOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => SpotLimitOrder, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.SpotLimitOrder order */
        2:
          message.order = SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.order)
      SpotLimitOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventCancelSpotOrder = new EventCancelSpotOrder$Type();
class EventSpotMarketUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventSpotMarketUpdate", [
      { no: 1, name: "market", kind: "message", T: () => SpotMarket, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.SpotMarket market */
        1:
          message.market = SpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      SpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventSpotMarketUpdate = new EventSpotMarketUpdate$Type();
class EventPerpetualMarketUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventPerpetualMarketUpdate", [
      { no: 1, name: "market", kind: "message", T: () => DerivativeMarket, options: { "gogoproto.nullable": false } },
      { no: 2, name: "perpetual_market_info", kind: "message", T: () => PerpetualMarketInfo, options: { "gogoproto.nullable": true } },
      { no: 3, name: "funding", kind: "message", T: () => PerpetualMarketFunding, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.DerivativeMarket market */
        1:
          message.market = DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        case /* injective.exchange.v2.PerpetualMarketInfo perpetual_market_info */
        2:
          message.perpetualMarketInfo = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.perpetualMarketInfo);
          break;
        case /* injective.exchange.v2.PerpetualMarketFunding funding */
        3:
          message.funding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.funding);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      DerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.perpetualMarketInfo)
      PerpetualMarketInfo.internalBinaryWrite(message.perpetualMarketInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.funding)
      PerpetualMarketFunding.internalBinaryWrite(message.funding, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventPerpetualMarketUpdate = new EventPerpetualMarketUpdate$Type();
class EventExpiryFuturesMarketUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventExpiryFuturesMarketUpdate", [
      { no: 1, name: "market", kind: "message", T: () => DerivativeMarket, options: { "gogoproto.nullable": false } },
      { no: 3, name: "expiry_futures_market_info", kind: "message", T: () => ExpiryFuturesMarketInfo, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.DerivativeMarket market */
        1:
          message.market = DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        case /* injective.exchange.v2.ExpiryFuturesMarketInfo expiry_futures_market_info */
        3:
          message.expiryFuturesMarketInfo = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.expiryFuturesMarketInfo);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.market)
      DerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.expiryFuturesMarketInfo)
      ExpiryFuturesMarketInfo.internalBinaryWrite(message.expiryFuturesMarketInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventExpiryFuturesMarketUpdate = new EventExpiryFuturesMarketUpdate$Type();
class EventPerpetualMarketFundingUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventPerpetualMarketFundingUpdate", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "funding", kind: "message", T: () => PerpetualMarketFunding, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "is_hourly_funding",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "funding_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "mark_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isHourlyFunding = false;
    message.fundingRate = "";
    message.markPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.PerpetualMarketFunding funding */
        2:
          message.funding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.funding);
          break;
        case /* bool is_hourly_funding */
        3:
          message.isHourlyFunding = reader.bool();
          break;
        case /* string funding_rate */
        4:
          message.fundingRate = reader.string();
          break;
        case /* string mark_price */
        5:
          message.markPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.funding)
      PerpetualMarketFunding.internalBinaryWrite(message.funding, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.isHourlyFunding !== false)
      writer.tag(3, WireType.Varint).bool(message.isHourlyFunding);
    if (message.fundingRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fundingRate);
    if (message.markPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.markPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventPerpetualMarketFundingUpdate = new EventPerpetualMarketFundingUpdate$Type();
class EventSubaccountDeposit$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventSubaccountDeposit", [
      {
        no: 1,
        name: "src_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.srcAddress = "";
    message.subaccountId = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string src_address */
        1:
          message.srcAddress = reader.string();
          break;
        case /* bytes subaccount_id */
        2:
          message.subaccountId = reader.bytes();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        3:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.srcAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.srcAddress);
    if (message.subaccountId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventSubaccountDeposit = new EventSubaccountDeposit$Type();
class EventSubaccountWithdraw$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventSubaccountWithdraw", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "dst_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = new Uint8Array(0);
    message.dstAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes subaccount_id */
        1:
          message.subaccountId = reader.bytes();
          break;
        case /* string dst_address */
        2:
          message.dstAddress = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        3:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.dstAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.dstAddress);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventSubaccountWithdraw = new EventSubaccountWithdraw$Type();
class EventSubaccountBalanceTransfer$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventSubaccountBalanceTransfer", [
      {
        no: 1,
        name: "src_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "dst_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.srcSubaccountId = "";
    message.dstSubaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string src_subaccount_id */
        1:
          message.srcSubaccountId = reader.string();
          break;
        case /* string dst_subaccount_id */
        2:
          message.dstSubaccountId = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        3:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.srcSubaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.srcSubaccountId);
    if (message.dstSubaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.dstSubaccountId);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventSubaccountBalanceTransfer = new EventSubaccountBalanceTransfer$Type();
class EventBatchDepositUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventBatchDepositUpdate", [
      { no: 1, name: "deposit_updates", kind: "message", repeat: 2, T: () => DepositUpdate }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.depositUpdates = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.DepositUpdate deposit_updates */
        1:
          message.depositUpdates.push(DepositUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.depositUpdates.length; i++)
      DepositUpdate.internalBinaryWrite(message.depositUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventBatchDepositUpdate = new EventBatchDepositUpdate$Type();
class DerivativeMarketOrderCancel$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeMarketOrderCancel", [
      { no: 1, name: "market_order", kind: "message", T: () => DerivativeMarketOrder, options: { "gogoproto.nullable": true } },
      { no: 2, name: "cancel_quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cancelQuantity = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.DerivativeMarketOrder market_order */
        1:
          message.marketOrder = DerivativeMarketOrder.internalBinaryRead(reader, reader.uint32(), options, message.marketOrder);
          break;
        case /* string cancel_quantity */
        2:
          message.cancelQuantity = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketOrder)
      DerivativeMarketOrder.internalBinaryWrite(message.marketOrder, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.cancelQuantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cancelQuantity);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketOrderCancel = new DerivativeMarketOrderCancel$Type();
class EventCancelDerivativeOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventCancelDerivativeOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "isLimitCancel",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 3, name: "limit_order", kind: "message", T: () => DerivativeLimitOrder, options: { "gogoproto.nullable": true } },
      { no: 4, name: "market_order_cancel", kind: "message", T: () => DerivativeMarketOrderCancel, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isLimitCancel = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool isLimitCancel */
        2:
          message.isLimitCancel = reader.bool();
          break;
        case /* injective.exchange.v2.DerivativeLimitOrder limit_order */
        3:
          message.limitOrder = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.limitOrder);
          break;
        case /* injective.exchange.v2.DerivativeMarketOrderCancel market_order_cancel */
        4:
          message.marketOrderCancel = DerivativeMarketOrderCancel.internalBinaryRead(reader, reader.uint32(), options, message.marketOrderCancel);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isLimitCancel !== false)
      writer.tag(2, WireType.Varint).bool(message.isLimitCancel);
    if (message.limitOrder)
      DerivativeLimitOrder.internalBinaryWrite(message.limitOrder, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.marketOrderCancel)
      DerivativeMarketOrderCancel.internalBinaryWrite(message.marketOrderCancel, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventCancelDerivativeOrder = new EventCancelDerivativeOrder$Type();
class EventFeeDiscountSchedule$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventFeeDiscountSchedule", [
      { no: 1, name: "schedule", kind: "message", T: () => FeeDiscountSchedule }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.FeeDiscountSchedule schedule */
        1:
          message.schedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.schedule);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.schedule)
      FeeDiscountSchedule.internalBinaryWrite(message.schedule, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventFeeDiscountSchedule = new EventFeeDiscountSchedule$Type();
class EventTradingRewardCampaignUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventTradingRewardCampaignUpdate", [
      { no: 1, name: "campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
      { no: 2, name: "campaign_reward_pools", kind: "message", repeat: 2, T: () => CampaignRewardPool }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.campaignRewardPools = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.TradingRewardCampaignInfo campaign_info */
        1:
          message.campaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.campaignInfo);
          break;
        case /* repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools */
        2:
          message.campaignRewardPools.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.campaignInfo)
      TradingRewardCampaignInfo.internalBinaryWrite(message.campaignInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.campaignRewardPools.length; i++)
      CampaignRewardPool.internalBinaryWrite(message.campaignRewardPools[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventTradingRewardCampaignUpdate = new EventTradingRewardCampaignUpdate$Type();
class EventTradingRewardDistribution$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventTradingRewardDistribution", [
      { no: 1, name: "account_rewards", kind: "message", repeat: 2, T: () => AccountRewards }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountRewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.AccountRewards account_rewards */
        1:
          message.accountRewards.push(AccountRewards.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accountRewards.length; i++)
      AccountRewards.internalBinaryWrite(message.accountRewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventTradingRewardDistribution = new EventTradingRewardDistribution$Type();
class EventNewConditionalDerivativeOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventNewConditionalDerivativeOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => DerivativeOrder },
      {
        no: 3,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "is_market",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.hash = new Uint8Array(0);
    message.isMarket = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.DerivativeOrder order */
        2:
          message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* bytes hash */
        3:
          message.hash = reader.bytes();
          break;
        case /* bool is_market */
        4:
          message.isMarket = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.order)
      DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.hash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.hash);
    if (message.isMarket !== false)
      writer.tag(4, WireType.Varint).bool(message.isMarket);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventNewConditionalDerivativeOrder = new EventNewConditionalDerivativeOrder$Type();
class EventCancelConditionalDerivativeOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventCancelConditionalDerivativeOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "isLimitCancel",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 3, name: "limit_order", kind: "message", T: () => DerivativeLimitOrder, options: { "gogoproto.nullable": true } },
      { no: 4, name: "market_order", kind: "message", T: () => DerivativeMarketOrder, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isLimitCancel = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool isLimitCancel */
        2:
          message.isLimitCancel = reader.bool();
          break;
        case /* injective.exchange.v2.DerivativeLimitOrder limit_order */
        3:
          message.limitOrder = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.limitOrder);
          break;
        case /* injective.exchange.v2.DerivativeMarketOrder market_order */
        4:
          message.marketOrder = DerivativeMarketOrder.internalBinaryRead(reader, reader.uint32(), options, message.marketOrder);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isLimitCancel !== false)
      writer.tag(2, WireType.Varint).bool(message.isLimitCancel);
    if (message.limitOrder)
      DerivativeLimitOrder.internalBinaryWrite(message.limitOrder, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.marketOrder)
      DerivativeMarketOrder.internalBinaryWrite(message.marketOrder, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventCancelConditionalDerivativeOrder = new EventCancelConditionalDerivativeOrder$Type();
class EventConditionalDerivativeOrderTrigger$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventConditionalDerivativeOrderTrigger", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "isLimitTrigger",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "triggered_order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "placed_order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "triggered_order_cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = new Uint8Array(0);
    message.isLimitTrigger = false;
    message.triggeredOrderHash = new Uint8Array(0);
    message.placedOrderHash = new Uint8Array(0);
    message.triggeredOrderCid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes market_id */
        1:
          message.marketId = reader.bytes();
          break;
        case /* bool isLimitTrigger */
        2:
          message.isLimitTrigger = reader.bool();
          break;
        case /* bytes triggered_order_hash */
        3:
          message.triggeredOrderHash = reader.bytes();
          break;
        case /* bytes placed_order_hash */
        4:
          message.placedOrderHash = reader.bytes();
          break;
        case /* string triggered_order_cid */
        5:
          message.triggeredOrderCid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.marketId);
    if (message.isLimitTrigger !== false)
      writer.tag(2, WireType.Varint).bool(message.isLimitTrigger);
    if (message.triggeredOrderHash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.triggeredOrderHash);
    if (message.placedOrderHash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.placedOrderHash);
    if (message.triggeredOrderCid !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggeredOrderCid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventConditionalDerivativeOrderTrigger = new EventConditionalDerivativeOrderTrigger$Type();
class EventOrderFail$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventOrderFail", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "hashes",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "flags",
        kind: "scalar",
        repeat: 1,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = new Uint8Array(0);
    message.hashes = [];
    message.flags = [];
    message.cids = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes account */
        1:
          message.account = reader.bytes();
          break;
        case /* repeated bytes hashes */
        2:
          message.hashes.push(reader.bytes());
          break;
        case /* repeated uint32 flags */
        3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.flags.push(reader.uint32());
          else
            message.flags.push(reader.uint32());
          break;
        case /* repeated string cids */
        4:
          message.cids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.account);
    for (let i = 0; i < message.hashes.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.hashes[i]);
    if (message.flags.length) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.flags.length; i++)
        writer.uint32(message.flags[i]);
      writer.join();
    }
    for (let i = 0; i < message.cids.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.cids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventOrderFail = new EventOrderFail$Type();
class EventAtomicMarketOrderFeeMultipliersUpdated$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventAtomicMarketOrderFeeMultipliersUpdated", [
      { no: 1, name: "market_fee_multipliers", kind: "message", repeat: 2, T: () => MarketFeeMultiplier }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketFeeMultipliers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers */
        1:
          message.marketFeeMultipliers.push(MarketFeeMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketFeeMultipliers.length; i++)
      MarketFeeMultiplier.internalBinaryWrite(message.marketFeeMultipliers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventAtomicMarketOrderFeeMultipliersUpdated = new EventAtomicMarketOrderFeeMultipliersUpdated$Type();
class EventOrderbookUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventOrderbookUpdate", [
      { no: 1, name: "spot_updates", kind: "message", repeat: 2, T: () => OrderbookUpdate },
      { no: 2, name: "derivative_updates", kind: "message", repeat: 2, T: () => OrderbookUpdate }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.spotUpdates = [];
    message.derivativeUpdates = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.exchange.v2.OrderbookUpdate spot_updates */
        1:
          message.spotUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.OrderbookUpdate derivative_updates */
        2:
          message.derivativeUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.spotUpdates.length; i++)
      OrderbookUpdate.internalBinaryWrite(message.spotUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeUpdates.length; i++)
      OrderbookUpdate.internalBinaryWrite(message.derivativeUpdates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventOrderbookUpdate = new EventOrderbookUpdate$Type();
class OrderbookUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OrderbookUpdate", [
      {
        no: 1,
        name: "seq",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "orderbook", kind: "message", T: () => Orderbook }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.seq = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 seq */
        1:
          message.seq = reader.uint64().toBigInt();
          break;
        case /* injective.exchange.v2.Orderbook orderbook */
        2:
          message.orderbook = Orderbook.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.seq !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.seq);
    if (message.orderbook)
      Orderbook.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookUpdate = new OrderbookUpdate$Type();
class Orderbook$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.Orderbook", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "buy_levels", kind: "message", repeat: 2, T: () => Level },
      { no: 3, name: "sell_levels", kind: "message", repeat: 2, T: () => Level }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = new Uint8Array(0);
    message.buyLevels = [];
    message.sellLevels = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes market_id */
        1:
          message.marketId = reader.bytes();
          break;
        case /* repeated injective.exchange.v2.Level buy_levels */
        2:
          message.buyLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.Level sell_levels */
        3:
          message.sellLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.marketId);
    for (let i = 0; i < message.buyLevels.length; i++)
      Level.internalBinaryWrite(message.buyLevels[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellLevels.length; i++)
      Level.internalBinaryWrite(message.sellLevels[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Orderbook = new Orderbook$Type();
class EventGrantAuthorizations$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventGrantAuthorizations", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "grants", kind: "message", repeat: 2, T: () => GrantAuthorization }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    message.grants = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        case /* repeated injective.exchange.v2.GrantAuthorization grants */
        2:
          message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    for (let i = 0; i < message.grants.length; i++)
      GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventGrantAuthorizations = new EventGrantAuthorizations$Type();
class EventGrantActivation$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventGrantActivation", [
      {
        no: 1,
        name: "grantee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.grantee = "";
    message.granter = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string grantee */
        1:
          message.grantee = reader.string();
          break;
        case /* string granter */
        2:
          message.granter = reader.string();
          break;
        case /* string amount */
        3:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.grantee !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.grantee);
    if (message.granter !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.granter);
    if (message.amount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventGrantActivation = new EventGrantActivation$Type();
class EventInvalidGrant$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventInvalidGrant", [
      {
        no: 1,
        name: "grantee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.grantee = "";
    message.granter = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string grantee */
        1:
          message.grantee = reader.string();
          break;
        case /* string granter */
        2:
          message.granter = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.grantee !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.grantee);
    if (message.granter !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.granter);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventInvalidGrant = new EventInvalidGrant$Type();
class EventOrderCancelFail$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventOrderCancelFail", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.orderHash = "";
    message.cid = "";
    message.description = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string order_hash */
        3:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        4:
          message.cid = reader.string();
          break;
        case /* string description */
        5:
          message.description = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.orderHash !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.cid);
    if (message.description !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.description);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventOrderCancelFail = new EventOrderCancelFail$Type();
class EventDerivativeOrdersV2Migration$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventDerivativeOrdersV2Migration", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "buy_order_changes", kind: "message", repeat: 2, T: () => DerivativeOrderV2Changes },
      { no: 3, name: "sell_order_changes", kind: "message", repeat: 2, T: () => DerivativeOrderV2Changes }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.buyOrderChanges = [];
    message.sellOrderChanges = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v2.DerivativeOrderV2Changes buy_order_changes */
        2:
          message.buyOrderChanges.push(DerivativeOrderV2Changes.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.DerivativeOrderV2Changes sell_order_changes */
        3:
          message.sellOrderChanges.push(DerivativeOrderV2Changes.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.buyOrderChanges.length; i++)
      DerivativeOrderV2Changes.internalBinaryWrite(message.buyOrderChanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellOrderChanges.length; i++)
      DerivativeOrderV2Changes.internalBinaryWrite(message.sellOrderChanges[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventDerivativeOrdersV2Migration = new EventDerivativeOrdersV2Migration$Type();
class DerivativeOrderV2Changes$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeOrderV2Changes", [
      {
        no: 1,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "p", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "q", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "m", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "f", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "tp", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = "";
    message.hash = new Uint8Array(0);
    message.p = "";
    message.q = "";
    message.m = "";
    message.f = "";
    message.tp = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cid */
        1:
          message.cid = reader.string();
          break;
        case /* bytes hash */
        2:
          message.hash = reader.bytes();
          break;
        case /* string p */
        3:
          message.p = reader.string();
          break;
        case /* string q */
        4:
          message.q = reader.string();
          break;
        case /* string m */
        5:
          message.m = reader.string();
          break;
        case /* string f */
        6:
          message.f = reader.string();
          break;
        case /* string tp */
        7:
          message.tp = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cid);
    if (message.hash.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.hash);
    if (message.p !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.p);
    if (message.q !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.q);
    if (message.m !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.m);
    if (message.f !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.f);
    if (message.tp !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.tp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeOrderV2Changes = new DerivativeOrderV2Changes$Type();
class EventSpotOrdersV2Migration$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventSpotOrdersV2Migration", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "buy_order_changes", kind: "message", repeat: 2, T: () => SpotOrderV2Changes },
      { no: 3, name: "sell_order_changes", kind: "message", repeat: 2, T: () => SpotOrderV2Changes }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.buyOrderChanges = [];
    message.sellOrderChanges = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v2.SpotOrderV2Changes buy_order_changes */
        2:
          message.buyOrderChanges.push(SpotOrderV2Changes.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v2.SpotOrderV2Changes sell_order_changes */
        3:
          message.sellOrderChanges.push(SpotOrderV2Changes.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.buyOrderChanges.length; i++)
      SpotOrderV2Changes.internalBinaryWrite(message.buyOrderChanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellOrderChanges.length; i++)
      SpotOrderV2Changes.internalBinaryWrite(message.sellOrderChanges[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventSpotOrdersV2Migration = new EventSpotOrdersV2Migration$Type();
class EventTriggerConditionalMarketOrderFailed$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventTriggerConditionalMarketOrderFailed", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "mark_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 4,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "trigger_err",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.markPrice = "";
    message.orderHash = new Uint8Array(0);
    message.triggerErr = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string mark_price */
        3:
          message.markPrice = reader.string();
          break;
        case /* bytes order_hash */
        4:
          message.orderHash = reader.bytes();
          break;
        case /* string trigger_err */
        5:
          message.triggerErr = reader.string();
          break;
        case /* string cid */
        6:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.markPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.markPrice);
    if (message.orderHash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.triggerErr !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerErr);
    if (message.cid !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventTriggerConditionalMarketOrderFailed = new EventTriggerConditionalMarketOrderFailed$Type();
class EventTriggerConditionalLimitOrderFailed$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventTriggerConditionalLimitOrderFailed", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "mark_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 4,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "trigger_err",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.markPrice = "";
    message.orderHash = new Uint8Array(0);
    message.triggerErr = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string mark_price */
        3:
          message.markPrice = reader.string();
          break;
        case /* bytes order_hash */
        4:
          message.orderHash = reader.bytes();
          break;
        case /* string trigger_err */
        5:
          message.triggerErr = reader.string();
          break;
        case /* string cid */
        6:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.markPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.markPrice);
    if (message.orderHash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.triggerErr !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerErr);
    if (message.cid !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventTriggerConditionalLimitOrderFailed = new EventTriggerConditionalLimitOrderFailed$Type();
class SpotOrderV2Changes$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SpotOrderV2Changes", [
      {
        no: 1,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "p", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "q", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "f", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "tp", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = "";
    message.hash = new Uint8Array(0);
    message.p = "";
    message.q = "";
    message.f = "";
    message.tp = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cid */
        1:
          message.cid = reader.string();
          break;
        case /* bytes hash */
        2:
          message.hash = reader.bytes();
          break;
        case /* string p */
        3:
          message.p = reader.string();
          break;
        case /* string q */
        4:
          message.q = reader.string();
          break;
        case /* string f */
        5:
          message.f = reader.string();
          break;
        case /* string tp */
        6:
          message.tp = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cid);
    if (message.hash.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.hash);
    if (message.p !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.p);
    if (message.q !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.q);
    if (message.f !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.f);
    if (message.tp !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.tp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotOrderV2Changes = new SpotOrderV2Changes$Type();
class EventDerivativePositionV2Migration$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.EventDerivativePositionV2Migration", [
      { no: 1, name: "position", kind: "message", T: () => DerivativePosition }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.DerivativePosition position */
        1:
          message.position = DerivativePosition.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.position)
      DerivativePosition.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventDerivativePositionV2Migration = new EventDerivativePositionV2Migration$Type();
export {
  DerivativeMarketOrderCancel,
  DerivativeOrderV2Changes,
  EventAllPositionsHaircut,
  EventAtomicMarketOrderFeeMultipliersUpdated,
  EventBatchDepositUpdate,
  EventBatchDerivativeExecution,
  EventBatchDerivativePosition,
  EventBatchSpotExecution,
  EventBinaryOptionsMarketUpdate,
  EventCancelConditionalDerivativeOrder,
  EventCancelDerivativeOrder,
  EventCancelSpotOrder,
  EventConditionalDerivativeOrderTrigger,
  EventDerivativeMarketPaused,
  EventDerivativeOrdersV2Migration,
  EventDerivativePositionV2Migration,
  EventExpiryFuturesMarketUpdate,
  EventFeeDiscountSchedule,
  EventGrantActivation,
  EventGrantAuthorizations,
  EventInvalidGrant,
  EventLostFundsFromLiquidation,
  EventMarketBeyondBankruptcy,
  EventNewConditionalDerivativeOrder,
  EventNewDerivativeOrders,
  EventNewSpotOrders,
  EventNotSettledMarketBalance,
  EventOrderCancelFail,
  EventOrderFail,
  EventOrderbookUpdate,
  EventPerpetualMarketFundingUpdate,
  EventPerpetualMarketUpdate,
  EventSettledMarketBalance,
  EventSpotMarketUpdate,
  EventSpotOrdersV2Migration,
  EventSubaccountBalanceTransfer,
  EventSubaccountDeposit,
  EventSubaccountWithdraw,
  EventTradingRewardCampaignUpdate,
  EventTradingRewardDistribution,
  EventTriggerConditionalLimitOrderFailed,
  EventTriggerConditionalMarketOrderFailed,
  Orderbook,
  OrderbookUpdate,
  SpotOrderV2Changes
};
