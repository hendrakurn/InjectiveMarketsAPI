// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v2/query.proto" (package "injective.exchange.v2", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DenomMinNotional } from "./exchange_pb";
import { GrantAuthorization } from "./exchange_pb";
import { EffectiveGrant } from "./exchange_pb";
import { ActiveGrant } from "./exchange_pb";
import { BinaryOptionsMarket } from "./market_pb";
import { TradeRecord } from "./exchange_pb";
import { MetadataStatistics } from "../../oracle/v1beta1/oracle_pb";
import { TradeRecords } from "./exchange_pb";
import { FeeDiscountSchedule } from "./exchange_pb";
import { FeeDiscountTierTTL } from "./exchange_pb";
import { FeeDiscountTierInfo } from "./exchange_pb";
import { CampaignRewardPool } from "./exchange_pb";
import { TradingRewardCampaignInfo } from "./exchange_pb";
import { GenesisState } from "./genesis_pb";
import { Position } from "./exchange_pb";
import { DerivativePosition } from "./exchange_pb";
import { ExpiryFuturesMarketInfo } from "./market_pb";
import { DerivativeMarket } from "./market_pb";
import { PerpetualMarketFunding } from "./market_pb";
import { PerpetualMarketInfo } from "./market_pb";
import { MidPriceAndTOB } from "./exchange_pb";
import { Level } from "./exchange_pb";
import { SpotMarket } from "./market_pb";
import { DenomDecimals } from "./exchange_pb";
import { VolumeRecord } from "./market_pb";
import { AggregateAccountVolumeRecord } from "./exchange_pb";
import { MarketVolume } from "./market_pb";
import { Balance } from "./exchange_pb";
import { Deposit } from "./exchange_pb";
import { Params } from "./exchange_pb";
import { SubaccountOrderbookMetadata } from "./orderbook_pb";
import { SubaccountOrderData } from "./exchange_pb";
/**
 * @generated from protobuf message injective.exchange.v2.Subaccount
 */
export interface Subaccount {
    /**
     * the subaccount's trader address
     *
     * @generated from protobuf field: string trader = 1
     */
    trader: string;
    /**
     * the subaccount's nonce number
     *
     * @generated from protobuf field: uint32 subaccount_nonce = 2
     */
    subaccountNonce: number;
}
/**
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountOrdersRequest
 */
export interface QuerySubaccountOrdersRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountOrdersResponse
 */
export interface QuerySubaccountOrdersResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SubaccountOrderData buy_orders = 1
     */
    buyOrders: SubaccountOrderData[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SubaccountOrderData sell_orders = 2
     */
    sellOrders: SubaccountOrderData[];
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountOrderbookMetadataWithMarket
 */
export interface SubaccountOrderbookMetadataWithMarket {
    /**
     * the subaccount orderbook details
     *
     * @generated from protobuf field: injective.exchange.v2.SubaccountOrderbookMetadata metadata = 1
     */
    metadata?: SubaccountOrderbookMetadata;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * true if the orderbook is for a buy orders
     *
     * @generated from protobuf field: bool isBuy = 3
     */
    isBuy: boolean;
}
/**
 * QueryExchangeParamsRequest is the request type for the Query/ExchangeParams
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryExchangeParamsRequest
 */
export interface QueryExchangeParamsRequest {
}
/**
 * QueryExchangeParamsRequest is the response type for the Query/ExchangeParams
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryExchangeParamsResponse
 */
export interface QueryExchangeParamsResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.Params params = 1
     */
    params?: Params;
}
/**
 * QuerySubaccountDepositsRequest is the request type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountDepositsRequest
 */
export interface QuerySubaccountDepositsRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the subaccount details
     *
     * @generated from protobuf field: injective.exchange.v2.Subaccount subaccount = 2
     */
    subaccount?: Subaccount;
}
/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountDepositsResponse
 */
export interface QuerySubaccountDepositsResponse {
    /**
     * @generated from protobuf field: map<string, injective.exchange.v2.Deposit> deposits = 1
     */
    deposits: {
        [key: string]: Deposit;
    };
}
/**
 * QueryExchangeBalancesRequest is the request type for the
 * Query/ExchangeBalances RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryExchangeBalancesRequest
 */
export interface QueryExchangeBalancesRequest {
}
/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryExchangeBalancesResponse
 */
export interface QueryExchangeBalancesResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.Balance balances = 1
     */
    balances: Balance[];
}
/**
 * QueryAggregateVolumeRequest is the request type for the Query/AggregateVolume
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateVolumeRequest
 */
export interface QueryAggregateVolumeRequest {
    /**
     * can either be an address or a subaccount
     *
     * @generated from protobuf field: string account = 1
     */
    account: string;
}
/**
 * QueryAggregateVolumeResponse is the response type for the
 * Query/AggregateVolume RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateVolumeResponse
 */
export interface QueryAggregateVolumeResponse {
    /**
     * if an address is specified, then the aggregate_volumes will aggregate the
     * volumes across all subaccounts for the address
     *
     * @generated from protobuf field: repeated injective.exchange.v2.MarketVolume aggregate_volumes = 1
     */
    aggregateVolumes: MarketVolume[];
}
/**
 * QueryAggregateVolumesRequest is the request type for the
 * Query/AggregateVolumes RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateVolumesRequest
 */
export interface QueryAggregateVolumesRequest {
    /**
     * @generated from protobuf field: repeated string accounts = 1
     */
    accounts: string[];
    /**
     * @generated from protobuf field: repeated string market_ids = 2
     */
    marketIds: string[];
}
/**
 * QueryAggregateVolumesResponse is the response type for the
 * Query/AggregateVolumes RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateVolumesResponse
 */
export interface QueryAggregateVolumesResponse {
    /**
     * the aggregate volume records for the accounts specified
     *
     * @generated from protobuf field: repeated injective.exchange.v2.AggregateAccountVolumeRecord aggregate_account_volumes = 1
     */
    aggregateAccountVolumes: AggregateAccountVolumeRecord[];
    /**
     * the aggregate volumes for the markets specified
     *
     * @generated from protobuf field: repeated injective.exchange.v2.MarketVolume aggregate_market_volumes = 2
     */
    aggregateMarketVolumes: MarketVolume[];
}
/**
 * QueryAggregateMarketVolumeRequest is the request type for the
 * Query/AggregateMarketVolume RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateMarketVolumeRequest
 */
export interface QueryAggregateMarketVolumeRequest {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryAggregateMarketVolumeResponse is the response type for the
 * Query/AggregateMarketVolume RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateMarketVolumeResponse
 */
export interface QueryAggregateMarketVolumeResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.VolumeRecord volume = 1
     */
    volume?: VolumeRecord;
}
/**
 * QueryAuctionExchangeTransferDenomDecimalRequest is the request type for the
 * Query/DenomDecimal RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalRequest
 */
export interface QueryAuctionExchangeTransferDenomDecimalRequest {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
}
/**
 * QueryDenomDecimalResponse is the response type for the Query/DenomDecimal RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalResponse
 */
export interface QueryAuctionExchangeTransferDenomDecimalResponse {
    /**
     * @generated from protobuf field: uint64 decimal = 1
     */
    decimal: bigint;
}
/**
 * QueryDenomDecimalsRequest is the request type for the Query/DenomDecimals RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsRequest
 */
export interface QueryAuctionExchangeTransferDenomDecimalsRequest {
    /**
     * denoms can be empty to query all denom decimals
     *
     * @generated from protobuf field: repeated string denoms = 1
     */
    denoms: string[];
}
/**
 * QueryDenomDecimalsRequest is the response type for the Query/DenomDecimals
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsResponse
 */
export interface QueryAuctionExchangeTransferDenomDecimalsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DenomDecimals denom_decimals = 1
     */
    denomDecimals: DenomDecimals[];
}
/**
 * QueryAggregateMarketVolumesRequest is the request type for the
 * Query/AggregateMarketVolumes RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateMarketVolumesRequest
 */
export interface QueryAggregateMarketVolumesRequest {
    /**
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * QueryAggregateMarketVolumesResponse is the response type for the
 * Query/AggregateMarketVolumes RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAggregateMarketVolumesResponse
 */
export interface QueryAggregateMarketVolumesResponse {
    /**
     * the aggregate volumes for the entire market
     *
     * @generated from protobuf field: repeated injective.exchange.v2.MarketVolume volumes = 1
     */
    volumes: MarketVolume[];
}
/**
 * QuerySubaccountDepositsRequest is the request type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountDepositRequest
 */
export interface QuerySubaccountDepositRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the token denom
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
}
/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountDepositResponse
 */
export interface QuerySubaccountDepositResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.Deposit deposits = 1
     */
    deposits?: Deposit;
}
/**
 * QuerySpotMarketsRequest is the request type for the Query/SpotMarkets RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotMarketsRequest
 */
export interface QuerySpotMarketsRequest {
    /**
     * Status of the market, for convenience it is set to string - not enum
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
    /**
     * Filter by market IDs
     *
     * @generated from protobuf field: repeated string market_ids = 2
     */
    marketIds: string[];
}
/**
 * QuerySpotMarketsResponse is the response type for the Query/SpotMarkets RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotMarketsResponse
 */
export interface QuerySpotMarketsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SpotMarket markets = 1
     */
    markets: SpotMarket[];
}
/**
 * QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotMarketRequest
 */
export interface QuerySpotMarketRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotMarketResponse
 */
export interface QuerySpotMarketResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.SpotMarket market = 1
     */
    market?: SpotMarket;
}
/**
 * QuerySpotOrderbookRequest is the request type for the Query/SpotOrderbook RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotOrderbookRequest
 */
export interface QuerySpotOrderbookRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the maximum number of orderbook entries to return per side (optional)
     *
     * @generated from protobuf field: uint64 limit = 2
     */
    limit: bigint;
    /**
     * the order side to return the orderbook entries for (optional)
     *
     * @generated from protobuf field: injective.exchange.v2.OrderSide order_side = 3
     */
    orderSide: OrderSide;
    /**
     * limits the number of entries to return per side based on the cumulative
     * notional (in human readable format)
     *
     * @generated from protobuf field: string limit_cumulative_notional = 4
     */
    limitCumulativeNotional: string;
    /**
     * limits the number of entries to return per side based on the cumulative
     * quantity (in human readable format)
     *
     * @generated from protobuf field: string limit_cumulative_quantity = 5
     */
    limitCumulativeQuantity: string;
}
/**
 * QuerySpotOrderbookResponse is the response type for the Query/SpotOrderbook
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotOrderbookResponse
 */
export interface QuerySpotOrderbookResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.Level buys_price_level = 1
     */
    buysPriceLevel: Level[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.Level sells_price_level = 2
     */
    sellsPriceLevel: Level[];
    /**
     * the current orderbook sequence number
     *
     * @generated from protobuf field: uint64 seq = 3
     */
    seq: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.FullSpotMarket
 */
export interface FullSpotMarket {
    /**
     * spot market details
     *
     * @generated from protobuf field: injective.exchange.v2.SpotMarket market = 1
     */
    market?: SpotMarket;
    /**
     * mid_price_and_tob defines the mid price for this market and the best ask
     * and bid orders
     *
     * @generated from protobuf field: injective.exchange.v2.MidPriceAndTOB mid_price_and_tob = 2
     */
    midPriceAndTob?: MidPriceAndTOB;
}
/**
 * QueryFullSpotMarketsRequest is the request type for the Query/FullSpotMarkets
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFullSpotMarketsRequest
 */
export interface QueryFullSpotMarketsRequest {
    /**
     * Status of the market, for convenience it is set to string - not enum
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
    /**
     * Filter by market IDs
     *
     * @generated from protobuf field: repeated string market_ids = 2
     */
    marketIds: string[];
    /**
     * Flag to return the markets mid price and top of the book buy and sell
     * orders.
     *
     * @generated from protobuf field: bool with_mid_price_and_tob = 3
     */
    withMidPriceAndTob: boolean;
}
/**
 * QueryFullSpotMarketsResponse is the response type for the
 * Query/FullSpotMarkets RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFullSpotMarketsResponse
 */
export interface QueryFullSpotMarketsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.FullSpotMarket markets = 1
     */
    markets: FullSpotMarket[];
}
/**
 * QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFullSpotMarketRequest
 */
export interface QueryFullSpotMarketRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Flag to return the markets mid price and top of the book buy and sell
     * orders.
     *
     * @generated from protobuf field: bool with_mid_price_and_tob = 2
     */
    withMidPriceAndTob: boolean;
}
/**
 * QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFullSpotMarketResponse
 */
export interface QueryFullSpotMarketResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.FullSpotMarket market = 1
     */
    market?: FullSpotMarket;
}
/**
 * QuerySpotOrdersByHashesRequest is the request type for the
 * Query/SpotOrdersByHashes RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotOrdersByHashesRequest
 */
export interface QuerySpotOrdersByHashesRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * SubaccountID of the trader
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the order hashes
     *
     * @generated from protobuf field: repeated string order_hashes = 3
     */
    orderHashes: string[];
}
/**
 * QuerySpotOrdersByHashesResponse is the response type for the
 * Query/SpotOrdersByHashes RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotOrdersByHashesResponse
 */
export interface QuerySpotOrdersByHashesResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedSpotLimitOrder orders = 1
     */
    orders: TrimmedSpotLimitOrder[];
}
/**
 * QueryTraderSpotOrdersRequest is the request type for the
 * Query/TraderSpotOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderSpotOrdersRequest
 */
export interface QueryTraderSpotOrdersRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * SubaccountID of the trader
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
}
/**
 * QueryAccountAddressSpotOrdersRequest is the request type for the
 * Query/AccountAddressSpotOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAccountAddressSpotOrdersRequest
 */
export interface QueryAccountAddressSpotOrdersRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Account address of the trader
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.TrimmedSpotLimitOrder
 */
export interface TrimmedSpotLimitOrder {
    /**
     * price of the order (in human readable format)
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * quantity of the order (in human readable format)
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * the amount of the quantity remaining fillable (in human readable format)
     *
     * @generated from protobuf field: string fillable = 3
     */
    fillable: string;
    /**
     * true if the order is a buy
     *
     * @generated from protobuf field: bool isBuy = 4
     */
    isBuy: boolean;
    /**
     * the order hash (optional)
     *
     * @generated from protobuf field: string order_hash = 5
     */
    orderHash: string;
    /**
     * the client order ID (optional)
     *
     * @generated from protobuf field: string cid = 6
     */
    cid: string;
}
/**
 * QueryTraderSpotOrdersResponse is the response type for the
 * Query/TraderSpotOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderSpotOrdersResponse
 */
export interface QueryTraderSpotOrdersResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedSpotLimitOrder orders = 1
     */
    orders: TrimmedSpotLimitOrder[];
}
/**
 * QueryAccountAddressSpotOrdersResponse is the response type for the
 * Query/AccountAddressSpotOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAccountAddressSpotOrdersResponse
 */
export interface QueryAccountAddressSpotOrdersResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedSpotLimitOrder orders = 1
     */
    orders: TrimmedSpotLimitOrder[];
}
/**
 * QuerySpotMidPriceAndTOBRequest is the request type for the
 * Query/SpotMidPriceAndTOB RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotMidPriceAndTOBRequest
 */
export interface QuerySpotMidPriceAndTOBRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QuerySpotMidPriceAndTOBResponse is the response type for the
 * Query/SpotMidPriceAndTOB RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySpotMidPriceAndTOBResponse
 */
export interface QuerySpotMidPriceAndTOBResponse {
    /**
     * mid price of the market (in human readable format)
     *
     * @generated from protobuf field: string mid_price = 1
     */
    midPrice: string;
    /**
     * best buy price of the market (in human readable format)
     *
     * @generated from protobuf field: string best_buy_price = 2
     */
    bestBuyPrice: string;
    /**
     * best sell price of the market
     *
     * @generated from protobuf field: string best_sell_price = 3
     */
    bestSellPrice: string;
}
/**
 * QueryDerivativeMidPriceAndTOBRequest is the request type for the
 * Query/GetDerivativeMidPriceAndTOB RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMidPriceAndTOBRequest
 */
export interface QueryDerivativeMidPriceAndTOBRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryDerivativeMidPriceAndTOBResponse is the response type for the
 * Query/GetDerivativeMidPriceAndTOB RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMidPriceAndTOBResponse
 */
export interface QueryDerivativeMidPriceAndTOBResponse {
    /**
     * mid price of the market
     *
     * @generated from protobuf field: string mid_price = 1
     */
    midPrice: string;
    /**
     * best buy price of the market
     *
     * @generated from protobuf field: string best_buy_price = 2
     */
    bestBuyPrice: string;
    /**
     * best sell price of the market
     *
     * @generated from protobuf field: string best_sell_price = 3
     */
    bestSellPrice: string;
}
/**
 * QueryDerivativeOrderbookRequest is the request type for the
 * Query/DerivativeOrderbook RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeOrderbookRequest
 */
export interface QueryDerivativeOrderbookRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: uint64 limit = 2
     */
    limit: bigint;
    /**
     * @generated from protobuf field: string limit_cumulative_notional = 3
     */
    limitCumulativeNotional: string;
}
/**
 * QueryDerivativeOrderbookResponse is the response type for the
 * Query/DerivativeOrderbook RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeOrderbookResponse
 */
export interface QueryDerivativeOrderbookResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.Level buys_price_level = 1
     */
    buysPriceLevel: Level[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.Level sells_price_level = 2
     */
    sellsPriceLevel: Level[];
    /**
     * the current orderbook sequence number
     *
     * @generated from protobuf field: uint64 seq = 3
     */
    seq: bigint;
}
/**
 * QueryTraderSpotOrdersToCancelUpToAmountRequest is the request type for the
 * Query/TraderSpotOrdersToCancelUpToAmountRequest RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderSpotOrdersToCancelUpToAmountRequest
 */
export interface QueryTraderSpotOrdersToCancelUpToAmountRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * SubaccountID of the trader
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the base amount to cancel (free up)
     *
     * @generated from protobuf field: string base_amount = 3
     */
    baseAmount: string;
    /**
     * the quote amount to cancel (free up)
     *
     * @generated from protobuf field: string quote_amount = 4
     */
    quoteAmount: string;
    /**
     * The cancellation strategy
     *
     * @generated from protobuf field: injective.exchange.v2.CancellationStrategy strategy = 5
     */
    strategy: CancellationStrategy;
    /**
     * The reference price for the cancellation strategy, e.g. mid price or mark
     * price
     *
     * @generated from protobuf field: string reference_price = 6
     */
    referencePrice: string;
}
/**
 * QueryTraderDerivativeOrdersToCancelUpToAmountRequest is the request type for
 * the Query/TraderDerivativeOrdersToCancelUpToAmountRequest RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderDerivativeOrdersToCancelUpToAmountRequest
 */
export interface QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * SubaccountID of the trader
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the quote amount to cancel (free up)
     *
     * @generated from protobuf field: string quote_amount = 3
     */
    quoteAmount: string;
    /**
     * The cancellation strategy
     *
     * @generated from protobuf field: injective.exchange.v2.CancellationStrategy strategy = 4
     */
    strategy: CancellationStrategy;
    /**
     * The reference price for the cancellation strategy, e.g. mid price or mark
     * price
     *
     * @generated from protobuf field: string reference_price = 5
     */
    referencePrice: string;
}
/**
 * QueryTraderDerivativeOrdersRequest is the request type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderDerivativeOrdersRequest
 */
export interface QueryTraderDerivativeOrdersRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * SubaccountID of the trader
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
}
/**
 * QueryAccountAddressSpotOrdersRequest is the request type for the
 * Query/AccountAddressDerivativeOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAccountAddressDerivativeOrdersRequest
 */
export interface QueryAccountAddressDerivativeOrdersRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Account address of the trader
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.TrimmedDerivativeLimitOrder
 */
export interface TrimmedDerivativeLimitOrder {
    /**
     * price of the order (in human readable format)
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * quantity of the order (in human readable format)
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * margin of the order (in human readable format)
     *
     * @generated from protobuf field: string margin = 3
     */
    margin: string;
    /**
     * the amount of the quantity remaining fillable (in human readable format)
     *
     * @generated from protobuf field: string fillable = 4
     */
    fillable: string;
    /**
     * true if the order is a buy
     *
     * @generated from protobuf field: bool isBuy = 5
     */
    isBuy: boolean;
    /**
     * the order hash (optional)
     *
     * @generated from protobuf field: string order_hash = 6
     */
    orderHash: string;
    /**
     * the client order ID (optional)
     *
     * @generated from protobuf field: string cid = 7
     */
    cid: string;
}
/**
 * QueryTraderDerivativeOrdersResponse is the response type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderDerivativeOrdersResponse
 */
export interface QueryTraderDerivativeOrdersResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders = 1
     */
    orders: TrimmedDerivativeLimitOrder[];
}
/**
 * QueryAccountAddressDerivativeOrdersResponse is the response type for the
 * Query/AccountAddressDerivativeOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryAccountAddressDerivativeOrdersResponse
 */
export interface QueryAccountAddressDerivativeOrdersResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders = 1
     */
    orders: TrimmedDerivativeLimitOrder[];
}
/**
 * QueryTraderDerivativeOrdersRequest is the request type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeOrdersByHashesRequest
 */
export interface QueryDerivativeOrdersByHashesRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * SubaccountID of the trader
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the order hashes
     *
     * @generated from protobuf field: repeated string order_hashes = 3
     */
    orderHashes: string[];
}
/**
 * QueryDerivativeOrdersByHashesResponse is the response type for the
 * Query/DerivativeOrdersByHashes RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeOrdersByHashesResponse
 */
export interface QueryDerivativeOrdersByHashesResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders = 1
     */
    orders: TrimmedDerivativeLimitOrder[];
}
/**
 * QueryDerivativeMarketsRequest is the request type for the
 * Query/DerivativeMarkets RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMarketsRequest
 */
export interface QueryDerivativeMarketsRequest {
    /**
     * Status of the market, for convenience it is set to string - not enum
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
    /**
     * Filter by market IDs
     *
     * @generated from protobuf field: repeated string market_ids = 2
     */
    marketIds: string[];
    /**
     * Flag to return the markets mid price and top of the book buy and sell
     * orders.
     *
     * @generated from protobuf field: bool with_mid_price_and_tob = 3
     */
    withMidPriceAndTob: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v2.PriceLevel
 */
export interface PriceLevel {
    /**
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * quantity
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.PerpetualMarketState
 */
export interface PerpetualMarketState {
    /**
     * @generated from protobuf field: injective.exchange.v2.PerpetualMarketInfo market_info = 1
     */
    marketInfo?: PerpetualMarketInfo;
    /**
     * @generated from protobuf field: injective.exchange.v2.PerpetualMarketFunding funding_info = 2
     */
    fundingInfo?: PerpetualMarketFunding;
}
/**
 * @generated from protobuf message injective.exchange.v2.FullDerivativeMarket
 */
export interface FullDerivativeMarket {
    /**
     * derivative market details
     *
     * @generated from protobuf field: injective.exchange.v2.DerivativeMarket market = 1
     */
    market?: DerivativeMarket;
    /**
     * perpetual market state or expiry futures market state
     *
     * @generated from protobuf oneof: info
     */
    info: {
        oneofKind: "perpetualInfo";
        /**
         * perpetual market info
         *
         * @generated from protobuf field: injective.exchange.v2.PerpetualMarketState perpetual_info = 2
         */
        perpetualInfo: PerpetualMarketState;
    } | {
        oneofKind: "futuresInfo";
        /**
         * expiry futures market info
         *
         * @generated from protobuf field: injective.exchange.v2.ExpiryFuturesMarketInfo futures_info = 3
         */
        futuresInfo: ExpiryFuturesMarketInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * mark price (in human readable format)
     *
     * @generated from protobuf field: string mark_price = 4
     */
    markPrice: string;
    /**
     * mid_price_and_tob defines the mid price for this market and the best ask
     * and bid orders
     *
     * @generated from protobuf field: injective.exchange.v2.MidPriceAndTOB mid_price_and_tob = 5
     */
    midPriceAndTob?: MidPriceAndTOB;
}
/**
 * QueryDerivativeMarketsResponse is the response type for the
 * Query/DerivativeMarkets RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMarketsResponse
 */
export interface QueryDerivativeMarketsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.FullDerivativeMarket markets = 1
     */
    markets: FullDerivativeMarket[];
}
/**
 * QueryDerivativeMarketRequest is the request type for the
 * Query/DerivativeMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMarketRequest
 */
export interface QueryDerivativeMarketRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryDerivativeMarketResponse is the response type for the
 * Query/DerivativeMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMarketResponse
 */
export interface QueryDerivativeMarketResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.FullDerivativeMarket market = 1
     */
    market?: FullDerivativeMarket;
}
/**
 * QueryDerivativeMarketAddressRequest is the request type for the
 * Query/DerivativeMarketAddress RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMarketAddressRequest
 */
export interface QueryDerivativeMarketAddressRequest {
    /**
     * Market ID for the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryDerivativeMarketAddressResponse is the response type for the
 * Query/DerivativeMarketAddress RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryDerivativeMarketAddressResponse
 */
export interface QueryDerivativeMarketAddressResponse {
    /**
     * address for the market
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * subaccountID for the market
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
}
/**
 * QuerySubaccountTradeNonceRequest is the request type for the
 * Query/SubaccountTradeNonce RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountTradeNonceRequest
 */
export interface QuerySubaccountTradeNonceRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
}
/**
 * QueryPositionsInMarketRequest is the request type for the
 * Query/PositionsInMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPositionsInMarketRequest
 */
export interface QueryPositionsInMarketRequest {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryPositionsInMarketResponse is the response type for the
 * Query/PositionsInMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPositionsInMarketResponse
 */
export interface QueryPositionsInMarketResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativePosition state = 1
     */
    state: DerivativePosition[];
}
/**
 * QuerySubaccountPositionsRequest is the request type for the
 * Query/SubaccountPositions RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountPositionsRequest
 */
export interface QuerySubaccountPositionsRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
}
/**
 * QuerySubaccountPositionInMarketRequest is the request type for the
 * Query/SubaccountPositionInMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountPositionInMarketRequest
 */
export interface QuerySubaccountPositionInMarketRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
}
/**
 * QuerySubaccountEffectivePositionInMarketRequest is the request type for the
 * Query/SubaccountEffectivePositionInMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountEffectivePositionInMarketRequest
 */
export interface QuerySubaccountEffectivePositionInMarketRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
}
/**
 * QuerySubaccountOrderMetadataRequest is the request type for the
 * Query/SubaccountOrderMetadata RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountOrderMetadataRequest
 */
export interface QuerySubaccountOrderMetadataRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
}
/**
 * QuerySubaccountPositionsResponse is the response type for the
 * Query/SubaccountPositions RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountPositionsResponse
 */
export interface QuerySubaccountPositionsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativePosition state = 1
     */
    state: DerivativePosition[];
}
/**
 * QuerySubaccountPositionInMarketResponse is the response type for the
 * Query/SubaccountPositionInMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountPositionInMarketResponse
 */
export interface QuerySubaccountPositionInMarketResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.Position state = 1
     */
    state?: Position;
}
/**
 * @generated from protobuf message injective.exchange.v2.EffectivePosition
 */
export interface EffectivePosition {
    /**
     * whether the position is long or short
     *
     * @generated from protobuf field: bool is_long = 1
     */
    isLong: boolean;
    /**
     * the quantity of the position (in human readable format)
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * the entry price of the position (in human readable format)
     *
     * @generated from protobuf field: string entry_price = 3
     */
    entryPrice: string;
    /**
     * the effective margin of the position (in human readable format)
     *
     * @generated from protobuf field: string effective_margin = 4
     */
    effectiveMargin: string;
}
/**
 * QuerySubaccountEffectivePositionInMarketResponse is the response type for the
 * Query/SubaccountEffectivePositionInMarket RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountEffectivePositionInMarketResponse
 */
export interface QuerySubaccountEffectivePositionInMarketResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.EffectivePosition state = 1
     */
    state?: EffectivePosition;
}
/**
 * QueryPerpetualMarketInfoRequest is the request type for the
 * Query/PerpetualMarketInfo RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPerpetualMarketInfoRequest
 */
export interface QueryPerpetualMarketInfoRequest {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryPerpetualMarketInfoResponse is the response type for the
 * Query/PerpetualMarketInfo RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPerpetualMarketInfoResponse
 */
export interface QueryPerpetualMarketInfoResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.PerpetualMarketInfo info = 1
     */
    info?: PerpetualMarketInfo;
}
/**
 * QueryExpiryFuturesMarketInfoRequest is the request type for the Query/
 * ExpiryFuturesMarketInfo RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryExpiryFuturesMarketInfoRequest
 */
export interface QueryExpiryFuturesMarketInfoRequest {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryExpiryFuturesMarketInfoResponse is the response type for the Query/
 * ExpiryFuturesMarketInfo RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryExpiryFuturesMarketInfoResponse
 */
export interface QueryExpiryFuturesMarketInfoResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.ExpiryFuturesMarketInfo info = 1
     */
    info?: ExpiryFuturesMarketInfo;
}
/**
 * QueryPerpetualMarketFundingRequest is the request type for the
 * Query/PerpetualMarketFunding RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPerpetualMarketFundingRequest
 */
export interface QueryPerpetualMarketFundingRequest {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * QueryPerpetualMarketFundingResponse is the response type for the
 * Query/PerpetualMarketFunding RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPerpetualMarketFundingResponse
 */
export interface QueryPerpetualMarketFundingResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.PerpetualMarketFunding state = 1
     */
    state?: PerpetualMarketFunding;
}
/**
 * QuerySubaccountOrderMetadataResponse is the response type for the
 * Query/SubaccountOrderMetadata RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountOrderMetadataResponse
 */
export interface QuerySubaccountOrderMetadataResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.SubaccountOrderbookMetadataWithMarket metadata = 1
     */
    metadata: SubaccountOrderbookMetadataWithMarket[];
}
/**
 * QuerySubaccountTradeNonceResponse is the response type for the
 * Query/SubaccountTradeNonce RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QuerySubaccountTradeNonceResponse
 */
export interface QuerySubaccountTradeNonceResponse {
    /**
     * @generated from protobuf field: uint32 nonce = 1
     */
    nonce: number;
}
/**
 * QueryModuleStateRequest is the request type for the Query/ExchangeModuleState
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryModuleStateRequest
 */
export interface QueryModuleStateRequest {
}
/**
 * QueryModuleStateResponse is the response type for the
 * Query/ExchangeModuleState RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryModuleStateResponse
 */
export interface QueryModuleStateResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.GenesisState state = 1
     */
    state?: GenesisState;
}
/**
 * QueryPositionsRequest is the request type for the Query/Positions RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPositionsRequest
 */
export interface QueryPositionsRequest {
}
/**
 * QueryPositionsResponse is the response type for the Query/Positions RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryPositionsResponse
 */
export interface QueryPositionsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativePosition state = 1
     */
    state: DerivativePosition[];
}
/**
 * QueryTradeRewardPointsRequest is the request type for the
 * Query/TradeRewardPoints RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTradeRewardPointsRequest
 */
export interface QueryTradeRewardPointsRequest {
    /**
     * @generated from protobuf field: repeated string accounts = 1
     */
    accounts: string[];
    /**
     * @generated from protobuf field: int64 pending_pool_timestamp = 2
     */
    pendingPoolTimestamp: bigint;
}
/**
 * QueryTradeRewardPointsResponse is the response type for the
 * Query/TradeRewardPoints RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTradeRewardPointsResponse
 */
export interface QueryTradeRewardPointsResponse {
    /**
     * @generated from protobuf field: repeated string account_trade_reward_points = 1
     */
    accountTradeRewardPoints: string[];
}
/**
 * QueryTradeRewardCampaignRequest is the request type for the
 * Query/TradeRewardCampaign RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTradeRewardCampaignRequest
 */
export interface QueryTradeRewardCampaignRequest {
}
/**
 * QueryTradeRewardCampaignResponse is the response type for the
 * Query/TradeRewardCampaign RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTradeRewardCampaignResponse
 */
export interface QueryTradeRewardCampaignResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info = 1
     */
    tradingRewardCampaignInfo?: TradingRewardCampaignInfo;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule = 2
     */
    tradingRewardPoolCampaignSchedule: CampaignRewardPool[];
    /**
     * @generated from protobuf field: string total_trade_reward_points = 3
     */
    totalTradeRewardPoints: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4
     */
    pendingTradingRewardPoolCampaignSchedule: CampaignRewardPool[];
    /**
     * @generated from protobuf field: repeated string pending_total_trade_reward_points = 5
     */
    pendingTotalTradeRewardPoints: string[];
}
/**
 * QueryIsRegisteredDMMRequest is the request type for the Query/IsRegisteredDMM
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryIsOptedOutOfRewardsRequest
 */
export interface QueryIsOptedOutOfRewardsRequest {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
}
/**
 * QueryIsRegisteredDMMResponse is the response type for the
 * Query/IsRegisteredDMM RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryIsOptedOutOfRewardsResponse
 */
export interface QueryIsOptedOutOfRewardsResponse {
    /**
     * @generated from protobuf field: bool is_opted_out = 1
     */
    isOptedOut: boolean;
}
/**
 * QueryRegisteredDMMsRequest is the request type for the Query/RegisteredDMMs
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryOptedOutOfRewardsAccountsRequest
 */
export interface QueryOptedOutOfRewardsAccountsRequest {
}
/**
 * QueryRegisteredDMMsResponse is the response type for the Query/RegisteredDMMs
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryOptedOutOfRewardsAccountsResponse
 */
export interface QueryOptedOutOfRewardsAccountsResponse {
    /**
     * @generated from protobuf field: repeated string accounts = 1
     */
    accounts: string[];
}
/**
 * QueryFeeDiscountAccountInfoRequest is the request type for the
 * Query/FeeDiscountAccountInfo RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFeeDiscountAccountInfoRequest
 */
export interface QueryFeeDiscountAccountInfoRequest {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
}
/**
 * QueryFeeDiscountAccountInfoResponse is the response type for the
 * Query/FeeDiscountAccountInfo RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFeeDiscountAccountInfoResponse
 */
export interface QueryFeeDiscountAccountInfoResponse {
    /**
     * @generated from protobuf field: uint64 tier_level = 1
     */
    tierLevel: bigint;
    /**
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountTierInfo account_info = 2
     */
    accountInfo?: FeeDiscountTierInfo;
    /**
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountTierTTL account_ttl = 3
     */
    accountTtl?: FeeDiscountTierTTL;
}
/**
 * QueryFeeDiscountScheduleRequest is the request type for the
 * Query/FeeDiscountSchedule RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFeeDiscountScheduleRequest
 */
export interface QueryFeeDiscountScheduleRequest {
}
/**
 * QueryFeeDiscountScheduleResponse is the response type for the
 * Query/FeeDiscountSchedule RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFeeDiscountScheduleResponse
 */
export interface QueryFeeDiscountScheduleResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule = 1
     */
    feeDiscountSchedule?: FeeDiscountSchedule;
}
/**
 * QueryBalanceMismatchesRequest is the request type for the
 * Query/QueryBalanceMismatches RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryBalanceMismatchesRequest
 */
export interface QueryBalanceMismatchesRequest {
    /**
     * @generated from protobuf field: int64 dust_factor = 1
     */
    dustFactor: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.BalanceMismatch
 */
export interface BalanceMismatch {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccountId = 1
     */
    subaccountId: string;
    /**
     * the denom of the balance
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * the available balance
     *
     * @generated from protobuf field: string available = 3
     */
    available: string;
    /**
     * the total balance
     *
     * @generated from protobuf field: string total = 4
     */
    total: string;
    /**
     * the balance hold
     *
     * @generated from protobuf field: string balance_hold = 5
     */
    balanceHold: string;
    /**
     * the expected total balance
     *
     * @generated from protobuf field: string expected_total = 6
     */
    expectedTotal: string;
    /**
     * the difference between the total balance and the expected total balance
     *
     * @generated from protobuf field: string difference = 7
     */
    difference: string;
}
/**
 * QueryBalanceMismatchesResponse is the response type for the
 * Query/QueryBalanceMismatches RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryBalanceMismatchesResponse
 */
export interface QueryBalanceMismatchesResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.BalanceMismatch balance_mismatches = 1
     */
    balanceMismatches: BalanceMismatch[];
}
/**
 * QueryBalanceWithBalanceHoldsRequest is the request type for the
 * Query/QueryBalanceWithBalanceHolds RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryBalanceWithBalanceHoldsRequest
 */
export interface QueryBalanceWithBalanceHoldsRequest {
}
/**
 * @generated from protobuf message injective.exchange.v2.BalanceWithMarginHold
 */
export interface BalanceWithMarginHold {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccountId = 1
     */
    subaccountId: string;
    /**
     * the denom of the balance
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * the available balance
     *
     * @generated from protobuf field: string available = 3
     */
    available: string;
    /**
     * the total balance
     *
     * @generated from protobuf field: string total = 4
     */
    total: string;
    /**
     * the balance on hold
     *
     * @generated from protobuf field: string balance_hold = 5
     */
    balanceHold: string;
}
/**
 * QueryBalanceWithBalanceHoldsResponse is the response type for the
 * Query/QueryBalanceWithBalanceHolds RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryBalanceWithBalanceHoldsResponse
 */
export interface QueryBalanceWithBalanceHoldsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.BalanceWithMarginHold balance_with_balance_holds = 1
     */
    balanceWithBalanceHolds: BalanceWithMarginHold[];
}
/**
 * QueryFeeDiscountTierStatisticsRequest is the request type for the
 * Query/QueryFeeDiscountTierStatistics RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFeeDiscountTierStatisticsRequest
 */
export interface QueryFeeDiscountTierStatisticsRequest {
}
/**
 * @generated from protobuf message injective.exchange.v2.TierStatistic
 */
export interface TierStatistic {
    /**
     * @generated from protobuf field: uint64 tier = 1
     */
    tier: bigint;
    /**
     * @generated from protobuf field: uint64 count = 2
     */
    count: bigint;
}
/**
 * QueryFeeDiscountTierStatisticsResponse is the response type for the
 * Query/QueryFeeDiscountTierStatistics RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryFeeDiscountTierStatisticsResponse
 */
export interface QueryFeeDiscountTierStatisticsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TierStatistic statistics = 1
     */
    statistics: TierStatistic[];
}
/**
 * MitoVaultInfosRequest is the request type for the Query/MitoVaultInfos RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.MitoVaultInfosRequest
 */
export interface MitoVaultInfosRequest {
}
/**
 * MitoVaultInfosResponse is the response type for the Query/MitoVaultInfos RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.MitoVaultInfosResponse
 */
export interface MitoVaultInfosResponse {
    /**
     * list of master addresses
     *
     * @generated from protobuf field: repeated string master_addresses = 1
     */
    masterAddresses: string[];
    /**
     * list of derivative addresses
     *
     * @generated from protobuf field: repeated string derivative_addresses = 2
     */
    derivativeAddresses: string[];
    /**
     * list of spot addresses
     *
     * @generated from protobuf field: repeated string spot_addresses = 3
     */
    spotAddresses: string[];
    /**
     * list of cw20 addresses
     *
     * @generated from protobuf field: repeated string cw20_addresses = 4
     */
    cw20Addresses: string[];
}
/**
 * QueryMarketIDFromVaultRequest is the request type for the
 * Query/QueryMarketIDFromVault RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryMarketIDFromVaultRequest
 */
export interface QueryMarketIDFromVaultRequest {
    /**
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
}
/**
 * QueryMarketIDFromVaultResponse is the response type for the
 * Query/QueryMarketIDFromVault RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryMarketIDFromVaultResponse
 */
export interface QueryMarketIDFromVaultResponse {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryHistoricalTradeRecordsRequest
 */
export interface QueryHistoricalTradeRecordsRequest {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryHistoricalTradeRecordsResponse
 */
export interface QueryHistoricalTradeRecordsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TradeRecords trade_records = 1
     */
    tradeRecords: TradeRecords[];
}
/**
 * TradeHistoryOptions are the optional params for Query/MarketVolatility RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.TradeHistoryOptions
 */
export interface TradeHistoryOptions {
    /**
     * TradeGroupingSec of 0 means use the chain's default grouping
     *
     * @generated from protobuf field: uint64 trade_grouping_sec = 1
     */
    tradeGroupingSec: bigint;
    /**
     * MaxAge restricts the trade records oldest age in seconds from the current
     * block time to consider. A value of 0 means use all the records present on
     * the chain.
     *
     * @generated from protobuf field: uint64 max_age = 2
     */
    maxAge: bigint;
    /**
     * If IncludeRawHistory is true, the raw underlying data used for the
     * computation is included in the response
     *
     * @generated from protobuf field: bool include_raw_history = 4
     */
    includeRawHistory: boolean;
    /**
     * If IncludeMetadata is true, metadata on the computation is included in the
     * response
     *
     * @generated from protobuf field: bool include_metadata = 5
     */
    includeMetadata: boolean;
}
/**
 * QueryMarketVolatilityRequest are the request params for the
 * Query/MarketVolatility RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryMarketVolatilityRequest
 */
export interface QueryMarketVolatilityRequest {
    /**
     * the market ID to query volatility for
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the trade history options
     *
     * @generated from protobuf field: injective.exchange.v2.TradeHistoryOptions trade_history_options = 2
     */
    tradeHistoryOptions?: TradeHistoryOptions;
}
/**
 * QueryMarketVolatilityResponse is the response type for the
 * Query/MarketVolatility RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryMarketVolatilityResponse
 */
export interface QueryMarketVolatilityResponse {
    /**
     * @generated from protobuf field: string volatility = 1
     */
    volatility: string;
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.MetadataStatistics history_metadata = 2
     */
    historyMetadata?: MetadataStatistics;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TradeRecord raw_history = 3
     */
    rawHistory: TradeRecord[];
}
/**
 * QuerBinaryMarketsRequest is the request type for the Query/BinaryMarkets RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryBinaryMarketsRequest
 */
export interface QueryBinaryMarketsRequest {
    /**
     * Status of the market, for convenience it is set to string - not enum
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
}
/**
 * QueryBinaryMarketsResponse is the response type for the Query/BinaryMarkets
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryBinaryMarketsResponse
 */
export interface QueryBinaryMarketsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.BinaryOptionsMarket markets = 1
     */
    markets: BinaryOptionsMarket[];
}
/**
 * QueryConditionalOrdersRequest is the request type for the
 * Query/ConditionalOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderDerivativeConditionalOrdersRequest
 */
export interface QueryTraderDerivativeConditionalOrdersRequest {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.TrimmedDerivativeConditionalOrder
 */
export interface TrimmedDerivativeConditionalOrder {
    /**
     * price of the order (in human readable format)
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * quantity of the order (in human readable format)
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * margin of the order (in human readable format)
     *
     * @generated from protobuf field: string margin = 3
     */
    margin: string;
    /**
     * price to trigger the order (in human readable format)
     *
     * @generated from protobuf field: string triggerPrice = 4
     */
    triggerPrice: string;
    /**
     * true if the order is a buy
     *
     * @generated from protobuf field: bool isBuy = 5
     */
    isBuy: boolean;
    /**
     * true if the order is a limit order
     *
     * @generated from protobuf field: bool isLimit = 6
     */
    isLimit: boolean;
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 7
     */
    orderHash: string;
    /**
     * the client ID
     *
     * @generated from protobuf field: string cid = 8
     */
    cid: string;
}
/**
 * QueryTraderDerivativeOrdersResponse is the response type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from protobuf message injective.exchange.v2.QueryTraderDerivativeConditionalOrdersResponse
 */
export interface QueryTraderDerivativeConditionalOrdersResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedDerivativeConditionalOrder orders = 1
     */
    orders: TrimmedDerivativeConditionalOrder[];
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryFullSpotOrderbookRequest
 */
export interface QueryFullSpotOrderbookRequest {
    /**
     * market id
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryFullSpotOrderbookResponse
 */
export interface QueryFullSpotOrderbookResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedLimitOrder Bids = 1
     */
    bids: TrimmedLimitOrder[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedLimitOrder Asks = 2
     */
    asks: TrimmedLimitOrder[];
    /**
     * the current orderbook sequence number
     *
     * @generated from protobuf field: uint64 seq = 3
     */
    seq: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryFullDerivativeOrderbookRequest
 */
export interface QueryFullDerivativeOrderbookRequest {
    /**
     * market id
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryFullDerivativeOrderbookResponse
 */
export interface QueryFullDerivativeOrderbookResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedLimitOrder Bids = 1
     */
    bids: TrimmedLimitOrder[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TrimmedLimitOrder Asks = 2
     */
    asks: TrimmedLimitOrder[];
    /**
     * the current orderbook sequence number
     *
     * @generated from protobuf field: uint64 seq = 3
     */
    seq: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v2.TrimmedLimitOrder
 */
export interface TrimmedLimitOrder {
    /**
     * price of the order (in human readable format)
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * quantity of the order (in human readable format)
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 3
     */
    orderHash: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierRequest
 */
export interface QueryMarketAtomicExecutionFeeMultiplierRequest {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierResponse
 */
export interface QueryMarketAtomicExecutionFeeMultiplierResponse {
    /**
     * @generated from protobuf field: string multiplier = 1
     */
    multiplier: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryActiveStakeGrantRequest
 */
export interface QueryActiveStakeGrantRequest {
    /**
     * @generated from protobuf field: string grantee = 1
     */
    grantee: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryActiveStakeGrantResponse
 */
export interface QueryActiveStakeGrantResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.ActiveGrant grant = 1
     */
    grant?: ActiveGrant;
    /**
     * @generated from protobuf field: injective.exchange.v2.EffectiveGrant effective_grant = 2
     */
    effectiveGrant?: EffectiveGrant;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryGrantAuthorizationRequest
 */
export interface QueryGrantAuthorizationRequest {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
    /**
     * @generated from protobuf field: string grantee = 2
     */
    grantee: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryGrantAuthorizationResponse
 */
export interface QueryGrantAuthorizationResponse {
    /**
     * @generated from protobuf field: string amount = 1
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryGrantAuthorizationsRequest
 */
export interface QueryGrantAuthorizationsRequest {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryGrantAuthorizationsResponse
 */
export interface QueryGrantAuthorizationsResponse {
    /**
     * @generated from protobuf field: string total_grant_amount = 1
     */
    totalGrantAmount: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.GrantAuthorization grants = 2
     */
    grants: GrantAuthorization[];
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryMarketBalanceRequest
 */
export interface QueryMarketBalanceRequest {
    /**
     * market id
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryMarketBalanceResponse
 */
export interface QueryMarketBalanceResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.MarketBalance balance = 1
     */
    balance?: MarketBalance;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryMarketBalancesRequest
 */
export interface QueryMarketBalancesRequest {
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryMarketBalancesResponse
 */
export interface QueryMarketBalancesResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.MarketBalance balances = 1
     */
    balances: MarketBalance[];
}
/**
 * @generated from protobuf message injective.exchange.v2.MarketBalance
 */
export interface MarketBalance {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the current balance of the market
     *
     * @generated from protobuf field: string balance = 2
     */
    balance: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryDenomMinNotionalRequest
 */
export interface QueryDenomMinNotionalRequest {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryDenomMinNotionalResponse
 */
export interface QueryDenomMinNotionalResponse {
    /**
     * the minimum notional amount for the denom (in human readable format)
     *
     * @generated from protobuf field: string amount = 1
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryDenomMinNotionalsRequest
 */
export interface QueryDenomMinNotionalsRequest {
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryDenomMinNotionalsResponse
 */
export interface QueryDenomMinNotionalsResponse {
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DenomMinNotional denom_min_notionals = 1
     */
    denomMinNotionals: DenomMinNotional[];
}
/**
 * @generated from protobuf message injective.exchange.v2.OpenInterest
 */
export interface OpenInterest {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the open interest of the market
     *
     * @generated from protobuf field: string balance = 2
     */
    balance: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryOpenInterestRequest
 */
export interface QueryOpenInterestRequest {
    /**
     * market id
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.QueryOpenInterestResponse
 */
export interface QueryOpenInterestResponse {
    /**
     * @generated from protobuf field: injective.exchange.v2.OpenInterest amount = 1
     */
    amount?: OpenInterest;
}
/**
 * @generated from protobuf enum injective.exchange.v2.OrderSide
 */
export enum OrderSide {
    /**
     * will return both
     *
     * @generated from protobuf enum value: Side_Unspecified = 0;
     */
    Side_Unspecified = 0,
    /**
     * @generated from protobuf enum value: Buy = 1;
     */
    Buy = 1,
    /**
     * @generated from protobuf enum value: Sell = 2;
     */
    Sell = 2
}
/**
 * CancellationStrategy is the list of cancellation strategies.
 *
 * @generated from protobuf enum injective.exchange.v2.CancellationStrategy
 */
export enum CancellationStrategy {
    /**
     * just cancelling in random order in most efficient way
     *
     * @generated from protobuf enum value: UnspecifiedOrder = 0;
     */
    UnspecifiedOrder = 0,
    /**
     * e.g. for buy orders from lowest to highest price
     *
     * @generated from protobuf enum value: FromWorstToBest = 1;
     */
    FromWorstToBest = 1,
    /**
     * e.g. for buy orders from higest to lowest price
     *
     * @generated from protobuf enum value: FromBestToWorst = 2;
     */
    FromBestToWorst = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Subaccount$Type extends MessageType<Subaccount> {
    constructor() {
        super("injective.exchange.v2.Subaccount", [
            { no: 1, name: "trader", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_nonce", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Subaccount>): Subaccount {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trader = "";
        message.subaccountNonce = 0;
        if (value !== undefined)
            reflectionMergePartial<Subaccount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subaccount): Subaccount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trader */ 1:
                    message.trader = reader.string();
                    break;
                case /* uint32 subaccount_nonce */ 2:
                    message.subaccountNonce = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subaccount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trader = 1; */
        if (message.trader !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trader);
        /* uint32 subaccount_nonce = 2; */
        if (message.subaccountNonce !== 0)
            writer.tag(2, WireType.Varint).uint32(message.subaccountNonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.Subaccount
 */
export const Subaccount = new Subaccount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountOrdersRequest$Type extends MessageType<QuerySubaccountOrdersRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountOrdersRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountOrdersRequest>): QuerySubaccountOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountOrdersRequest): QuerySubaccountOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountOrdersRequest
 */
export const QuerySubaccountOrdersRequest = new QuerySubaccountOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountOrdersResponse$Type extends MessageType<QuerySubaccountOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountOrdersResponse", [
            { no: 1, name: "buy_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountOrderData },
            { no: 2, name: "sell_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountOrderData }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountOrdersResponse>): QuerySubaccountOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buyOrders = [];
        message.sellOrders = [];
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountOrdersResponse): QuerySubaccountOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.SubaccountOrderData buy_orders */ 1:
                    message.buyOrders.push(SubaccountOrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.SubaccountOrderData sell_orders */ 2:
                    message.sellOrders.push(SubaccountOrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.SubaccountOrderData buy_orders = 1; */
        for (let i = 0; i < message.buyOrders.length; i++)
            SubaccountOrderData.internalBinaryWrite(message.buyOrders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.SubaccountOrderData sell_orders = 2; */
        for (let i = 0; i < message.sellOrders.length; i++)
            SubaccountOrderData.internalBinaryWrite(message.sellOrders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountOrdersResponse
 */
export const QuerySubaccountOrdersResponse = new QuerySubaccountOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrderbookMetadataWithMarket$Type extends MessageType<SubaccountOrderbookMetadataWithMarket> {
    constructor() {
        super("injective.exchange.v2.SubaccountOrderbookMetadataWithMarket", [
            { no: 1, name: "metadata", kind: "message", T: () => SubaccountOrderbookMetadata },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "isBuy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrderbookMetadataWithMarket>): SubaccountOrderbookMetadataWithMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isBuy = false;
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrderbookMetadataWithMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrderbookMetadataWithMarket): SubaccountOrderbookMetadataWithMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.SubaccountOrderbookMetadata metadata */ 1:
                    message.metadata = SubaccountOrderbookMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* bool isBuy */ 3:
                    message.isBuy = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrderbookMetadataWithMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.SubaccountOrderbookMetadata metadata = 1; */
        if (message.metadata)
            SubaccountOrderbookMetadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* bool isBuy = 3; */
        if (message.isBuy !== false)
            writer.tag(3, WireType.Varint).bool(message.isBuy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountOrderbookMetadataWithMarket
 */
export const SubaccountOrderbookMetadataWithMarket = new SubaccountOrderbookMetadataWithMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryExchangeParamsRequest$Type extends MessageType<QueryExchangeParamsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryExchangeParamsRequest", []);
    }
    create(value?: PartialMessage<QueryExchangeParamsRequest>): QueryExchangeParamsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryExchangeParamsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryExchangeParamsRequest): QueryExchangeParamsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryExchangeParamsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryExchangeParamsRequest
 */
export const QueryExchangeParamsRequest = new QueryExchangeParamsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryExchangeParamsResponse$Type extends MessageType<QueryExchangeParamsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryExchangeParamsResponse", [
            { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryExchangeParamsResponse>): QueryExchangeParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryExchangeParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryExchangeParamsResponse): QueryExchangeParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.Params params */ 1:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryExchangeParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.Params params = 1; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryExchangeParamsResponse
 */
export const QueryExchangeParamsResponse = new QueryExchangeParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountDepositsRequest$Type extends MessageType<QuerySubaccountDepositsRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountDepositsRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount", kind: "message", T: () => Subaccount, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountDepositsRequest>): QuerySubaccountDepositsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountDepositsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountDepositsRequest): QuerySubaccountDepositsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* injective.exchange.v2.Subaccount subaccount */ 2:
                    message.subaccount = Subaccount.internalBinaryRead(reader, reader.uint32(), options, message.subaccount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountDepositsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* injective.exchange.v2.Subaccount subaccount = 2; */
        if (message.subaccount)
            Subaccount.internalBinaryWrite(message.subaccount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountDepositsRequest
 */
export const QuerySubaccountDepositsRequest = new QuerySubaccountDepositsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountDepositsResponse$Type extends MessageType<QuerySubaccountDepositsResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountDepositsResponse", [
            { no: 1, name: "deposits", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Deposit } }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountDepositsResponse>): QuerySubaccountDepositsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deposits = {};
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountDepositsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountDepositsResponse): QuerySubaccountDepositsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, injective.exchange.v2.Deposit> deposits */ 1:
                    this.binaryReadMap1(message.deposits, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: QuerySubaccountDepositsResponse["deposits"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QuerySubaccountDepositsResponse["deposits"] | undefined, val: QuerySubaccountDepositsResponse["deposits"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Deposit.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for injective.exchange.v2.QuerySubaccountDepositsResponse.deposits");
            }
        }
        map[key ?? ""] = val ?? Deposit.create();
    }
    internalBinaryWrite(message: QuerySubaccountDepositsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, injective.exchange.v2.Deposit> deposits = 1; */
        for (let k of globalThis.Object.keys(message.deposits)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Deposit.internalBinaryWrite(message.deposits[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountDepositsResponse
 */
export const QuerySubaccountDepositsResponse = new QuerySubaccountDepositsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryExchangeBalancesRequest$Type extends MessageType<QueryExchangeBalancesRequest> {
    constructor() {
        super("injective.exchange.v2.QueryExchangeBalancesRequest", []);
    }
    create(value?: PartialMessage<QueryExchangeBalancesRequest>): QueryExchangeBalancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryExchangeBalancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryExchangeBalancesRequest): QueryExchangeBalancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryExchangeBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryExchangeBalancesRequest
 */
export const QueryExchangeBalancesRequest = new QueryExchangeBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryExchangeBalancesResponse$Type extends MessageType<QueryExchangeBalancesResponse> {
    constructor() {
        super("injective.exchange.v2.QueryExchangeBalancesResponse", [
            { no: 1, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Balance, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryExchangeBalancesResponse>): QueryExchangeBalancesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<QueryExchangeBalancesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryExchangeBalancesResponse): QueryExchangeBalancesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.Balance balances */ 1:
                    message.balances.push(Balance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryExchangeBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.Balance balances = 1; */
        for (let i = 0; i < message.balances.length; i++)
            Balance.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryExchangeBalancesResponse
 */
export const QueryExchangeBalancesResponse = new QueryExchangeBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateVolumeRequest$Type extends MessageType<QueryAggregateVolumeRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateVolumeRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateVolumeRequest>): QueryAggregateVolumeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateVolumeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateVolumeRequest): QueryAggregateVolumeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateVolumeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateVolumeRequest
 */
export const QueryAggregateVolumeRequest = new QueryAggregateVolumeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateVolumeResponse$Type extends MessageType<QueryAggregateVolumeResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateVolumeResponse", [
            { no: 1, name: "aggregate_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateVolumeResponse>): QueryAggregateVolumeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aggregateVolumes = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateVolumeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateVolumeResponse): QueryAggregateVolumeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.MarketVolume aggregate_volumes */ 1:
                    message.aggregateVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateVolumeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.MarketVolume aggregate_volumes = 1; */
        for (let i = 0; i < message.aggregateVolumes.length; i++)
            MarketVolume.internalBinaryWrite(message.aggregateVolumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateVolumeResponse
 */
export const QueryAggregateVolumeResponse = new QueryAggregateVolumeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateVolumesRequest$Type extends MessageType<QueryAggregateVolumesRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateVolumesRequest", [
            { no: 1, name: "accounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateVolumesRequest>): QueryAggregateVolumesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accounts = [];
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateVolumesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateVolumesRequest): QueryAggregateVolumesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accounts */ 1:
                    message.accounts.push(reader.string());
                    break;
                case /* repeated string market_ids */ 2:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateVolumesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
        /* repeated string market_ids = 2; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateVolumesRequest
 */
export const QueryAggregateVolumesRequest = new QueryAggregateVolumesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateVolumesResponse$Type extends MessageType<QueryAggregateVolumesResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateVolumesResponse", [
            { no: 1, name: "aggregate_account_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AggregateAccountVolumeRecord },
            { no: 2, name: "aggregate_market_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateVolumesResponse>): QueryAggregateVolumesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aggregateAccountVolumes = [];
        message.aggregateMarketVolumes = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateVolumesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateVolumesResponse): QueryAggregateVolumesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.AggregateAccountVolumeRecord aggregate_account_volumes */ 1:
                    message.aggregateAccountVolumes.push(AggregateAccountVolumeRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.MarketVolume aggregate_market_volumes */ 2:
                    message.aggregateMarketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateVolumesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.AggregateAccountVolumeRecord aggregate_account_volumes = 1; */
        for (let i = 0; i < message.aggregateAccountVolumes.length; i++)
            AggregateAccountVolumeRecord.internalBinaryWrite(message.aggregateAccountVolumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.MarketVolume aggregate_market_volumes = 2; */
        for (let i = 0; i < message.aggregateMarketVolumes.length; i++)
            MarketVolume.internalBinaryWrite(message.aggregateMarketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateVolumesResponse
 */
export const QueryAggregateVolumesResponse = new QueryAggregateVolumesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateMarketVolumeRequest$Type extends MessageType<QueryAggregateMarketVolumeRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateMarketVolumeRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateMarketVolumeRequest>): QueryAggregateMarketVolumeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateMarketVolumeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateMarketVolumeRequest): QueryAggregateMarketVolumeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateMarketVolumeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateMarketVolumeRequest
 */
export const QueryAggregateMarketVolumeRequest = new QueryAggregateMarketVolumeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateMarketVolumeResponse$Type extends MessageType<QueryAggregateMarketVolumeResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateMarketVolumeResponse", [
            { no: 1, name: "volume", kind: "message", T: () => VolumeRecord, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateMarketVolumeResponse>): QueryAggregateMarketVolumeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateMarketVolumeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateMarketVolumeResponse): QueryAggregateMarketVolumeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.VolumeRecord volume */ 1:
                    message.volume = VolumeRecord.internalBinaryRead(reader, reader.uint32(), options, message.volume);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateMarketVolumeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.VolumeRecord volume = 1; */
        if (message.volume)
            VolumeRecord.internalBinaryWrite(message.volume, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateMarketVolumeResponse
 */
export const QueryAggregateMarketVolumeResponse = new QueryAggregateMarketVolumeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAuctionExchangeTransferDenomDecimalRequest$Type extends MessageType<QueryAuctionExchangeTransferDenomDecimalRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalRequest", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAuctionExchangeTransferDenomDecimalRequest>): QueryAuctionExchangeTransferDenomDecimalRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<QueryAuctionExchangeTransferDenomDecimalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAuctionExchangeTransferDenomDecimalRequest): QueryAuctionExchangeTransferDenomDecimalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAuctionExchangeTransferDenomDecimalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalRequest
 */
export const QueryAuctionExchangeTransferDenomDecimalRequest = new QueryAuctionExchangeTransferDenomDecimalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAuctionExchangeTransferDenomDecimalResponse$Type extends MessageType<QueryAuctionExchangeTransferDenomDecimalResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalResponse", [
            { no: 1, name: "decimal", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAuctionExchangeTransferDenomDecimalResponse>): QueryAuctionExchangeTransferDenomDecimalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.decimal = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryAuctionExchangeTransferDenomDecimalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAuctionExchangeTransferDenomDecimalResponse): QueryAuctionExchangeTransferDenomDecimalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 decimal */ 1:
                    message.decimal = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAuctionExchangeTransferDenomDecimalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 decimal = 1; */
        if (message.decimal !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.decimal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalResponse
 */
export const QueryAuctionExchangeTransferDenomDecimalResponse = new QueryAuctionExchangeTransferDenomDecimalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAuctionExchangeTransferDenomDecimalsRequest$Type extends MessageType<QueryAuctionExchangeTransferDenomDecimalsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsRequest", [
            { no: 1, name: "denoms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAuctionExchangeTransferDenomDecimalsRequest>): QueryAuctionExchangeTransferDenomDecimalsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denoms = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAuctionExchangeTransferDenomDecimalsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAuctionExchangeTransferDenomDecimalsRequest): QueryAuctionExchangeTransferDenomDecimalsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string denoms */ 1:
                    message.denoms.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAuctionExchangeTransferDenomDecimalsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string denoms = 1; */
        for (let i = 0; i < message.denoms.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.denoms[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsRequest
 */
export const QueryAuctionExchangeTransferDenomDecimalsRequest = new QueryAuctionExchangeTransferDenomDecimalsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAuctionExchangeTransferDenomDecimalsResponse$Type extends MessageType<QueryAuctionExchangeTransferDenomDecimalsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsResponse", [
            { no: 1, name: "denom_decimals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DenomDecimals, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryAuctionExchangeTransferDenomDecimalsResponse>): QueryAuctionExchangeTransferDenomDecimalsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denomDecimals = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAuctionExchangeTransferDenomDecimalsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAuctionExchangeTransferDenomDecimalsResponse): QueryAuctionExchangeTransferDenomDecimalsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.DenomDecimals denom_decimals */ 1:
                    message.denomDecimals.push(DenomDecimals.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAuctionExchangeTransferDenomDecimalsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.DenomDecimals denom_decimals = 1; */
        for (let i = 0; i < message.denomDecimals.length; i++)
            DenomDecimals.internalBinaryWrite(message.denomDecimals[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAuctionExchangeTransferDenomDecimalsResponse
 */
export const QueryAuctionExchangeTransferDenomDecimalsResponse = new QueryAuctionExchangeTransferDenomDecimalsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateMarketVolumesRequest$Type extends MessageType<QueryAggregateMarketVolumesRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateMarketVolumesRequest", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateMarketVolumesRequest>): QueryAggregateMarketVolumesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateMarketVolumesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateMarketVolumesRequest): QueryAggregateMarketVolumesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateMarketVolumesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateMarketVolumesRequest
 */
export const QueryAggregateMarketVolumesRequest = new QueryAggregateMarketVolumesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAggregateMarketVolumesResponse$Type extends MessageType<QueryAggregateMarketVolumesResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAggregateMarketVolumesResponse", [
            { no: 1, name: "volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<QueryAggregateMarketVolumesResponse>): QueryAggregateMarketVolumesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.volumes = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAggregateMarketVolumesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAggregateMarketVolumesResponse): QueryAggregateMarketVolumesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.MarketVolume volumes */ 1:
                    message.volumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAggregateMarketVolumesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.MarketVolume volumes = 1; */
        for (let i = 0; i < message.volumes.length; i++)
            MarketVolume.internalBinaryWrite(message.volumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAggregateMarketVolumesResponse
 */
export const QueryAggregateMarketVolumesResponse = new QueryAggregateMarketVolumesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountDepositRequest$Type extends MessageType<QuerySubaccountDepositRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountDepositRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountDepositRequest>): QuerySubaccountDepositRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountDepositRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountDepositRequest): QuerySubaccountDepositRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountDepositRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountDepositRequest
 */
export const QuerySubaccountDepositRequest = new QuerySubaccountDepositRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountDepositResponse$Type extends MessageType<QuerySubaccountDepositResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountDepositResponse", [
            { no: 1, name: "deposits", kind: "message", T: () => Deposit }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountDepositResponse>): QuerySubaccountDepositResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountDepositResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountDepositResponse): QuerySubaccountDepositResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.Deposit deposits */ 1:
                    message.deposits = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposits);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountDepositResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.Deposit deposits = 1; */
        if (message.deposits)
            Deposit.internalBinaryWrite(message.deposits, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountDepositResponse
 */
export const QuerySubaccountDepositResponse = new QuerySubaccountDepositResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotMarketsRequest$Type extends MessageType<QuerySpotMarketsRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySpotMarketsRequest", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySpotMarketsRequest>): QuerySpotMarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<QuerySpotMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotMarketsRequest): QuerySpotMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* repeated string market_ids */ 2:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* repeated string market_ids = 2; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotMarketsRequest
 */
export const QuerySpotMarketsRequest = new QuerySpotMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotMarketsResponse$Type extends MessageType<QuerySpotMarketsResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySpotMarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotMarket }
        ]);
    }
    create(value?: PartialMessage<QuerySpotMarketsResponse>): QuerySpotMarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<QuerySpotMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotMarketsResponse): QuerySpotMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.SpotMarket markets */ 1:
                    message.markets.push(SpotMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.SpotMarket markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            SpotMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotMarketsResponse
 */
export const QuerySpotMarketsResponse = new QuerySpotMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotMarketRequest$Type extends MessageType<QuerySpotMarketRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySpotMarketRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySpotMarketRequest>): QuerySpotMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySpotMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotMarketRequest): QuerySpotMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotMarketRequest
 */
export const QuerySpotMarketRequest = new QuerySpotMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotMarketResponse$Type extends MessageType<QuerySpotMarketResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySpotMarketResponse", [
            { no: 1, name: "market", kind: "message", T: () => SpotMarket }
        ]);
    }
    create(value?: PartialMessage<QuerySpotMarketResponse>): QuerySpotMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QuerySpotMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotMarketResponse): QuerySpotMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.SpotMarket market */ 1:
                    message.market = SpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.SpotMarket market = 1; */
        if (message.market)
            SpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotMarketResponse
 */
export const QuerySpotMarketResponse = new QuerySpotMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotOrderbookRequest$Type extends MessageType<QuerySpotOrderbookRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySpotOrderbookRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "order_side", kind: "enum", T: () => ["injective.exchange.v2.OrderSide", OrderSide] },
            { no: 4, name: "limit_cumulative_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "limit_cumulative_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QuerySpotOrderbookRequest>): QuerySpotOrderbookRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.limit = 0n;
        message.orderSide = 0;
        message.limitCumulativeNotional = "";
        message.limitCumulativeQuantity = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySpotOrderbookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotOrderbookRequest): QuerySpotOrderbookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* uint64 limit */ 2:
                    message.limit = reader.uint64().toBigInt();
                    break;
                case /* injective.exchange.v2.OrderSide order_side */ 3:
                    message.orderSide = reader.int32();
                    break;
                case /* string limit_cumulative_notional */ 4:
                    message.limitCumulativeNotional = reader.string();
                    break;
                case /* string limit_cumulative_quantity */ 5:
                    message.limitCumulativeQuantity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotOrderbookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* uint64 limit = 2; */
        if (message.limit !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.limit);
        /* injective.exchange.v2.OrderSide order_side = 3; */
        if (message.orderSide !== 0)
            writer.tag(3, WireType.Varint).int32(message.orderSide);
        /* string limit_cumulative_notional = 4; */
        if (message.limitCumulativeNotional !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.limitCumulativeNotional);
        /* string limit_cumulative_quantity = 5; */
        if (message.limitCumulativeQuantity !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.limitCumulativeQuantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotOrderbookRequest
 */
export const QuerySpotOrderbookRequest = new QuerySpotOrderbookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotOrderbookResponse$Type extends MessageType<QuerySpotOrderbookResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySpotOrderbookResponse", [
            { no: 1, name: "buys_price_level", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level },
            { no: 2, name: "sells_price_level", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level },
            { no: 3, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySpotOrderbookResponse>): QuerySpotOrderbookResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buysPriceLevel = [];
        message.sellsPriceLevel = [];
        message.seq = 0n;
        if (value !== undefined)
            reflectionMergePartial<QuerySpotOrderbookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotOrderbookResponse): QuerySpotOrderbookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.Level buys_price_level */ 1:
                    message.buysPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.Level sells_price_level */ 2:
                    message.sellsPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 seq */ 3:
                    message.seq = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotOrderbookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.Level buys_price_level = 1; */
        for (let i = 0; i < message.buysPriceLevel.length; i++)
            Level.internalBinaryWrite(message.buysPriceLevel[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.Level sells_price_level = 2; */
        for (let i = 0; i < message.sellsPriceLevel.length; i++)
            Level.internalBinaryWrite(message.sellsPriceLevel[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 seq = 3; */
        if (message.seq !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.seq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotOrderbookResponse
 */
export const QuerySpotOrderbookResponse = new QuerySpotOrderbookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullSpotMarket$Type extends MessageType<FullSpotMarket> {
    constructor() {
        super("injective.exchange.v2.FullSpotMarket", [
            { no: 1, name: "market", kind: "message", T: () => SpotMarket },
            { no: 2, name: "mid_price_and_tob", kind: "message", T: () => MidPriceAndTOB, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<FullSpotMarket>): FullSpotMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FullSpotMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullSpotMarket): FullSpotMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.SpotMarket market */ 1:
                    message.market = SpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* injective.exchange.v2.MidPriceAndTOB mid_price_and_tob */ 2:
                    message.midPriceAndTob = MidPriceAndTOB.internalBinaryRead(reader, reader.uint32(), options, message.midPriceAndTob);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullSpotMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.SpotMarket market = 1; */
        if (message.market)
            SpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.MidPriceAndTOB mid_price_and_tob = 2; */
        if (message.midPriceAndTob)
            MidPriceAndTOB.internalBinaryWrite(message.midPriceAndTob, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FullSpotMarket
 */
export const FullSpotMarket = new FullSpotMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullSpotMarketsRequest$Type extends MessageType<QueryFullSpotMarketsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryFullSpotMarketsRequest", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFullSpotMarketsRequest>): QueryFullSpotMarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.marketIds = [];
        message.withMidPriceAndTob = false;
        if (value !== undefined)
            reflectionMergePartial<QueryFullSpotMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullSpotMarketsRequest): QueryFullSpotMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* repeated string market_ids */ 2:
                    message.marketIds.push(reader.string());
                    break;
                case /* bool with_mid_price_and_tob */ 3:
                    message.withMidPriceAndTob = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullSpotMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* repeated string market_ids = 2; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
        /* bool with_mid_price_and_tob = 3; */
        if (message.withMidPriceAndTob !== false)
            writer.tag(3, WireType.Varint).bool(message.withMidPriceAndTob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullSpotMarketsRequest
 */
export const QueryFullSpotMarketsRequest = new QueryFullSpotMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullSpotMarketsResponse$Type extends MessageType<QueryFullSpotMarketsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryFullSpotMarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FullSpotMarket }
        ]);
    }
    create(value?: PartialMessage<QueryFullSpotMarketsResponse>): QueryFullSpotMarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<QueryFullSpotMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullSpotMarketsResponse): QueryFullSpotMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.FullSpotMarket markets */ 1:
                    message.markets.push(FullSpotMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullSpotMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.FullSpotMarket markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            FullSpotMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullSpotMarketsResponse
 */
export const QueryFullSpotMarketsResponse = new QueryFullSpotMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullSpotMarketRequest$Type extends MessageType<QueryFullSpotMarketRequest> {
    constructor() {
        super("injective.exchange.v2.QueryFullSpotMarketRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFullSpotMarketRequest>): QueryFullSpotMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.withMidPriceAndTob = false;
        if (value !== undefined)
            reflectionMergePartial<QueryFullSpotMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullSpotMarketRequest): QueryFullSpotMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool with_mid_price_and_tob */ 2:
                    message.withMidPriceAndTob = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullSpotMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool with_mid_price_and_tob = 2; */
        if (message.withMidPriceAndTob !== false)
            writer.tag(2, WireType.Varint).bool(message.withMidPriceAndTob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullSpotMarketRequest
 */
export const QueryFullSpotMarketRequest = new QueryFullSpotMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullSpotMarketResponse$Type extends MessageType<QueryFullSpotMarketResponse> {
    constructor() {
        super("injective.exchange.v2.QueryFullSpotMarketResponse", [
            { no: 1, name: "market", kind: "message", T: () => FullSpotMarket }
        ]);
    }
    create(value?: PartialMessage<QueryFullSpotMarketResponse>): QueryFullSpotMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryFullSpotMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullSpotMarketResponse): QueryFullSpotMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.FullSpotMarket market */ 1:
                    message.market = FullSpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullSpotMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.FullSpotMarket market = 1; */
        if (message.market)
            FullSpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullSpotMarketResponse
 */
export const QueryFullSpotMarketResponse = new QueryFullSpotMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotOrdersByHashesRequest$Type extends MessageType<QuerySpotOrdersByHashesRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySpotOrdersByHashesRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySpotOrdersByHashesRequest>): QuerySpotOrdersByHashesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.orderHashes = [];
        if (value !== undefined)
            reflectionMergePartial<QuerySpotOrdersByHashesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotOrdersByHashesRequest): QuerySpotOrdersByHashesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated string order_hashes */ 3:
                    message.orderHashes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotOrdersByHashesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated string order_hashes = 3; */
        for (let i = 0; i < message.orderHashes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.orderHashes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotOrdersByHashesRequest
 */
export const QuerySpotOrdersByHashesRequest = new QuerySpotOrdersByHashesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotOrdersByHashesResponse$Type extends MessageType<QuerySpotOrdersByHashesResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySpotOrdersByHashesResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedSpotLimitOrder }
        ]);
    }
    create(value?: PartialMessage<QuerySpotOrdersByHashesResponse>): QuerySpotOrdersByHashesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<QuerySpotOrdersByHashesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotOrdersByHashesResponse): QuerySpotOrdersByHashesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders */ 1:
                    message.orders.push(TrimmedSpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotOrdersByHashesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            TrimmedSpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotOrdersByHashesResponse
 */
export const QuerySpotOrdersByHashesResponse = new QuerySpotOrdersByHashesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderSpotOrdersRequest$Type extends MessageType<QueryTraderSpotOrdersRequest> {
    constructor() {
        super("injective.exchange.v2.QueryTraderSpotOrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryTraderSpotOrdersRequest>): QueryTraderSpotOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryTraderSpotOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderSpotOrdersRequest): QueryTraderSpotOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderSpotOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderSpotOrdersRequest
 */
export const QueryTraderSpotOrdersRequest = new QueryTraderSpotOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAccountAddressSpotOrdersRequest$Type extends MessageType<QueryAccountAddressSpotOrdersRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAccountAddressSpotOrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAccountAddressSpotOrdersRequest>): QueryAccountAddressSpotOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryAccountAddressSpotOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAccountAddressSpotOrdersRequest): QueryAccountAddressSpotOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAccountAddressSpotOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAccountAddressSpotOrdersRequest
 */
export const QueryAccountAddressSpotOrdersRequest = new QueryAccountAddressSpotOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrimmedSpotLimitOrder$Type extends MessageType<TrimmedSpotLimitOrder> {
    constructor() {
        super("injective.exchange.v2.TrimmedSpotLimitOrder", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "fillable", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "isBuy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrimmedSpotLimitOrder>): TrimmedSpotLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.fillable = "";
        message.isBuy = false;
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<TrimmedSpotLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrimmedSpotLimitOrder): TrimmedSpotLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string fillable */ 3:
                    message.fillable = reader.string();
                    break;
                case /* bool isBuy */ 4:
                    message.isBuy = reader.bool();
                    break;
                case /* string order_hash */ 5:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 6:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrimmedSpotLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string fillable = 3; */
        if (message.fillable !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fillable);
        /* bool isBuy = 4; */
        if (message.isBuy !== false)
            writer.tag(4, WireType.Varint).bool(message.isBuy);
        /* string order_hash = 5; */
        if (message.orderHash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 6; */
        if (message.cid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TrimmedSpotLimitOrder
 */
export const TrimmedSpotLimitOrder = new TrimmedSpotLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderSpotOrdersResponse$Type extends MessageType<QueryTraderSpotOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.QueryTraderSpotOrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedSpotLimitOrder }
        ]);
    }
    create(value?: PartialMessage<QueryTraderSpotOrdersResponse>): QueryTraderSpotOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<QueryTraderSpotOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderSpotOrdersResponse): QueryTraderSpotOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders */ 1:
                    message.orders.push(TrimmedSpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderSpotOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            TrimmedSpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderSpotOrdersResponse
 */
export const QueryTraderSpotOrdersResponse = new QueryTraderSpotOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAccountAddressSpotOrdersResponse$Type extends MessageType<QueryAccountAddressSpotOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAccountAddressSpotOrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedSpotLimitOrder }
        ]);
    }
    create(value?: PartialMessage<QueryAccountAddressSpotOrdersResponse>): QueryAccountAddressSpotOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAccountAddressSpotOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAccountAddressSpotOrdersResponse): QueryAccountAddressSpotOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders */ 1:
                    message.orders.push(TrimmedSpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAccountAddressSpotOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedSpotLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            TrimmedSpotLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAccountAddressSpotOrdersResponse
 */
export const QueryAccountAddressSpotOrdersResponse = new QueryAccountAddressSpotOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotMidPriceAndTOBRequest$Type extends MessageType<QuerySpotMidPriceAndTOBRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySpotMidPriceAndTOBRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySpotMidPriceAndTOBRequest>): QuerySpotMidPriceAndTOBRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySpotMidPriceAndTOBRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotMidPriceAndTOBRequest): QuerySpotMidPriceAndTOBRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotMidPriceAndTOBRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotMidPriceAndTOBRequest
 */
export const QuerySpotMidPriceAndTOBRequest = new QuerySpotMidPriceAndTOBRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySpotMidPriceAndTOBResponse$Type extends MessageType<QuerySpotMidPriceAndTOBResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySpotMidPriceAndTOBResponse", [
            { no: 1, name: "mid_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QuerySpotMidPriceAndTOBResponse>): QuerySpotMidPriceAndTOBResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.midPrice = "";
        message.bestBuyPrice = "";
        message.bestSellPrice = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySpotMidPriceAndTOBResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySpotMidPriceAndTOBResponse): QuerySpotMidPriceAndTOBResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mid_price */ 1:
                    message.midPrice = reader.string();
                    break;
                case /* string best_buy_price */ 2:
                    message.bestBuyPrice = reader.string();
                    break;
                case /* string best_sell_price */ 3:
                    message.bestSellPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySpotMidPriceAndTOBResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mid_price = 1; */
        if (message.midPrice !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
        /* string best_buy_price = 2; */
        if (message.bestBuyPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
        /* string best_sell_price = 3; */
        if (message.bestSellPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySpotMidPriceAndTOBResponse
 */
export const QuerySpotMidPriceAndTOBResponse = new QuerySpotMidPriceAndTOBResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMidPriceAndTOBRequest$Type extends MessageType<QueryDerivativeMidPriceAndTOBRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMidPriceAndTOBRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMidPriceAndTOBRequest>): QueryDerivativeMidPriceAndTOBRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMidPriceAndTOBRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMidPriceAndTOBRequest): QueryDerivativeMidPriceAndTOBRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMidPriceAndTOBRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMidPriceAndTOBRequest
 */
export const QueryDerivativeMidPriceAndTOBRequest = new QueryDerivativeMidPriceAndTOBRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMidPriceAndTOBResponse$Type extends MessageType<QueryDerivativeMidPriceAndTOBResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMidPriceAndTOBResponse", [
            { no: 1, name: "mid_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMidPriceAndTOBResponse>): QueryDerivativeMidPriceAndTOBResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.midPrice = "";
        message.bestBuyPrice = "";
        message.bestSellPrice = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMidPriceAndTOBResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMidPriceAndTOBResponse): QueryDerivativeMidPriceAndTOBResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mid_price */ 1:
                    message.midPrice = reader.string();
                    break;
                case /* string best_buy_price */ 2:
                    message.bestBuyPrice = reader.string();
                    break;
                case /* string best_sell_price */ 3:
                    message.bestSellPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMidPriceAndTOBResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mid_price = 1; */
        if (message.midPrice !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
        /* string best_buy_price = 2; */
        if (message.bestBuyPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
        /* string best_sell_price = 3; */
        if (message.bestSellPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMidPriceAndTOBResponse
 */
export const QueryDerivativeMidPriceAndTOBResponse = new QueryDerivativeMidPriceAndTOBResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeOrderbookRequest$Type extends MessageType<QueryDerivativeOrderbookRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeOrderbookRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit_cumulative_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeOrderbookRequest>): QueryDerivativeOrderbookRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.limit = 0n;
        message.limitCumulativeNotional = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeOrderbookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeOrderbookRequest): QueryDerivativeOrderbookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* uint64 limit */ 2:
                    message.limit = reader.uint64().toBigInt();
                    break;
                case /* string limit_cumulative_notional */ 3:
                    message.limitCumulativeNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeOrderbookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* uint64 limit = 2; */
        if (message.limit !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.limit);
        /* string limit_cumulative_notional = 3; */
        if (message.limitCumulativeNotional !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.limitCumulativeNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeOrderbookRequest
 */
export const QueryDerivativeOrderbookRequest = new QueryDerivativeOrderbookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeOrderbookResponse$Type extends MessageType<QueryDerivativeOrderbookResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeOrderbookResponse", [
            { no: 1, name: "buys_price_level", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level },
            { no: 2, name: "sells_price_level", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level },
            { no: 3, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeOrderbookResponse>): QueryDerivativeOrderbookResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buysPriceLevel = [];
        message.sellsPriceLevel = [];
        message.seq = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeOrderbookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeOrderbookResponse): QueryDerivativeOrderbookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.Level buys_price_level */ 1:
                    message.buysPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.Level sells_price_level */ 2:
                    message.sellsPriceLevel.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 seq */ 3:
                    message.seq = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeOrderbookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.Level buys_price_level = 1; */
        for (let i = 0; i < message.buysPriceLevel.length; i++)
            Level.internalBinaryWrite(message.buysPriceLevel[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.Level sells_price_level = 2; */
        for (let i = 0; i < message.sellsPriceLevel.length; i++)
            Level.internalBinaryWrite(message.sellsPriceLevel[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 seq = 3; */
        if (message.seq !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.seq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeOrderbookResponse
 */
export const QueryDerivativeOrderbookResponse = new QueryDerivativeOrderbookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderSpotOrdersToCancelUpToAmountRequest$Type extends MessageType<QueryTraderSpotOrdersToCancelUpToAmountRequest> {
    constructor() {
        super("injective.exchange.v2.QueryTraderSpotOrdersToCancelUpToAmountRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "base_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "quote_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "strategy", kind: "enum", T: () => ["injective.exchange.v2.CancellationStrategy", CancellationStrategy] },
            { no: 6, name: "reference_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryTraderSpotOrdersToCancelUpToAmountRequest>): QueryTraderSpotOrdersToCancelUpToAmountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.baseAmount = "";
        message.quoteAmount = "";
        message.strategy = 0;
        message.referencePrice = "";
        if (value !== undefined)
            reflectionMergePartial<QueryTraderSpotOrdersToCancelUpToAmountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderSpotOrdersToCancelUpToAmountRequest): QueryTraderSpotOrdersToCancelUpToAmountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string base_amount */ 3:
                    message.baseAmount = reader.string();
                    break;
                case /* string quote_amount */ 4:
                    message.quoteAmount = reader.string();
                    break;
                case /* injective.exchange.v2.CancellationStrategy strategy */ 5:
                    message.strategy = reader.int32();
                    break;
                case /* string reference_price */ 6:
                    message.referencePrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderSpotOrdersToCancelUpToAmountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string base_amount = 3; */
        if (message.baseAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.baseAmount);
        /* string quote_amount = 4; */
        if (message.quoteAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quoteAmount);
        /* injective.exchange.v2.CancellationStrategy strategy = 5; */
        if (message.strategy !== 0)
            writer.tag(5, WireType.Varint).int32(message.strategy);
        /* string reference_price = 6; */
        if (message.referencePrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.referencePrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderSpotOrdersToCancelUpToAmountRequest
 */
export const QueryTraderSpotOrdersToCancelUpToAmountRequest = new QueryTraderSpotOrdersToCancelUpToAmountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderDerivativeOrdersToCancelUpToAmountRequest$Type extends MessageType<QueryTraderDerivativeOrdersToCancelUpToAmountRequest> {
    constructor() {
        super("injective.exchange.v2.QueryTraderDerivativeOrdersToCancelUpToAmountRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "strategy", kind: "enum", T: () => ["injective.exchange.v2.CancellationStrategy", CancellationStrategy] },
            { no: 5, name: "reference_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryTraderDerivativeOrdersToCancelUpToAmountRequest>): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.quoteAmount = "";
        message.strategy = 0;
        message.referencePrice = "";
        if (value !== undefined)
            reflectionMergePartial<QueryTraderDerivativeOrdersToCancelUpToAmountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderDerivativeOrdersToCancelUpToAmountRequest): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string quote_amount */ 3:
                    message.quoteAmount = reader.string();
                    break;
                case /* injective.exchange.v2.CancellationStrategy strategy */ 4:
                    message.strategy = reader.int32();
                    break;
                case /* string reference_price */ 5:
                    message.referencePrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderDerivativeOrdersToCancelUpToAmountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string quote_amount = 3; */
        if (message.quoteAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteAmount);
        /* injective.exchange.v2.CancellationStrategy strategy = 4; */
        if (message.strategy !== 0)
            writer.tag(4, WireType.Varint).int32(message.strategy);
        /* string reference_price = 5; */
        if (message.referencePrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.referencePrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderDerivativeOrdersToCancelUpToAmountRequest
 */
export const QueryTraderDerivativeOrdersToCancelUpToAmountRequest = new QueryTraderDerivativeOrdersToCancelUpToAmountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderDerivativeOrdersRequest$Type extends MessageType<QueryTraderDerivativeOrdersRequest> {
    constructor() {
        super("injective.exchange.v2.QueryTraderDerivativeOrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryTraderDerivativeOrdersRequest>): QueryTraderDerivativeOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryTraderDerivativeOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderDerivativeOrdersRequest): QueryTraderDerivativeOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderDerivativeOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderDerivativeOrdersRequest
 */
export const QueryTraderDerivativeOrdersRequest = new QueryTraderDerivativeOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAccountAddressDerivativeOrdersRequest$Type extends MessageType<QueryAccountAddressDerivativeOrdersRequest> {
    constructor() {
        super("injective.exchange.v2.QueryAccountAddressDerivativeOrdersRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAccountAddressDerivativeOrdersRequest>): QueryAccountAddressDerivativeOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryAccountAddressDerivativeOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAccountAddressDerivativeOrdersRequest): QueryAccountAddressDerivativeOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAccountAddressDerivativeOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAccountAddressDerivativeOrdersRequest
 */
export const QueryAccountAddressDerivativeOrdersRequest = new QueryAccountAddressDerivativeOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrimmedDerivativeLimitOrder$Type extends MessageType<TrimmedDerivativeLimitOrder> {
    constructor() {
        super("injective.exchange.v2.TrimmedDerivativeLimitOrder", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "fillable", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "isBuy", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "isBuy" } },
            { no: 6, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrimmedDerivativeLimitOrder>): TrimmedDerivativeLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.margin = "";
        message.fillable = "";
        message.isBuy = false;
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<TrimmedDerivativeLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrimmedDerivativeLimitOrder): TrimmedDerivativeLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string margin */ 3:
                    message.margin = reader.string();
                    break;
                case /* string fillable */ 4:
                    message.fillable = reader.string();
                    break;
                case /* bool isBuy */ 5:
                    message.isBuy = reader.bool();
                    break;
                case /* string order_hash */ 6:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 7:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrimmedDerivativeLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string margin = 3; */
        if (message.margin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.margin);
        /* string fillable = 4; */
        if (message.fillable !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fillable);
        /* bool isBuy = 5; */
        if (message.isBuy !== false)
            writer.tag(5, WireType.Varint).bool(message.isBuy);
        /* string order_hash = 6; */
        if (message.orderHash !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 7; */
        if (message.cid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TrimmedDerivativeLimitOrder
 */
export const TrimmedDerivativeLimitOrder = new TrimmedDerivativeLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderDerivativeOrdersResponse$Type extends MessageType<QueryTraderDerivativeOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.QueryTraderDerivativeOrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedDerivativeLimitOrder }
        ]);
    }
    create(value?: PartialMessage<QueryTraderDerivativeOrdersResponse>): QueryTraderDerivativeOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<QueryTraderDerivativeOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderDerivativeOrdersResponse): QueryTraderDerivativeOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders */ 1:
                    message.orders.push(TrimmedDerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderDerivativeOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            TrimmedDerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderDerivativeOrdersResponse
 */
export const QueryTraderDerivativeOrdersResponse = new QueryTraderDerivativeOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAccountAddressDerivativeOrdersResponse$Type extends MessageType<QueryAccountAddressDerivativeOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.QueryAccountAddressDerivativeOrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedDerivativeLimitOrder }
        ]);
    }
    create(value?: PartialMessage<QueryAccountAddressDerivativeOrdersResponse>): QueryAccountAddressDerivativeOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<QueryAccountAddressDerivativeOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAccountAddressDerivativeOrdersResponse): QueryAccountAddressDerivativeOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders */ 1:
                    message.orders.push(TrimmedDerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAccountAddressDerivativeOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            TrimmedDerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryAccountAddressDerivativeOrdersResponse
 */
export const QueryAccountAddressDerivativeOrdersResponse = new QueryAccountAddressDerivativeOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeOrdersByHashesRequest$Type extends MessageType<QueryDerivativeOrdersByHashesRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeOrdersByHashesRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeOrdersByHashesRequest>): QueryDerivativeOrdersByHashesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.orderHashes = [];
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeOrdersByHashesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeOrdersByHashesRequest): QueryDerivativeOrdersByHashesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated string order_hashes */ 3:
                    message.orderHashes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeOrdersByHashesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated string order_hashes = 3; */
        for (let i = 0; i < message.orderHashes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.orderHashes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeOrdersByHashesRequest
 */
export const QueryDerivativeOrdersByHashesRequest = new QueryDerivativeOrdersByHashesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeOrdersByHashesResponse$Type extends MessageType<QueryDerivativeOrdersByHashesResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeOrdersByHashesResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedDerivativeLimitOrder }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeOrdersByHashesResponse>): QueryDerivativeOrdersByHashesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeOrdersByHashesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeOrdersByHashesResponse): QueryDerivativeOrdersByHashesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders */ 1:
                    message.orders.push(TrimmedDerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeOrdersByHashesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedDerivativeLimitOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            TrimmedDerivativeLimitOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeOrdersByHashesResponse
 */
export const QueryDerivativeOrdersByHashesResponse = new QueryDerivativeOrdersByHashesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMarketsRequest$Type extends MessageType<QueryDerivativeMarketsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMarketsRequest", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMarketsRequest>): QueryDerivativeMarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.marketIds = [];
        message.withMidPriceAndTob = false;
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMarketsRequest): QueryDerivativeMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* repeated string market_ids */ 2:
                    message.marketIds.push(reader.string());
                    break;
                case /* bool with_mid_price_and_tob */ 3:
                    message.withMidPriceAndTob = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* repeated string market_ids = 2; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
        /* bool with_mid_price_and_tob = 3; */
        if (message.withMidPriceAndTob !== false)
            writer.tag(3, WireType.Varint).bool(message.withMidPriceAndTob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMarketsRequest
 */
export const QueryDerivativeMarketsRequest = new QueryDerivativeMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevel$Type extends MessageType<PriceLevel> {
    constructor() {
        super("injective.exchange.v2.PriceLevel", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<PriceLevel>): PriceLevel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        if (value !== undefined)
            reflectionMergePartial<PriceLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevel): PriceLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PriceLevel
 */
export const PriceLevel = new PriceLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketState$Type extends MessageType<PerpetualMarketState> {
    constructor() {
        super("injective.exchange.v2.PerpetualMarketState", [
            { no: 1, name: "market_info", kind: "message", T: () => PerpetualMarketInfo },
            { no: 2, name: "funding_info", kind: "message", T: () => PerpetualMarketFunding }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketState>): PerpetualMarketState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketState): PerpetualMarketState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.PerpetualMarketInfo market_info */ 1:
                    message.marketInfo = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.marketInfo);
                    break;
                case /* injective.exchange.v2.PerpetualMarketFunding funding_info */ 2:
                    message.fundingInfo = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.fundingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.PerpetualMarketInfo market_info = 1; */
        if (message.marketInfo)
            PerpetualMarketInfo.internalBinaryWrite(message.marketInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.PerpetualMarketFunding funding_info = 2; */
        if (message.fundingInfo)
            PerpetualMarketFunding.internalBinaryWrite(message.fundingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PerpetualMarketState
 */
export const PerpetualMarketState = new PerpetualMarketState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullDerivativeMarket$Type extends MessageType<FullDerivativeMarket> {
    constructor() {
        super("injective.exchange.v2.FullDerivativeMarket", [
            { no: 1, name: "market", kind: "message", T: () => DerivativeMarket },
            { no: 2, name: "perpetual_info", kind: "message", oneof: "info", T: () => PerpetualMarketState },
            { no: 3, name: "futures_info", kind: "message", oneof: "info", T: () => ExpiryFuturesMarketInfo },
            { no: 4, name: "mark_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "mid_price_and_tob", kind: "message", T: () => MidPriceAndTOB, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<FullDerivativeMarket>): FullDerivativeMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.info = { oneofKind: undefined };
        message.markPrice = "";
        if (value !== undefined)
            reflectionMergePartial<FullDerivativeMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullDerivativeMarket): FullDerivativeMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.DerivativeMarket market */ 1:
                    message.market = DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* injective.exchange.v2.PerpetualMarketState perpetual_info */ 2:
                    message.info = {
                        oneofKind: "perpetualInfo",
                        perpetualInfo: PerpetualMarketState.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).perpetualInfo)
                    };
                    break;
                case /* injective.exchange.v2.ExpiryFuturesMarketInfo futures_info */ 3:
                    message.info = {
                        oneofKind: "futuresInfo",
                        futuresInfo: ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).futuresInfo)
                    };
                    break;
                case /* string mark_price */ 4:
                    message.markPrice = reader.string();
                    break;
                case /* injective.exchange.v2.MidPriceAndTOB mid_price_and_tob */ 5:
                    message.midPriceAndTob = MidPriceAndTOB.internalBinaryRead(reader, reader.uint32(), options, message.midPriceAndTob);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullDerivativeMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.DerivativeMarket market = 1; */
        if (message.market)
            DerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.PerpetualMarketState perpetual_info = 2; */
        if (message.info.oneofKind === "perpetualInfo")
            PerpetualMarketState.internalBinaryWrite(message.info.perpetualInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.ExpiryFuturesMarketInfo futures_info = 3; */
        if (message.info.oneofKind === "futuresInfo")
            ExpiryFuturesMarketInfo.internalBinaryWrite(message.info.futuresInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string mark_price = 4; */
        if (message.markPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.markPrice);
        /* injective.exchange.v2.MidPriceAndTOB mid_price_and_tob = 5; */
        if (message.midPriceAndTob)
            MidPriceAndTOB.internalBinaryWrite(message.midPriceAndTob, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FullDerivativeMarket
 */
export const FullDerivativeMarket = new FullDerivativeMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMarketsResponse$Type extends MessageType<QueryDerivativeMarketsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FullDerivativeMarket }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMarketsResponse>): QueryDerivativeMarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMarketsResponse): QueryDerivativeMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.FullDerivativeMarket markets */ 1:
                    message.markets.push(FullDerivativeMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.FullDerivativeMarket markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            FullDerivativeMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMarketsResponse
 */
export const QueryDerivativeMarketsResponse = new QueryDerivativeMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMarketRequest$Type extends MessageType<QueryDerivativeMarketRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMarketRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMarketRequest>): QueryDerivativeMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMarketRequest): QueryDerivativeMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMarketRequest
 */
export const QueryDerivativeMarketRequest = new QueryDerivativeMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMarketResponse$Type extends MessageType<QueryDerivativeMarketResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMarketResponse", [
            { no: 1, name: "market", kind: "message", T: () => FullDerivativeMarket }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMarketResponse>): QueryDerivativeMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMarketResponse): QueryDerivativeMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.FullDerivativeMarket market */ 1:
                    message.market = FullDerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.FullDerivativeMarket market = 1; */
        if (message.market)
            FullDerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMarketResponse
 */
export const QueryDerivativeMarketResponse = new QueryDerivativeMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMarketAddressRequest$Type extends MessageType<QueryDerivativeMarketAddressRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMarketAddressRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMarketAddressRequest>): QueryDerivativeMarketAddressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMarketAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMarketAddressRequest): QueryDerivativeMarketAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMarketAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMarketAddressRequest
 */
export const QueryDerivativeMarketAddressRequest = new QueryDerivativeMarketAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDerivativeMarketAddressResponse$Type extends MessageType<QueryDerivativeMarketAddressResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDerivativeMarketAddressResponse", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDerivativeMarketAddressResponse>): QueryDerivativeMarketAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDerivativeMarketAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDerivativeMarketAddressResponse): QueryDerivativeMarketAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDerivativeMarketAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDerivativeMarketAddressResponse
 */
export const QueryDerivativeMarketAddressResponse = new QueryDerivativeMarketAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountTradeNonceRequest$Type extends MessageType<QuerySubaccountTradeNonceRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountTradeNonceRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountTradeNonceRequest>): QuerySubaccountTradeNonceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountTradeNonceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountTradeNonceRequest): QuerySubaccountTradeNonceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountTradeNonceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountTradeNonceRequest
 */
export const QuerySubaccountTradeNonceRequest = new QuerySubaccountTradeNonceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPositionsInMarketRequest$Type extends MessageType<QueryPositionsInMarketRequest> {
    constructor() {
        super("injective.exchange.v2.QueryPositionsInMarketRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPositionsInMarketRequest>): QueryPositionsInMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryPositionsInMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPositionsInMarketRequest): QueryPositionsInMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPositionsInMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPositionsInMarketRequest
 */
export const QueryPositionsInMarketRequest = new QueryPositionsInMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPositionsInMarketResponse$Type extends MessageType<QueryPositionsInMarketResponse> {
    constructor() {
        super("injective.exchange.v2.QueryPositionsInMarketResponse", [
            { no: 1, name: "state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativePosition, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<QueryPositionsInMarketResponse>): QueryPositionsInMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = [];
        if (value !== undefined)
            reflectionMergePartial<QueryPositionsInMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPositionsInMarketResponse): QueryPositionsInMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.DerivativePosition state */ 1:
                    message.state.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPositionsInMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.DerivativePosition state = 1; */
        for (let i = 0; i < message.state.length; i++)
            DerivativePosition.internalBinaryWrite(message.state[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPositionsInMarketResponse
 */
export const QueryPositionsInMarketResponse = new QueryPositionsInMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountPositionsRequest$Type extends MessageType<QuerySubaccountPositionsRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountPositionsRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountPositionsRequest>): QuerySubaccountPositionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountPositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountPositionsRequest): QuerySubaccountPositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountPositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountPositionsRequest
 */
export const QuerySubaccountPositionsRequest = new QuerySubaccountPositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountPositionInMarketRequest$Type extends MessageType<QuerySubaccountPositionInMarketRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountPositionInMarketRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountPositionInMarketRequest>): QuerySubaccountPositionInMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountPositionInMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountPositionInMarketRequest): QuerySubaccountPositionInMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountPositionInMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountPositionInMarketRequest
 */
export const QuerySubaccountPositionInMarketRequest = new QuerySubaccountPositionInMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountEffectivePositionInMarketRequest$Type extends MessageType<QuerySubaccountEffectivePositionInMarketRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountEffectivePositionInMarketRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountEffectivePositionInMarketRequest>): QuerySubaccountEffectivePositionInMarketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountEffectivePositionInMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountEffectivePositionInMarketRequest): QuerySubaccountEffectivePositionInMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountEffectivePositionInMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountEffectivePositionInMarketRequest
 */
export const QuerySubaccountEffectivePositionInMarketRequest = new QuerySubaccountEffectivePositionInMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountOrderMetadataRequest$Type extends MessageType<QuerySubaccountOrderMetadataRequest> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountOrderMetadataRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountOrderMetadataRequest>): QuerySubaccountOrderMetadataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountOrderMetadataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountOrderMetadataRequest): QuerySubaccountOrderMetadataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountOrderMetadataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountOrderMetadataRequest
 */
export const QuerySubaccountOrderMetadataRequest = new QuerySubaccountOrderMetadataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountPositionsResponse$Type extends MessageType<QuerySubaccountPositionsResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountPositionsResponse", [
            { no: 1, name: "state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativePosition, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountPositionsResponse>): QuerySubaccountPositionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = [];
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountPositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountPositionsResponse): QuerySubaccountPositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.DerivativePosition state */ 1:
                    message.state.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountPositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.DerivativePosition state = 1; */
        for (let i = 0; i < message.state.length; i++)
            DerivativePosition.internalBinaryWrite(message.state[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountPositionsResponse
 */
export const QuerySubaccountPositionsResponse = new QuerySubaccountPositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountPositionInMarketResponse$Type extends MessageType<QuerySubaccountPositionInMarketResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountPositionInMarketResponse", [
            { no: 1, name: "state", kind: "message", T: () => Position, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountPositionInMarketResponse>): QuerySubaccountPositionInMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountPositionInMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountPositionInMarketResponse): QuerySubaccountPositionInMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.Position state */ 1:
                    message.state = Position.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountPositionInMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.Position state = 1; */
        if (message.state)
            Position.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountPositionInMarketResponse
 */
export const QuerySubaccountPositionInMarketResponse = new QuerySubaccountPositionInMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EffectivePosition$Type extends MessageType<EffectivePosition> {
    constructor() {
        super("injective.exchange.v2.EffectivePosition", [
            { no: 1, name: "is_long", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "effective_margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<EffectivePosition>): EffectivePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLong = false;
        message.quantity = "";
        message.entryPrice = "";
        message.effectiveMargin = "";
        if (value !== undefined)
            reflectionMergePartial<EffectivePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffectivePosition): EffectivePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_long */ 1:
                    message.isLong = reader.bool();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 3:
                    message.entryPrice = reader.string();
                    break;
                case /* string effective_margin */ 4:
                    message.effectiveMargin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EffectivePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_long = 1; */
        if (message.isLong !== false)
            writer.tag(1, WireType.Varint).bool(message.isLong);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 3; */
        if (message.entryPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.entryPrice);
        /* string effective_margin = 4; */
        if (message.effectiveMargin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.effectiveMargin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.EffectivePosition
 */
export const EffectivePosition = new EffectivePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountEffectivePositionInMarketResponse$Type extends MessageType<QuerySubaccountEffectivePositionInMarketResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountEffectivePositionInMarketResponse", [
            { no: 1, name: "state", kind: "message", T: () => EffectivePosition, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountEffectivePositionInMarketResponse>): QuerySubaccountEffectivePositionInMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountEffectivePositionInMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountEffectivePositionInMarketResponse): QuerySubaccountEffectivePositionInMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.EffectivePosition state */ 1:
                    message.state = EffectivePosition.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountEffectivePositionInMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.EffectivePosition state = 1; */
        if (message.state)
            EffectivePosition.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountEffectivePositionInMarketResponse
 */
export const QuerySubaccountEffectivePositionInMarketResponse = new QuerySubaccountEffectivePositionInMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPerpetualMarketInfoRequest$Type extends MessageType<QueryPerpetualMarketInfoRequest> {
    constructor() {
        super("injective.exchange.v2.QueryPerpetualMarketInfoRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPerpetualMarketInfoRequest>): QueryPerpetualMarketInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryPerpetualMarketInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPerpetualMarketInfoRequest): QueryPerpetualMarketInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPerpetualMarketInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPerpetualMarketInfoRequest
 */
export const QueryPerpetualMarketInfoRequest = new QueryPerpetualMarketInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPerpetualMarketInfoResponse$Type extends MessageType<QueryPerpetualMarketInfoResponse> {
    constructor() {
        super("injective.exchange.v2.QueryPerpetualMarketInfoResponse", [
            { no: 1, name: "info", kind: "message", T: () => PerpetualMarketInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPerpetualMarketInfoResponse>): QueryPerpetualMarketInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryPerpetualMarketInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPerpetualMarketInfoResponse): QueryPerpetualMarketInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.PerpetualMarketInfo info */ 1:
                    message.info = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPerpetualMarketInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.PerpetualMarketInfo info = 1; */
        if (message.info)
            PerpetualMarketInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPerpetualMarketInfoResponse
 */
export const QueryPerpetualMarketInfoResponse = new QueryPerpetualMarketInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryExpiryFuturesMarketInfoRequest$Type extends MessageType<QueryExpiryFuturesMarketInfoRequest> {
    constructor() {
        super("injective.exchange.v2.QueryExpiryFuturesMarketInfoRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryExpiryFuturesMarketInfoRequest>): QueryExpiryFuturesMarketInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryExpiryFuturesMarketInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryExpiryFuturesMarketInfoRequest): QueryExpiryFuturesMarketInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryExpiryFuturesMarketInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryExpiryFuturesMarketInfoRequest
 */
export const QueryExpiryFuturesMarketInfoRequest = new QueryExpiryFuturesMarketInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryExpiryFuturesMarketInfoResponse$Type extends MessageType<QueryExpiryFuturesMarketInfoResponse> {
    constructor() {
        super("injective.exchange.v2.QueryExpiryFuturesMarketInfoResponse", [
            { no: 1, name: "info", kind: "message", T: () => ExpiryFuturesMarketInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryExpiryFuturesMarketInfoResponse>): QueryExpiryFuturesMarketInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryExpiryFuturesMarketInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryExpiryFuturesMarketInfoResponse): QueryExpiryFuturesMarketInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.ExpiryFuturesMarketInfo info */ 1:
                    message.info = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryExpiryFuturesMarketInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.ExpiryFuturesMarketInfo info = 1; */
        if (message.info)
            ExpiryFuturesMarketInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryExpiryFuturesMarketInfoResponse
 */
export const QueryExpiryFuturesMarketInfoResponse = new QueryExpiryFuturesMarketInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPerpetualMarketFundingRequest$Type extends MessageType<QueryPerpetualMarketFundingRequest> {
    constructor() {
        super("injective.exchange.v2.QueryPerpetualMarketFundingRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPerpetualMarketFundingRequest>): QueryPerpetualMarketFundingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryPerpetualMarketFundingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPerpetualMarketFundingRequest): QueryPerpetualMarketFundingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPerpetualMarketFundingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPerpetualMarketFundingRequest
 */
export const QueryPerpetualMarketFundingRequest = new QueryPerpetualMarketFundingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPerpetualMarketFundingResponse$Type extends MessageType<QueryPerpetualMarketFundingResponse> {
    constructor() {
        super("injective.exchange.v2.QueryPerpetualMarketFundingResponse", [
            { no: 1, name: "state", kind: "message", T: () => PerpetualMarketFunding, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPerpetualMarketFundingResponse>): QueryPerpetualMarketFundingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryPerpetualMarketFundingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPerpetualMarketFundingResponse): QueryPerpetualMarketFundingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.PerpetualMarketFunding state */ 1:
                    message.state = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPerpetualMarketFundingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.PerpetualMarketFunding state = 1; */
        if (message.state)
            PerpetualMarketFunding.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPerpetualMarketFundingResponse
 */
export const QueryPerpetualMarketFundingResponse = new QueryPerpetualMarketFundingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountOrderMetadataResponse$Type extends MessageType<QuerySubaccountOrderMetadataResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountOrderMetadataResponse", [
            { no: 1, name: "metadata", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountOrderbookMetadataWithMarket, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountOrderMetadataResponse>): QuerySubaccountOrderMetadataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metadata = [];
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountOrderMetadataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountOrderMetadataResponse): QuerySubaccountOrderMetadataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.SubaccountOrderbookMetadataWithMarket metadata */ 1:
                    message.metadata.push(SubaccountOrderbookMetadataWithMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountOrderMetadataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.SubaccountOrderbookMetadataWithMarket metadata = 1; */
        for (let i = 0; i < message.metadata.length; i++)
            SubaccountOrderbookMetadataWithMarket.internalBinaryWrite(message.metadata[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountOrderMetadataResponse
 */
export const QuerySubaccountOrderMetadataResponse = new QuerySubaccountOrderMetadataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuerySubaccountTradeNonceResponse$Type extends MessageType<QuerySubaccountTradeNonceResponse> {
    constructor() {
        super("injective.exchange.v2.QuerySubaccountTradeNonceResponse", [
            { no: 1, name: "nonce", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuerySubaccountTradeNonceResponse>): QuerySubaccountTradeNonceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0;
        if (value !== undefined)
            reflectionMergePartial<QuerySubaccountTradeNonceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuerySubaccountTradeNonceResponse): QuerySubaccountTradeNonceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 nonce */ 1:
                    message.nonce = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuerySubaccountTradeNonceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 nonce = 1; */
        if (message.nonce !== 0)
            writer.tag(1, WireType.Varint).uint32(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QuerySubaccountTradeNonceResponse
 */
export const QuerySubaccountTradeNonceResponse = new QuerySubaccountTradeNonceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryModuleStateRequest$Type extends MessageType<QueryModuleStateRequest> {
    constructor() {
        super("injective.exchange.v2.QueryModuleStateRequest", []);
    }
    create(value?: PartialMessage<QueryModuleStateRequest>): QueryModuleStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryModuleStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryModuleStateRequest): QueryModuleStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryModuleStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryModuleStateRequest
 */
export const QueryModuleStateRequest = new QueryModuleStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryModuleStateResponse$Type extends MessageType<QueryModuleStateResponse> {
    constructor() {
        super("injective.exchange.v2.QueryModuleStateResponse", [
            { no: 1, name: "state", kind: "message", T: () => GenesisState }
        ]);
    }
    create(value?: PartialMessage<QueryModuleStateResponse>): QueryModuleStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryModuleStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryModuleStateResponse): QueryModuleStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.GenesisState state */ 1:
                    message.state = GenesisState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryModuleStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.GenesisState state = 1; */
        if (message.state)
            GenesisState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryModuleStateResponse
 */
export const QueryModuleStateResponse = new QueryModuleStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPositionsRequest$Type extends MessageType<QueryPositionsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryPositionsRequest", []);
    }
    create(value?: PartialMessage<QueryPositionsRequest>): QueryPositionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryPositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPositionsRequest): QueryPositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPositionsRequest
 */
export const QueryPositionsRequest = new QueryPositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPositionsResponse$Type extends MessageType<QueryPositionsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryPositionsResponse", [
            { no: 1, name: "state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativePosition, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPositionsResponse>): QueryPositionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = [];
        if (value !== undefined)
            reflectionMergePartial<QueryPositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPositionsResponse): QueryPositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.DerivativePosition state */ 1:
                    message.state.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.DerivativePosition state = 1; */
        for (let i = 0; i < message.state.length; i++)
            DerivativePosition.internalBinaryWrite(message.state[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryPositionsResponse
 */
export const QueryPositionsResponse = new QueryPositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTradeRewardPointsRequest$Type extends MessageType<QueryTradeRewardPointsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryTradeRewardPointsRequest", [
            { no: 1, name: "accounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pending_pool_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryTradeRewardPointsRequest>): QueryTradeRewardPointsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accounts = [];
        message.pendingPoolTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryTradeRewardPointsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTradeRewardPointsRequest): QueryTradeRewardPointsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accounts */ 1:
                    message.accounts.push(reader.string());
                    break;
                case /* int64 pending_pool_timestamp */ 2:
                    message.pendingPoolTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTradeRewardPointsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
        /* int64 pending_pool_timestamp = 2; */
        if (message.pendingPoolTimestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.pendingPoolTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTradeRewardPointsRequest
 */
export const QueryTradeRewardPointsRequest = new QueryTradeRewardPointsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTradeRewardPointsResponse$Type extends MessageType<QueryTradeRewardPointsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryTradeRewardPointsResponse", [
            { no: 1, name: "account_trade_reward_points", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryTradeRewardPointsResponse>): QueryTradeRewardPointsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountTradeRewardPoints = [];
        if (value !== undefined)
            reflectionMergePartial<QueryTradeRewardPointsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTradeRewardPointsResponse): QueryTradeRewardPointsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string account_trade_reward_points */ 1:
                    message.accountTradeRewardPoints.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTradeRewardPointsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string account_trade_reward_points = 1; */
        for (let i = 0; i < message.accountTradeRewardPoints.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accountTradeRewardPoints[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTradeRewardPointsResponse
 */
export const QueryTradeRewardPointsResponse = new QueryTradeRewardPointsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTradeRewardCampaignRequest$Type extends MessageType<QueryTradeRewardCampaignRequest> {
    constructor() {
        super("injective.exchange.v2.QueryTradeRewardCampaignRequest", []);
    }
    create(value?: PartialMessage<QueryTradeRewardCampaignRequest>): QueryTradeRewardCampaignRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryTradeRewardCampaignRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTradeRewardCampaignRequest): QueryTradeRewardCampaignRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTradeRewardCampaignRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTradeRewardCampaignRequest
 */
export const QueryTradeRewardCampaignRequest = new QueryTradeRewardCampaignRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTradeRewardCampaignResponse$Type extends MessageType<QueryTradeRewardCampaignResponse> {
    constructor() {
        super("injective.exchange.v2.QueryTradeRewardCampaignResponse", [
            { no: 1, name: "trading_reward_campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
            { no: 2, name: "trading_reward_pool_campaign_schedule", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool },
            { no: 3, name: "total_trade_reward_points", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "pending_trading_reward_pool_campaign_schedule", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool },
            { no: 5, name: "pending_total_trade_reward_points", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryTradeRewardCampaignResponse>): QueryTradeRewardCampaignResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradingRewardPoolCampaignSchedule = [];
        message.totalTradeRewardPoints = "";
        message.pendingTradingRewardPoolCampaignSchedule = [];
        message.pendingTotalTradeRewardPoints = [];
        if (value !== undefined)
            reflectionMergePartial<QueryTradeRewardCampaignResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTradeRewardCampaignResponse): QueryTradeRewardCampaignResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info */ 1:
                    message.tradingRewardCampaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardCampaignInfo);
                    break;
                case /* repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule */ 2:
                    message.tradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string total_trade_reward_points */ 3:
                    message.totalTradeRewardPoints = reader.string();
                    break;
                case /* repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule */ 4:
                    message.pendingTradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string pending_total_trade_reward_points */ 5:
                    message.pendingTotalTradeRewardPoints.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTradeRewardCampaignResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info = 1; */
        if (message.tradingRewardCampaignInfo)
            TradingRewardCampaignInfo.internalBinaryWrite(message.tradingRewardCampaignInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule = 2; */
        for (let i = 0; i < message.tradingRewardPoolCampaignSchedule.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.tradingRewardPoolCampaignSchedule[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string total_trade_reward_points = 3; */
        if (message.totalTradeRewardPoints !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.totalTradeRewardPoints);
        /* repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4; */
        for (let i = 0; i < message.pendingTradingRewardPoolCampaignSchedule.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.pendingTradingRewardPoolCampaignSchedule[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string pending_total_trade_reward_points = 5; */
        for (let i = 0; i < message.pendingTotalTradeRewardPoints.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.pendingTotalTradeRewardPoints[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTradeRewardCampaignResponse
 */
export const QueryTradeRewardCampaignResponse = new QueryTradeRewardCampaignResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryIsOptedOutOfRewardsRequest$Type extends MessageType<QueryIsOptedOutOfRewardsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryIsOptedOutOfRewardsRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryIsOptedOutOfRewardsRequest>): QueryIsOptedOutOfRewardsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<QueryIsOptedOutOfRewardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryIsOptedOutOfRewardsRequest): QueryIsOptedOutOfRewardsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryIsOptedOutOfRewardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryIsOptedOutOfRewardsRequest
 */
export const QueryIsOptedOutOfRewardsRequest = new QueryIsOptedOutOfRewardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryIsOptedOutOfRewardsResponse$Type extends MessageType<QueryIsOptedOutOfRewardsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryIsOptedOutOfRewardsResponse", [
            { no: 1, name: "is_opted_out", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryIsOptedOutOfRewardsResponse>): QueryIsOptedOutOfRewardsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isOptedOut = false;
        if (value !== undefined)
            reflectionMergePartial<QueryIsOptedOutOfRewardsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryIsOptedOutOfRewardsResponse): QueryIsOptedOutOfRewardsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_opted_out */ 1:
                    message.isOptedOut = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryIsOptedOutOfRewardsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_opted_out = 1; */
        if (message.isOptedOut !== false)
            writer.tag(1, WireType.Varint).bool(message.isOptedOut);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryIsOptedOutOfRewardsResponse
 */
export const QueryIsOptedOutOfRewardsResponse = new QueryIsOptedOutOfRewardsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryOptedOutOfRewardsAccountsRequest$Type extends MessageType<QueryOptedOutOfRewardsAccountsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryOptedOutOfRewardsAccountsRequest", []);
    }
    create(value?: PartialMessage<QueryOptedOutOfRewardsAccountsRequest>): QueryOptedOutOfRewardsAccountsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryOptedOutOfRewardsAccountsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryOptedOutOfRewardsAccountsRequest): QueryOptedOutOfRewardsAccountsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryOptedOutOfRewardsAccountsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryOptedOutOfRewardsAccountsRequest
 */
export const QueryOptedOutOfRewardsAccountsRequest = new QueryOptedOutOfRewardsAccountsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryOptedOutOfRewardsAccountsResponse$Type extends MessageType<QueryOptedOutOfRewardsAccountsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryOptedOutOfRewardsAccountsResponse", [
            { no: 1, name: "accounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryOptedOutOfRewardsAccountsResponse>): QueryOptedOutOfRewardsAccountsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accounts = [];
        if (value !== undefined)
            reflectionMergePartial<QueryOptedOutOfRewardsAccountsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryOptedOutOfRewardsAccountsResponse): QueryOptedOutOfRewardsAccountsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accounts */ 1:
                    message.accounts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryOptedOutOfRewardsAccountsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryOptedOutOfRewardsAccountsResponse
 */
export const QueryOptedOutOfRewardsAccountsResponse = new QueryOptedOutOfRewardsAccountsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFeeDiscountAccountInfoRequest$Type extends MessageType<QueryFeeDiscountAccountInfoRequest> {
    constructor() {
        super("injective.exchange.v2.QueryFeeDiscountAccountInfoRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFeeDiscountAccountInfoRequest>): QueryFeeDiscountAccountInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<QueryFeeDiscountAccountInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFeeDiscountAccountInfoRequest): QueryFeeDiscountAccountInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFeeDiscountAccountInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFeeDiscountAccountInfoRequest
 */
export const QueryFeeDiscountAccountInfoRequest = new QueryFeeDiscountAccountInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFeeDiscountAccountInfoResponse$Type extends MessageType<QueryFeeDiscountAccountInfoResponse> {
    constructor() {
        super("injective.exchange.v2.QueryFeeDiscountAccountInfoResponse", [
            { no: 1, name: "tier_level", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "account_info", kind: "message", T: () => FeeDiscountTierInfo },
            { no: 3, name: "account_ttl", kind: "message", T: () => FeeDiscountTierTTL }
        ]);
    }
    create(value?: PartialMessage<QueryFeeDiscountAccountInfoResponse>): QueryFeeDiscountAccountInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tierLevel = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryFeeDiscountAccountInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFeeDiscountAccountInfoResponse): QueryFeeDiscountAccountInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 tier_level */ 1:
                    message.tierLevel = reader.uint64().toBigInt();
                    break;
                case /* injective.exchange.v2.FeeDiscountTierInfo account_info */ 2:
                    message.accountInfo = FeeDiscountTierInfo.internalBinaryRead(reader, reader.uint32(), options, message.accountInfo);
                    break;
                case /* injective.exchange.v2.FeeDiscountTierTTL account_ttl */ 3:
                    message.accountTtl = FeeDiscountTierTTL.internalBinaryRead(reader, reader.uint32(), options, message.accountTtl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFeeDiscountAccountInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 tier_level = 1; */
        if (message.tierLevel !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.tierLevel);
        /* injective.exchange.v2.FeeDiscountTierInfo account_info = 2; */
        if (message.accountInfo)
            FeeDiscountTierInfo.internalBinaryWrite(message.accountInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.FeeDiscountTierTTL account_ttl = 3; */
        if (message.accountTtl)
            FeeDiscountTierTTL.internalBinaryWrite(message.accountTtl, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFeeDiscountAccountInfoResponse
 */
export const QueryFeeDiscountAccountInfoResponse = new QueryFeeDiscountAccountInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFeeDiscountScheduleRequest$Type extends MessageType<QueryFeeDiscountScheduleRequest> {
    constructor() {
        super("injective.exchange.v2.QueryFeeDiscountScheduleRequest", []);
    }
    create(value?: PartialMessage<QueryFeeDiscountScheduleRequest>): QueryFeeDiscountScheduleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryFeeDiscountScheduleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFeeDiscountScheduleRequest): QueryFeeDiscountScheduleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFeeDiscountScheduleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFeeDiscountScheduleRequest
 */
export const QueryFeeDiscountScheduleRequest = new QueryFeeDiscountScheduleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFeeDiscountScheduleResponse$Type extends MessageType<QueryFeeDiscountScheduleResponse> {
    constructor() {
        super("injective.exchange.v2.QueryFeeDiscountScheduleResponse", [
            { no: 1, name: "fee_discount_schedule", kind: "message", T: () => FeeDiscountSchedule }
        ]);
    }
    create(value?: PartialMessage<QueryFeeDiscountScheduleResponse>): QueryFeeDiscountScheduleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryFeeDiscountScheduleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFeeDiscountScheduleResponse): QueryFeeDiscountScheduleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule */ 1:
                    message.feeDiscountSchedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.feeDiscountSchedule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFeeDiscountScheduleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule = 1; */
        if (message.feeDiscountSchedule)
            FeeDiscountSchedule.internalBinaryWrite(message.feeDiscountSchedule, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFeeDiscountScheduleResponse
 */
export const QueryFeeDiscountScheduleResponse = new QueryFeeDiscountScheduleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBalanceMismatchesRequest$Type extends MessageType<QueryBalanceMismatchesRequest> {
    constructor() {
        super("injective.exchange.v2.QueryBalanceMismatchesRequest", [
            { no: 1, name: "dust_factor", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryBalanceMismatchesRequest>): QueryBalanceMismatchesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dustFactor = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryBalanceMismatchesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBalanceMismatchesRequest): QueryBalanceMismatchesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 dust_factor */ 1:
                    message.dustFactor = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBalanceMismatchesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 dust_factor = 1; */
        if (message.dustFactor !== 0n)
            writer.tag(1, WireType.Varint).int64(message.dustFactor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryBalanceMismatchesRequest
 */
export const QueryBalanceMismatchesRequest = new QueryBalanceMismatchesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceMismatch$Type extends MessageType<BalanceMismatch> {
    constructor() {
        super("injective.exchange.v2.BalanceMismatch", [
            { no: 1, name: "subaccountId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "available", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "total", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "balance_hold", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "expected_total", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "difference", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<BalanceMismatch>): BalanceMismatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denom = "";
        message.available = "";
        message.total = "";
        message.balanceHold = "";
        message.expectedTotal = "";
        message.difference = "";
        if (value !== undefined)
            reflectionMergePartial<BalanceMismatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceMismatch): BalanceMismatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccountId */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* string available */ 3:
                    message.available = reader.string();
                    break;
                case /* string total */ 4:
                    message.total = reader.string();
                    break;
                case /* string balance_hold */ 5:
                    message.balanceHold = reader.string();
                    break;
                case /* string expected_total */ 6:
                    message.expectedTotal = reader.string();
                    break;
                case /* string difference */ 7:
                    message.difference = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceMismatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccountId = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* string available = 3; */
        if (message.available !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.available);
        /* string total = 4; */
        if (message.total !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.total);
        /* string balance_hold = 5; */
        if (message.balanceHold !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.balanceHold);
        /* string expected_total = 6; */
        if (message.expectedTotal !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.expectedTotal);
        /* string difference = 7; */
        if (message.difference !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.difference);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.BalanceMismatch
 */
export const BalanceMismatch = new BalanceMismatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBalanceMismatchesResponse$Type extends MessageType<QueryBalanceMismatchesResponse> {
    constructor() {
        super("injective.exchange.v2.QueryBalanceMismatchesResponse", [
            { no: 1, name: "balance_mismatches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BalanceMismatch }
        ]);
    }
    create(value?: PartialMessage<QueryBalanceMismatchesResponse>): QueryBalanceMismatchesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balanceMismatches = [];
        if (value !== undefined)
            reflectionMergePartial<QueryBalanceMismatchesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBalanceMismatchesResponse): QueryBalanceMismatchesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.BalanceMismatch balance_mismatches */ 1:
                    message.balanceMismatches.push(BalanceMismatch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBalanceMismatchesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.BalanceMismatch balance_mismatches = 1; */
        for (let i = 0; i < message.balanceMismatches.length; i++)
            BalanceMismatch.internalBinaryWrite(message.balanceMismatches[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryBalanceMismatchesResponse
 */
export const QueryBalanceMismatchesResponse = new QueryBalanceMismatchesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBalanceWithBalanceHoldsRequest$Type extends MessageType<QueryBalanceWithBalanceHoldsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryBalanceWithBalanceHoldsRequest", []);
    }
    create(value?: PartialMessage<QueryBalanceWithBalanceHoldsRequest>): QueryBalanceWithBalanceHoldsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryBalanceWithBalanceHoldsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBalanceWithBalanceHoldsRequest): QueryBalanceWithBalanceHoldsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBalanceWithBalanceHoldsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryBalanceWithBalanceHoldsRequest
 */
export const QueryBalanceWithBalanceHoldsRequest = new QueryBalanceWithBalanceHoldsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceWithMarginHold$Type extends MessageType<BalanceWithMarginHold> {
    constructor() {
        super("injective.exchange.v2.BalanceWithMarginHold", [
            { no: 1, name: "subaccountId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "available", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "total", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "balance_hold", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<BalanceWithMarginHold>): BalanceWithMarginHold {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.denom = "";
        message.available = "";
        message.total = "";
        message.balanceHold = "";
        if (value !== undefined)
            reflectionMergePartial<BalanceWithMarginHold>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceWithMarginHold): BalanceWithMarginHold {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccountId */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* string available */ 3:
                    message.available = reader.string();
                    break;
                case /* string total */ 4:
                    message.total = reader.string();
                    break;
                case /* string balance_hold */ 5:
                    message.balanceHold = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceWithMarginHold, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccountId = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* string available = 3; */
        if (message.available !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.available);
        /* string total = 4; */
        if (message.total !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.total);
        /* string balance_hold = 5; */
        if (message.balanceHold !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.balanceHold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.BalanceWithMarginHold
 */
export const BalanceWithMarginHold = new BalanceWithMarginHold$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBalanceWithBalanceHoldsResponse$Type extends MessageType<QueryBalanceWithBalanceHoldsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryBalanceWithBalanceHoldsResponse", [
            { no: 1, name: "balance_with_balance_holds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BalanceWithMarginHold }
        ]);
    }
    create(value?: PartialMessage<QueryBalanceWithBalanceHoldsResponse>): QueryBalanceWithBalanceHoldsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balanceWithBalanceHolds = [];
        if (value !== undefined)
            reflectionMergePartial<QueryBalanceWithBalanceHoldsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBalanceWithBalanceHoldsResponse): QueryBalanceWithBalanceHoldsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.BalanceWithMarginHold balance_with_balance_holds */ 1:
                    message.balanceWithBalanceHolds.push(BalanceWithMarginHold.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBalanceWithBalanceHoldsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.BalanceWithMarginHold balance_with_balance_holds = 1; */
        for (let i = 0; i < message.balanceWithBalanceHolds.length; i++)
            BalanceWithMarginHold.internalBinaryWrite(message.balanceWithBalanceHolds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryBalanceWithBalanceHoldsResponse
 */
export const QueryBalanceWithBalanceHoldsResponse = new QueryBalanceWithBalanceHoldsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFeeDiscountTierStatisticsRequest$Type extends MessageType<QueryFeeDiscountTierStatisticsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryFeeDiscountTierStatisticsRequest", []);
    }
    create(value?: PartialMessage<QueryFeeDiscountTierStatisticsRequest>): QueryFeeDiscountTierStatisticsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryFeeDiscountTierStatisticsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFeeDiscountTierStatisticsRequest): QueryFeeDiscountTierStatisticsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFeeDiscountTierStatisticsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFeeDiscountTierStatisticsRequest
 */
export const QueryFeeDiscountTierStatisticsRequest = new QueryFeeDiscountTierStatisticsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TierStatistic$Type extends MessageType<TierStatistic> {
    constructor() {
        super("injective.exchange.v2.TierStatistic", [
            { no: 1, name: "tier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TierStatistic>): TierStatistic {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tier = 0n;
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<TierStatistic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TierStatistic): TierStatistic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 tier */ 1:
                    message.tier = reader.uint64().toBigInt();
                    break;
                case /* uint64 count */ 2:
                    message.count = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TierStatistic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 tier = 1; */
        if (message.tier !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.tier);
        /* uint64 count = 2; */
        if (message.count !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TierStatistic
 */
export const TierStatistic = new TierStatistic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFeeDiscountTierStatisticsResponse$Type extends MessageType<QueryFeeDiscountTierStatisticsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryFeeDiscountTierStatisticsResponse", [
            { no: 1, name: "statistics", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TierStatistic }
        ]);
    }
    create(value?: PartialMessage<QueryFeeDiscountTierStatisticsResponse>): QueryFeeDiscountTierStatisticsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statistics = [];
        if (value !== undefined)
            reflectionMergePartial<QueryFeeDiscountTierStatisticsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFeeDiscountTierStatisticsResponse): QueryFeeDiscountTierStatisticsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TierStatistic statistics */ 1:
                    message.statistics.push(TierStatistic.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFeeDiscountTierStatisticsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TierStatistic statistics = 1; */
        for (let i = 0; i < message.statistics.length; i++)
            TierStatistic.internalBinaryWrite(message.statistics[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFeeDiscountTierStatisticsResponse
 */
export const QueryFeeDiscountTierStatisticsResponse = new QueryFeeDiscountTierStatisticsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MitoVaultInfosRequest$Type extends MessageType<MitoVaultInfosRequest> {
    constructor() {
        super("injective.exchange.v2.MitoVaultInfosRequest", []);
    }
    create(value?: PartialMessage<MitoVaultInfosRequest>): MitoVaultInfosRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MitoVaultInfosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MitoVaultInfosRequest): MitoVaultInfosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MitoVaultInfosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MitoVaultInfosRequest
 */
export const MitoVaultInfosRequest = new MitoVaultInfosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MitoVaultInfosResponse$Type extends MessageType<MitoVaultInfosResponse> {
    constructor() {
        super("injective.exchange.v2.MitoVaultInfosResponse", [
            { no: 1, name: "master_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "derivative_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spot_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cw20_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MitoVaultInfosResponse>): MitoVaultInfosResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.masterAddresses = [];
        message.derivativeAddresses = [];
        message.spotAddresses = [];
        message.cw20Addresses = [];
        if (value !== undefined)
            reflectionMergePartial<MitoVaultInfosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MitoVaultInfosResponse): MitoVaultInfosResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string master_addresses */ 1:
                    message.masterAddresses.push(reader.string());
                    break;
                case /* repeated string derivative_addresses */ 2:
                    message.derivativeAddresses.push(reader.string());
                    break;
                case /* repeated string spot_addresses */ 3:
                    message.spotAddresses.push(reader.string());
                    break;
                case /* repeated string cw20_addresses */ 4:
                    message.cw20Addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MitoVaultInfosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string master_addresses = 1; */
        for (let i = 0; i < message.masterAddresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.masterAddresses[i]);
        /* repeated string derivative_addresses = 2; */
        for (let i = 0; i < message.derivativeAddresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.derivativeAddresses[i]);
        /* repeated string spot_addresses = 3; */
        for (let i = 0; i < message.spotAddresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.spotAddresses[i]);
        /* repeated string cw20_addresses = 4; */
        for (let i = 0; i < message.cw20Addresses.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.cw20Addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MitoVaultInfosResponse
 */
export const MitoVaultInfosResponse = new MitoVaultInfosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketIDFromVaultRequest$Type extends MessageType<QueryMarketIDFromVaultRequest> {
    constructor() {
        super("injective.exchange.v2.QueryMarketIDFromVaultRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryMarketIDFromVaultRequest>): QueryMarketIDFromVaultRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryMarketIDFromVaultRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketIDFromVaultRequest): QueryMarketIDFromVaultRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketIDFromVaultRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketIDFromVaultRequest
 */
export const QueryMarketIDFromVaultRequest = new QueryMarketIDFromVaultRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketIDFromVaultResponse$Type extends MessageType<QueryMarketIDFromVaultResponse> {
    constructor() {
        super("injective.exchange.v2.QueryMarketIDFromVaultResponse", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryMarketIDFromVaultResponse>): QueryMarketIDFromVaultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryMarketIDFromVaultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketIDFromVaultResponse): QueryMarketIDFromVaultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketIDFromVaultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketIDFromVaultResponse
 */
export const QueryMarketIDFromVaultResponse = new QueryMarketIDFromVaultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryHistoricalTradeRecordsRequest$Type extends MessageType<QueryHistoricalTradeRecordsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryHistoricalTradeRecordsRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryHistoricalTradeRecordsRequest>): QueryHistoricalTradeRecordsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryHistoricalTradeRecordsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryHistoricalTradeRecordsRequest): QueryHistoricalTradeRecordsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryHistoricalTradeRecordsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryHistoricalTradeRecordsRequest
 */
export const QueryHistoricalTradeRecordsRequest = new QueryHistoricalTradeRecordsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryHistoricalTradeRecordsResponse$Type extends MessageType<QueryHistoricalTradeRecordsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryHistoricalTradeRecordsResponse", [
            { no: 1, name: "trade_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradeRecords }
        ]);
    }
    create(value?: PartialMessage<QueryHistoricalTradeRecordsResponse>): QueryHistoricalTradeRecordsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeRecords = [];
        if (value !== undefined)
            reflectionMergePartial<QueryHistoricalTradeRecordsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryHistoricalTradeRecordsResponse): QueryHistoricalTradeRecordsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TradeRecords trade_records */ 1:
                    message.tradeRecords.push(TradeRecords.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryHistoricalTradeRecordsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TradeRecords trade_records = 1; */
        for (let i = 0; i < message.tradeRecords.length; i++)
            TradeRecords.internalBinaryWrite(message.tradeRecords[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryHistoricalTradeRecordsResponse
 */
export const QueryHistoricalTradeRecordsResponse = new QueryHistoricalTradeRecordsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeHistoryOptions$Type extends MessageType<TradeHistoryOptions> {
    constructor() {
        super("injective.exchange.v2.TradeHistoryOptions", [
            { no: 1, name: "trade_grouping_sec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_age", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "include_raw_history", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "include_metadata", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TradeHistoryOptions>): TradeHistoryOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeGroupingSec = 0n;
        message.maxAge = 0n;
        message.includeRawHistory = false;
        message.includeMetadata = false;
        if (value !== undefined)
            reflectionMergePartial<TradeHistoryOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeHistoryOptions): TradeHistoryOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 trade_grouping_sec */ 1:
                    message.tradeGroupingSec = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_age */ 2:
                    message.maxAge = reader.uint64().toBigInt();
                    break;
                case /* bool include_raw_history */ 4:
                    message.includeRawHistory = reader.bool();
                    break;
                case /* bool include_metadata */ 5:
                    message.includeMetadata = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeHistoryOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 trade_grouping_sec = 1; */
        if (message.tradeGroupingSec !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.tradeGroupingSec);
        /* uint64 max_age = 2; */
        if (message.maxAge !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.maxAge);
        /* bool include_raw_history = 4; */
        if (message.includeRawHistory !== false)
            writer.tag(4, WireType.Varint).bool(message.includeRawHistory);
        /* bool include_metadata = 5; */
        if (message.includeMetadata !== false)
            writer.tag(5, WireType.Varint).bool(message.includeMetadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradeHistoryOptions
 */
export const TradeHistoryOptions = new TradeHistoryOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketVolatilityRequest$Type extends MessageType<QueryMarketVolatilityRequest> {
    constructor() {
        super("injective.exchange.v2.QueryMarketVolatilityRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trade_history_options", kind: "message", T: () => TradeHistoryOptions }
        ]);
    }
    create(value?: PartialMessage<QueryMarketVolatilityRequest>): QueryMarketVolatilityRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryMarketVolatilityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketVolatilityRequest): QueryMarketVolatilityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v2.TradeHistoryOptions trade_history_options */ 2:
                    message.tradeHistoryOptions = TradeHistoryOptions.internalBinaryRead(reader, reader.uint32(), options, message.tradeHistoryOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketVolatilityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v2.TradeHistoryOptions trade_history_options = 2; */
        if (message.tradeHistoryOptions)
            TradeHistoryOptions.internalBinaryWrite(message.tradeHistoryOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketVolatilityRequest
 */
export const QueryMarketVolatilityRequest = new QueryMarketVolatilityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketVolatilityResponse$Type extends MessageType<QueryMarketVolatilityResponse> {
    constructor() {
        super("injective.exchange.v2.QueryMarketVolatilityResponse", [
            { no: 1, name: "volatility", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "history_metadata", kind: "message", T: () => MetadataStatistics },
            { no: 3, name: "raw_history", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradeRecord }
        ]);
    }
    create(value?: PartialMessage<QueryMarketVolatilityResponse>): QueryMarketVolatilityResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.volatility = "";
        message.rawHistory = [];
        if (value !== undefined)
            reflectionMergePartial<QueryMarketVolatilityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketVolatilityResponse): QueryMarketVolatilityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string volatility */ 1:
                    message.volatility = reader.string();
                    break;
                case /* injective.oracle.v1beta1.MetadataStatistics history_metadata */ 2:
                    message.historyMetadata = MetadataStatistics.internalBinaryRead(reader, reader.uint32(), options, message.historyMetadata);
                    break;
                case /* repeated injective.exchange.v2.TradeRecord raw_history */ 3:
                    message.rawHistory.push(TradeRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketVolatilityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string volatility = 1; */
        if (message.volatility !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.volatility);
        /* injective.oracle.v1beta1.MetadataStatistics history_metadata = 2; */
        if (message.historyMetadata)
            MetadataStatistics.internalBinaryWrite(message.historyMetadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.TradeRecord raw_history = 3; */
        for (let i = 0; i < message.rawHistory.length; i++)
            TradeRecord.internalBinaryWrite(message.rawHistory[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketVolatilityResponse
 */
export const QueryMarketVolatilityResponse = new QueryMarketVolatilityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBinaryMarketsRequest$Type extends MessageType<QueryBinaryMarketsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryBinaryMarketsRequest", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryBinaryMarketsRequest>): QueryBinaryMarketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<QueryBinaryMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBinaryMarketsRequest): QueryBinaryMarketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBinaryMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryBinaryMarketsRequest
 */
export const QueryBinaryMarketsRequest = new QueryBinaryMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBinaryMarketsResponse$Type extends MessageType<QueryBinaryMarketsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryBinaryMarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BinaryOptionsMarket }
        ]);
    }
    create(value?: PartialMessage<QueryBinaryMarketsResponse>): QueryBinaryMarketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markets = [];
        if (value !== undefined)
            reflectionMergePartial<QueryBinaryMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBinaryMarketsResponse): QueryBinaryMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.BinaryOptionsMarket markets */ 1:
                    message.markets.push(BinaryOptionsMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBinaryMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.BinaryOptionsMarket markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            BinaryOptionsMarket.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryBinaryMarketsResponse
 */
export const QueryBinaryMarketsResponse = new QueryBinaryMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderDerivativeConditionalOrdersRequest$Type extends MessageType<QueryTraderDerivativeConditionalOrdersRequest> {
    constructor() {
        super("injective.exchange.v2.QueryTraderDerivativeConditionalOrdersRequest", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryTraderDerivativeConditionalOrdersRequest>): QueryTraderDerivativeConditionalOrdersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryTraderDerivativeConditionalOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderDerivativeConditionalOrdersRequest): QueryTraderDerivativeConditionalOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderDerivativeConditionalOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderDerivativeConditionalOrdersRequest
 */
export const QueryTraderDerivativeConditionalOrdersRequest = new QueryTraderDerivativeConditionalOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrimmedDerivativeConditionalOrder$Type extends MessageType<TrimmedDerivativeConditionalOrder> {
    constructor() {
        super("injective.exchange.v2.TrimmedDerivativeConditionalOrder", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "triggerPrice", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "isBuy", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "isBuy" } },
            { no: 6, name: "isLimit", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "isLimit" } },
            { no: 7, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrimmedDerivativeConditionalOrder>): TrimmedDerivativeConditionalOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.margin = "";
        message.triggerPrice = "";
        message.isBuy = false;
        message.isLimit = false;
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<TrimmedDerivativeConditionalOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrimmedDerivativeConditionalOrder): TrimmedDerivativeConditionalOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string margin */ 3:
                    message.margin = reader.string();
                    break;
                case /* string triggerPrice */ 4:
                    message.triggerPrice = reader.string();
                    break;
                case /* bool isBuy */ 5:
                    message.isBuy = reader.bool();
                    break;
                case /* bool isLimit */ 6:
                    message.isLimit = reader.bool();
                    break;
                case /* string order_hash */ 7:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 8:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrimmedDerivativeConditionalOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string margin = 3; */
        if (message.margin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.margin);
        /* string triggerPrice = 4; */
        if (message.triggerPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
        /* bool isBuy = 5; */
        if (message.isBuy !== false)
            writer.tag(5, WireType.Varint).bool(message.isBuy);
        /* bool isLimit = 6; */
        if (message.isLimit !== false)
            writer.tag(6, WireType.Varint).bool(message.isLimit);
        /* string order_hash = 7; */
        if (message.orderHash !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 8; */
        if (message.cid !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TrimmedDerivativeConditionalOrder
 */
export const TrimmedDerivativeConditionalOrder = new TrimmedDerivativeConditionalOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTraderDerivativeConditionalOrdersResponse$Type extends MessageType<QueryTraderDerivativeConditionalOrdersResponse> {
    constructor() {
        super("injective.exchange.v2.QueryTraderDerivativeConditionalOrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedDerivativeConditionalOrder }
        ]);
    }
    create(value?: PartialMessage<QueryTraderDerivativeConditionalOrdersResponse>): QueryTraderDerivativeConditionalOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<QueryTraderDerivativeConditionalOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTraderDerivativeConditionalOrdersResponse): QueryTraderDerivativeConditionalOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedDerivativeConditionalOrder orders */ 1:
                    message.orders.push(TrimmedDerivativeConditionalOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTraderDerivativeConditionalOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedDerivativeConditionalOrder orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            TrimmedDerivativeConditionalOrder.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryTraderDerivativeConditionalOrdersResponse
 */
export const QueryTraderDerivativeConditionalOrdersResponse = new QueryTraderDerivativeConditionalOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullSpotOrderbookRequest$Type extends MessageType<QueryFullSpotOrderbookRequest> {
    constructor() {
        super("injective.exchange.v2.QueryFullSpotOrderbookRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFullSpotOrderbookRequest>): QueryFullSpotOrderbookRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryFullSpotOrderbookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullSpotOrderbookRequest): QueryFullSpotOrderbookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullSpotOrderbookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullSpotOrderbookRequest
 */
export const QueryFullSpotOrderbookRequest = new QueryFullSpotOrderbookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullSpotOrderbookResponse$Type extends MessageType<QueryFullSpotOrderbookResponse> {
    constructor() {
        super("injective.exchange.v2.QueryFullSpotOrderbookResponse", [
            { no: 1, name: "Bids", kind: "message", jsonName: "Bids", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedLimitOrder },
            { no: 2, name: "Asks", kind: "message", jsonName: "Asks", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedLimitOrder },
            { no: 3, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFullSpotOrderbookResponse>): QueryFullSpotOrderbookResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bids = [];
        message.asks = [];
        message.seq = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryFullSpotOrderbookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullSpotOrderbookResponse): QueryFullSpotOrderbookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedLimitOrder Bids */ 1:
                    message.bids.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.TrimmedLimitOrder Asks */ 2:
                    message.asks.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 seq */ 3:
                    message.seq = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullSpotOrderbookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedLimitOrder Bids = 1; */
        for (let i = 0; i < message.bids.length; i++)
            TrimmedLimitOrder.internalBinaryWrite(message.bids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.TrimmedLimitOrder Asks = 2; */
        for (let i = 0; i < message.asks.length; i++)
            TrimmedLimitOrder.internalBinaryWrite(message.asks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 seq = 3; */
        if (message.seq !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.seq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullSpotOrderbookResponse
 */
export const QueryFullSpotOrderbookResponse = new QueryFullSpotOrderbookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullDerivativeOrderbookRequest$Type extends MessageType<QueryFullDerivativeOrderbookRequest> {
    constructor() {
        super("injective.exchange.v2.QueryFullDerivativeOrderbookRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFullDerivativeOrderbookRequest>): QueryFullDerivativeOrderbookRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryFullDerivativeOrderbookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullDerivativeOrderbookRequest): QueryFullDerivativeOrderbookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullDerivativeOrderbookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullDerivativeOrderbookRequest
 */
export const QueryFullDerivativeOrderbookRequest = new QueryFullDerivativeOrderbookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFullDerivativeOrderbookResponse$Type extends MessageType<QueryFullDerivativeOrderbookResponse> {
    constructor() {
        super("injective.exchange.v2.QueryFullDerivativeOrderbookResponse", [
            { no: 1, name: "Bids", kind: "message", jsonName: "Bids", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedLimitOrder },
            { no: 2, name: "Asks", kind: "message", jsonName: "Asks", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrimmedLimitOrder },
            { no: 3, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFullDerivativeOrderbookResponse>): QueryFullDerivativeOrderbookResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bids = [];
        message.asks = [];
        message.seq = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryFullDerivativeOrderbookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFullDerivativeOrderbookResponse): QueryFullDerivativeOrderbookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.TrimmedLimitOrder Bids */ 1:
                    message.bids.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.TrimmedLimitOrder Asks */ 2:
                    message.asks.push(TrimmedLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 seq */ 3:
                    message.seq = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFullDerivativeOrderbookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.TrimmedLimitOrder Bids = 1; */
        for (let i = 0; i < message.bids.length; i++)
            TrimmedLimitOrder.internalBinaryWrite(message.bids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.TrimmedLimitOrder Asks = 2; */
        for (let i = 0; i < message.asks.length; i++)
            TrimmedLimitOrder.internalBinaryWrite(message.asks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 seq = 3; */
        if (message.seq !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.seq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryFullDerivativeOrderbookResponse
 */
export const QueryFullDerivativeOrderbookResponse = new QueryFullDerivativeOrderbookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrimmedLimitOrder$Type extends MessageType<TrimmedLimitOrder> {
    constructor() {
        super("injective.exchange.v2.TrimmedLimitOrder", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrimmedLimitOrder>): TrimmedLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.orderHash = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<TrimmedLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrimmedLimitOrder): TrimmedLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string order_hash */ 3:
                    message.orderHash = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrimmedLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string order_hash = 3; */
        if (message.orderHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.orderHash);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TrimmedLimitOrder
 */
export const TrimmedLimitOrder = new TrimmedLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketAtomicExecutionFeeMultiplierRequest$Type extends MessageType<QueryMarketAtomicExecutionFeeMultiplierRequest> {
    constructor() {
        super("injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryMarketAtomicExecutionFeeMultiplierRequest>): QueryMarketAtomicExecutionFeeMultiplierRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryMarketAtomicExecutionFeeMultiplierRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketAtomicExecutionFeeMultiplierRequest): QueryMarketAtomicExecutionFeeMultiplierRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketAtomicExecutionFeeMultiplierRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierRequest
 */
export const QueryMarketAtomicExecutionFeeMultiplierRequest = new QueryMarketAtomicExecutionFeeMultiplierRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketAtomicExecutionFeeMultiplierResponse$Type extends MessageType<QueryMarketAtomicExecutionFeeMultiplierResponse> {
    constructor() {
        super("injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierResponse", [
            { no: 1, name: "multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryMarketAtomicExecutionFeeMultiplierResponse>): QueryMarketAtomicExecutionFeeMultiplierResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.multiplier = "";
        if (value !== undefined)
            reflectionMergePartial<QueryMarketAtomicExecutionFeeMultiplierResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketAtomicExecutionFeeMultiplierResponse): QueryMarketAtomicExecutionFeeMultiplierResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string multiplier */ 1:
                    message.multiplier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketAtomicExecutionFeeMultiplierResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string multiplier = 1; */
        if (message.multiplier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.multiplier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketAtomicExecutionFeeMultiplierResponse
 */
export const QueryMarketAtomicExecutionFeeMultiplierResponse = new QueryMarketAtomicExecutionFeeMultiplierResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryActiveStakeGrantRequest$Type extends MessageType<QueryActiveStakeGrantRequest> {
    constructor() {
        super("injective.exchange.v2.QueryActiveStakeGrantRequest", [
            { no: 1, name: "grantee", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryActiveStakeGrantRequest>): QueryActiveStakeGrantRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantee = "";
        if (value !== undefined)
            reflectionMergePartial<QueryActiveStakeGrantRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryActiveStakeGrantRequest): QueryActiveStakeGrantRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grantee */ 1:
                    message.grantee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryActiveStakeGrantRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grantee = 1; */
        if (message.grantee !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryActiveStakeGrantRequest
 */
export const QueryActiveStakeGrantRequest = new QueryActiveStakeGrantRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryActiveStakeGrantResponse$Type extends MessageType<QueryActiveStakeGrantResponse> {
    constructor() {
        super("injective.exchange.v2.QueryActiveStakeGrantResponse", [
            { no: 1, name: "grant", kind: "message", T: () => ActiveGrant },
            { no: 2, name: "effective_grant", kind: "message", T: () => EffectiveGrant }
        ]);
    }
    create(value?: PartialMessage<QueryActiveStakeGrantResponse>): QueryActiveStakeGrantResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryActiveStakeGrantResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryActiveStakeGrantResponse): QueryActiveStakeGrantResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.ActiveGrant grant */ 1:
                    message.grant = ActiveGrant.internalBinaryRead(reader, reader.uint32(), options, message.grant);
                    break;
                case /* injective.exchange.v2.EffectiveGrant effective_grant */ 2:
                    message.effectiveGrant = EffectiveGrant.internalBinaryRead(reader, reader.uint32(), options, message.effectiveGrant);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryActiveStakeGrantResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.ActiveGrant grant = 1; */
        if (message.grant)
            ActiveGrant.internalBinaryWrite(message.grant, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.EffectiveGrant effective_grant = 2; */
        if (message.effectiveGrant)
            EffectiveGrant.internalBinaryWrite(message.effectiveGrant, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryActiveStakeGrantResponse
 */
export const QueryActiveStakeGrantResponse = new QueryActiveStakeGrantResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryGrantAuthorizationRequest$Type extends MessageType<QueryGrantAuthorizationRequest> {
    constructor() {
        super("injective.exchange.v2.QueryGrantAuthorizationRequest", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grantee", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryGrantAuthorizationRequest>): QueryGrantAuthorizationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        message.grantee = "";
        if (value !== undefined)
            reflectionMergePartial<QueryGrantAuthorizationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryGrantAuthorizationRequest): QueryGrantAuthorizationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                case /* string grantee */ 2:
                    message.grantee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryGrantAuthorizationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        /* string grantee = 2; */
        if (message.grantee !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.grantee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryGrantAuthorizationRequest
 */
export const QueryGrantAuthorizationRequest = new QueryGrantAuthorizationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryGrantAuthorizationResponse$Type extends MessageType<QueryGrantAuthorizationResponse> {
    constructor() {
        super("injective.exchange.v2.QueryGrantAuthorizationResponse", [
            { no: 1, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
        ]);
    }
    create(value?: PartialMessage<QueryGrantAuthorizationResponse>): QueryGrantAuthorizationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<QueryGrantAuthorizationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryGrantAuthorizationResponse): QueryGrantAuthorizationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string amount */ 1:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryGrantAuthorizationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string amount = 1; */
        if (message.amount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryGrantAuthorizationResponse
 */
export const QueryGrantAuthorizationResponse = new QueryGrantAuthorizationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryGrantAuthorizationsRequest$Type extends MessageType<QueryGrantAuthorizationsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryGrantAuthorizationsRequest", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryGrantAuthorizationsRequest>): QueryGrantAuthorizationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        if (value !== undefined)
            reflectionMergePartial<QueryGrantAuthorizationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryGrantAuthorizationsRequest): QueryGrantAuthorizationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryGrantAuthorizationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryGrantAuthorizationsRequest
 */
export const QueryGrantAuthorizationsRequest = new QueryGrantAuthorizationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryGrantAuthorizationsResponse$Type extends MessageType<QueryGrantAuthorizationsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryGrantAuthorizationsResponse", [
            { no: 1, name: "total_grant_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 2, name: "grants", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GrantAuthorization }
        ]);
    }
    create(value?: PartialMessage<QueryGrantAuthorizationsResponse>): QueryGrantAuthorizationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalGrantAmount = "";
        message.grants = [];
        if (value !== undefined)
            reflectionMergePartial<QueryGrantAuthorizationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryGrantAuthorizationsResponse): QueryGrantAuthorizationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string total_grant_amount */ 1:
                    message.totalGrantAmount = reader.string();
                    break;
                case /* repeated injective.exchange.v2.GrantAuthorization grants */ 2:
                    message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryGrantAuthorizationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string total_grant_amount = 1; */
        if (message.totalGrantAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.totalGrantAmount);
        /* repeated injective.exchange.v2.GrantAuthorization grants = 2; */
        for (let i = 0; i < message.grants.length; i++)
            GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryGrantAuthorizationsResponse
 */
export const QueryGrantAuthorizationsResponse = new QueryGrantAuthorizationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketBalanceRequest$Type extends MessageType<QueryMarketBalanceRequest> {
    constructor() {
        super("injective.exchange.v2.QueryMarketBalanceRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryMarketBalanceRequest>): QueryMarketBalanceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryMarketBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketBalanceRequest): QueryMarketBalanceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketBalanceRequest
 */
export const QueryMarketBalanceRequest = new QueryMarketBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketBalanceResponse$Type extends MessageType<QueryMarketBalanceResponse> {
    constructor() {
        super("injective.exchange.v2.QueryMarketBalanceResponse", [
            { no: 1, name: "balance", kind: "message", T: () => MarketBalance }
        ]);
    }
    create(value?: PartialMessage<QueryMarketBalanceResponse>): QueryMarketBalanceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryMarketBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketBalanceResponse): QueryMarketBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.MarketBalance balance */ 1:
                    message.balance = MarketBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.MarketBalance balance = 1; */
        if (message.balance)
            MarketBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketBalanceResponse
 */
export const QueryMarketBalanceResponse = new QueryMarketBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketBalancesRequest$Type extends MessageType<QueryMarketBalancesRequest> {
    constructor() {
        super("injective.exchange.v2.QueryMarketBalancesRequest", []);
    }
    create(value?: PartialMessage<QueryMarketBalancesRequest>): QueryMarketBalancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryMarketBalancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketBalancesRequest): QueryMarketBalancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketBalancesRequest
 */
export const QueryMarketBalancesRequest = new QueryMarketBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMarketBalancesResponse$Type extends MessageType<QueryMarketBalancesResponse> {
    constructor() {
        super("injective.exchange.v2.QueryMarketBalancesResponse", [
            { no: 1, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketBalance }
        ]);
    }
    create(value?: PartialMessage<QueryMarketBalancesResponse>): QueryMarketBalancesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<QueryMarketBalancesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMarketBalancesResponse): QueryMarketBalancesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.MarketBalance balances */ 1:
                    message.balances.push(MarketBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMarketBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.MarketBalance balances = 1; */
        for (let i = 0; i < message.balances.length; i++)
            MarketBalance.internalBinaryWrite(message.balances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryMarketBalancesResponse
 */
export const QueryMarketBalancesResponse = new QueryMarketBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketBalance$Type extends MessageType<MarketBalance> {
    constructor() {
        super("injective.exchange.v2.MarketBalance", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<MarketBalance>): MarketBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.balance = "";
        if (value !== undefined)
            reflectionMergePartial<MarketBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketBalance): MarketBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string balance */ 2:
                    message.balance = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string balance = 2; */
        if (message.balance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.balance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MarketBalance
 */
export const MarketBalance = new MarketBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDenomMinNotionalRequest$Type extends MessageType<QueryDenomMinNotionalRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDenomMinNotionalRequest", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDenomMinNotionalRequest>): QueryDenomMinNotionalRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDenomMinNotionalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDenomMinNotionalRequest): QueryDenomMinNotionalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDenomMinNotionalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDenomMinNotionalRequest
 */
export const QueryDenomMinNotionalRequest = new QueryDenomMinNotionalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDenomMinNotionalResponse$Type extends MessageType<QueryDenomMinNotionalResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDenomMinNotionalResponse", [
            { no: 1, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<QueryDenomMinNotionalResponse>): QueryDenomMinNotionalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDenomMinNotionalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDenomMinNotionalResponse): QueryDenomMinNotionalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string amount */ 1:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDenomMinNotionalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string amount = 1; */
        if (message.amount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDenomMinNotionalResponse
 */
export const QueryDenomMinNotionalResponse = new QueryDenomMinNotionalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDenomMinNotionalsRequest$Type extends MessageType<QueryDenomMinNotionalsRequest> {
    constructor() {
        super("injective.exchange.v2.QueryDenomMinNotionalsRequest", []);
    }
    create(value?: PartialMessage<QueryDenomMinNotionalsRequest>): QueryDenomMinNotionalsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryDenomMinNotionalsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDenomMinNotionalsRequest): QueryDenomMinNotionalsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDenomMinNotionalsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDenomMinNotionalsRequest
 */
export const QueryDenomMinNotionalsRequest = new QueryDenomMinNotionalsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDenomMinNotionalsResponse$Type extends MessageType<QueryDenomMinNotionalsResponse> {
    constructor() {
        super("injective.exchange.v2.QueryDenomMinNotionalsResponse", [
            { no: 1, name: "denom_min_notionals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DenomMinNotional }
        ]);
    }
    create(value?: PartialMessage<QueryDenomMinNotionalsResponse>): QueryDenomMinNotionalsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denomMinNotionals = [];
        if (value !== undefined)
            reflectionMergePartial<QueryDenomMinNotionalsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDenomMinNotionalsResponse): QueryDenomMinNotionalsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals */ 1:
                    message.denomMinNotionals.push(DenomMinNotional.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDenomMinNotionalsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals = 1; */
        for (let i = 0; i < message.denomMinNotionals.length; i++)
            DenomMinNotional.internalBinaryWrite(message.denomMinNotionals[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryDenomMinNotionalsResponse
 */
export const QueryDenomMinNotionalsResponse = new QueryDenomMinNotionalsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenInterest$Type extends MessageType<OpenInterest> {
    constructor() {
        super("injective.exchange.v2.OpenInterest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<OpenInterest>): OpenInterest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.balance = "";
        if (value !== undefined)
            reflectionMergePartial<OpenInterest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenInterest): OpenInterest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string balance */ 2:
                    message.balance = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenInterest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string balance = 2; */
        if (message.balance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.balance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OpenInterest
 */
export const OpenInterest = new OpenInterest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryOpenInterestRequest$Type extends MessageType<QueryOpenInterestRequest> {
    constructor() {
        super("injective.exchange.v2.QueryOpenInterestRequest", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryOpenInterestRequest>): QueryOpenInterestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<QueryOpenInterestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryOpenInterestRequest): QueryOpenInterestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryOpenInterestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryOpenInterestRequest
 */
export const QueryOpenInterestRequest = new QueryOpenInterestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryOpenInterestResponse$Type extends MessageType<QueryOpenInterestResponse> {
    constructor() {
        super("injective.exchange.v2.QueryOpenInterestResponse", [
            { no: 1, name: "amount", kind: "message", T: () => OpenInterest }
        ]);
    }
    create(value?: PartialMessage<QueryOpenInterestResponse>): QueryOpenInterestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryOpenInterestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryOpenInterestResponse): QueryOpenInterestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.OpenInterest amount */ 1:
                    message.amount = OpenInterest.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryOpenInterestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.OpenInterest amount = 1; */
        if (message.amount)
            OpenInterest.internalBinaryWrite(message.amount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.QueryOpenInterestResponse
 */
export const QueryOpenInterestResponse = new QueryOpenInterestResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.exchange.v2.Query
 */
export const Query = new ServiceType("injective.exchange.v2.Query", [
    { name: "L3DerivativeOrderBook", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/L3OrderBook/{market_id}" } }, I: QueryFullDerivativeOrderbookRequest, O: QueryFullDerivativeOrderbookResponse },
    { name: "L3SpotOrderBook", options: { "google.api.http": { get: "/injective/exchange/v2/spot/L3OrderBook/{market_id}" } }, I: QueryFullSpotOrderbookRequest, O: QueryFullSpotOrderbookResponse },
    { name: "QueryExchangeParams", options: { "google.api.http": { get: "/injective/exchange/v2/exchangeParams" } }, I: QueryExchangeParamsRequest, O: QueryExchangeParamsResponse },
    { name: "SubaccountDeposits", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/subaccountDeposits" } }, I: QuerySubaccountDepositsRequest, O: QuerySubaccountDepositsResponse },
    { name: "SubaccountDeposit", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/subaccountDeposit" } }, I: QuerySubaccountDepositRequest, O: QuerySubaccountDepositResponse },
    { name: "ExchangeBalances", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/exchangeBalances" } }, I: QueryExchangeBalancesRequest, O: QueryExchangeBalancesResponse },
    { name: "AggregateVolume", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateVolume/{account}" } }, I: QueryAggregateVolumeRequest, O: QueryAggregateVolumeResponse },
    { name: "AggregateVolumes", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateVolumes" } }, I: QueryAggregateVolumesRequest, O: QueryAggregateVolumesResponse },
    { name: "AggregateMarketVolume", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateMarketVolume/{market_id}" } }, I: QueryAggregateMarketVolumeRequest, O: QueryAggregateMarketVolumeResponse },
    { name: "AggregateMarketVolumes", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/aggregateMarketVolumes" } }, I: QueryAggregateMarketVolumesRequest, O: QueryAggregateMarketVolumesResponse },
    { name: "AuctionExchangeTransferDenomDecimal", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/auction_exchange_transfer_denom_decimal/{denom}" } }, I: QueryAuctionExchangeTransferDenomDecimalRequest, O: QueryAuctionExchangeTransferDenomDecimalResponse },
    { name: "AuctionExchangeTransferDenomDecimals", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/auction_exchange_transfer_denom_decimals" } }, I: QueryAuctionExchangeTransferDenomDecimalsRequest, O: QueryAuctionExchangeTransferDenomDecimalsResponse },
    { name: "SpotMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/spot/markets" } }, I: QuerySpotMarketsRequest, O: QuerySpotMarketsResponse },
    { name: "SpotMarket", options: { "google.api.http": { get: "/injective/exchange/v2/spot/markets/{market_id}" } }, I: QuerySpotMarketRequest, O: QuerySpotMarketResponse },
    { name: "FullSpotMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/spot/full_markets" } }, I: QueryFullSpotMarketsRequest, O: QueryFullSpotMarketsResponse },
    { name: "FullSpotMarket", options: { "google.api.http": { get: "/injective/exchange/v2/spot/full_market/{market_id}" } }, I: QueryFullSpotMarketRequest, O: QueryFullSpotMarketResponse },
    { name: "SpotOrderbook", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orderbook/{market_id}" } }, I: QuerySpotOrderbookRequest, O: QuerySpotOrderbookResponse },
    { name: "TraderSpotOrders", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orders/{market_id}/{subaccount_id}" } }, I: QueryTraderSpotOrdersRequest, O: QueryTraderSpotOrdersResponse },
    { name: "AccountAddressSpotOrders", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orders/{market_id}/account/{account_address}" } }, I: QueryAccountAddressSpotOrdersRequest, O: QueryAccountAddressSpotOrdersResponse },
    { name: "SpotOrdersByHashes", options: { "google.api.http": { get: "/injective/exchange/v2/spot/orders_by_hashes/{market_id}/{subaccount_id}" } }, I: QuerySpotOrdersByHashesRequest, O: QuerySpotOrdersByHashesResponse },
    { name: "SubaccountOrders", options: { "google.api.http": { get: "/injective/exchange/v2/orders/{subaccount_id}" } }, I: QuerySubaccountOrdersRequest, O: QuerySubaccountOrdersResponse },
    { name: "TraderSpotTransientOrders", options: { "google.api.http": { get: "/injective/exchange/v2/spot/transient_orders/{market_id}/{subaccount_id}" } }, I: QueryTraderSpotOrdersRequest, O: QueryTraderSpotOrdersResponse },
    { name: "SpotMidPriceAndTOB", options: { "google.api.http": { get: "/injective/exchange/v2/spot/mid_price_and_tob/{market_id}" } }, I: QuerySpotMidPriceAndTOBRequest, O: QuerySpotMidPriceAndTOBResponse },
    { name: "DerivativeMidPriceAndTOB", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/mid_price_and_tob/{market_id}" } }, I: QueryDerivativeMidPriceAndTOBRequest, O: QueryDerivativeMidPriceAndTOBResponse },
    { name: "DerivativeOrderbook", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orderbook/{market_id}" } }, I: QueryDerivativeOrderbookRequest, O: QueryDerivativeOrderbookResponse },
    { name: "TraderDerivativeOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders/{market_id}/{subaccount_id}" } }, I: QueryTraderDerivativeOrdersRequest, O: QueryTraderDerivativeOrdersResponse },
    { name: "AccountAddressDerivativeOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders/{market_id}/account/{account_address}" } }, I: QueryAccountAddressDerivativeOrdersRequest, O: QueryAccountAddressDerivativeOrdersResponse },
    { name: "DerivativeOrdersByHashes", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders_by_hashes/{market_id}/{subaccount_id}" } }, I: QueryDerivativeOrdersByHashesRequest, O: QueryDerivativeOrdersByHashesResponse },
    { name: "TraderDerivativeTransientOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/transient_orders/{market_id}/{subaccount_id}" } }, I: QueryTraderDerivativeOrdersRequest, O: QueryTraderDerivativeOrdersResponse },
    { name: "DerivativeMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/markets" } }, I: QueryDerivativeMarketsRequest, O: QueryDerivativeMarketsResponse },
    { name: "DerivativeMarket", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/markets/{market_id}" } }, I: QueryDerivativeMarketRequest, O: QueryDerivativeMarketResponse },
    { name: "DerivativeMarketAddress", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/market_address/{market_id}" } }, I: QueryDerivativeMarketAddressRequest, O: QueryDerivativeMarketAddressResponse },
    { name: "SubaccountTradeNonce", options: { "google.api.http": { get: "/injective/exchange/v2/exchange/{subaccount_id}" } }, I: QuerySubaccountTradeNonceRequest, O: QuerySubaccountTradeNonceResponse },
    { name: "ExchangeModuleState", options: { "google.api.http": { get: "/injective/exchange/v2/module_state" } }, I: QueryModuleStateRequest, O: QueryModuleStateResponse },
    { name: "Positions", options: { "google.api.http": { get: "/injective/exchange/v2/positions" } }, I: QueryPositionsRequest, O: QueryPositionsResponse },
    { name: "PositionsInMarket", options: { "google.api.http": { get: "/injective/exchange/v2/positions_in_market/{market_id}" } }, I: QueryPositionsInMarketRequest, O: QueryPositionsInMarketResponse },
    { name: "SubaccountPositions", options: { "google.api.http": { get: "/injective/exchange/v2/subaccount_positions/{subaccount_id}" } }, I: QuerySubaccountPositionsRequest, O: QuerySubaccountPositionsResponse },
    { name: "SubaccountPositionInMarket", options: { "google.api.http": { get: "/injective/exchange/v2/positions/{subaccount_id}/{market_id}" } }, I: QuerySubaccountPositionInMarketRequest, O: QuerySubaccountPositionInMarketResponse },
    { name: "SubaccountEffectivePositionInMarket", options: { "google.api.http": { get: "/injective/exchange/v2/effective_positions/{subaccount_id}/{market_id}" } }, I: QuerySubaccountEffectivePositionInMarketRequest, O: QuerySubaccountEffectivePositionInMarketResponse },
    { name: "PerpetualMarketInfo", options: { "google.api.http": { get: "/injective/exchange/v2/perpetual_market_info/{market_id}" } }, I: QueryPerpetualMarketInfoRequest, O: QueryPerpetualMarketInfoResponse },
    { name: "ExpiryFuturesMarketInfo", options: { "google.api.http": { get: "/injective/exchange/v2/expiry_market_info/{market_id}" } }, I: QueryExpiryFuturesMarketInfoRequest, O: QueryExpiryFuturesMarketInfoResponse },
    { name: "PerpetualMarketFunding", options: { "google.api.http": { get: "/injective/exchange/v2/perpetual_market_funding/{market_id}" } }, I: QueryPerpetualMarketFundingRequest, O: QueryPerpetualMarketFundingResponse },
    { name: "SubaccountOrderMetadata", options: { "google.api.http": { get: "/injective/exchange/v2/order_metadata/{subaccount_id}" } }, I: QuerySubaccountOrderMetadataRequest, O: QuerySubaccountOrderMetadataResponse },
    { name: "TradeRewardPoints", options: { "google.api.http": { get: "/injective/exchange/v2/trade_reward_points" } }, I: QueryTradeRewardPointsRequest, O: QueryTradeRewardPointsResponse },
    { name: "PendingTradeRewardPoints", options: { "google.api.http": { get: "/injective/exchange/v2/pending_trade_reward_points" } }, I: QueryTradeRewardPointsRequest, O: QueryTradeRewardPointsResponse },
    { name: "TradeRewardCampaign", options: { "google.api.http": { get: "/injective/exchange/v2/trade_reward_campaign" } }, I: QueryTradeRewardCampaignRequest, O: QueryTradeRewardCampaignResponse },
    { name: "FeeDiscountAccountInfo", options: { "google.api.http": { get: "/injective/exchange/v2/fee_discount_account_info/{account}" } }, I: QueryFeeDiscountAccountInfoRequest, O: QueryFeeDiscountAccountInfoResponse },
    { name: "FeeDiscountSchedule", options: { "google.api.http": { get: "/injective/exchange/v2/fee_discount_schedule" } }, I: QueryFeeDiscountScheduleRequest, O: QueryFeeDiscountScheduleResponse },
    { name: "BalanceMismatches", options: { "google.api.http": { get: "/injective/exchange/v2/balance_mismatches/{dust_factor}" } }, I: QueryBalanceMismatchesRequest, O: QueryBalanceMismatchesResponse },
    { name: "BalanceWithBalanceHolds", options: { "google.api.http": { get: "/injective/exchange/v2/balances_with_balance_holds" } }, I: QueryBalanceWithBalanceHoldsRequest, O: QueryBalanceWithBalanceHoldsResponse },
    { name: "FeeDiscountTierStatistics", options: { "google.api.http": { get: "/injective/exchange/v2/fee_discount_tier_stats" } }, I: QueryFeeDiscountTierStatisticsRequest, O: QueryFeeDiscountTierStatisticsResponse },
    { name: "MitoVaultInfos", options: { "google.api.http": { get: "/injective/exchange/v2/mito_vault_infos" } }, I: MitoVaultInfosRequest, O: MitoVaultInfosResponse },
    { name: "QueryMarketIDFromVault", options: { "google.api.http": { get: "/injective/exchange/v2/vault_market_id/{vault_address}" } }, I: QueryMarketIDFromVaultRequest, O: QueryMarketIDFromVaultResponse },
    { name: "HistoricalTradeRecords", options: { "google.api.http": { get: "/injective/exchange/v2/historical_trade_records" } }, I: QueryHistoricalTradeRecordsRequest, O: QueryHistoricalTradeRecordsResponse },
    { name: "IsOptedOutOfRewards", options: { "google.api.http": { get: "/injective/exchange/v2/is_opted_out_of_rewards/{account}" } }, I: QueryIsOptedOutOfRewardsRequest, O: QueryIsOptedOutOfRewardsResponse },
    { name: "OptedOutOfRewardsAccounts", options: { "google.api.http": { get: "/injective/exchange/v2/opted_out_of_rewards_accounts" } }, I: QueryOptedOutOfRewardsAccountsRequest, O: QueryOptedOutOfRewardsAccountsResponse },
    { name: "MarketVolatility", options: { "google.api.http": { get: "/injective/exchange/v2/market_volatility/{market_id}" } }, I: QueryMarketVolatilityRequest, O: QueryMarketVolatilityResponse },
    { name: "BinaryOptionsMarkets", options: { "google.api.http": { get: "/injective/exchange/v2/binary_options/markets" } }, I: QueryBinaryMarketsRequest, O: QueryBinaryMarketsResponse },
    { name: "TraderDerivativeConditionalOrders", options: { "google.api.http": { get: "/injective/exchange/v2/derivative/orders/conditional/{market_id}/{subaccount_id}" } }, I: QueryTraderDerivativeConditionalOrdersRequest, O: QueryTraderDerivativeConditionalOrdersResponse },
    { name: "MarketAtomicExecutionFeeMultiplier", options: { "google.api.http": { get: "/injective/exchange/v2/atomic_order_fee_multiplier" } }, I: QueryMarketAtomicExecutionFeeMultiplierRequest, O: QueryMarketAtomicExecutionFeeMultiplierResponse },
    { name: "ActiveStakeGrant", options: { "google.api.http": { get: "/injective/exchange/v2/active_stake_grant/{grantee}" } }, I: QueryActiveStakeGrantRequest, O: QueryActiveStakeGrantResponse },
    { name: "GrantAuthorization", options: { "google.api.http": { get: "/injective/exchange/v2/grant_authorization/{granter}/{grantee}" } }, I: QueryGrantAuthorizationRequest, O: QueryGrantAuthorizationResponse },
    { name: "GrantAuthorizations", options: { "google.api.http": { get: "/injective/exchange/v2/grant_authorizations/{granter}" } }, I: QueryGrantAuthorizationsRequest, O: QueryGrantAuthorizationsResponse },
    { name: "MarketBalance", options: { "google.api.http": { get: "/injective/exchange/v2/market_balance/{market_id}" } }, I: QueryMarketBalanceRequest, O: QueryMarketBalanceResponse },
    { name: "MarketBalances", options: { "google.api.http": { get: "/injective/exchange/v2/market_balances" } }, I: QueryMarketBalancesRequest, O: QueryMarketBalancesResponse },
    { name: "DenomMinNotional", options: { "google.api.http": { get: "/injective/exchange/v2/denom_min_notional/{denom}" } }, I: QueryDenomMinNotionalRequest, O: QueryDenomMinNotionalResponse },
    { name: "DenomMinNotionals", options: { "google.api.http": { get: "/injective/exchange/v2/denom_min_notionals" } }, I: QueryDenomMinNotionalsRequest, O: QueryDenomMinNotionalsResponse },
    { name: "OpenInterest", options: { "google.api.http": { get: "/injective/exchange/v2/open_interest" } }, I: QueryOpenInterestRequest, O: QueryOpenInterestResponse }
]);
