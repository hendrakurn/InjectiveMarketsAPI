import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
var OrderType = /* @__PURE__ */ ((OrderType2) => {
  OrderType2[OrderType2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  OrderType2[OrderType2["BUY"] = 1] = "BUY";
  OrderType2[OrderType2["SELL"] = 2] = "SELL";
  OrderType2[OrderType2["STOP_BUY"] = 3] = "STOP_BUY";
  OrderType2[OrderType2["STOP_SELL"] = 4] = "STOP_SELL";
  OrderType2[OrderType2["TAKE_BUY"] = 5] = "TAKE_BUY";
  OrderType2[OrderType2["TAKE_SELL"] = 6] = "TAKE_SELL";
  OrderType2[OrderType2["BUY_PO"] = 7] = "BUY_PO";
  OrderType2[OrderType2["SELL_PO"] = 8] = "SELL_PO";
  OrderType2[OrderType2["BUY_ATOMIC"] = 9] = "BUY_ATOMIC";
  OrderType2[OrderType2["SELL_ATOMIC"] = 10] = "SELL_ATOMIC";
  return OrderType2;
})(OrderType || {});
var OrderMask = /* @__PURE__ */ ((OrderMask2) => {
  OrderMask2[OrderMask2["UNUSED"] = 0] = "UNUSED";
  OrderMask2[OrderMask2["ANY"] = 1] = "ANY";
  OrderMask2[OrderMask2["REGULAR"] = 2] = "REGULAR";
  OrderMask2[OrderMask2["CONDITIONAL"] = 4] = "CONDITIONAL";
  OrderMask2[OrderMask2["DIRECTION_BUY_OR_HIGHER"] = 8] = "DIRECTION_BUY_OR_HIGHER";
  OrderMask2[OrderMask2["DIRECTION_SELL_OR_LOWER"] = 16] = "DIRECTION_SELL_OR_LOWER";
  OrderMask2[OrderMask2["TYPE_MARKET"] = 32] = "TYPE_MARKET";
  OrderMask2[OrderMask2["TYPE_LIMIT"] = 64] = "TYPE_LIMIT";
  return OrderMask2;
})(OrderMask || {});
var AtomicMarketOrderAccessLevel = /* @__PURE__ */ ((AtomicMarketOrderAccessLevel2) => {
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["Nobody"] = 0] = "Nobody";
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["BeginBlockerSmartContractsOnly"] = 1] = "BeginBlockerSmartContractsOnly";
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["SmartContractsOnly"] = 2] = "SmartContractsOnly";
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["Everyone"] = 3] = "Everyone";
  return AtomicMarketOrderAccessLevel2;
})(AtomicMarketOrderAccessLevel || {});
class OrderInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OrderInfo", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.feeRecipient = "";
    message.price = "";
    message.quantity = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string fee_recipient */
        2:
          message.feeRecipient = reader.string();
          break;
        case /* string price */
        3:
          message.price = reader.string();
          break;
        case /* string quantity */
        4:
          message.quantity = reader.string();
          break;
        case /* string cid */
        5:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.feeRecipient !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.price !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quantity);
    if (message.cid !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderInfo = new OrderInfo$Type();
class SpotOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SpotOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "order_type", kind: "enum", T: () => ["injective.exchange.v2.OrderType", OrderType] },
      { no: 4, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "expiration_block", kind: "scalar", T: 3, L: 0, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderType = 0;
    message.triggerPrice = "";
    message.expirationBlock = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.OrderInfo order_info */
        2:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v2.OrderType order_type */
        3:
          message.orderType = reader.int32();
          break;
        case /* string trigger_price */
        4:
          message.triggerPrice = reader.string();
          break;
        case /* int64 expiration_block */
        5:
          message.expirationBlock = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(3, WireType.Varint).int32(message.orderType);
    if (message.triggerPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.expirationBlock !== 0n)
      writer.tag(5, WireType.Varint).int64(message.expirationBlock);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotOrder = new SpotOrder$Type();
class SpotMarketOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SpotMarketOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "balance_hold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "order_type", kind: "enum", T: () => ["injective.exchange.v2.OrderType", OrderType] },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balanceHold = "";
    message.orderHash = new Uint8Array(0);
    message.orderType = 0;
    message.triggerPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* string balance_hold */
        2:
          message.balanceHold = reader.string();
          break;
        case /* bytes order_hash */
        3:
          message.orderHash = reader.bytes();
          break;
        case /* injective.exchange.v2.OrderType order_type */
        4:
          message.orderType = reader.int32();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.balanceHold !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.balanceHold);
    if (message.orderHash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.orderType !== 0)
      writer.tag(4, WireType.Varint).int32(message.orderType);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketOrder = new SpotMarketOrder$Type();
class SpotLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SpotLimitOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v2.OrderType", OrderType] },
      { no: 3, name: "fillable", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 6, name: "expiration_block", kind: "scalar", T: 3, L: 0, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderType = 0;
    message.fillable = "";
    message.triggerPrice = "";
    message.orderHash = new Uint8Array(0);
    message.expirationBlock = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v2.OrderType order_type */
        2:
          message.orderType = reader.int32();
          break;
        case /* string fillable */
        3:
          message.fillable = reader.string();
          break;
        case /* string trigger_price */
        4:
          message.triggerPrice = reader.string();
          break;
        case /* bytes order_hash */
        5:
          message.orderHash = reader.bytes();
          break;
        case /* int64 expiration_block */
        6:
          message.expirationBlock = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(2, WireType.Varint).int32(message.orderType);
    if (message.fillable !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.fillable);
    if (message.triggerPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.orderHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.expirationBlock !== 0n)
      writer.tag(6, WireType.Varint).int64(message.expirationBlock);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotLimitOrder = new SpotLimitOrder$Type();
class DerivativeOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "order_type", kind: "enum", T: () => ["injective.exchange.v2.OrderType", OrderType] },
      { no: 4, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "expiration_block", kind: "scalar", T: 3, L: 0, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderType = 0;
    message.margin = "";
    message.triggerPrice = "";
    message.expirationBlock = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.OrderInfo order_info */
        2:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v2.OrderType order_type */
        3:
          message.orderType = reader.int32();
          break;
        case /* string margin */
        4:
          message.margin = reader.string();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        case /* int64 expiration_block */
        6:
          message.expirationBlock = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(3, WireType.Varint).int32(message.orderType);
    if (message.margin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.margin);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.expirationBlock !== 0n)
      writer.tag(6, WireType.Varint).int64(message.expirationBlock);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeOrder = new DerivativeOrder$Type();
class DerivativeMarketOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeMarketOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v2.OrderType", OrderType] },
      { no: 3, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "margin_hold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 6,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderType = 0;
    message.margin = "";
    message.marginHold = "";
    message.triggerPrice = "";
    message.orderHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v2.OrderType order_type */
        2:
          message.orderType = reader.int32();
          break;
        case /* string margin */
        3:
          message.margin = reader.string();
          break;
        case /* string margin_hold */
        4:
          message.marginHold = reader.string();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        case /* bytes order_hash */
        6:
          message.orderHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(2, WireType.Varint).int32(message.orderType);
    if (message.margin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.margin);
    if (message.marginHold !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marginHold);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.orderHash.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.orderHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketOrder = new DerivativeMarketOrder$Type();
class DerivativeLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeLimitOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v2.OrderType", OrderType] },
      { no: 3, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "fillable", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 6,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 7, name: "expiration_block", kind: "scalar", T: 3, L: 0, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderType = 0;
    message.margin = "";
    message.fillable = "";
    message.triggerPrice = "";
    message.orderHash = new Uint8Array(0);
    message.expirationBlock = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v2.OrderType order_type */
        2:
          message.orderType = reader.int32();
          break;
        case /* string margin */
        3:
          message.margin = reader.string();
          break;
        case /* string fillable */
        4:
          message.fillable = reader.string();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        case /* bytes order_hash */
        6:
          message.orderHash = reader.bytes();
          break;
        case /* int64 expiration_block */
        7:
          message.expirationBlock = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(2, WireType.Varint).int32(message.orderType);
    if (message.margin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.margin);
    if (message.fillable !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fillable);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.orderHash.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.expirationBlock !== 0n)
      writer.tag(7, WireType.Varint).int64(message.expirationBlock);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
export {
  AtomicMarketOrderAccessLevel,
  DerivativeLimitOrder,
  DerivativeMarketOrder,
  DerivativeOrder,
  OrderInfo,
  OrderMask,
  OrderType,
  SpotLimitOrder,
  SpotMarketOrder,
  SpotOrder
};
