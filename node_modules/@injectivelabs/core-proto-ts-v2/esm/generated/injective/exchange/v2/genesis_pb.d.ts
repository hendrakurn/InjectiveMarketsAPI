// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v2/genesis.proto" (package "injective.exchange.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ActiveGrant } from "./exchange_pb";
import { GrantAuthorization } from "./exchange_pb";
import { SubaccountTradeNonce } from "./exchange_pb";
import { FeeDiscountTierTTL } from "./exchange_pb";
import { DenomMinNotional } from "./exchange_pb";
import { MarketVolume } from "./market_pb";
import { AggregateSubaccountVolumeRecord } from "./exchange_pb";
import { MarketFeeMultiplier } from "./market_pb";
import { ConditionalDerivativeOrderBook } from "./orderbook_pb";
import { DenomDecimals } from "./exchange_pb";
import { BinaryOptionsMarket } from "./market_pb";
import { TradeRecords } from "./exchange_pb";
import { FeeDiscountSchedule } from "./exchange_pb";
import { CampaignRewardPool } from "./exchange_pb";
import { TradingRewardCampaignInfo } from "./exchange_pb";
import { DerivativeMarketSettlementInfo } from "./market_pb";
import { PerpetualMarketFundingState } from "./market_pb";
import { PerpetualMarketInfo } from "./market_pb";
import { ExpiryFuturesMarketInfoState } from "./market_pb";
import { DerivativePosition } from "./exchange_pb";
import { Balance } from "./exchange_pb";
import { DerivativeOrderBook } from "./orderbook_pb";
import { SpotOrderBook } from "./orderbook_pb";
import { DerivativeMarket } from "./market_pb";
import { SpotMarket } from "./market_pb";
import { Params } from "./exchange_pb";
/**
 * GenesisState defines the exchange module's genesis state.
 *
 * @generated from protobuf message injective.exchange.v2.GenesisState
 */
export interface GenesisState {
    /**
     * params defines all the parameters of related to exchange.
     *
     * @generated from protobuf field: injective.exchange.v2.Params params = 1
     */
    params?: Params;
    /**
     * spot_markets is an array containing the genesis trade pairs
     *
     * @generated from protobuf field: repeated injective.exchange.v2.SpotMarket spot_markets = 2
     */
    spotMarkets: SpotMarket[];
    /**
     * derivative_markets is an array containing the genesis derivative markets
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeMarket derivative_markets = 3
     */
    derivativeMarkets: DerivativeMarket[];
    /**
     * spot_orderbook defines the spot exchange limit orderbook active at genesis.
     *
     * @generated from protobuf field: repeated injective.exchange.v2.SpotOrderBook spot_orderbook = 4
     */
    spotOrderbook: SpotOrderBook[];
    /**
     * derivative_orderbook defines the derivative exchange limit orderbook active
     * at genesis.
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeOrderBook derivative_orderbook = 5
     */
    derivativeOrderbook: DerivativeOrderBook[];
    /**
     * balances defines the exchange users balances active at genesis.
     *
     * @generated from protobuf field: repeated injective.exchange.v2.Balance balances = 6
     */
    balances: Balance[];
    /**
     * positions defines the exchange derivative positions at genesis
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativePosition positions = 7
     */
    positions: DerivativePosition[];
    /**
     * subaccount_trade_nonces defines the subaccount trade nonces for the
     * subaccounts at genesis
     *
     * @generated from protobuf field: repeated injective.exchange.v2.SubaccountNonce subaccount_trade_nonces = 8
     */
    subaccountTradeNonces: SubaccountNonce[];
    /**
     * expiry_futures_market_info defines the market info for the expiry futures
     * markets at genesis
     *
     * @generated from protobuf field: repeated injective.exchange.v2.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9
     */
    expiryFuturesMarketInfoState: ExpiryFuturesMarketInfoState[];
    /**
     * perpetual_market_info defines the market info for the perpetual derivative
     * markets at genesis
     *
     * @generated from protobuf field: repeated injective.exchange.v2.PerpetualMarketInfo perpetual_market_info = 10
     */
    perpetualMarketInfo: PerpetualMarketInfo[];
    /**
     * perpetual_market_funding_state defines the funding state for the perpetual
     * derivative markets at genesis
     *
     * @generated from protobuf field: repeated injective.exchange.v2.PerpetualMarketFundingState perpetual_market_funding_state = 11
     */
    perpetualMarketFundingState: PerpetualMarketFundingState[];
    /**
     * derivative_market_settlement_scheduled defines the scheduled markets for
     * settlement at genesis
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12
     */
    derivativeMarketSettlementScheduled: DerivativeMarketSettlementInfo[];
    /**
     * sets spot markets as enabled
     *
     * @generated from protobuf field: bool is_spot_exchange_enabled = 13
     */
    isSpotExchangeEnabled: boolean;
    /**
     * sets derivative markets as enabled
     *
     * @generated from protobuf field: bool is_derivatives_exchange_enabled = 14
     */
    isDerivativesExchangeEnabled: boolean;
    /**
     * the current trading reward campaign info
     *
     * @generated from protobuf field: injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info = 15
     */
    tradingRewardCampaignInfo?: TradingRewardCampaignInfo;
    /**
     * the current and upcoming trading reward campaign pools
     *
     * @generated from protobuf field: repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule = 16
     */
    tradingRewardPoolCampaignSchedule: CampaignRewardPool[];
    /**
     * the current trading reward account points
     *
     * @generated from protobuf field: repeated injective.exchange.v2.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17
     */
    tradingRewardCampaignAccountPoints: TradingRewardCampaignAccountPoints[];
    /**
     * the fee discount schedule
     *
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule = 18
     */
    feeDiscountSchedule?: FeeDiscountSchedule;
    /**
     * the cached fee discount account tiers with TTL
     *
     * @generated from protobuf field: repeated injective.exchange.v2.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19
     */
    feeDiscountAccountTierTtl: FeeDiscountAccountTierTTL[];
    /**
     * the fee discount paid by accounts in all buckets
     *
     * @generated from protobuf field: repeated injective.exchange.v2.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20
     */
    feeDiscountBucketVolumeAccounts: FeeDiscountBucketVolumeAccounts[];
    /**
     * sets the first fee cycle as finished
     *
     * @generated from protobuf field: bool is_first_fee_cycle_finished = 21
     */
    isFirstFeeCycleFinished: boolean;
    /**
     * the current and upcoming trading reward campaign pending pools
     *
     * @generated from protobuf field: repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22
     */
    pendingTradingRewardPoolCampaignSchedule: CampaignRewardPool[];
    /**
     * the pending trading reward account points
     *
     * @generated from protobuf field: repeated injective.exchange.v2.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23
     */
    pendingTradingRewardCampaignAccountPoints: TradingRewardCampaignAccountPendingPoints[];
    /**
     * the addresses opting out of trading rewards
     *
     * @generated from protobuf field: repeated string rewards_opt_out_addresses = 24
     */
    rewardsOptOutAddresses: string[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TradeRecords historical_trade_records = 25
     */
    historicalTradeRecords: TradeRecords[];
    /**
     * binary_options_markets is an array containing the genesis binary options
     * markets
     *
     * @generated from protobuf field: repeated injective.exchange.v2.BinaryOptionsMarket binary_options_markets = 26
     */
    binaryOptionsMarkets: BinaryOptionsMarket[];
    /**
     * binary_options_markets_scheduled_for_settlement contains the marketIDs of
     * binary options markets scheduled for next-block settlement
     *
     * @generated from protobuf field: repeated string binary_options_market_ids_scheduled_for_settlement = 27
     */
    binaryOptionsMarketIdsScheduledForSettlement: string[];
    /**
     * spot_market_ids_scheduled_to_force_close defines the scheduled markets for
     * forced closings at genesis
     *
     * @generated from protobuf field: repeated string spot_market_ids_scheduled_to_force_close = 28
     */
    spotMarketIdsScheduledToForceClose: string[];
    /**
     * auction_exchange_transfer_denom_decimals defines the denom decimals for the
     * exchange.
     *
     * @generated from protobuf field: repeated injective.exchange.v2.DenomDecimals auction_exchange_transfer_denom_decimals = 29
     */
    auctionExchangeTransferDenomDecimals: DenomDecimals[];
    /**
     * conditional_derivative_orderbook contains conditional orderbooks for all
     * markets (both lmit and market conditional orders)
     *
     * @generated from protobuf field: repeated injective.exchange.v2.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30
     */
    conditionalDerivativeOrderbooks: ConditionalDerivativeOrderBook[];
    /**
     * market_fee_multipliers contains any non-default atomic order fee
     * multipliers
     *
     * @generated from protobuf field: repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers = 31
     */
    marketFeeMultipliers: MarketFeeMultiplier[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.OrderbookSequence orderbook_sequences = 32
     */
    orderbookSequences: OrderbookSequence[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.AggregateSubaccountVolumeRecord subaccount_volumes = 33
     */
    subaccountVolumes: AggregateSubaccountVolumeRecord[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.MarketVolume market_volumes = 34
     */
    marketVolumes: MarketVolume[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.FullGrantAuthorizations grant_authorizations = 35
     */
    grantAuthorizations: FullGrantAuthorizations[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.FullActiveGrant active_grants = 36
     */
    activeGrants: FullActiveGrant[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.DenomMinNotional denom_min_notionals = 37
     */
    denomMinNotionals: DenomMinNotional[];
}
/**
 * @generated from protobuf message injective.exchange.v2.OrderbookSequence
 */
export interface OrderbookSequence {
    /**
     * @generated from protobuf field: uint64 sequence = 1
     */
    sequence: bigint;
    /**
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.FeeDiscountAccountTierTTL
 */
export interface FeeDiscountAccountTierTTL {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.FeeDiscountTierTTL tier_ttl = 2
     */
    tierTtl?: FeeDiscountTierTTL;
}
/**
 * @generated from protobuf message injective.exchange.v2.FeeDiscountBucketVolumeAccounts
 */
export interface FeeDiscountBucketVolumeAccounts {
    /**
     * @generated from protobuf field: int64 bucket_start_timestamp = 1
     */
    bucketStartTimestamp: bigint;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.AccountVolume account_volume = 2
     */
    accountVolume: AccountVolume[];
}
/**
 * @generated from protobuf message injective.exchange.v2.AccountVolume
 */
export interface AccountVolume {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * @generated from protobuf field: string volume = 2
     */
    volume: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.TradingRewardCampaignAccountPoints
 */
export interface TradingRewardCampaignAccountPoints {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * @generated from protobuf field: string points = 2
     */
    points: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.TradingRewardCampaignAccountPendingPoints
 */
export interface TradingRewardCampaignAccountPendingPoints {
    /**
     * @generated from protobuf field: int64 reward_pool_start_timestamp = 1
     */
    rewardPoolStartTimestamp: bigint;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.TradingRewardCampaignAccountPoints account_points = 2
     */
    accountPoints: TradingRewardCampaignAccountPoints[];
}
/**
 * @generated from protobuf message injective.exchange.v2.SubaccountNonce
 */
export interface SubaccountNonce {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the subaccount trade nonce
     *
     * @generated from protobuf field: injective.exchange.v2.SubaccountTradeNonce subaccount_trade_nonce = 2
     */
    subaccountTradeNonce?: SubaccountTradeNonce;
}
/**
 * @generated from protobuf message injective.exchange.v2.FullGrantAuthorizations
 */
export interface FullGrantAuthorizations {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
    /**
     * @generated from protobuf field: string total_grant_amount = 2
     */
    totalGrantAmount: string;
    /**
     * @generated from protobuf field: int64 last_delegations_checked_time = 3
     */
    lastDelegationsCheckedTime: bigint;
    /**
     * @generated from protobuf field: repeated injective.exchange.v2.GrantAuthorization grants = 4
     */
    grants: GrantAuthorization[];
}
/**
 * @generated from protobuf message injective.exchange.v2.FullActiveGrant
 */
export interface FullActiveGrant {
    /**
     * @generated from protobuf field: string grantee = 1
     */
    grantee: string;
    /**
     * @generated from protobuf field: injective.exchange.v2.ActiveGrant active_grant = 2
     */
    activeGrant?: ActiveGrant;
}
// @generated message type with reflection information, may provide speed optimized methods
class GenesisState$Type extends MessageType<GenesisState> {
    constructor() {
        super("injective.exchange.v2.GenesisState", [
            { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } },
            { no: 2, name: "spot_markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotMarket },
            { no: 3, name: "derivative_markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeMarket },
            { no: 4, name: "spot_orderbook", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrderBook, options: { "gogoproto.nullable": false } },
            { no: 5, name: "derivative_orderbook", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrderBook, options: { "gogoproto.nullable": false } },
            { no: 6, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Balance, options: { "gogoproto.nullable": false } },
            { no: 7, name: "positions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativePosition, options: { "gogoproto.nullable": false } },
            { no: 8, name: "subaccount_trade_nonces", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountNonce, options: { "gogoproto.nullable": false } },
            { no: 9, name: "expiry_futures_market_info_state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExpiryFuturesMarketInfoState, options: { "gogoproto.nullable": false } },
            { no: 10, name: "perpetual_market_info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PerpetualMarketInfo, options: { "gogoproto.nullable": false } },
            { no: 11, name: "perpetual_market_funding_state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PerpetualMarketFundingState, options: { "gogoproto.nullable": false } },
            { no: 12, name: "derivative_market_settlement_scheduled", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeMarketSettlementInfo, options: { "gogoproto.nullable": false } },
            { no: 13, name: "is_spot_exchange_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "is_derivatives_exchange_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "trading_reward_campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
            { no: 16, name: "trading_reward_pool_campaign_schedule", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool },
            { no: 17, name: "trading_reward_campaign_account_points", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradingRewardCampaignAccountPoints },
            { no: 18, name: "fee_discount_schedule", kind: "message", T: () => FeeDiscountSchedule },
            { no: 19, name: "fee_discount_account_tier_ttl", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeeDiscountAccountTierTTL },
            { no: 20, name: "fee_discount_bucket_volume_accounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeeDiscountBucketVolumeAccounts },
            { no: 21, name: "is_first_fee_cycle_finished", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "pending_trading_reward_pool_campaign_schedule", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool },
            { no: 23, name: "pending_trading_reward_campaign_account_points", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradingRewardCampaignAccountPendingPoints },
            { no: 24, name: "rewards_opt_out_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "historical_trade_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradeRecords },
            { no: 26, name: "binary_options_markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BinaryOptionsMarket },
            { no: 27, name: "binary_options_market_ids_scheduled_for_settlement", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "spot_market_ids_scheduled_to_force_close", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 29, name: "auction_exchange_transfer_denom_decimals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DenomDecimals, options: { "gogoproto.nullable": false } },
            { no: 30, name: "conditional_derivative_orderbooks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ConditionalDerivativeOrderBook },
            { no: 31, name: "market_fee_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketFeeMultiplier },
            { no: 32, name: "orderbook_sequences", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderbookSequence },
            { no: 33, name: "subaccount_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AggregateSubaccountVolumeRecord },
            { no: 34, name: "market_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume },
            { no: 35, name: "grant_authorizations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FullGrantAuthorizations },
            { no: 36, name: "active_grants", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FullActiveGrant },
            { no: 37, name: "denom_min_notionals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DenomMinNotional }
        ]);
    }
    create(value?: PartialMessage<GenesisState>): GenesisState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spotMarkets = [];
        message.derivativeMarkets = [];
        message.spotOrderbook = [];
        message.derivativeOrderbook = [];
        message.balances = [];
        message.positions = [];
        message.subaccountTradeNonces = [];
        message.expiryFuturesMarketInfoState = [];
        message.perpetualMarketInfo = [];
        message.perpetualMarketFundingState = [];
        message.derivativeMarketSettlementScheduled = [];
        message.isSpotExchangeEnabled = false;
        message.isDerivativesExchangeEnabled = false;
        message.tradingRewardPoolCampaignSchedule = [];
        message.tradingRewardCampaignAccountPoints = [];
        message.feeDiscountAccountTierTtl = [];
        message.feeDiscountBucketVolumeAccounts = [];
        message.isFirstFeeCycleFinished = false;
        message.pendingTradingRewardPoolCampaignSchedule = [];
        message.pendingTradingRewardCampaignAccountPoints = [];
        message.rewardsOptOutAddresses = [];
        message.historicalTradeRecords = [];
        message.binaryOptionsMarkets = [];
        message.binaryOptionsMarketIdsScheduledForSettlement = [];
        message.spotMarketIdsScheduledToForceClose = [];
        message.auctionExchangeTransferDenomDecimals = [];
        message.conditionalDerivativeOrderbooks = [];
        message.marketFeeMultipliers = [];
        message.orderbookSequences = [];
        message.subaccountVolumes = [];
        message.marketVolumes = [];
        message.grantAuthorizations = [];
        message.activeGrants = [];
        message.denomMinNotionals = [];
        if (value !== undefined)
            reflectionMergePartial<GenesisState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenesisState): GenesisState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v2.Params params */ 1:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* repeated injective.exchange.v2.SpotMarket spot_markets */ 2:
                    message.spotMarkets.push(SpotMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativeMarket derivative_markets */ 3:
                    message.derivativeMarkets.push(DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.SpotOrderBook spot_orderbook */ 4:
                    message.spotOrderbook.push(SpotOrderBook.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativeOrderBook derivative_orderbook */ 5:
                    message.derivativeOrderbook.push(DerivativeOrderBook.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.Balance balances */ 6:
                    message.balances.push(Balance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativePosition positions */ 7:
                    message.positions.push(DerivativePosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.SubaccountNonce subaccount_trade_nonces */ 8:
                    message.subaccountTradeNonces.push(SubaccountNonce.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.ExpiryFuturesMarketInfoState expiry_futures_market_info_state */ 9:
                    message.expiryFuturesMarketInfoState.push(ExpiryFuturesMarketInfoState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.PerpetualMarketInfo perpetual_market_info */ 10:
                    message.perpetualMarketInfo.push(PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.PerpetualMarketFundingState perpetual_market_funding_state */ 11:
                    message.perpetualMarketFundingState.push(PerpetualMarketFundingState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled */ 12:
                    message.derivativeMarketSettlementScheduled.push(DerivativeMarketSettlementInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_spot_exchange_enabled */ 13:
                    message.isSpotExchangeEnabled = reader.bool();
                    break;
                case /* bool is_derivatives_exchange_enabled */ 14:
                    message.isDerivativesExchangeEnabled = reader.bool();
                    break;
                case /* injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info */ 15:
                    message.tradingRewardCampaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardCampaignInfo);
                    break;
                case /* repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule */ 16:
                    message.tradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points */ 17:
                    message.tradingRewardCampaignAccountPoints.push(TradingRewardCampaignAccountPoints.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule */ 18:
                    message.feeDiscountSchedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.feeDiscountSchedule);
                    break;
                case /* repeated injective.exchange.v2.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl */ 19:
                    message.feeDiscountAccountTierTtl.push(FeeDiscountAccountTierTTL.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts */ 20:
                    message.feeDiscountBucketVolumeAccounts.push(FeeDiscountBucketVolumeAccounts.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_first_fee_cycle_finished */ 21:
                    message.isFirstFeeCycleFinished = reader.bool();
                    break;
                case /* repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule */ 22:
                    message.pendingTradingRewardPoolCampaignSchedule.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points */ 23:
                    message.pendingTradingRewardCampaignAccountPoints.push(TradingRewardCampaignAccountPendingPoints.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string rewards_opt_out_addresses */ 24:
                    message.rewardsOptOutAddresses.push(reader.string());
                    break;
                case /* repeated injective.exchange.v2.TradeRecords historical_trade_records */ 25:
                    message.historicalTradeRecords.push(TradeRecords.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.BinaryOptionsMarket binary_options_markets */ 26:
                    message.binaryOptionsMarkets.push(BinaryOptionsMarket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string binary_options_market_ids_scheduled_for_settlement */ 27:
                    message.binaryOptionsMarketIdsScheduledForSettlement.push(reader.string());
                    break;
                case /* repeated string spot_market_ids_scheduled_to_force_close */ 28:
                    message.spotMarketIdsScheduledToForceClose.push(reader.string());
                    break;
                case /* repeated injective.exchange.v2.DenomDecimals auction_exchange_transfer_denom_decimals */ 29:
                    message.auctionExchangeTransferDenomDecimals.push(DenomDecimals.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.ConditionalDerivativeOrderBook conditional_derivative_orderbooks */ 30:
                    message.conditionalDerivativeOrderbooks.push(ConditionalDerivativeOrderBook.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers */ 31:
                    message.marketFeeMultipliers.push(MarketFeeMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.OrderbookSequence orderbook_sequences */ 32:
                    message.orderbookSequences.push(OrderbookSequence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.AggregateSubaccountVolumeRecord subaccount_volumes */ 33:
                    message.subaccountVolumes.push(AggregateSubaccountVolumeRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.MarketVolume market_volumes */ 34:
                    message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.FullGrantAuthorizations grant_authorizations */ 35:
                    message.grantAuthorizations.push(FullGrantAuthorizations.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.FullActiveGrant active_grants */ 36:
                    message.activeGrants.push(FullActiveGrant.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals */ 37:
                    message.denomMinNotionals.push(DenomMinNotional.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenesisState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v2.Params params = 1; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.SpotMarket spot_markets = 2; */
        for (let i = 0; i < message.spotMarkets.length; i++)
            SpotMarket.internalBinaryWrite(message.spotMarkets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativeMarket derivative_markets = 3; */
        for (let i = 0; i < message.derivativeMarkets.length; i++)
            DerivativeMarket.internalBinaryWrite(message.derivativeMarkets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.SpotOrderBook spot_orderbook = 4; */
        for (let i = 0; i < message.spotOrderbook.length; i++)
            SpotOrderBook.internalBinaryWrite(message.spotOrderbook[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativeOrderBook derivative_orderbook = 5; */
        for (let i = 0; i < message.derivativeOrderbook.length; i++)
            DerivativeOrderBook.internalBinaryWrite(message.derivativeOrderbook[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.Balance balances = 6; */
        for (let i = 0; i < message.balances.length; i++)
            Balance.internalBinaryWrite(message.balances[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativePosition positions = 7; */
        for (let i = 0; i < message.positions.length; i++)
            DerivativePosition.internalBinaryWrite(message.positions[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.SubaccountNonce subaccount_trade_nonces = 8; */
        for (let i = 0; i < message.subaccountTradeNonces.length; i++)
            SubaccountNonce.internalBinaryWrite(message.subaccountTradeNonces[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9; */
        for (let i = 0; i < message.expiryFuturesMarketInfoState.length; i++)
            ExpiryFuturesMarketInfoState.internalBinaryWrite(message.expiryFuturesMarketInfoState[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.PerpetualMarketInfo perpetual_market_info = 10; */
        for (let i = 0; i < message.perpetualMarketInfo.length; i++)
            PerpetualMarketInfo.internalBinaryWrite(message.perpetualMarketInfo[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.PerpetualMarketFundingState perpetual_market_funding_state = 11; */
        for (let i = 0; i < message.perpetualMarketFundingState.length; i++)
            PerpetualMarketFundingState.internalBinaryWrite(message.perpetualMarketFundingState[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12; */
        for (let i = 0; i < message.derivativeMarketSettlementScheduled.length; i++)
            DerivativeMarketSettlementInfo.internalBinaryWrite(message.derivativeMarketSettlementScheduled[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool is_spot_exchange_enabled = 13; */
        if (message.isSpotExchangeEnabled !== false)
            writer.tag(13, WireType.Varint).bool(message.isSpotExchangeEnabled);
        /* bool is_derivatives_exchange_enabled = 14; */
        if (message.isDerivativesExchangeEnabled !== false)
            writer.tag(14, WireType.Varint).bool(message.isDerivativesExchangeEnabled);
        /* injective.exchange.v2.TradingRewardCampaignInfo trading_reward_campaign_info = 15; */
        if (message.tradingRewardCampaignInfo)
            TradingRewardCampaignInfo.internalBinaryWrite(message.tradingRewardCampaignInfo, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.CampaignRewardPool trading_reward_pool_campaign_schedule = 16; */
        for (let i = 0; i < message.tradingRewardPoolCampaignSchedule.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.tradingRewardPoolCampaignSchedule[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17; */
        for (let i = 0; i < message.tradingRewardCampaignAccountPoints.length; i++)
            TradingRewardCampaignAccountPoints.internalBinaryWrite(message.tradingRewardCampaignAccountPoints[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v2.FeeDiscountSchedule fee_discount_schedule = 18; */
        if (message.feeDiscountSchedule)
            FeeDiscountSchedule.internalBinaryWrite(message.feeDiscountSchedule, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19; */
        for (let i = 0; i < message.feeDiscountAccountTierTtl.length; i++)
            FeeDiscountAccountTierTTL.internalBinaryWrite(message.feeDiscountAccountTierTtl[i], writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20; */
        for (let i = 0; i < message.feeDiscountBucketVolumeAccounts.length; i++)
            FeeDiscountBucketVolumeAccounts.internalBinaryWrite(message.feeDiscountBucketVolumeAccounts[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* bool is_first_fee_cycle_finished = 21; */
        if (message.isFirstFeeCycleFinished !== false)
            writer.tag(21, WireType.Varint).bool(message.isFirstFeeCycleFinished);
        /* repeated injective.exchange.v2.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22; */
        for (let i = 0; i < message.pendingTradingRewardPoolCampaignSchedule.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.pendingTradingRewardPoolCampaignSchedule[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23; */
        for (let i = 0; i < message.pendingTradingRewardCampaignAccountPoints.length; i++)
            TradingRewardCampaignAccountPendingPoints.internalBinaryWrite(message.pendingTradingRewardCampaignAccountPoints[i], writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* repeated string rewards_opt_out_addresses = 24; */
        for (let i = 0; i < message.rewardsOptOutAddresses.length; i++)
            writer.tag(24, WireType.LengthDelimited).string(message.rewardsOptOutAddresses[i]);
        /* repeated injective.exchange.v2.TradeRecords historical_trade_records = 25; */
        for (let i = 0; i < message.historicalTradeRecords.length; i++)
            TradeRecords.internalBinaryWrite(message.historicalTradeRecords[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.BinaryOptionsMarket binary_options_markets = 26; */
        for (let i = 0; i < message.binaryOptionsMarkets.length; i++)
            BinaryOptionsMarket.internalBinaryWrite(message.binaryOptionsMarkets[i], writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* repeated string binary_options_market_ids_scheduled_for_settlement = 27; */
        for (let i = 0; i < message.binaryOptionsMarketIdsScheduledForSettlement.length; i++)
            writer.tag(27, WireType.LengthDelimited).string(message.binaryOptionsMarketIdsScheduledForSettlement[i]);
        /* repeated string spot_market_ids_scheduled_to_force_close = 28; */
        for (let i = 0; i < message.spotMarketIdsScheduledToForceClose.length; i++)
            writer.tag(28, WireType.LengthDelimited).string(message.spotMarketIdsScheduledToForceClose[i]);
        /* repeated injective.exchange.v2.DenomDecimals auction_exchange_transfer_denom_decimals = 29; */
        for (let i = 0; i < message.auctionExchangeTransferDenomDecimals.length; i++)
            DenomDecimals.internalBinaryWrite(message.auctionExchangeTransferDenomDecimals[i], writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30; */
        for (let i = 0; i < message.conditionalDerivativeOrderbooks.length; i++)
            ConditionalDerivativeOrderBook.internalBinaryWrite(message.conditionalDerivativeOrderbooks[i], writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers = 31; */
        for (let i = 0; i < message.marketFeeMultipliers.length; i++)
            MarketFeeMultiplier.internalBinaryWrite(message.marketFeeMultipliers[i], writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.OrderbookSequence orderbook_sequences = 32; */
        for (let i = 0; i < message.orderbookSequences.length; i++)
            OrderbookSequence.internalBinaryWrite(message.orderbookSequences[i], writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.AggregateSubaccountVolumeRecord subaccount_volumes = 33; */
        for (let i = 0; i < message.subaccountVolumes.length; i++)
            AggregateSubaccountVolumeRecord.internalBinaryWrite(message.subaccountVolumes[i], writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.MarketVolume market_volumes = 34; */
        for (let i = 0; i < message.marketVolumes.length; i++)
            MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.FullGrantAuthorizations grant_authorizations = 35; */
        for (let i = 0; i < message.grantAuthorizations.length; i++)
            FullGrantAuthorizations.internalBinaryWrite(message.grantAuthorizations[i], writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.FullActiveGrant active_grants = 36; */
        for (let i = 0; i < message.activeGrants.length; i++)
            FullActiveGrant.internalBinaryWrite(message.activeGrants[i], writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v2.DenomMinNotional denom_min_notionals = 37; */
        for (let i = 0; i < message.denomMinNotionals.length; i++)
            DenomMinNotional.internalBinaryWrite(message.denomMinNotionals[i], writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.GenesisState
 */
export const GenesisState = new GenesisState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookSequence$Type extends MessageType<OrderbookSequence> {
    constructor() {
        super("injective.exchange.v2.OrderbookSequence", [
            { no: 1, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbookSequence>): OrderbookSequence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sequence = 0n;
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<OrderbookSequence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookSequence): OrderbookSequence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 sequence */ 1:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookSequence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 sequence = 1; */
        if (message.sequence !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.sequence);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OrderbookSequence
 */
export const OrderbookSequence = new OrderbookSequence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountAccountTierTTL$Type extends MessageType<FeeDiscountAccountTierTTL> {
    constructor() {
        super("injective.exchange.v2.FeeDiscountAccountTierTTL", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tier_ttl", kind: "message", T: () => FeeDiscountTierTTL }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountAccountTierTTL>): FeeDiscountAccountTierTTL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountAccountTierTTL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountAccountTierTTL): FeeDiscountAccountTierTTL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* injective.exchange.v2.FeeDiscountTierTTL tier_ttl */ 2:
                    message.tierTtl = FeeDiscountTierTTL.internalBinaryRead(reader, reader.uint32(), options, message.tierTtl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountAccountTierTTL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* injective.exchange.v2.FeeDiscountTierTTL tier_ttl = 2; */
        if (message.tierTtl)
            FeeDiscountTierTTL.internalBinaryWrite(message.tierTtl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FeeDiscountAccountTierTTL
 */
export const FeeDiscountAccountTierTTL = new FeeDiscountAccountTierTTL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountBucketVolumeAccounts$Type extends MessageType<FeeDiscountBucketVolumeAccounts> {
    constructor() {
        super("injective.exchange.v2.FeeDiscountBucketVolumeAccounts", [
            { no: 1, name: "bucket_start_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "account_volume", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AccountVolume }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountBucketVolumeAccounts>): FeeDiscountBucketVolumeAccounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketStartTimestamp = 0n;
        message.accountVolume = [];
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountBucketVolumeAccounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountBucketVolumeAccounts): FeeDiscountBucketVolumeAccounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 bucket_start_timestamp */ 1:
                    message.bucketStartTimestamp = reader.int64().toBigInt();
                    break;
                case /* repeated injective.exchange.v2.AccountVolume account_volume */ 2:
                    message.accountVolume.push(AccountVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountBucketVolumeAccounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 bucket_start_timestamp = 1; */
        if (message.bucketStartTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.bucketStartTimestamp);
        /* repeated injective.exchange.v2.AccountVolume account_volume = 2; */
        for (let i = 0; i < message.accountVolume.length; i++)
            AccountVolume.internalBinaryWrite(message.accountVolume[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FeeDiscountBucketVolumeAccounts
 */
export const FeeDiscountBucketVolumeAccounts = new FeeDiscountBucketVolumeAccounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountVolume$Type extends MessageType<AccountVolume> {
    constructor() {
        super("injective.exchange.v2.AccountVolume", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "volume", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<AccountVolume>): AccountVolume {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.volume = "";
        if (value !== undefined)
            reflectionMergePartial<AccountVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountVolume): AccountVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string volume */ 2:
                    message.volume = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string volume = 2; */
        if (message.volume !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.AccountVolume
 */
export const AccountVolume = new AccountVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignAccountPoints$Type extends MessageType<TradingRewardCampaignAccountPoints> {
    constructor() {
        super("injective.exchange.v2.TradingRewardCampaignAccountPoints", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "points", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<TradingRewardCampaignAccountPoints>): TradingRewardCampaignAccountPoints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.points = "";
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignAccountPoints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignAccountPoints): TradingRewardCampaignAccountPoints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string points */ 2:
                    message.points = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignAccountPoints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string points = 2; */
        if (message.points !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.points);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradingRewardCampaignAccountPoints
 */
export const TradingRewardCampaignAccountPoints = new TradingRewardCampaignAccountPoints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignAccountPendingPoints$Type extends MessageType<TradingRewardCampaignAccountPendingPoints> {
    constructor() {
        super("injective.exchange.v2.TradingRewardCampaignAccountPendingPoints", [
            { no: 1, name: "reward_pool_start_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "account_points", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradingRewardCampaignAccountPoints }
        ]);
    }
    create(value?: PartialMessage<TradingRewardCampaignAccountPendingPoints>): TradingRewardCampaignAccountPendingPoints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rewardPoolStartTimestamp = 0n;
        message.accountPoints = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignAccountPendingPoints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignAccountPendingPoints): TradingRewardCampaignAccountPendingPoints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 reward_pool_start_timestamp */ 1:
                    message.rewardPoolStartTimestamp = reader.int64().toBigInt();
                    break;
                case /* repeated injective.exchange.v2.TradingRewardCampaignAccountPoints account_points */ 2:
                    message.accountPoints.push(TradingRewardCampaignAccountPoints.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignAccountPendingPoints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 reward_pool_start_timestamp = 1; */
        if (message.rewardPoolStartTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.rewardPoolStartTimestamp);
        /* repeated injective.exchange.v2.TradingRewardCampaignAccountPoints account_points = 2; */
        for (let i = 0; i < message.accountPoints.length; i++)
            TradingRewardCampaignAccountPoints.internalBinaryWrite(message.accountPoints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.TradingRewardCampaignAccountPendingPoints
 */
export const TradingRewardCampaignAccountPendingPoints = new TradingRewardCampaignAccountPendingPoints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountNonce$Type extends MessageType<SubaccountNonce> {
    constructor() {
        super("injective.exchange.v2.SubaccountNonce", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_trade_nonce", kind: "message", T: () => SubaccountTradeNonce, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<SubaccountNonce>): SubaccountNonce {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountNonce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountNonce): SubaccountNonce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* injective.exchange.v2.SubaccountTradeNonce subaccount_trade_nonce */ 2:
                    message.subaccountTradeNonce = SubaccountTradeNonce.internalBinaryRead(reader, reader.uint32(), options, message.subaccountTradeNonce);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountNonce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* injective.exchange.v2.SubaccountTradeNonce subaccount_trade_nonce = 2; */
        if (message.subaccountTradeNonce)
            SubaccountTradeNonce.internalBinaryWrite(message.subaccountTradeNonce, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.SubaccountNonce
 */
export const SubaccountNonce = new SubaccountNonce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullGrantAuthorizations$Type extends MessageType<FullGrantAuthorizations> {
    constructor() {
        super("injective.exchange.v2.FullGrantAuthorizations", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_grant_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 3, name: "last_delegations_checked_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "grants", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GrantAuthorization }
        ]);
    }
    create(value?: PartialMessage<FullGrantAuthorizations>): FullGrantAuthorizations {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        message.totalGrantAmount = "";
        message.lastDelegationsCheckedTime = 0n;
        message.grants = [];
        if (value !== undefined)
            reflectionMergePartial<FullGrantAuthorizations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullGrantAuthorizations): FullGrantAuthorizations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                case /* string total_grant_amount */ 2:
                    message.totalGrantAmount = reader.string();
                    break;
                case /* int64 last_delegations_checked_time */ 3:
                    message.lastDelegationsCheckedTime = reader.int64().toBigInt();
                    break;
                case /* repeated injective.exchange.v2.GrantAuthorization grants */ 4:
                    message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullGrantAuthorizations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        /* string total_grant_amount = 2; */
        if (message.totalGrantAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.totalGrantAmount);
        /* int64 last_delegations_checked_time = 3; */
        if (message.lastDelegationsCheckedTime !== 0n)
            writer.tag(3, WireType.Varint).int64(message.lastDelegationsCheckedTime);
        /* repeated injective.exchange.v2.GrantAuthorization grants = 4; */
        for (let i = 0; i < message.grants.length; i++)
            GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FullGrantAuthorizations
 */
export const FullGrantAuthorizations = new FullGrantAuthorizations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullActiveGrant$Type extends MessageType<FullActiveGrant> {
    constructor() {
        super("injective.exchange.v2.FullActiveGrant", [
            { no: 1, name: "grantee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active_grant", kind: "message", T: () => ActiveGrant }
        ]);
    }
    create(value?: PartialMessage<FullActiveGrant>): FullActiveGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantee = "";
        if (value !== undefined)
            reflectionMergePartial<FullActiveGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullActiveGrant): FullActiveGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grantee */ 1:
                    message.grantee = reader.string();
                    break;
                case /* injective.exchange.v2.ActiveGrant active_grant */ 2:
                    message.activeGrant = ActiveGrant.internalBinaryRead(reader, reader.uint32(), options, message.activeGrant);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullActiveGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grantee = 1; */
        if (message.grantee !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantee);
        /* injective.exchange.v2.ActiveGrant active_grant = 2; */
        if (message.activeGrant)
            ActiveGrant.internalBinaryWrite(message.activeGrant, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.FullActiveGrant
 */
export const FullActiveGrant = new FullActiveGrant$Type();
