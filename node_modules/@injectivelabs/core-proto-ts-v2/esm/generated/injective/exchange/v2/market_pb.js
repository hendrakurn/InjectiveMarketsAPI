import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";
var MarketStatus = /* @__PURE__ */ ((MarketStatus2) => {
  MarketStatus2[MarketStatus2["Unspecified"] = 0] = "Unspecified";
  MarketStatus2[MarketStatus2["Active"] = 1] = "Active";
  MarketStatus2[MarketStatus2["Paused"] = 2] = "Paused";
  MarketStatus2[MarketStatus2["Demolished"] = 3] = "Demolished";
  MarketStatus2[MarketStatus2["Expired"] = 4] = "Expired";
  return MarketStatus2;
})(MarketStatus || {});
class OpenNotionalCap$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OpenNotionalCap", [
      { no: 1, name: "uncapped", kind: "message", oneof: "cap", T: () => OpenNotionalCapUncapped, options: { "amino.oneof_name": "injective.exchange.v2.OpenNotionalCapUncapped" } },
      { no: 2, name: "capped", kind: "message", oneof: "cap", T: () => OpenNotionalCapCapped, options: { "amino.oneof_name": "injective.exchange.v2.OpenNotionalCapCapped" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cap = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v2.OpenNotionalCapUncapped uncapped */
        1:
          message.cap = {
            oneofKind: "uncapped",
            uncapped: OpenNotionalCapUncapped.internalBinaryRead(reader, reader.uint32(), options, message.cap.uncapped)
          };
          break;
        case /* injective.exchange.v2.OpenNotionalCapCapped capped */
        2:
          message.cap = {
            oneofKind: "capped",
            capped: OpenNotionalCapCapped.internalBinaryRead(reader, reader.uint32(), options, message.cap.capped)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cap.oneofKind === "uncapped")
      OpenNotionalCapUncapped.internalBinaryWrite(message.cap.uncapped, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.cap.oneofKind === "capped")
      OpenNotionalCapCapped.internalBinaryWrite(message.cap.capped, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenNotionalCap = new OpenNotionalCap$Type();
class OpenNotionalCapUncapped$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OpenNotionalCapUncapped", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenNotionalCapUncapped = new OpenNotionalCapUncapped$Type();
class OpenNotionalCapCapped$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.OpenNotionalCapCapped", [
      { no: 1, name: "value", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenNotionalCapCapped = new OpenNotionalCapCapped$Type();
class MarketFeeMultiplier$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MarketFeeMultiplier", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.feeMultiplier = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string fee_multiplier */
        2:
          message.feeMultiplier = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.feeMultiplier !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.feeMultiplier);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketFeeMultiplier = new MarketFeeMultiplier$Type();
class SpotMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.SpotMarket", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "base_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 7,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
      { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 12,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 14,
        name: "base_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 15,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.baseDenom = "";
    message.quoteDenom = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.marketId = "";
    message.status = 0;
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.admin = "";
    message.adminPermissions = 0;
    message.baseDecimals = 0;
    message.quoteDecimals = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string base_denom */
        2:
          message.baseDenom = reader.string();
          break;
        case /* string quote_denom */
        3:
          message.quoteDenom = reader.string();
          break;
        case /* string maker_fee_rate */
        4:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        5:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        6:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* string market_id */
        7:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.MarketStatus status */
        8:
          message.status = reader.int32();
          break;
        case /* string min_price_tick_size */
        9:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        10:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        11:
          message.minNotional = reader.string();
          break;
        case /* string admin */
        12:
          message.admin = reader.string();
          break;
        case /* uint32 admin_permissions */
        13:
          message.adminPermissions = reader.uint32();
          break;
        case /* uint32 base_decimals */
        14:
          message.baseDecimals = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        15:
          message.quoteDecimals = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.baseDenom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.baseDenom);
    if (message.quoteDenom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.makerFeeRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.marketId !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.marketId);
    if (message.status !== 0)
      writer.tag(8, WireType.Varint).int32(message.status);
    if (message.minPriceTickSize !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.minNotional);
    if (message.admin !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.admin);
    if (message.adminPermissions !== 0)
      writer.tag(13, WireType.Varint).uint32(message.adminPermissions);
    if (message.baseDecimals !== 0)
      writer.tag(14, WireType.Varint).uint32(message.baseDecimals);
    if (message.quoteDecimals !== 0)
      writer.tag(15, WireType.Varint).uint32(message.quoteDecimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarket = new SpotMarket$Type();
class BinaryOptionsMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.BinaryOptionsMarket", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "oracle_symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "oracle_provider",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 5,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "settlement_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
      { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 17, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 18, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 19,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 20,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 21, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.oracleSymbol = "";
    message.oracleProvider = "";
    message.oracleType = 0;
    message.oracleScaleFactor = 0;
    message.expirationTimestamp = 0n;
    message.settlementTimestamp = 0n;
    message.admin = "";
    message.quoteDenom = "";
    message.marketId = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.status = 0;
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.settlementPrice = "";
    message.minNotional = "";
    message.adminPermissions = 0;
    message.quoteDecimals = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string oracle_symbol */
        2:
          message.oracleSymbol = reader.string();
          break;
        case /* string oracle_provider */
        3:
          message.oracleProvider = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        4:
          message.oracleType = reader.int32();
          break;
        case /* uint32 oracle_scale_factor */
        5:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* int64 expiration_timestamp */
        6:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 settlement_timestamp */
        7:
          message.settlementTimestamp = reader.int64().toBigInt();
          break;
        case /* string admin */
        8:
          message.admin = reader.string();
          break;
        case /* string quote_denom */
        9:
          message.quoteDenom = reader.string();
          break;
        case /* string market_id */
        10:
          message.marketId = reader.string();
          break;
        case /* string maker_fee_rate */
        11:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        12:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        13:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* injective.exchange.v2.MarketStatus status */
        14:
          message.status = reader.int32();
          break;
        case /* string min_price_tick_size */
        15:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        16:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string settlement_price */
        17:
          message.settlementPrice = reader.string();
          break;
        case /* string min_notional */
        18:
          message.minNotional = reader.string();
          break;
        case /* uint32 admin_permissions */
        19:
          message.adminPermissions = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        20:
          message.quoteDecimals = reader.uint32();
          break;
        case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */
        21:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleSymbol !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.oracleSymbol);
    if (message.oracleProvider !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.oracleProvider);
    if (message.oracleType !== 0)
      writer.tag(4, WireType.Varint).int32(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.expirationTimestamp !== 0n)
      writer.tag(6, WireType.Varint).int64(message.expirationTimestamp);
    if (message.settlementTimestamp !== 0n)
      writer.tag(7, WireType.Varint).int64(message.settlementTimestamp);
    if (message.admin !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.admin);
    if (message.quoteDenom !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.marketId !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.marketId);
    if (message.makerFeeRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.status !== 0)
      writer.tag(14, WireType.Varint).int32(message.status);
    if (message.minPriceTickSize !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.settlementPrice !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.settlementPrice);
    if (message.minNotional !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminPermissions !== 0)
      writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
    if (message.quoteDecimals !== 0)
      writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarket = new BinaryOptionsMarket$Type();
class DerivativeMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeMarket", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 5,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 13,
        name: "isPerpetual",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v2.MarketStatus", MarketStatus] },
      { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 17, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 18,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 19,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 20,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 21, name: "reduce_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 22, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleType = 0;
    message.oracleScaleFactor = 0;
    message.quoteDenom = "";
    message.marketId = "";
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.isPerpetual = false;
    message.status = 0;
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.admin = "";
    message.adminPermissions = 0;
    message.quoteDecimals = 0;
    message.reduceMarginRatio = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string oracle_base */
        2:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        3:
          message.oracleQuote = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        4:
          message.oracleType = reader.int32();
          break;
        case /* uint32 oracle_scale_factor */
        5:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* string quote_denom */
        6:
          message.quoteDenom = reader.string();
          break;
        case /* string market_id */
        7:
          message.marketId = reader.string();
          break;
        case /* string initial_margin_ratio */
        8:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        9:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string maker_fee_rate */
        10:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        11:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        12:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* bool isPerpetual */
        13:
          message.isPerpetual = reader.bool();
          break;
        case /* injective.exchange.v2.MarketStatus status */
        14:
          message.status = reader.int32();
          break;
        case /* string min_price_tick_size */
        15:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        16:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        17:
          message.minNotional = reader.string();
          break;
        case /* string admin */
        18:
          message.admin = reader.string();
          break;
        case /* uint32 admin_permissions */
        19:
          message.adminPermissions = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        20:
          message.quoteDecimals = reader.uint32();
          break;
        case /* string reduce_margin_ratio */
        21:
          message.reduceMarginRatio = reader.string();
          break;
        case /* injective.exchange.v2.OpenNotionalCap open_notional_cap */
        22:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleBase !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleType !== 0)
      writer.tag(4, WireType.Varint).int32(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.quoteDenom !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.marketId !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.marketId);
    if (message.initialMarginRatio !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.makerFeeRate !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.isPerpetual !== false)
      writer.tag(13, WireType.Varint).bool(message.isPerpetual);
    if (message.status !== 0)
      writer.tag(14, WireType.Varint).int32(message.status);
    if (message.minPriceTickSize !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.minNotional);
    if (message.admin !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.admin);
    if (message.adminPermissions !== 0)
      writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
    if (message.quoteDecimals !== 0)
      writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
    if (message.reduceMarginRatio !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.reduceMarginRatio);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarket = new DerivativeMarket$Type();
class DerivativeMarketSettlementInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.DerivativeMarketSettlementInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.settlementPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string settlement_price */
        2:
          message.settlementPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.settlementPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.settlementPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketSettlementInfo = new DerivativeMarketSettlementInfo$Type();
class MarketVolume$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.MarketVolume", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "volume", kind: "message", T: () => VolumeRecord, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.VolumeRecord volume */
        2:
          message.volume = VolumeRecord.internalBinaryRead(reader, reader.uint32(), options, message.volume);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.volume)
      VolumeRecord.internalBinaryWrite(message.volume, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketVolume = new MarketVolume$Type();
class VolumeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.VolumeRecord", [
      { no: 1, name: "maker_volume", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "taker_volume", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.makerVolume = "";
    message.takerVolume = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string maker_volume */
        1:
          message.makerVolume = reader.string();
          break;
        case /* string taker_volume */
        2:
          message.takerVolume = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.makerVolume !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.makerVolume);
    if (message.takerVolume !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.takerVolume);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolumeRecord = new VolumeRecord$Type();
class ExpiryFuturesMarketInfoState$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.ExpiryFuturesMarketInfoState", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "market_info", kind: "message", T: () => ExpiryFuturesMarketInfo }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.ExpiryFuturesMarketInfo market_info */
        2:
          message.marketInfo = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.marketInfo);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.marketInfo)
      ExpiryFuturesMarketInfo.internalBinaryWrite(message.marketInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExpiryFuturesMarketInfoState = new ExpiryFuturesMarketInfoState$Type();
class PerpetualMarketFundingState$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PerpetualMarketFundingState", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "funding", kind: "message", T: () => PerpetualMarketFunding }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v2.PerpetualMarketFunding funding */
        2:
          message.funding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.funding);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.funding)
      PerpetualMarketFunding.internalBinaryWrite(message.funding, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketFundingState = new PerpetualMarketFundingState$Type();
class ExpiryFuturesMarketInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.ExpiryFuturesMarketInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "twap_start_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "expiration_twap_start_price_cumulative", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "expiration_twap_start_base_cumulative_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "expiration_twap_start_quote_cumulative_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.expirationTimestamp = 0n;
    message.twapStartTimestamp = 0n;
    message.expirationTwapStartPriceCumulative = "";
    message.settlementPrice = "";
    message.expirationTwapStartBaseCumulativePrice = "";
    message.expirationTwapStartQuoteCumulativePrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* int64 expiration_timestamp */
        2:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 twap_start_timestamp */
        3:
          message.twapStartTimestamp = reader.int64().toBigInt();
          break;
        case /* string expiration_twap_start_price_cumulative = 4 [deprecated = true] */
        4:
          message.expirationTwapStartPriceCumulative = reader.string();
          break;
        case /* string settlement_price */
        5:
          message.settlementPrice = reader.string();
          break;
        case /* string expiration_twap_start_base_cumulative_price */
        6:
          message.expirationTwapStartBaseCumulativePrice = reader.string();
          break;
        case /* string expiration_twap_start_quote_cumulative_price */
        7:
          message.expirationTwapStartQuoteCumulativePrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.expirationTimestamp !== 0n)
      writer.tag(2, WireType.Varint).int64(message.expirationTimestamp);
    if (message.twapStartTimestamp !== 0n)
      writer.tag(3, WireType.Varint).int64(message.twapStartTimestamp);
    if (message.expirationTwapStartPriceCumulative !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.expirationTwapStartPriceCumulative);
    if (message.settlementPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.settlementPrice);
    if (message.expirationTwapStartBaseCumulativePrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.expirationTwapStartBaseCumulativePrice);
    if (message.expirationTwapStartQuoteCumulativePrice !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.expirationTwapStartQuoteCumulativePrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExpiryFuturesMarketInfo = new ExpiryFuturesMarketInfo$Type();
class PerpetualMarketInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PerpetualMarketInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "hourly_funding_rate_cap", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "hourly_interest_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 4,
        name: "next_funding_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "funding_interval",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.hourlyFundingRateCap = "";
    message.hourlyInterestRate = "";
    message.nextFundingTimestamp = 0n;
    message.fundingInterval = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string hourly_funding_rate_cap */
        2:
          message.hourlyFundingRateCap = reader.string();
          break;
        case /* string hourly_interest_rate */
        3:
          message.hourlyInterestRate = reader.string();
          break;
        case /* int64 next_funding_timestamp */
        4:
          message.nextFundingTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 funding_interval */
        5:
          message.fundingInterval = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.hourlyFundingRateCap !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
    if (message.hourlyInterestRate !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.hourlyInterestRate);
    if (message.nextFundingTimestamp !== 0n)
      writer.tag(4, WireType.Varint).int64(message.nextFundingTimestamp);
    if (message.fundingInterval !== 0n)
      writer.tag(5, WireType.Varint).int64(message.fundingInterval);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketInfo = new PerpetualMarketInfo$Type();
class PerpetualMarketFunding$Type extends MessageType {
  constructor() {
    super("injective.exchange.v2.PerpetualMarketFunding", [
      { no: 1, name: "cumulative_funding", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "cumulative_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "last_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cumulativeFunding = "";
    message.cumulativePrice = "";
    message.lastTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cumulative_funding */
        1:
          message.cumulativeFunding = reader.string();
          break;
        case /* string cumulative_price */
        2:
          message.cumulativePrice = reader.string();
          break;
        case /* int64 last_timestamp */
        3:
          message.lastTimestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cumulativeFunding !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cumulativeFunding);
    if (message.cumulativePrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
    if (message.lastTimestamp !== 0n)
      writer.tag(3, WireType.Varint).int64(message.lastTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketFunding = new PerpetualMarketFunding$Type();
export {
  BinaryOptionsMarket,
  DerivativeMarket,
  DerivativeMarketSettlementInfo,
  ExpiryFuturesMarketInfo,
  ExpiryFuturesMarketInfoState,
  MarketFeeMultiplier,
  MarketStatus,
  MarketVolume,
  OpenNotionalCap,
  OpenNotionalCapCapped,
  OpenNotionalCapUncapped,
  PerpetualMarketFunding,
  PerpetualMarketFundingState,
  PerpetualMarketInfo,
  SpotMarket,
  VolumeRecord
};
