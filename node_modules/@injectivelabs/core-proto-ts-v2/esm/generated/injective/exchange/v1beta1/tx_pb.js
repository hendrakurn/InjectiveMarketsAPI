import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BatchExchangeModificationProposal } from "./proposal_pb.js";
import { GrantAuthorization } from "./exchange_pb.js";
import { MarketStatus } from "./exchange_pb.js";
import { PositionDelta } from "./exchange_pb.js";
import { DerivativeOrder } from "./exchange_pb.js";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";
import { SpotOrder } from "./exchange_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { Params } from "./exchange_pb.js";
class MsgUpdateSpotMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgUpdateSpotMarket", [
      {
        no: 1,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "new_ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "new_min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "new_min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "new_min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.equal": false, "amino.name": "exchange/MsgUpdateSpotMarket", "cosmos.msg.v1.signer": ["admin"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.admin = "";
    message.marketId = "";
    message.newTicker = "";
    message.newMinPriceTickSize = "";
    message.newMinQuantityTickSize = "";
    message.newMinNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string admin */
        1:
          message.admin = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string new_ticker */
        3:
          message.newTicker = reader.string();
          break;
        case /* string new_min_price_tick_size */
        4:
          message.newMinPriceTickSize = reader.string();
          break;
        case /* string new_min_quantity_tick_size */
        5:
          message.newMinQuantityTickSize = reader.string();
          break;
        case /* string new_min_notional */
        6:
          message.newMinNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.admin !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.admin);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.newTicker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.newTicker);
    if (message.newMinPriceTickSize !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.newMinPriceTickSize);
    if (message.newMinQuantityTickSize !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.newMinQuantityTickSize);
    if (message.newMinNotional !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.newMinNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgUpdateSpotMarket = new MsgUpdateSpotMarket$Type();
class MsgUpdateSpotMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgUpdateSpotMarketResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgUpdateSpotMarketResponse = new MsgUpdateSpotMarketResponse$Type();
class MsgUpdateDerivativeMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgUpdateDerivativeMarket", [
      {
        no: 1,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "new_ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "new_min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "new_min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "new_min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "new_initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "new_maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgUpdateDerivativeMarket", "cosmos.msg.v1.signer": ["admin"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.admin = "";
    message.marketId = "";
    message.newTicker = "";
    message.newMinPriceTickSize = "";
    message.newMinQuantityTickSize = "";
    message.newMinNotional = "";
    message.newInitialMarginRatio = "";
    message.newMaintenanceMarginRatio = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string admin */
        1:
          message.admin = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string new_ticker */
        3:
          message.newTicker = reader.string();
          break;
        case /* string new_min_price_tick_size */
        4:
          message.newMinPriceTickSize = reader.string();
          break;
        case /* string new_min_quantity_tick_size */
        5:
          message.newMinQuantityTickSize = reader.string();
          break;
        case /* string new_min_notional */
        6:
          message.newMinNotional = reader.string();
          break;
        case /* string new_initial_margin_ratio */
        7:
          message.newInitialMarginRatio = reader.string();
          break;
        case /* string new_maintenance_margin_ratio */
        8:
          message.newMaintenanceMarginRatio = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.admin !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.admin);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.newTicker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.newTicker);
    if (message.newMinPriceTickSize !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.newMinPriceTickSize);
    if (message.newMinQuantityTickSize !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.newMinQuantityTickSize);
    if (message.newMinNotional !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.newMinNotional);
    if (message.newInitialMarginRatio !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.newInitialMarginRatio);
    if (message.newMaintenanceMarginRatio !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.newMaintenanceMarginRatio);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgUpdateDerivativeMarket = new MsgUpdateDerivativeMarket$Type();
class MsgUpdateDerivativeMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgUpdateDerivativeMarketResponse = new MsgUpdateDerivativeMarketResponse$Type();
class MsgUpdateParams$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgUpdateParams", [
      { no: 1, name: "authority", kind: "scalar", T: 9, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
      { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
    ], { "amino.name": "exchange/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.authority = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string authority */
        1:
          message.authority = reader.string();
          break;
        case /* injective.exchange.v1beta1.Params params */
        2:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.authority !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.authority);
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgUpdateParams = new MsgUpdateParams$Type();
class MsgUpdateParamsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgUpdateParamsResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
class MsgDeposit$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgDeposit", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgDeposit", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        3:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgDeposit = new MsgDeposit$Type();
class MsgDepositResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgDepositResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgDepositResponse = new MsgDepositResponse$Type();
class MsgWithdraw$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgWithdraw", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgWithdraw", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.subaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        3:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgWithdraw = new MsgWithdraw$Type();
class MsgWithdrawResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgWithdrawResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgWithdrawResponse = new MsgWithdrawResponse$Type();
class MsgCreateSpotLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateSpotLimitOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => SpotOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgCreateSpotLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* injective.exchange.v1beta1.SpotOrder order */
        2:
          message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.order)
      SpotOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateSpotLimitOrder = new MsgCreateSpotLimitOrder$Type();
class MsgCreateSpotLimitOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        2:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateSpotLimitOrderResponse = new MsgCreateSpotLimitOrderResponse$Type();
class MsgBatchCreateSpotLimitOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "orders", kind: "message", repeat: 2, T: () => SpotOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBatchCreateSpotLimitOrders", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.SpotOrder orders */
        2:
          message.orders.push(SpotOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    for (let i = 0; i < message.orders.length; i++)
      SpotOrder.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCreateSpotLimitOrders = new MsgBatchCreateSpotLimitOrders$Type();
class MsgBatchCreateSpotLimitOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse", [
      {
        no: 1,
        name: "order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "created_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "failed_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHashes = [];
    message.createdOrdersCids = [];
    message.failedOrdersCids = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string order_hashes */
        1:
          message.orderHashes.push(reader.string());
          break;
        case /* repeated string created_orders_cids */
        2:
          message.createdOrdersCids.push(reader.string());
          break;
        case /* repeated string failed_orders_cids */
        3:
          message.failedOrdersCids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orderHashes.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.orderHashes[i]);
    for (let i = 0; i < message.createdOrdersCids.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.createdOrdersCids[i]);
    for (let i = 0; i < message.failedOrdersCids.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.failedOrdersCids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCreateSpotLimitOrdersResponse = new MsgBatchCreateSpotLimitOrdersResponse$Type();
class MsgInstantSpotMarketLaunch$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantSpotMarketLaunch", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "base_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 8,
        name: "base_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 9,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantSpotMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.ticker = "";
    message.baseDenom = "";
    message.quoteDenom = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.baseDecimals = 0;
    message.quoteDecimals = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string ticker */
        2:
          message.ticker = reader.string();
          break;
        case /* string base_denom */
        3:
          message.baseDenom = reader.string();
          break;
        case /* string quote_denom */
        4:
          message.quoteDenom = reader.string();
          break;
        case /* string min_price_tick_size */
        5:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        6:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        7:
          message.minNotional = reader.string();
          break;
        case /* uint32 base_decimals */
        8:
          message.baseDecimals = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        9:
          message.quoteDecimals = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.ticker !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.ticker);
    if (message.baseDenom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.baseDenom);
    if (message.quoteDenom !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.minPriceTickSize !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.minNotional);
    if (message.baseDecimals !== 0)
      writer.tag(8, WireType.Varint).uint32(message.baseDecimals);
    if (message.quoteDecimals !== 0)
      writer.tag(9, WireType.Varint).uint32(message.quoteDecimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantSpotMarketLaunch = new MsgInstantSpotMarketLaunch$Type();
class MsgInstantSpotMarketLaunchResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantSpotMarketLaunchResponse = new MsgInstantSpotMarketLaunchResponse$Type();
class MsgInstantPerpetualMarketLaunch$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 7, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      { no: 8, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 9, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantPerpetualMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.ticker = "";
    message.quoteDenom = "";
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleScaleFactor = 0;
    message.oracleType = 0;
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string ticker */
        2:
          message.ticker = reader.string();
          break;
        case /* string quote_denom */
        3:
          message.quoteDenom = reader.string();
          break;
        case /* string oracle_base */
        4:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        5:
          message.oracleQuote = reader.string();
          break;
        case /* uint32 oracle_scale_factor */
        6:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        7:
          message.oracleType = reader.int32();
          break;
        case /* string maker_fee_rate */
        8:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        9:
          message.takerFeeRate = reader.string();
          break;
        case /* string initial_margin_ratio */
        10:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        11:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string min_price_tick_size */
        12:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        13:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        14:
          message.minNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.ticker !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.ticker);
    if (message.quoteDenom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.oracleBase !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleScaleFactor !== 0)
      writer.tag(6, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.oracleType !== 0)
      writer.tag(7, WireType.Varint).int32(message.oracleType);
    if (message.makerFeeRate !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.initialMarginRatio !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.minPriceTickSize !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.minNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantPerpetualMarketLaunch = new MsgInstantPerpetualMarketLaunch$Type();
class MsgInstantPerpetualMarketLaunchResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantPerpetualMarketLaunchResponse = new MsgInstantPerpetualMarketLaunchResponse$Type();
class MsgInstantBinaryOptionsMarketLaunch$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "oracle_symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "oracle_provider",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 6,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 7, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 9,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "settlement_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 15, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantBinaryOptionsMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.ticker = "";
    message.oracleSymbol = "";
    message.oracleProvider = "";
    message.oracleType = 0;
    message.oracleScaleFactor = 0;
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.expirationTimestamp = 0n;
    message.settlementTimestamp = 0n;
    message.admin = "";
    message.quoteDenom = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string ticker */
        2:
          message.ticker = reader.string();
          break;
        case /* string oracle_symbol */
        3:
          message.oracleSymbol = reader.string();
          break;
        case /* string oracle_provider */
        4:
          message.oracleProvider = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        5:
          message.oracleType = reader.int32();
          break;
        case /* uint32 oracle_scale_factor */
        6:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* string maker_fee_rate */
        7:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        8:
          message.takerFeeRate = reader.string();
          break;
        case /* int64 expiration_timestamp */
        9:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 settlement_timestamp */
        10:
          message.settlementTimestamp = reader.int64().toBigInt();
          break;
        case /* string admin */
        11:
          message.admin = reader.string();
          break;
        case /* string quote_denom */
        12:
          message.quoteDenom = reader.string();
          break;
        case /* string min_price_tick_size */
        13:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        14:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        15:
          message.minNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.ticker !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleSymbol !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.oracleSymbol);
    if (message.oracleProvider !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.oracleProvider);
    if (message.oracleType !== 0)
      writer.tag(5, WireType.Varint).int32(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(6, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.makerFeeRate !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.expirationTimestamp !== 0n)
      writer.tag(9, WireType.Varint).int64(message.expirationTimestamp);
    if (message.settlementTimestamp !== 0n)
      writer.tag(10, WireType.Varint).int64(message.settlementTimestamp);
    if (message.admin !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.admin);
    if (message.quoteDenom !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.minPriceTickSize !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantBinaryOptionsMarketLaunch = new MsgInstantBinaryOptionsMarketLaunch$Type();
class MsgInstantBinaryOptionsMarketLaunchResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantBinaryOptionsMarketLaunchResponse = new MsgInstantBinaryOptionsMarketLaunchResponse$Type();
class MsgInstantExpiryFuturesMarketLaunch$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 7,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "expiry",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 9, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 15, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantExpiryFuturesMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.ticker = "";
    message.quoteDenom = "";
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleType = 0;
    message.oracleScaleFactor = 0;
    message.expiry = 0n;
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string ticker */
        2:
          message.ticker = reader.string();
          break;
        case /* string quote_denom */
        3:
          message.quoteDenom = reader.string();
          break;
        case /* string oracle_base */
        4:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        5:
          message.oracleQuote = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        6:
          message.oracleType = reader.int32();
          break;
        case /* uint32 oracle_scale_factor */
        7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* int64 expiry */
        8:
          message.expiry = reader.int64().toBigInt();
          break;
        case /* string maker_fee_rate */
        9:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        10:
          message.takerFeeRate = reader.string();
          break;
        case /* string initial_margin_ratio */
        11:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        12:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string min_price_tick_size */
        13:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        14:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        15:
          message.minNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.ticker !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.ticker);
    if (message.quoteDenom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.oracleBase !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleType !== 0)
      writer.tag(6, WireType.Varint).int32(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.expiry !== 0n)
      writer.tag(8, WireType.Varint).int64(message.expiry);
    if (message.makerFeeRate !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.initialMarginRatio !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.minPriceTickSize !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantExpiryFuturesMarketLaunch = new MsgInstantExpiryFuturesMarketLaunch$Type();
class MsgInstantExpiryFuturesMarketLaunchResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgInstantExpiryFuturesMarketLaunchResponse = new MsgInstantExpiryFuturesMarketLaunchResponse$Type();
class MsgCreateSpotMarketOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateSpotMarketOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => SpotOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgCreateSpotMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* injective.exchange.v1beta1.SpotOrder order */
        2:
          message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.order)
      SpotOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateSpotMarketOrder = new MsgCreateSpotMarketOrder$Type();
class MsgCreateSpotMarketOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "results", kind: "message", T: () => SpotMarketOrderResults, options: { "gogoproto.nullable": true } },
      {
        no: 3,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* injective.exchange.v1beta1.SpotMarketOrderResults results */
        2:
          message.results = SpotMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
          break;
        case /* string cid */
        3:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.results)
      SpotMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.cid !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateSpotMarketOrderResponse = new MsgCreateSpotMarketOrderResponse$Type();
class SpotMarketOrderResults$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SpotMarketOrderResults", [
      { no: 1, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.quantity = "";
    message.price = "";
    message.fee = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string quantity */
        1:
          message.quantity = reader.string();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        case /* string fee */
        3:
          message.fee = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.quantity !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.quantity);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    if (message.fee !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.fee);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketOrderResults = new SpotMarketOrderResults$Type();
class MsgCreateDerivativeLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateDerivativeLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeOrder order */
        2:
          message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.order)
      DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateDerivativeLimitOrder = new MsgCreateDerivativeLimitOrder$Type();
class MsgCreateDerivativeLimitOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        2:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateDerivativeLimitOrderResponse = new MsgCreateDerivativeLimitOrderResponse$Type();
class MsgCreateBinaryOptionsLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateBinaryOptionsLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeOrder order */
        2:
          message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.order)
      DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateBinaryOptionsLimitOrder = new MsgCreateBinaryOptionsLimitOrder$Type();
class MsgCreateBinaryOptionsLimitOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        2:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateBinaryOptionsLimitOrderResponse = new MsgCreateBinaryOptionsLimitOrderResponse$Type();
class MsgBatchCreateDerivativeLimitOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "orders", kind: "message", repeat: 2, T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCreateDerivativeLimitOrders", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.orders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.DerivativeOrder orders */
        2:
          message.orders.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    for (let i = 0; i < message.orders.length; i++)
      DerivativeOrder.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCreateDerivativeLimitOrders = new MsgBatchCreateDerivativeLimitOrders$Type();
class MsgBatchCreateDerivativeLimitOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse", [
      {
        no: 1,
        name: "order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "created_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "failed_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHashes = [];
    message.createdOrdersCids = [];
    message.failedOrdersCids = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string order_hashes */
        1:
          message.orderHashes.push(reader.string());
          break;
        case /* repeated string created_orders_cids */
        2:
          message.createdOrdersCids.push(reader.string());
          break;
        case /* repeated string failed_orders_cids */
        3:
          message.failedOrdersCids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.orderHashes.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.orderHashes[i]);
    for (let i = 0; i < message.createdOrdersCids.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.createdOrdersCids[i]);
    for (let i = 0; i < message.failedOrdersCids.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.failedOrdersCids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCreateDerivativeLimitOrdersResponse = new MsgBatchCreateDerivativeLimitOrdersResponse$Type();
class MsgCancelSpotOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCancelSpotOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelSpotOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.marketId = "";
    message.subaccountId = "";
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string order_hash */
        4:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        5:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.orderHash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCancelSpotOrder = new MsgCancelSpotOrder$Type();
class MsgCancelSpotOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCancelSpotOrderResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCancelSpotOrderResponse = new MsgCancelSpotOrderResponse$Type();
class MsgBatchCancelSpotOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCancelSpotOrders", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => OrderData, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelSpotOrders", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.OrderData data */
        2:
          message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    for (let i = 0; i < message.data.length; i++)
      OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCancelSpotOrders = new MsgBatchCancelSpotOrders$Type();
class MsgBatchCancelSpotOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse", [
      {
        no: 1,
        name: "success",
        kind: "scalar",
        repeat: 1,
        T: 8
        /*ScalarType.BOOL*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.success = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bool success */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.success.push(reader.bool());
          else
            message.success.push(reader.bool());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.success.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.success.length; i++)
        writer.bool(message.success[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCancelSpotOrdersResponse = new MsgBatchCancelSpotOrdersResponse$Type();
class MsgBatchCancelBinaryOptionsOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => OrderData, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelBinaryOptionsOrders", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.OrderData data */
        2:
          message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    for (let i = 0; i < message.data.length; i++)
      OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCancelBinaryOptionsOrders = new MsgBatchCancelBinaryOptionsOrders$Type();
class MsgBatchCancelBinaryOptionsOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse", [
      {
        no: 1,
        name: "success",
        kind: "scalar",
        repeat: 1,
        T: 8
        /*ScalarType.BOOL*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.success = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bool success */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.success.push(reader.bool());
          else
            message.success.push(reader.bool());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.success.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.success.length; i++)
        writer.bool(message.success[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCancelBinaryOptionsOrdersResponse = new MsgBatchCancelBinaryOptionsOrdersResponse$Type();
class MsgBatchUpdateOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchUpdateOrders", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "spot_market_ids_to_cancel_all",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "derivative_market_ids_to_cancel_all",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "spot_orders_to_cancel", kind: "message", repeat: 2, T: () => OrderData, options: { "gogoproto.nullable": true } },
      { no: 6, name: "derivative_orders_to_cancel", kind: "message", repeat: 2, T: () => OrderData, options: { "gogoproto.nullable": true } },
      { no: 7, name: "spot_orders_to_create", kind: "message", repeat: 2, T: () => SpotOrder, options: { "gogoproto.nullable": true } },
      { no: 8, name: "derivative_orders_to_create", kind: "message", repeat: 2, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } },
      { no: 9, name: "binary_options_orders_to_cancel", kind: "message", repeat: 2, T: () => OrderData, options: { "gogoproto.nullable": true } },
      {
        no: 10,
        name: "binary_options_market_ids_to_cancel_all",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 11, name: "binary_options_orders_to_create", kind: "message", repeat: 2, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchUpdateOrders", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.subaccountId = "";
    message.spotMarketIdsToCancelAll = [];
    message.derivativeMarketIdsToCancelAll = [];
    message.spotOrdersToCancel = [];
    message.derivativeOrdersToCancel = [];
    message.spotOrdersToCreate = [];
    message.derivativeOrdersToCreate = [];
    message.binaryOptionsOrdersToCancel = [];
    message.binaryOptionsMarketIdsToCancelAll = [];
    message.binaryOptionsOrdersToCreate = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* repeated string spot_market_ids_to_cancel_all */
        3:
          message.spotMarketIdsToCancelAll.push(reader.string());
          break;
        case /* repeated string derivative_market_ids_to_cancel_all */
        4:
          message.derivativeMarketIdsToCancelAll.push(reader.string());
          break;
        case /* repeated injective.exchange.v1beta1.OrderData spot_orders_to_cancel */
        5:
          message.spotOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v1beta1.OrderData derivative_orders_to_cancel */
        6:
          message.derivativeOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v1beta1.SpotOrder spot_orders_to_create */
        7:
          message.spotOrdersToCreate.push(SpotOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create */
        8:
          message.derivativeOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel */
        9:
          message.binaryOptionsOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string binary_options_market_ids_to_cancel_all */
        10:
          message.binaryOptionsMarketIdsToCancelAll.push(reader.string());
          break;
        case /* repeated injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create */
        11:
          message.binaryOptionsOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.spotMarketIdsToCancelAll.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.spotMarketIdsToCancelAll[i]);
    for (let i = 0; i < message.derivativeMarketIdsToCancelAll.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.derivativeMarketIdsToCancelAll[i]);
    for (let i = 0; i < message.spotOrdersToCancel.length; i++)
      OrderData.internalBinaryWrite(message.spotOrdersToCancel[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeOrdersToCancel.length; i++)
      OrderData.internalBinaryWrite(message.derivativeOrdersToCancel[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.spotOrdersToCreate.length; i++)
      SpotOrder.internalBinaryWrite(message.spotOrdersToCreate[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeOrdersToCreate.length; i++)
      DerivativeOrder.internalBinaryWrite(message.derivativeOrdersToCreate[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.binaryOptionsOrdersToCancel.length; i++)
      OrderData.internalBinaryWrite(message.binaryOptionsOrdersToCancel[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.binaryOptionsMarketIdsToCancelAll.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.binaryOptionsMarketIdsToCancelAll[i]);
    for (let i = 0; i < message.binaryOptionsOrdersToCreate.length; i++)
      DerivativeOrder.internalBinaryWrite(message.binaryOptionsOrdersToCreate[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchUpdateOrders = new MsgBatchUpdateOrders$Type();
class MsgBatchUpdateOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse", [
      {
        no: 1,
        name: "spot_cancel_success",
        kind: "scalar",
        repeat: 1,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "derivative_cancel_success",
        kind: "scalar",
        repeat: 1,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "spot_order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "derivative_order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "binary_options_cancel_success",
        kind: "scalar",
        repeat: 1,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "binary_options_order_hashes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "created_spot_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "failed_spot_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "created_derivative_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "failed_derivative_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "created_binary_options_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "failed_binary_options_orders_cids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.spotCancelSuccess = [];
    message.derivativeCancelSuccess = [];
    message.spotOrderHashes = [];
    message.derivativeOrderHashes = [];
    message.binaryOptionsCancelSuccess = [];
    message.binaryOptionsOrderHashes = [];
    message.createdSpotOrdersCids = [];
    message.failedSpotOrdersCids = [];
    message.createdDerivativeOrdersCids = [];
    message.failedDerivativeOrdersCids = [];
    message.createdBinaryOptionsOrdersCids = [];
    message.failedBinaryOptionsOrdersCids = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bool spot_cancel_success */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.spotCancelSuccess.push(reader.bool());
          else
            message.spotCancelSuccess.push(reader.bool());
          break;
        case /* repeated bool derivative_cancel_success */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.derivativeCancelSuccess.push(reader.bool());
          else
            message.derivativeCancelSuccess.push(reader.bool());
          break;
        case /* repeated string spot_order_hashes */
        3:
          message.spotOrderHashes.push(reader.string());
          break;
        case /* repeated string derivative_order_hashes */
        4:
          message.derivativeOrderHashes.push(reader.string());
          break;
        case /* repeated bool binary_options_cancel_success */
        5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.binaryOptionsCancelSuccess.push(reader.bool());
          else
            message.binaryOptionsCancelSuccess.push(reader.bool());
          break;
        case /* repeated string binary_options_order_hashes */
        6:
          message.binaryOptionsOrderHashes.push(reader.string());
          break;
        case /* repeated string created_spot_orders_cids */
        7:
          message.createdSpotOrdersCids.push(reader.string());
          break;
        case /* repeated string failed_spot_orders_cids */
        8:
          message.failedSpotOrdersCids.push(reader.string());
          break;
        case /* repeated string created_derivative_orders_cids */
        9:
          message.createdDerivativeOrdersCids.push(reader.string());
          break;
        case /* repeated string failed_derivative_orders_cids */
        10:
          message.failedDerivativeOrdersCids.push(reader.string());
          break;
        case /* repeated string created_binary_options_orders_cids */
        11:
          message.createdBinaryOptionsOrdersCids.push(reader.string());
          break;
        case /* repeated string failed_binary_options_orders_cids */
        12:
          message.failedBinaryOptionsOrdersCids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.spotCancelSuccess.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.spotCancelSuccess.length; i++)
        writer.bool(message.spotCancelSuccess[i]);
      writer.join();
    }
    if (message.derivativeCancelSuccess.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.derivativeCancelSuccess.length; i++)
        writer.bool(message.derivativeCancelSuccess[i]);
      writer.join();
    }
    for (let i = 0; i < message.spotOrderHashes.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.spotOrderHashes[i]);
    for (let i = 0; i < message.derivativeOrderHashes.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.derivativeOrderHashes[i]);
    if (message.binaryOptionsCancelSuccess.length) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.binaryOptionsCancelSuccess.length; i++)
        writer.bool(message.binaryOptionsCancelSuccess[i]);
      writer.join();
    }
    for (let i = 0; i < message.binaryOptionsOrderHashes.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.binaryOptionsOrderHashes[i]);
    for (let i = 0; i < message.createdSpotOrdersCids.length; i++)
      writer.tag(7, WireType.LengthDelimited).string(message.createdSpotOrdersCids[i]);
    for (let i = 0; i < message.failedSpotOrdersCids.length; i++)
      writer.tag(8, WireType.LengthDelimited).string(message.failedSpotOrdersCids[i]);
    for (let i = 0; i < message.createdDerivativeOrdersCids.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.createdDerivativeOrdersCids[i]);
    for (let i = 0; i < message.failedDerivativeOrdersCids.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.failedDerivativeOrdersCids[i]);
    for (let i = 0; i < message.createdBinaryOptionsOrdersCids.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.createdBinaryOptionsOrdersCids[i]);
    for (let i = 0; i < message.failedBinaryOptionsOrdersCids.length; i++)
      writer.tag(12, WireType.LengthDelimited).string(message.failedBinaryOptionsOrdersCids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchUpdateOrdersResponse = new MsgBatchUpdateOrdersResponse$Type();
class MsgCreateDerivativeMarketOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateDerivativeMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeOrder order */
        2:
          message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.order)
      DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateDerivativeMarketOrder = new MsgCreateDerivativeMarketOrder$Type();
class MsgCreateDerivativeMarketOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "results", kind: "message", T: () => DerivativeMarketOrderResults, options: { "gogoproto.nullable": true } },
      {
        no: 3,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeMarketOrderResults results */
        2:
          message.results = DerivativeMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
          break;
        case /* string cid */
        3:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.results)
      DerivativeMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.cid !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateDerivativeMarketOrderResponse = new MsgCreateDerivativeMarketOrderResponse$Type();
class DerivativeMarketOrderResults$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DerivativeMarketOrderResults", [
      { no: 1, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "position_delta", kind: "message", T: () => PositionDelta, options: { "gogoproto.nullable": false } },
      { no: 5, name: "payout", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.quantity = "";
    message.price = "";
    message.fee = "";
    message.payout = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string quantity */
        1:
          message.quantity = reader.string();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        case /* string fee */
        3:
          message.fee = reader.string();
          break;
        case /* injective.exchange.v1beta1.PositionDelta position_delta */
        4:
          message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
          break;
        case /* string payout */
        5:
          message.payout = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.quantity !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.quantity);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    if (message.fee !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.fee);
    if (message.positionDelta)
      PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.payout !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.payout);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketOrderResults = new DerivativeMarketOrderResults$Type();
class MsgCreateBinaryOptionsMarketOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateBinaryOptionsMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeOrder order */
        2:
          message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.order)
      DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateBinaryOptionsMarketOrder = new MsgCreateBinaryOptionsMarketOrder$Type();
class MsgCreateBinaryOptionsMarketOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse", [
      {
        no: 1,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "results", kind: "message", T: () => DerivativeMarketOrderResults, options: { "gogoproto.nullable": true } },
      {
        no: 3,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string order_hash */
        1:
          message.orderHash = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeMarketOrderResults results */
        2:
          message.results = DerivativeMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
          break;
        case /* string cid */
        3:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderHash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
    if (message.results)
      DerivativeMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.cid !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCreateBinaryOptionsMarketOrderResponse = new MsgCreateBinaryOptionsMarketOrderResponse$Type();
class MsgCancelDerivativeOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCancelDerivativeOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "order_mask",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 6,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelDerivativeOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.marketId = "";
    message.subaccountId = "";
    message.orderHash = "";
    message.orderMask = 0;
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string order_hash */
        4:
          message.orderHash = reader.string();
          break;
        case /* int32 order_mask */
        5:
          message.orderMask = reader.int32();
          break;
        case /* string cid */
        6:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.orderHash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
    if (message.orderMask !== 0)
      writer.tag(5, WireType.Varint).int32(message.orderMask);
    if (message.cid !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCancelDerivativeOrder = new MsgCancelDerivativeOrder$Type();
class MsgCancelDerivativeOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCancelDerivativeOrderResponse = new MsgCancelDerivativeOrderResponse$Type();
class MsgCancelBinaryOptionsOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "order_mask",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 6,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelBinaryOptionsOrder", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.marketId = "";
    message.subaccountId = "";
    message.orderHash = "";
    message.orderMask = 0;
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        3:
          message.subaccountId = reader.string();
          break;
        case /* string order_hash */
        4:
          message.orderHash = reader.string();
          break;
        case /* int32 order_mask */
        5:
          message.orderMask = reader.int32();
          break;
        case /* string cid */
        6:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
    if (message.orderHash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
    if (message.orderMask !== 0)
      writer.tag(5, WireType.Varint).int32(message.orderMask);
    if (message.cid !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCancelBinaryOptionsOrder = new MsgCancelBinaryOptionsOrder$Type();
class MsgCancelBinaryOptionsOrderResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgCancelBinaryOptionsOrderResponse = new MsgCancelBinaryOptionsOrderResponse$Type();
class OrderData$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.OrderData", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "order_mask",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.orderHash = "";
    message.orderMask = 0;
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string order_hash */
        3:
          message.orderHash = reader.string();
          break;
        case /* int32 order_mask */
        4:
          message.orderMask = reader.int32();
          break;
        case /* string cid */
        5:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.orderHash !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.orderHash);
    if (message.orderMask !== 0)
      writer.tag(4, WireType.Varint).int32(message.orderMask);
    if (message.cid !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderData = new OrderData$Type();
class MsgBatchCancelDerivativeOrders$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "data", kind: "message", repeat: 2, T: () => OrderData, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelDerivativeOrders", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.OrderData data */
        2:
          message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    for (let i = 0; i < message.data.length; i++)
      OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCancelDerivativeOrders = new MsgBatchCancelDerivativeOrders$Type();
class MsgBatchCancelDerivativeOrdersResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse", [
      {
        no: 1,
        name: "success",
        kind: "scalar",
        repeat: 1,
        T: 8
        /*ScalarType.BOOL*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.success = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bool success */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.success.push(reader.bool());
          else
            message.success.push(reader.bool());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.success.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.success.length; i++)
        writer.bool(message.success[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchCancelDerivativeOrdersResponse = new MsgBatchCancelDerivativeOrdersResponse$Type();
class MsgSubaccountTransfer$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgSubaccountTransfer", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "source_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "destination_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ], { "amino.name": "exchange/MsgSubaccountTransfer", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.sourceSubaccountId = "";
    message.destinationSubaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string source_subaccount_id */
        2:
          message.sourceSubaccountId = reader.string();
          break;
        case /* string destination_subaccount_id */
        3:
          message.destinationSubaccountId = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        4:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.sourceSubaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
    if (message.destinationSubaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgSubaccountTransfer = new MsgSubaccountTransfer$Type();
class MsgSubaccountTransferResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgSubaccountTransferResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgSubaccountTransferResponse = new MsgSubaccountTransferResponse$Type();
class MsgExternalTransfer$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgExternalTransfer", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "source_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "destination_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ], { "amino.name": "exchange/MsgExternalTransfer", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.sourceSubaccountId = "";
    message.destinationSubaccountId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string source_subaccount_id */
        2:
          message.sourceSubaccountId = reader.string();
          break;
        case /* string destination_subaccount_id */
        3:
          message.destinationSubaccountId = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        4:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.sourceSubaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
    if (message.destinationSubaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgExternalTransfer = new MsgExternalTransfer$Type();
class MsgExternalTransferResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgExternalTransferResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgExternalTransferResponse = new MsgExternalTransferResponse$Type();
class MsgLiquidatePosition$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgLiquidatePosition", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": true } }
    ], { "amino.name": "exchange/MsgLiquidatePosition", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.subaccountId = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeOrder order */
        4:
          message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.order)
      DerivativeOrder.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgLiquidatePosition = new MsgLiquidatePosition$Type();
class MsgLiquidatePositionResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgLiquidatePositionResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgLiquidatePositionResponse = new MsgLiquidatePositionResponse$Type();
class MsgEmergencySettleMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgEmergencySettleMarket", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "amino.name": "exchange/MsgEmergencySettleMarket", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.subaccountId = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgEmergencySettleMarket = new MsgEmergencySettleMarket$Type();
class MsgEmergencySettleMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgEmergencySettleMarketResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgEmergencySettleMarketResponse = new MsgEmergencySettleMarketResponse$Type();
class MsgIncreasePositionMargin$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgIncreasePositionMargin", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "source_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "destination_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "amino.name": "exchange/MsgIncreasePositionMargin", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.sourceSubaccountId = "";
    message.destinationSubaccountId = "";
    message.marketId = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string source_subaccount_id */
        2:
          message.sourceSubaccountId = reader.string();
          break;
        case /* string destination_subaccount_id */
        3:
          message.destinationSubaccountId = reader.string();
          break;
        case /* string market_id */
        4:
          message.marketId = reader.string();
          break;
        case /* string amount */
        5:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.sourceSubaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
    if (message.destinationSubaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
    if (message.marketId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marketId);
    if (message.amount !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgIncreasePositionMargin = new MsgIncreasePositionMargin$Type();
class MsgIncreasePositionMarginResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgIncreasePositionMarginResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgIncreasePositionMarginResponse = new MsgIncreasePositionMarginResponse$Type();
class MsgDecreasePositionMargin$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgDecreasePositionMargin", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "source_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "destination_subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "amino.name": "exchange/MsgDecreasePositionMargin", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.sourceSubaccountId = "";
    message.destinationSubaccountId = "";
    message.marketId = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string source_subaccount_id */
        2:
          message.sourceSubaccountId = reader.string();
          break;
        case /* string destination_subaccount_id */
        3:
          message.destinationSubaccountId = reader.string();
          break;
        case /* string market_id */
        4:
          message.marketId = reader.string();
          break;
        case /* string amount */
        5:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.sourceSubaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
    if (message.destinationSubaccountId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
    if (message.marketId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marketId);
    if (message.amount !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgDecreasePositionMargin = new MsgDecreasePositionMargin$Type();
class MsgDecreasePositionMarginResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgDecreasePositionMarginResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgDecreasePositionMarginResponse = new MsgDecreasePositionMarginResponse$Type();
class MsgPrivilegedExecuteContract$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgPrivilegedExecuteContract", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "funds",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "data",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgPrivilegedExecuteContract", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.funds = "";
    message.contractAddress = "";
    message.data = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string funds */
        2:
          message.funds = reader.string();
          break;
        case /* string contract_address */
        3:
          message.contractAddress = reader.string();
          break;
        case /* string data */
        4:
          message.data = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.funds !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.funds);
    if (message.contractAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.contractAddress);
    if (message.data !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgPrivilegedExecuteContract = new MsgPrivilegedExecuteContract$Type();
class MsgPrivilegedExecuteContractResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse", [
      { no: 1, name: "funds_diff", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fundsDiff = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cosmos.base.v1beta1.Coin funds_diff */
        1:
          message.fundsDiff.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.fundsDiff.length; i++)
      Coin.internalBinaryWrite(message.fundsDiff[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgPrivilegedExecuteContractResponse = new MsgPrivilegedExecuteContractResponse$Type();
class MsgRewardsOptOut$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgRewardsOptOut", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgRewardsOptOut", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgRewardsOptOut = new MsgRewardsOptOut$Type();
class MsgRewardsOptOutResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgRewardsOptOutResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgRewardsOptOutResponse = new MsgRewardsOptOutResponse$Type();
class MsgReclaimLockedFunds$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgReclaimLockedFunds", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "lockedAccountPubKey",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "signature",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ], { "amino.name": "exchange/MsgReclaimLockedFunds", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.lockedAccountPubKey = new Uint8Array(0);
    message.signature = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* bytes lockedAccountPubKey */
        2:
          message.lockedAccountPubKey = reader.bytes();
          break;
        case /* bytes signature */
        3:
          message.signature = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.lockedAccountPubKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.lockedAccountPubKey);
    if (message.signature.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.signature);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgReclaimLockedFunds = new MsgReclaimLockedFunds$Type();
class MsgReclaimLockedFundsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgReclaimLockedFundsResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgReclaimLockedFundsResponse = new MsgReclaimLockedFundsResponse$Type();
class MsgSignData$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgSignData", [
      { no: 1, name: "Signer", kind: "scalar", jsonName: "Signer", T: 12, options: { "gogoproto.jsontag": "signer", "gogoproto.casttype": "github.com/cosmos/cosmos-sdk/types.AccAddress" } },
      { no: 2, name: "Data", kind: "scalar", jsonName: "Data", T: 12, options: { "gogoproto.jsontag": "data" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signer = new Uint8Array(0);
    message.data = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes Signer */
        1:
          message.signer = reader.bytes();
          break;
        case /* bytes Data */
        2:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.signer.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.signer);
    if (message.data.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgSignData = new MsgSignData$Type();
class MsgSignDoc$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgSignDoc", [
      { no: 1, name: "sign_type", kind: "scalar", T: 9, options: { "gogoproto.jsontag": "type" } },
      { no: 2, name: "value", kind: "message", T: () => MsgSignData, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signType = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sign_type */
        1:
          message.signType = reader.string();
          break;
        case /* injective.exchange.v1beta1.MsgSignData value */
        2:
          message.value = MsgSignData.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.signType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.signType);
    if (message.value)
      MsgSignData.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgSignDoc = new MsgSignDoc$Type();
class MsgAdminUpdateBinaryOptionsMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 4,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "settlement_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] }
    ], { "amino.name": "exchange/MsgAdminUpdateBinaryOptionsMarket", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.marketId = "";
    message.settlementPrice = "";
    message.expirationTimestamp = 0n;
    message.settlementTimestamp = 0n;
    message.status = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string settlement_price */
        3:
          message.settlementPrice = reader.string();
          break;
        case /* int64 expiration_timestamp */
        4:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 settlement_timestamp */
        5:
          message.settlementTimestamp = reader.int64().toBigInt();
          break;
        case /* injective.exchange.v1beta1.MarketStatus status */
        6:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.settlementPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.settlementPrice);
    if (message.expirationTimestamp !== 0n)
      writer.tag(4, WireType.Varint).int64(message.expirationTimestamp);
    if (message.settlementTimestamp !== 0n)
      writer.tag(5, WireType.Varint).int64(message.settlementTimestamp);
    if (message.status !== 0)
      writer.tag(6, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgAdminUpdateBinaryOptionsMarket = new MsgAdminUpdateBinaryOptionsMarket$Type();
class MsgAdminUpdateBinaryOptionsMarketResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgAdminUpdateBinaryOptionsMarketResponse = new MsgAdminUpdateBinaryOptionsMarketResponse$Type();
class MsgAuthorizeStakeGrants$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgAuthorizeStakeGrants", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "grants", kind: "message", repeat: 2, T: () => GrantAuthorization }
    ], { "amino.name": "exchange/MsgAuthorizeStakeGrants", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.grants = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.GrantAuthorization grants */
        2:
          message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    for (let i = 0; i < message.grants.length; i++)
      GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgAuthorizeStakeGrants = new MsgAuthorizeStakeGrants$Type();
class MsgAuthorizeStakeGrantsResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgAuthorizeStakeGrantsResponse = new MsgAuthorizeStakeGrantsResponse$Type();
class MsgActivateStakeGrant$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgActivateStakeGrant", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "amino.name": "exchange/MsgActivateStakeGrant", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    message.granter = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* string granter */
        2:
          message.granter = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.granter !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.granter);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgActivateStakeGrant = new MsgActivateStakeGrant$Type();
class MsgActivateStakeGrantResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgActivateStakeGrantResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgActivateStakeGrantResponse = new MsgActivateStakeGrantResponse$Type();
class MsgBatchExchangeModification$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchExchangeModification", [
      {
        no: 1,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "proposal", kind: "message", T: () => BatchExchangeModificationProposal }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBatchExchangeModification", "cosmos.msg.v1.signer": ["sender"] });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string sender */
        1:
          message.sender = reader.string();
          break;
        case /* injective.exchange.v1beta1.BatchExchangeModificationProposal proposal */
        2:
          message.proposal = BatchExchangeModificationProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.sender !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.sender);
    if (message.proposal)
      BatchExchangeModificationProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchExchangeModification = new MsgBatchExchangeModification$Type();
class MsgBatchExchangeModificationResponse$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MsgBatchExchangeModificationResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MsgBatchExchangeModificationResponse = new MsgBatchExchangeModificationResponse$Type();
const Msg = new ServiceType("injective.exchange.v1beta1.Msg", [
  { name: "Deposit", options: {}, I: MsgDeposit, O: MsgDepositResponse },
  { name: "Withdraw", options: {}, I: MsgWithdraw, O: MsgWithdrawResponse },
  { name: "InstantSpotMarketLaunch", options: {}, I: MsgInstantSpotMarketLaunch, O: MsgInstantSpotMarketLaunchResponse },
  { name: "CreateSpotLimitOrder", options: {}, I: MsgCreateSpotLimitOrder, O: MsgCreateSpotLimitOrderResponse },
  { name: "BatchCreateSpotLimitOrders", options: {}, I: MsgBatchCreateSpotLimitOrders, O: MsgBatchCreateSpotLimitOrdersResponse },
  { name: "CreateSpotMarketOrder", options: {}, I: MsgCreateSpotMarketOrder, O: MsgCreateSpotMarketOrderResponse },
  { name: "CancelSpotOrder", options: {}, I: MsgCancelSpotOrder, O: MsgCancelSpotOrderResponse },
  { name: "BatchCancelSpotOrders", options: {}, I: MsgBatchCancelSpotOrders, O: MsgBatchCancelSpotOrdersResponse },
  { name: "BatchUpdateOrders", options: {}, I: MsgBatchUpdateOrders, O: MsgBatchUpdateOrdersResponse },
  { name: "PrivilegedExecuteContract", options: {}, I: MsgPrivilegedExecuteContract, O: MsgPrivilegedExecuteContractResponse },
  { name: "CreateDerivativeLimitOrder", options: {}, I: MsgCreateDerivativeLimitOrder, O: MsgCreateDerivativeLimitOrderResponse },
  { name: "BatchCreateDerivativeLimitOrders", options: {}, I: MsgBatchCreateDerivativeLimitOrders, O: MsgBatchCreateDerivativeLimitOrdersResponse },
  { name: "CreateDerivativeMarketOrder", options: {}, I: MsgCreateDerivativeMarketOrder, O: MsgCreateDerivativeMarketOrderResponse },
  { name: "CancelDerivativeOrder", options: {}, I: MsgCancelDerivativeOrder, O: MsgCancelDerivativeOrderResponse },
  { name: "BatchCancelDerivativeOrders", options: {}, I: MsgBatchCancelDerivativeOrders, O: MsgBatchCancelDerivativeOrdersResponse },
  { name: "InstantBinaryOptionsMarketLaunch", options: {}, I: MsgInstantBinaryOptionsMarketLaunch, O: MsgInstantBinaryOptionsMarketLaunchResponse },
  { name: "CreateBinaryOptionsLimitOrder", options: {}, I: MsgCreateBinaryOptionsLimitOrder, O: MsgCreateBinaryOptionsLimitOrderResponse },
  { name: "CreateBinaryOptionsMarketOrder", options: {}, I: MsgCreateBinaryOptionsMarketOrder, O: MsgCreateBinaryOptionsMarketOrderResponse },
  { name: "CancelBinaryOptionsOrder", options: {}, I: MsgCancelBinaryOptionsOrder, O: MsgCancelBinaryOptionsOrderResponse },
  { name: "BatchCancelBinaryOptionsOrders", options: {}, I: MsgBatchCancelBinaryOptionsOrders, O: MsgBatchCancelBinaryOptionsOrdersResponse },
  { name: "SubaccountTransfer", options: {}, I: MsgSubaccountTransfer, O: MsgSubaccountTransferResponse },
  { name: "ExternalTransfer", options: {}, I: MsgExternalTransfer, O: MsgExternalTransferResponse },
  { name: "LiquidatePosition", options: {}, I: MsgLiquidatePosition, O: MsgLiquidatePositionResponse },
  { name: "EmergencySettleMarket", options: {}, I: MsgEmergencySettleMarket, O: MsgEmergencySettleMarketResponse },
  { name: "IncreasePositionMargin", options: {}, I: MsgIncreasePositionMargin, O: MsgIncreasePositionMarginResponse },
  { name: "DecreasePositionMargin", options: {}, I: MsgDecreasePositionMargin, O: MsgDecreasePositionMarginResponse },
  { name: "RewardsOptOut", options: {}, I: MsgRewardsOptOut, O: MsgRewardsOptOutResponse },
  { name: "AdminUpdateBinaryOptionsMarket", options: {}, I: MsgAdminUpdateBinaryOptionsMarket, O: MsgAdminUpdateBinaryOptionsMarketResponse },
  { name: "UpdateSpotMarket", options: {}, I: MsgUpdateSpotMarket, O: MsgUpdateSpotMarketResponse },
  { name: "UpdateDerivativeMarket", options: {}, I: MsgUpdateDerivativeMarket, O: MsgUpdateDerivativeMarketResponse },
  { name: "AuthorizeStakeGrants", options: {}, I: MsgAuthorizeStakeGrants, O: MsgAuthorizeStakeGrantsResponse },
  { name: "ActivateStakeGrant", options: {}, I: MsgActivateStakeGrant, O: MsgActivateStakeGrantResponse },
  { name: "BatchExchangeModification", options: {}, I: MsgBatchExchangeModification, O: MsgBatchExchangeModificationResponse }
], { "cosmos.msg.v1.service": true });
export {
  DerivativeMarketOrderResults,
  Msg,
  MsgActivateStakeGrant,
  MsgActivateStakeGrantResponse,
  MsgAdminUpdateBinaryOptionsMarket,
  MsgAdminUpdateBinaryOptionsMarketResponse,
  MsgAuthorizeStakeGrants,
  MsgAuthorizeStakeGrantsResponse,
  MsgBatchCancelBinaryOptionsOrders,
  MsgBatchCancelBinaryOptionsOrdersResponse,
  MsgBatchCancelDerivativeOrders,
  MsgBatchCancelDerivativeOrdersResponse,
  MsgBatchCancelSpotOrders,
  MsgBatchCancelSpotOrdersResponse,
  MsgBatchCreateDerivativeLimitOrders,
  MsgBatchCreateDerivativeLimitOrdersResponse,
  MsgBatchCreateSpotLimitOrders,
  MsgBatchCreateSpotLimitOrdersResponse,
  MsgBatchExchangeModification,
  MsgBatchExchangeModificationResponse,
  MsgBatchUpdateOrders,
  MsgBatchUpdateOrdersResponse,
  MsgCancelBinaryOptionsOrder,
  MsgCancelBinaryOptionsOrderResponse,
  MsgCancelDerivativeOrder,
  MsgCancelDerivativeOrderResponse,
  MsgCancelSpotOrder,
  MsgCancelSpotOrderResponse,
  MsgCreateBinaryOptionsLimitOrder,
  MsgCreateBinaryOptionsLimitOrderResponse,
  MsgCreateBinaryOptionsMarketOrder,
  MsgCreateBinaryOptionsMarketOrderResponse,
  MsgCreateDerivativeLimitOrder,
  MsgCreateDerivativeLimitOrderResponse,
  MsgCreateDerivativeMarketOrder,
  MsgCreateDerivativeMarketOrderResponse,
  MsgCreateSpotLimitOrder,
  MsgCreateSpotLimitOrderResponse,
  MsgCreateSpotMarketOrder,
  MsgCreateSpotMarketOrderResponse,
  MsgDecreasePositionMargin,
  MsgDecreasePositionMarginResponse,
  MsgDeposit,
  MsgDepositResponse,
  MsgEmergencySettleMarket,
  MsgEmergencySettleMarketResponse,
  MsgExternalTransfer,
  MsgExternalTransferResponse,
  MsgIncreasePositionMargin,
  MsgIncreasePositionMarginResponse,
  MsgInstantBinaryOptionsMarketLaunch,
  MsgInstantBinaryOptionsMarketLaunchResponse,
  MsgInstantExpiryFuturesMarketLaunch,
  MsgInstantExpiryFuturesMarketLaunchResponse,
  MsgInstantPerpetualMarketLaunch,
  MsgInstantPerpetualMarketLaunchResponse,
  MsgInstantSpotMarketLaunch,
  MsgInstantSpotMarketLaunchResponse,
  MsgLiquidatePosition,
  MsgLiquidatePositionResponse,
  MsgPrivilegedExecuteContract,
  MsgPrivilegedExecuteContractResponse,
  MsgReclaimLockedFunds,
  MsgReclaimLockedFundsResponse,
  MsgRewardsOptOut,
  MsgRewardsOptOutResponse,
  MsgSignData,
  MsgSignDoc,
  MsgSubaccountTransfer,
  MsgSubaccountTransferResponse,
  MsgUpdateDerivativeMarket,
  MsgUpdateDerivativeMarketResponse,
  MsgUpdateParams,
  MsgUpdateParamsResponse,
  MsgUpdateSpotMarket,
  MsgUpdateSpotMarketResponse,
  MsgWithdraw,
  MsgWithdrawResponse,
  OrderData,
  SpotMarketOrderResults
};
