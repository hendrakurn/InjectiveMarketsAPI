import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
var AtomicMarketOrderAccessLevel = /* @__PURE__ */ ((AtomicMarketOrderAccessLevel2) => {
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["Nobody"] = 0] = "Nobody";
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["BeginBlockerSmartContractsOnly"] = 1] = "BeginBlockerSmartContractsOnly";
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["SmartContractsOnly"] = 2] = "SmartContractsOnly";
  AtomicMarketOrderAccessLevel2[AtomicMarketOrderAccessLevel2["Everyone"] = 3] = "Everyone";
  return AtomicMarketOrderAccessLevel2;
})(AtomicMarketOrderAccessLevel || {});
var MarketStatus = /* @__PURE__ */ ((MarketStatus2) => {
  MarketStatus2[MarketStatus2["Unspecified"] = 0] = "Unspecified";
  MarketStatus2[MarketStatus2["Active"] = 1] = "Active";
  MarketStatus2[MarketStatus2["Paused"] = 2] = "Paused";
  MarketStatus2[MarketStatus2["Demolished"] = 3] = "Demolished";
  MarketStatus2[MarketStatus2["Expired"] = 4] = "Expired";
  return MarketStatus2;
})(MarketStatus || {});
var OrderType = /* @__PURE__ */ ((OrderType2) => {
  OrderType2[OrderType2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  OrderType2[OrderType2["BUY"] = 1] = "BUY";
  OrderType2[OrderType2["SELL"] = 2] = "SELL";
  OrderType2[OrderType2["STOP_BUY"] = 3] = "STOP_BUY";
  OrderType2[OrderType2["STOP_SELL"] = 4] = "STOP_SELL";
  OrderType2[OrderType2["TAKE_BUY"] = 5] = "TAKE_BUY";
  OrderType2[OrderType2["TAKE_SELL"] = 6] = "TAKE_SELL";
  OrderType2[OrderType2["BUY_PO"] = 7] = "BUY_PO";
  OrderType2[OrderType2["SELL_PO"] = 8] = "SELL_PO";
  OrderType2[OrderType2["BUY_ATOMIC"] = 9] = "BUY_ATOMIC";
  OrderType2[OrderType2["SELL_ATOMIC"] = 10] = "SELL_ATOMIC";
  return OrderType2;
})(OrderType || {});
var ExecutionType = /* @__PURE__ */ ((ExecutionType2) => {
  ExecutionType2[ExecutionType2["UnspecifiedExecutionType"] = 0] = "UnspecifiedExecutionType";
  ExecutionType2[ExecutionType2["Market"] = 1] = "Market";
  ExecutionType2[ExecutionType2["LimitFill"] = 2] = "LimitFill";
  ExecutionType2[ExecutionType2["LimitMatchRestingOrder"] = 3] = "LimitMatchRestingOrder";
  ExecutionType2[ExecutionType2["LimitMatchNewOrder"] = 4] = "LimitMatchNewOrder";
  ExecutionType2[ExecutionType2["MarketLiquidation"] = 5] = "MarketLiquidation";
  ExecutionType2[ExecutionType2["ExpiryMarketSettlement"] = 6] = "ExpiryMarketSettlement";
  return ExecutionType2;
})(ExecutionType || {});
var OrderMask = /* @__PURE__ */ ((OrderMask2) => {
  OrderMask2[OrderMask2["UNUSED"] = 0] = "UNUSED";
  OrderMask2[OrderMask2["ANY"] = 1] = "ANY";
  OrderMask2[OrderMask2["REGULAR"] = 2] = "REGULAR";
  OrderMask2[OrderMask2["CONDITIONAL"] = 4] = "CONDITIONAL";
  OrderMask2[OrderMask2["DIRECTION_BUY_OR_HIGHER"] = 8] = "DIRECTION_BUY_OR_HIGHER";
  OrderMask2[OrderMask2["DIRECTION_SELL_OR_LOWER"] = 16] = "DIRECTION_SELL_OR_LOWER";
  OrderMask2[OrderMask2["TYPE_MARKET"] = 32] = "TYPE_MARKET";
  OrderMask2[OrderMask2["TYPE_LIMIT"] = 64] = "TYPE_LIMIT";
  return OrderMask2;
})(OrderMask || {});
class OpenNotionalCap$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.OpenNotionalCap", [
      { no: 1, name: "uncapped", kind: "message", oneof: "cap", T: () => OpenNotionalCapUncapped, options: { "amino.oneof_name": "injective.exchange.v1beta1.OpenNotionalCapUncapped" } },
      { no: 2, name: "capped", kind: "message", oneof: "cap", T: () => OpenNotionalCapCapped, options: { "amino.oneof_name": "injective.exchange.v1beta1.OpenNotionalCapCapped" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cap = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v1beta1.OpenNotionalCapUncapped uncapped */
        1:
          message.cap = {
            oneofKind: "uncapped",
            uncapped: OpenNotionalCapUncapped.internalBinaryRead(reader, reader.uint32(), options, message.cap.uncapped)
          };
          break;
        case /* injective.exchange.v1beta1.OpenNotionalCapCapped capped */
        2:
          message.cap = {
            oneofKind: "capped",
            capped: OpenNotionalCapCapped.internalBinaryRead(reader, reader.uint32(), options, message.cap.capped)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cap.oneofKind === "uncapped")
      OpenNotionalCapUncapped.internalBinaryWrite(message.cap.uncapped, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.cap.oneofKind === "capped")
      OpenNotionalCapCapped.internalBinaryWrite(message.cap.capped, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenNotionalCap = new OpenNotionalCap$Type();
class OpenNotionalCapUncapped$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.OpenNotionalCapUncapped", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenNotionalCapUncapped = new OpenNotionalCapUncapped$Type();
class OpenNotionalCapCapped$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.OpenNotionalCapCapped", [
      { no: 1, name: "value", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenNotionalCapCapped = new OpenNotionalCapCapped$Type();
class Params$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.Params", [
      { no: 1, name: "spot_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
      { no: 2, name: "derivative_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
      { no: 3, name: "default_spot_maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "default_spot_taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "default_derivative_maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "default_derivative_taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "default_initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "default_maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 9,
        name: "default_funding_interval",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "funding_multiple",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 11, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "default_hourly_funding_rate_cap", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "default_hourly_interest_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 14,
        name: "max_derivative_order_side_count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 15, name: "inj_reward_staked_requirement_threshold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 16,
        name: "trading_rewards_vesting_duration",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 17, name: "liquidator_reward_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 18, name: "binary_options_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
      { no: 19, name: "atomic_market_order_access_level", kind: "enum", T: () => ["injective.exchange.v1beta1.AtomicMarketOrderAccessLevel", AtomicMarketOrderAccessLevel] },
      { no: 20, name: "spot_atomic_market_order_fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 21, name: "derivative_atomic_market_order_fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 22, name: "binary_options_atomic_market_order_fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 23, name: "minimal_protocol_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 24,
        name: "is_instant_derivative_market_launch_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 25,
        name: "post_only_mode_height_threshold",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 26,
        name: "margin_decrease_price_timestamp_threshold_seconds",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 27,
        name: "exchange_admins",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 28, name: "inj_auction_max_cap", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 29,
        name: "fixed_gas_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ], { "gogoproto.equal": true, "amino.name": "exchange/Params" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.defaultSpotMakerFeeRate = "";
    message.defaultSpotTakerFeeRate = "";
    message.defaultDerivativeMakerFeeRate = "";
    message.defaultDerivativeTakerFeeRate = "";
    message.defaultInitialMarginRatio = "";
    message.defaultMaintenanceMarginRatio = "";
    message.defaultFundingInterval = 0n;
    message.fundingMultiple = 0n;
    message.relayerFeeShareRate = "";
    message.defaultHourlyFundingRateCap = "";
    message.defaultHourlyInterestRate = "";
    message.maxDerivativeOrderSideCount = 0;
    message.injRewardStakedRequirementThreshold = "";
    message.tradingRewardsVestingDuration = 0n;
    message.liquidatorRewardShareRate = "";
    message.atomicMarketOrderAccessLevel = 0;
    message.spotAtomicMarketOrderFeeMultiplier = "";
    message.derivativeAtomicMarketOrderFeeMultiplier = "";
    message.binaryOptionsAtomicMarketOrderFeeMultiplier = "";
    message.minimalProtocolFeeRate = "";
    message.isInstantDerivativeMarketLaunchEnabled = false;
    message.postOnlyModeHeightThreshold = 0n;
    message.marginDecreasePriceTimestampThresholdSeconds = 0n;
    message.exchangeAdmins = [];
    message.injAuctionMaxCap = "";
    message.fixedGasEnabled = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.Coin spot_market_instant_listing_fee */
        1:
          message.spotMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.spotMarketInstantListingFee);
          break;
        case /* cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee */
        2:
          message.derivativeMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.derivativeMarketInstantListingFee);
          break;
        case /* string default_spot_maker_fee_rate */
        3:
          message.defaultSpotMakerFeeRate = reader.string();
          break;
        case /* string default_spot_taker_fee_rate */
        4:
          message.defaultSpotTakerFeeRate = reader.string();
          break;
        case /* string default_derivative_maker_fee_rate */
        5:
          message.defaultDerivativeMakerFeeRate = reader.string();
          break;
        case /* string default_derivative_taker_fee_rate */
        6:
          message.defaultDerivativeTakerFeeRate = reader.string();
          break;
        case /* string default_initial_margin_ratio */
        7:
          message.defaultInitialMarginRatio = reader.string();
          break;
        case /* string default_maintenance_margin_ratio */
        8:
          message.defaultMaintenanceMarginRatio = reader.string();
          break;
        case /* int64 default_funding_interval */
        9:
          message.defaultFundingInterval = reader.int64().toBigInt();
          break;
        case /* int64 funding_multiple */
        10:
          message.fundingMultiple = reader.int64().toBigInt();
          break;
        case /* string relayer_fee_share_rate */
        11:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* string default_hourly_funding_rate_cap */
        12:
          message.defaultHourlyFundingRateCap = reader.string();
          break;
        case /* string default_hourly_interest_rate */
        13:
          message.defaultHourlyInterestRate = reader.string();
          break;
        case /* uint32 max_derivative_order_side_count */
        14:
          message.maxDerivativeOrderSideCount = reader.uint32();
          break;
        case /* string inj_reward_staked_requirement_threshold */
        15:
          message.injRewardStakedRequirementThreshold = reader.string();
          break;
        case /* int64 trading_rewards_vesting_duration */
        16:
          message.tradingRewardsVestingDuration = reader.int64().toBigInt();
          break;
        case /* string liquidator_reward_share_rate */
        17:
          message.liquidatorRewardShareRate = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee */
        18:
          message.binaryOptionsMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.binaryOptionsMarketInstantListingFee);
          break;
        case /* injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level */
        19:
          message.atomicMarketOrderAccessLevel = reader.int32();
          break;
        case /* string spot_atomic_market_order_fee_multiplier */
        20:
          message.spotAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case /* string derivative_atomic_market_order_fee_multiplier */
        21:
          message.derivativeAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case /* string binary_options_atomic_market_order_fee_multiplier */
        22:
          message.binaryOptionsAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case /* string minimal_protocol_fee_rate */
        23:
          message.minimalProtocolFeeRate = reader.string();
          break;
        case /* bool is_instant_derivative_market_launch_enabled */
        24:
          message.isInstantDerivativeMarketLaunchEnabled = reader.bool();
          break;
        case /* int64 post_only_mode_height_threshold */
        25:
          message.postOnlyModeHeightThreshold = reader.int64().toBigInt();
          break;
        case /* int64 margin_decrease_price_timestamp_threshold_seconds */
        26:
          message.marginDecreasePriceTimestampThresholdSeconds = reader.int64().toBigInt();
          break;
        case /* repeated string exchange_admins */
        27:
          message.exchangeAdmins.push(reader.string());
          break;
        case /* string inj_auction_max_cap */
        28:
          message.injAuctionMaxCap = reader.string();
          break;
        case /* bool fixed_gas_enabled */
        29:
          message.fixedGasEnabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.spotMarketInstantListingFee)
      Coin.internalBinaryWrite(message.spotMarketInstantListingFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.derivativeMarketInstantListingFee)
      Coin.internalBinaryWrite(message.derivativeMarketInstantListingFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.defaultSpotMakerFeeRate !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.defaultSpotMakerFeeRate);
    if (message.defaultSpotTakerFeeRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.defaultSpotTakerFeeRate);
    if (message.defaultDerivativeMakerFeeRate !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.defaultDerivativeMakerFeeRate);
    if (message.defaultDerivativeTakerFeeRate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.defaultDerivativeTakerFeeRate);
    if (message.defaultInitialMarginRatio !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.defaultInitialMarginRatio);
    if (message.defaultMaintenanceMarginRatio !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.defaultMaintenanceMarginRatio);
    if (message.defaultFundingInterval !== 0n)
      writer.tag(9, WireType.Varint).int64(message.defaultFundingInterval);
    if (message.fundingMultiple !== 0n)
      writer.tag(10, WireType.Varint).int64(message.fundingMultiple);
    if (message.relayerFeeShareRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.defaultHourlyFundingRateCap !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.defaultHourlyFundingRateCap);
    if (message.defaultHourlyInterestRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.defaultHourlyInterestRate);
    if (message.maxDerivativeOrderSideCount !== 0)
      writer.tag(14, WireType.Varint).uint32(message.maxDerivativeOrderSideCount);
    if (message.injRewardStakedRequirementThreshold !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.injRewardStakedRequirementThreshold);
    if (message.tradingRewardsVestingDuration !== 0n)
      writer.tag(16, WireType.Varint).int64(message.tradingRewardsVestingDuration);
    if (message.liquidatorRewardShareRate !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.liquidatorRewardShareRate);
    if (message.binaryOptionsMarketInstantListingFee)
      Coin.internalBinaryWrite(message.binaryOptionsMarketInstantListingFee, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.atomicMarketOrderAccessLevel !== 0)
      writer.tag(19, WireType.Varint).int32(message.atomicMarketOrderAccessLevel);
    if (message.spotAtomicMarketOrderFeeMultiplier !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.spotAtomicMarketOrderFeeMultiplier);
    if (message.derivativeAtomicMarketOrderFeeMultiplier !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.derivativeAtomicMarketOrderFeeMultiplier);
    if (message.binaryOptionsAtomicMarketOrderFeeMultiplier !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.binaryOptionsAtomicMarketOrderFeeMultiplier);
    if (message.minimalProtocolFeeRate !== "")
      writer.tag(23, WireType.LengthDelimited).string(message.minimalProtocolFeeRate);
    if (message.isInstantDerivativeMarketLaunchEnabled !== false)
      writer.tag(24, WireType.Varint).bool(message.isInstantDerivativeMarketLaunchEnabled);
    if (message.postOnlyModeHeightThreshold !== 0n)
      writer.tag(25, WireType.Varint).int64(message.postOnlyModeHeightThreshold);
    if (message.marginDecreasePriceTimestampThresholdSeconds !== 0n)
      writer.tag(26, WireType.Varint).int64(message.marginDecreasePriceTimestampThresholdSeconds);
    for (let i = 0; i < message.exchangeAdmins.length; i++)
      writer.tag(27, WireType.LengthDelimited).string(message.exchangeAdmins[i]);
    if (message.injAuctionMaxCap !== "")
      writer.tag(28, WireType.LengthDelimited).string(message.injAuctionMaxCap);
    if (message.fixedGasEnabled !== false)
      writer.tag(29, WireType.Varint).bool(message.fixedGasEnabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Params = new Params$Type();
class MarketFeeMultiplier$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MarketFeeMultiplier", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "fee_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.feeMultiplier = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string fee_multiplier */
        2:
          message.feeMultiplier = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.feeMultiplier !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.feeMultiplier);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketFeeMultiplier = new MarketFeeMultiplier$Type();
class DerivativeMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DerivativeMarket", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "oracle_base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "oracle_quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 5,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 13,
        name: "isPerpetual",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] },
      { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 17, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 18,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 19,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 20,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 21, name: "reduce_margin_ratio", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 22, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.oracleBase = "";
    message.oracleQuote = "";
    message.oracleType = 0;
    message.oracleScaleFactor = 0;
    message.quoteDenom = "";
    message.marketId = "";
    message.initialMarginRatio = "";
    message.maintenanceMarginRatio = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.isPerpetual = false;
    message.status = 0;
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.admin = "";
    message.adminPermissions = 0;
    message.quoteDecimals = 0;
    message.reduceMarginRatio = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string oracle_base */
        2:
          message.oracleBase = reader.string();
          break;
        case /* string oracle_quote */
        3:
          message.oracleQuote = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        4:
          message.oracleType = reader.int32();
          break;
        case /* uint32 oracle_scale_factor */
        5:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* string quote_denom */
        6:
          message.quoteDenom = reader.string();
          break;
        case /* string market_id */
        7:
          message.marketId = reader.string();
          break;
        case /* string initial_margin_ratio */
        8:
          message.initialMarginRatio = reader.string();
          break;
        case /* string maintenance_margin_ratio */
        9:
          message.maintenanceMarginRatio = reader.string();
          break;
        case /* string maker_fee_rate */
        10:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        11:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        12:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* bool isPerpetual */
        13:
          message.isPerpetual = reader.bool();
          break;
        case /* injective.exchange.v1beta1.MarketStatus status */
        14:
          message.status = reader.int32();
          break;
        case /* string min_price_tick_size */
        15:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        16:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        17:
          message.minNotional = reader.string();
          break;
        case /* string admin */
        18:
          message.admin = reader.string();
          break;
        case /* uint32 admin_permissions */
        19:
          message.adminPermissions = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        20:
          message.quoteDecimals = reader.uint32();
          break;
        case /* string reduce_margin_ratio */
        21:
          message.reduceMarginRatio = reader.string();
          break;
        case /* injective.exchange.v1beta1.OpenNotionalCap open_notional_cap */
        22:
          message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleBase !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.oracleBase);
    if (message.oracleQuote !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.oracleQuote);
    if (message.oracleType !== 0)
      writer.tag(4, WireType.Varint).int32(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.quoteDenom !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.marketId !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.marketId);
    if (message.initialMarginRatio !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.initialMarginRatio);
    if (message.maintenanceMarginRatio !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
    if (message.makerFeeRate !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.isPerpetual !== false)
      writer.tag(13, WireType.Varint).bool(message.isPerpetual);
    if (message.status !== 0)
      writer.tag(14, WireType.Varint).int32(message.status);
    if (message.minPriceTickSize !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.minNotional);
    if (message.admin !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.admin);
    if (message.adminPermissions !== 0)
      writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
    if (message.quoteDecimals !== 0)
      writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
    if (message.reduceMarginRatio !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.reduceMarginRatio);
    if (message.openNotionalCap)
      OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarket = new DerivativeMarket$Type();
class BinaryOptionsMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.BinaryOptionsMarket", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "oracle_symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "oracle_provider",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 5,
        name: "oracle_scale_factor",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "settlement_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 13, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] },
      { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 17, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 18, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 19,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 20,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ], { "gogoproto.goproto_getters": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.oracleSymbol = "";
    message.oracleProvider = "";
    message.oracleType = 0;
    message.oracleScaleFactor = 0;
    message.expirationTimestamp = 0n;
    message.settlementTimestamp = 0n;
    message.admin = "";
    message.quoteDenom = "";
    message.marketId = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.status = 0;
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.settlementPrice = "";
    message.minNotional = "";
    message.adminPermissions = 0;
    message.quoteDecimals = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string oracle_symbol */
        2:
          message.oracleSymbol = reader.string();
          break;
        case /* string oracle_provider */
        3:
          message.oracleProvider = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        4:
          message.oracleType = reader.int32();
          break;
        case /* uint32 oracle_scale_factor */
        5:
          message.oracleScaleFactor = reader.uint32();
          break;
        case /* int64 expiration_timestamp */
        6:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 settlement_timestamp */
        7:
          message.settlementTimestamp = reader.int64().toBigInt();
          break;
        case /* string admin */
        8:
          message.admin = reader.string();
          break;
        case /* string quote_denom */
        9:
          message.quoteDenom = reader.string();
          break;
        case /* string market_id */
        10:
          message.marketId = reader.string();
          break;
        case /* string maker_fee_rate */
        11:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        12:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        13:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* injective.exchange.v1beta1.MarketStatus status */
        14:
          message.status = reader.int32();
          break;
        case /* string min_price_tick_size */
        15:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        16:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string settlement_price */
        17:
          message.settlementPrice = reader.string();
          break;
        case /* string min_notional */
        18:
          message.minNotional = reader.string();
          break;
        case /* uint32 admin_permissions */
        19:
          message.adminPermissions = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        20:
          message.quoteDecimals = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.oracleSymbol !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.oracleSymbol);
    if (message.oracleProvider !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.oracleProvider);
    if (message.oracleType !== 0)
      writer.tag(4, WireType.Varint).int32(message.oracleType);
    if (message.oracleScaleFactor !== 0)
      writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
    if (message.expirationTimestamp !== 0n)
      writer.tag(6, WireType.Varint).int64(message.expirationTimestamp);
    if (message.settlementTimestamp !== 0n)
      writer.tag(7, WireType.Varint).int64(message.settlementTimestamp);
    if (message.admin !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.admin);
    if (message.quoteDenom !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.marketId !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.marketId);
    if (message.makerFeeRate !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.status !== 0)
      writer.tag(14, WireType.Varint).int32(message.status);
    if (message.minPriceTickSize !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.settlementPrice !== "")
      writer.tag(17, WireType.LengthDelimited).string(message.settlementPrice);
    if (message.minNotional !== "")
      writer.tag(18, WireType.LengthDelimited).string(message.minNotional);
    if (message.adminPermissions !== 0)
      writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
    if (message.quoteDecimals !== 0)
      writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BinaryOptionsMarket = new BinaryOptionsMarket$Type();
class ExpiryFuturesMarketInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.ExpiryFuturesMarketInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "expiration_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "twap_start_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "expiration_twap_start_price_cumulative", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.expirationTimestamp = 0n;
    message.twapStartTimestamp = 0n;
    message.expirationTwapStartPriceCumulative = "";
    message.settlementPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* int64 expiration_timestamp */
        2:
          message.expirationTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 twap_start_timestamp */
        3:
          message.twapStartTimestamp = reader.int64().toBigInt();
          break;
        case /* string expiration_twap_start_price_cumulative */
        4:
          message.expirationTwapStartPriceCumulative = reader.string();
          break;
        case /* string settlement_price */
        5:
          message.settlementPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.expirationTimestamp !== 0n)
      writer.tag(2, WireType.Varint).int64(message.expirationTimestamp);
    if (message.twapStartTimestamp !== 0n)
      writer.tag(3, WireType.Varint).int64(message.twapStartTimestamp);
    if (message.expirationTwapStartPriceCumulative !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.expirationTwapStartPriceCumulative);
    if (message.settlementPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.settlementPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExpiryFuturesMarketInfo = new ExpiryFuturesMarketInfo$Type();
class PerpetualMarketInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.PerpetualMarketInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "hourly_funding_rate_cap", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "hourly_interest_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 4,
        name: "next_funding_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "funding_interval",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.hourlyFundingRateCap = "";
    message.hourlyInterestRate = "";
    message.nextFundingTimestamp = 0n;
    message.fundingInterval = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string hourly_funding_rate_cap */
        2:
          message.hourlyFundingRateCap = reader.string();
          break;
        case /* string hourly_interest_rate */
        3:
          message.hourlyInterestRate = reader.string();
          break;
        case /* int64 next_funding_timestamp */
        4:
          message.nextFundingTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 funding_interval */
        5:
          message.fundingInterval = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.hourlyFundingRateCap !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
    if (message.hourlyInterestRate !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.hourlyInterestRate);
    if (message.nextFundingTimestamp !== 0n)
      writer.tag(4, WireType.Varint).int64(message.nextFundingTimestamp);
    if (message.fundingInterval !== 0n)
      writer.tag(5, WireType.Varint).int64(message.fundingInterval);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketInfo = new PerpetualMarketInfo$Type();
class PerpetualMarketFunding$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.PerpetualMarketFunding", [
      { no: 1, name: "cumulative_funding", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "cumulative_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "last_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cumulativeFunding = "";
    message.cumulativePrice = "";
    message.lastTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cumulative_funding */
        1:
          message.cumulativeFunding = reader.string();
          break;
        case /* string cumulative_price */
        2:
          message.cumulativePrice = reader.string();
          break;
        case /* int64 last_timestamp */
        3:
          message.lastTimestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cumulativeFunding !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cumulativeFunding);
    if (message.cumulativePrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
    if (message.lastTimestamp !== 0n)
      writer.tag(3, WireType.Varint).int64(message.lastTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PerpetualMarketFunding = new PerpetualMarketFunding$Type();
class DerivativeMarketSettlementInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DerivativeMarketSettlementInfo", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "settlement_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.settlementPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string settlement_price */
        2:
          message.settlementPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.settlementPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.settlementPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketSettlementInfo = new DerivativeMarketSettlementInfo$Type();
class NextFundingTimestamp$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.NextFundingTimestamp", [
      {
        no: 1,
        name: "next_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.nextTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 next_timestamp */
        1:
          message.nextTimestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.nextTimestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.nextTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const NextFundingTimestamp = new NextFundingTimestamp$Type();
class MidPriceAndTOB$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MidPriceAndTOB", [
      { no: 1, name: "mid_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "best_buy_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "best_sell_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.midPrice = "";
    message.bestBuyPrice = "";
    message.bestSellPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string mid_price */
        1:
          message.midPrice = reader.string();
          break;
        case /* string best_buy_price */
        2:
          message.bestBuyPrice = reader.string();
          break;
        case /* string best_sell_price */
        3:
          message.bestSellPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.midPrice !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
    if (message.bestBuyPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
    if (message.bestSellPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MidPriceAndTOB = new MidPriceAndTOB$Type();
class SpotMarket$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SpotMarket", [
      {
        no: 1,
        name: "ticker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "base_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 7,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] },
      { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 11, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 12,
        name: "admin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "admin_permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 14,
        name: "base_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 15,
        name: "quote_decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ticker = "";
    message.baseDenom = "";
    message.quoteDenom = "";
    message.makerFeeRate = "";
    message.takerFeeRate = "";
    message.relayerFeeShareRate = "";
    message.marketId = "";
    message.status = 0;
    message.minPriceTickSize = "";
    message.minQuantityTickSize = "";
    message.minNotional = "";
    message.admin = "";
    message.adminPermissions = 0;
    message.baseDecimals = 0;
    message.quoteDecimals = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ticker */
        1:
          message.ticker = reader.string();
          break;
        case /* string base_denom */
        2:
          message.baseDenom = reader.string();
          break;
        case /* string quote_denom */
        3:
          message.quoteDenom = reader.string();
          break;
        case /* string maker_fee_rate */
        4:
          message.makerFeeRate = reader.string();
          break;
        case /* string taker_fee_rate */
        5:
          message.takerFeeRate = reader.string();
          break;
        case /* string relayer_fee_share_rate */
        6:
          message.relayerFeeShareRate = reader.string();
          break;
        case /* string market_id */
        7:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v1beta1.MarketStatus status */
        8:
          message.status = reader.int32();
          break;
        case /* string min_price_tick_size */
        9:
          message.minPriceTickSize = reader.string();
          break;
        case /* string min_quantity_tick_size */
        10:
          message.minQuantityTickSize = reader.string();
          break;
        case /* string min_notional */
        11:
          message.minNotional = reader.string();
          break;
        case /* string admin */
        12:
          message.admin = reader.string();
          break;
        case /* uint32 admin_permissions */
        13:
          message.adminPermissions = reader.uint32();
          break;
        case /* uint32 base_decimals */
        14:
          message.baseDecimals = reader.uint32();
          break;
        case /* uint32 quote_decimals */
        15:
          message.quoteDecimals = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ticker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ticker);
    if (message.baseDenom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.baseDenom);
    if (message.quoteDenom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.makerFeeRate !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
    if (message.takerFeeRate !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
    if (message.relayerFeeShareRate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
    if (message.marketId !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.marketId);
    if (message.status !== 0)
      writer.tag(8, WireType.Varint).int32(message.status);
    if (message.minPriceTickSize !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.minPriceTickSize);
    if (message.minQuantityTickSize !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.minQuantityTickSize);
    if (message.minNotional !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.minNotional);
    if (message.admin !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.admin);
    if (message.adminPermissions !== 0)
      writer.tag(13, WireType.Varint).uint32(message.adminPermissions);
    if (message.baseDecimals !== 0)
      writer.tag(14, WireType.Varint).uint32(message.baseDecimals);
    if (message.quoteDecimals !== 0)
      writer.tag(15, WireType.Varint).uint32(message.quoteDecimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarket = new SpotMarket$Type();
class Deposit$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.Deposit", [
      { no: 1, name: "available_balance", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "total_balance", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.availableBalance = "";
    message.totalBalance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string available_balance */
        1:
          message.availableBalance = reader.string();
          break;
        case /* string total_balance */
        2:
          message.totalBalance = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.availableBalance !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.availableBalance);
    if (message.totalBalance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.totalBalance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Deposit = new Deposit$Type();
class SubaccountTradeNonce$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SubaccountTradeNonce", [
      {
        no: 1,
        name: "nonce",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.nonce = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 nonce */
        1:
          message.nonce = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.nonce !== 0)
      writer.tag(1, WireType.Varint).uint32(message.nonce);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountTradeNonce = new SubaccountTradeNonce$Type();
class OrderInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.OrderInfo", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "fee_recipient",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.feeRecipient = "";
    message.price = "";
    message.quantity = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* string fee_recipient */
        2:
          message.feeRecipient = reader.string();
          break;
        case /* string price */
        3:
          message.price = reader.string();
          break;
        case /* string quantity */
        4:
          message.quantity = reader.string();
          break;
        case /* string cid */
        5:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    if (message.feeRecipient !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.feeRecipient);
    if (message.price !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quantity);
    if (message.cid !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderInfo = new OrderInfo$Type();
class SpotOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SpotOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
      { no: 4, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderType = 0;
    message.triggerPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v1beta1.OrderInfo order_info */
        2:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v1beta1.OrderType order_type */
        3:
          message.orderType = reader.int32();
          break;
        case /* string trigger_price */
        4:
          message.triggerPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(3, WireType.Varint).int32(message.orderType);
    if (message.triggerPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotOrder = new SpotOrder$Type();
class SpotLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SpotLimitOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
      { no: 3, name: "fillable", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderType = 0;
    message.fillable = "";
    message.triggerPrice = "";
    message.orderHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v1beta1.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v1beta1.OrderType order_type */
        2:
          message.orderType = reader.int32();
          break;
        case /* string fillable */
        3:
          message.fillable = reader.string();
          break;
        case /* string trigger_price */
        4:
          message.triggerPrice = reader.string();
          break;
        case /* bytes order_hash */
        5:
          message.orderHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(2, WireType.Varint).int32(message.orderType);
    if (message.fillable !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.fillable);
    if (message.triggerPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.orderHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotLimitOrder = new SpotLimitOrder$Type();
class SpotMarketOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SpotMarketOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "balance_hold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balanceHold = "";
    message.orderHash = new Uint8Array(0);
    message.orderType = 0;
    message.triggerPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v1beta1.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* string balance_hold */
        2:
          message.balanceHold = reader.string();
          break;
        case /* bytes order_hash */
        3:
          message.orderHash = reader.bytes();
          break;
        case /* injective.exchange.v1beta1.OrderType order_type */
        4:
          message.orderType = reader.int32();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.balanceHold !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.balanceHold);
    if (message.orderHash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.orderType !== 0)
      writer.tag(4, WireType.Varint).int32(message.orderType);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotMarketOrder = new SpotMarketOrder$Type();
class DerivativeOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DerivativeOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
      { no: 4, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.orderType = 0;
    message.margin = "";
    message.triggerPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v1beta1.OrderInfo order_info */
        2:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v1beta1.OrderType order_type */
        3:
          message.orderType = reader.int32();
          break;
        case /* string margin */
        4:
          message.margin = reader.string();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(3, WireType.Varint).int32(message.orderType);
    if (message.margin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.margin);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeOrder = new DerivativeOrder$Type();
class SubaccountOrderbookMetadata$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SubaccountOrderbookMetadata", [
      {
        no: 1,
        name: "vanilla_limit_order_count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "reduce_only_limit_order_count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "aggregate_reduce_only_quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "aggregate_vanilla_quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "vanilla_conditional_order_count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "reduce_only_conditional_order_count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vanillaLimitOrderCount = 0;
    message.reduceOnlyLimitOrderCount = 0;
    message.aggregateReduceOnlyQuantity = "";
    message.aggregateVanillaQuantity = "";
    message.vanillaConditionalOrderCount = 0;
    message.reduceOnlyConditionalOrderCount = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 vanilla_limit_order_count */
        1:
          message.vanillaLimitOrderCount = reader.uint32();
          break;
        case /* uint32 reduce_only_limit_order_count */
        2:
          message.reduceOnlyLimitOrderCount = reader.uint32();
          break;
        case /* string aggregate_reduce_only_quantity */
        3:
          message.aggregateReduceOnlyQuantity = reader.string();
          break;
        case /* string aggregate_vanilla_quantity */
        4:
          message.aggregateVanillaQuantity = reader.string();
          break;
        case /* uint32 vanilla_conditional_order_count */
        5:
          message.vanillaConditionalOrderCount = reader.uint32();
          break;
        case /* uint32 reduce_only_conditional_order_count */
        6:
          message.reduceOnlyConditionalOrderCount = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vanillaLimitOrderCount !== 0)
      writer.tag(1, WireType.Varint).uint32(message.vanillaLimitOrderCount);
    if (message.reduceOnlyLimitOrderCount !== 0)
      writer.tag(2, WireType.Varint).uint32(message.reduceOnlyLimitOrderCount);
    if (message.aggregateReduceOnlyQuantity !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.aggregateReduceOnlyQuantity);
    if (message.aggregateVanillaQuantity !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.aggregateVanillaQuantity);
    if (message.vanillaConditionalOrderCount !== 0)
      writer.tag(5, WireType.Varint).uint32(message.vanillaConditionalOrderCount);
    if (message.reduceOnlyConditionalOrderCount !== 0)
      writer.tag(6, WireType.Varint).uint32(message.reduceOnlyConditionalOrderCount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrderbookMetadata = new SubaccountOrderbookMetadata$Type();
class SubaccountOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SubaccountOrder", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "isReduceOnly",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.quantity = "";
    message.isReduceOnly = false;
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* bool isReduceOnly */
        3:
          message.isReduceOnly = reader.bool();
          break;
        case /* string cid */
        4:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.isReduceOnly !== false)
      writer.tag(3, WireType.Varint).bool(message.isReduceOnly);
    if (message.cid !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrder = new SubaccountOrder$Type();
class SubaccountOrderData$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SubaccountOrderData", [
      { no: 1, name: "order", kind: "message", T: () => SubaccountOrder },
      {
        no: 2,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v1beta1.SubaccountOrder order */
        1:
          message.order = SubaccountOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* bytes order_hash */
        2:
          message.orderHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.order)
      SubaccountOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderHash.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.orderHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountOrderData = new SubaccountOrderData$Type();
class DerivativeLimitOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DerivativeLimitOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
      { no: 3, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "fillable", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 6,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderType = 0;
    message.margin = "";
    message.fillable = "";
    message.triggerPrice = "";
    message.orderHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v1beta1.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v1beta1.OrderType order_type */
        2:
          message.orderType = reader.int32();
          break;
        case /* string margin */
        3:
          message.margin = reader.string();
          break;
        case /* string fillable */
        4:
          message.fillable = reader.string();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        case /* bytes order_hash */
        6:
          message.orderHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(2, WireType.Varint).int32(message.orderType);
    if (message.margin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.margin);
    if (message.fillable !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fillable);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.orderHash.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.orderHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
class DerivativeMarketOrder$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DerivativeMarketOrder", [
      { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
      { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
      { no: 3, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "margin_hold", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "trigger_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 6,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.orderType = 0;
    message.margin = "";
    message.marginHold = "";
    message.triggerPrice = "";
    message.orderHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v1beta1.OrderInfo order_info */
        1:
          message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
          break;
        case /* injective.exchange.v1beta1.OrderType order_type */
        2:
          message.orderType = reader.int32();
          break;
        case /* string margin */
        3:
          message.margin = reader.string();
          break;
        case /* string margin_hold */
        4:
          message.marginHold = reader.string();
          break;
        case /* string trigger_price */
        5:
          message.triggerPrice = reader.string();
          break;
        case /* bytes order_hash */
        6:
          message.orderHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.orderInfo)
      OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.orderType !== 0)
      writer.tag(2, WireType.Varint).int32(message.orderType);
    if (message.margin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.margin);
    if (message.marginHold !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marginHold);
    if (message.triggerPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
    if (message.orderHash.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.orderHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeMarketOrder = new DerivativeMarketOrder$Type();
class Position$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.Position", [
      {
        no: 1,
        name: "isLong",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "entry_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "cumulative_funding_entry", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.isLong = false;
    message.quantity = "";
    message.entryPrice = "";
    message.margin = "";
    message.cumulativeFundingEntry = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool isLong */
        1:
          message.isLong = reader.bool();
          break;
        case /* string quantity */
        2:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        3:
          message.entryPrice = reader.string();
          break;
        case /* string margin */
        4:
          message.margin = reader.string();
          break;
        case /* string cumulative_funding_entry */
        5:
          message.cumulativeFundingEntry = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.isLong !== false)
      writer.tag(1, WireType.Varint).bool(message.isLong);
    if (message.quantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.entryPrice);
    if (message.margin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.margin);
    if (message.cumulativeFundingEntry !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Position = new Position$Type();
class MarketOrderIndicator$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MarketOrderIndicator", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "isBuy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isBuy = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool isBuy */
        2:
          message.isBuy = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isBuy !== false)
      writer.tag(2, WireType.Varint).bool(message.isBuy);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketOrderIndicator = new MarketOrderIndicator$Type();
class TradeLog$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.TradeLog", [
      { no: 1, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12, options: { "gogoproto.nullable": true } },
      {
        no: 7,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.quantity = "";
    message.price = "";
    message.subaccountId = new Uint8Array(0);
    message.fee = "";
    message.orderHash = new Uint8Array(0);
    message.feeRecipientAddress = new Uint8Array(0);
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string quantity */
        1:
          message.quantity = reader.string();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        case /* bytes subaccount_id */
        3:
          message.subaccountId = reader.bytes();
          break;
        case /* string fee */
        4:
          message.fee = reader.string();
          break;
        case /* bytes order_hash */
        5:
          message.orderHash = reader.bytes();
          break;
        case /* bytes fee_recipient_address */
        6:
          message.feeRecipientAddress = reader.bytes();
          break;
        case /* string cid */
        7:
          message.cid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.quantity !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.quantity);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    if (message.subaccountId.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.fee !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fee);
    if (message.orderHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.feeRecipientAddress.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
    if (message.cid !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeLog = new TradeLog$Type();
class PositionDelta$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.PositionDelta", [
      {
        no: 1,
        name: "is_long",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "execution_quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "execution_margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "execution_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.isLong = false;
    message.executionQuantity = "";
    message.executionMargin = "";
    message.executionPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool is_long */
        1:
          message.isLong = reader.bool();
          break;
        case /* string execution_quantity */
        2:
          message.executionQuantity = reader.string();
          break;
        case /* string execution_margin */
        3:
          message.executionMargin = reader.string();
          break;
        case /* string execution_price */
        4:
          message.executionPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.isLong !== false)
      writer.tag(1, WireType.Varint).bool(message.isLong);
    if (message.executionQuantity !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.executionQuantity);
    if (message.executionMargin !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionMargin);
    if (message.executionPrice !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.executionPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionDelta = new PositionDelta$Type();
class DerivativeTradeLog$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DerivativeTradeLog", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "position_delta", kind: "message", T: () => PositionDelta },
      { no: 3, name: "payout", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "order_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12, options: { "gogoproto.nullable": true } },
      {
        no: 7,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "pnl", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = new Uint8Array(0);
    message.payout = "";
    message.fee = "";
    message.orderHash = new Uint8Array(0);
    message.feeRecipientAddress = new Uint8Array(0);
    message.cid = "";
    message.pnl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes subaccount_id */
        1:
          message.subaccountId = reader.bytes();
          break;
        case /* injective.exchange.v1beta1.PositionDelta position_delta */
        2:
          message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
          break;
        case /* string payout */
        3:
          message.payout = reader.string();
          break;
        case /* string fee */
        4:
          message.fee = reader.string();
          break;
        case /* bytes order_hash */
        5:
          message.orderHash = reader.bytes();
          break;
        case /* bytes fee_recipient_address */
        6:
          message.feeRecipientAddress = reader.bytes();
          break;
        case /* string cid */
        7:
          message.cid = reader.string();
          break;
        case /* string pnl */
        8:
          message.pnl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.positionDelta)
      PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.payout !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.payout);
    if (message.fee !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.fee);
    if (message.orderHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
    if (message.feeRecipientAddress.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
    if (message.cid !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.cid);
    if (message.pnl !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.pnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeTradeLog = new DerivativeTradeLog$Type();
class SubaccountPosition$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SubaccountPosition", [
      { no: 1, name: "position", kind: "message", T: () => Position },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.exchange.v1beta1.Position position */
        1:
          message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
          break;
        case /* bytes subaccount_id */
        2:
          message.subaccountId = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.position)
      Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.subaccountId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountPosition = new SubaccountPosition$Type();
class SubaccountDeposit$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SubaccountDeposit", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "deposit", kind: "message", T: () => Deposit }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes subaccount_id */
        1:
          message.subaccountId = reader.bytes();
          break;
        case /* injective.exchange.v1beta1.Deposit deposit */
        2:
          message.deposit = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
    if (message.deposit)
      Deposit.internalBinaryWrite(message.deposit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountDeposit = new SubaccountDeposit$Type();
class DepositUpdate$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DepositUpdate", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "deposits", kind: "message", repeat: 2, T: () => SubaccountDeposit }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.deposits = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.SubaccountDeposit deposits */
        2:
          message.deposits.push(SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    for (let i = 0; i < message.deposits.length; i++)
      SubaccountDeposit.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DepositUpdate = new DepositUpdate$Type();
class PointsMultiplier$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.PointsMultiplier", [
      { no: 1, name: "maker_points_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "taker_points_multiplier", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.makerPointsMultiplier = "";
    message.takerPointsMultiplier = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string maker_points_multiplier */
        1:
          message.makerPointsMultiplier = reader.string();
          break;
        case /* string taker_points_multiplier */
        2:
          message.takerPointsMultiplier = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.makerPointsMultiplier !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.makerPointsMultiplier);
    if (message.takerPointsMultiplier !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.takerPointsMultiplier);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PointsMultiplier = new PointsMultiplier$Type();
class TradingRewardCampaignBoostInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.TradingRewardCampaignBoostInfo", [
      {
        no: 1,
        name: "boosted_spot_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "spot_market_multipliers", kind: "message", repeat: 2, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "boosted_derivative_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "derivative_market_multipliers", kind: "message", repeat: 2, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.boostedSpotMarketIds = [];
    message.spotMarketMultipliers = [];
    message.boostedDerivativeMarketIds = [];
    message.derivativeMarketMultipliers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string boosted_spot_market_ids */
        1:
          message.boostedSpotMarketIds.push(reader.string());
          break;
        case /* repeated injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers */
        2:
          message.spotMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string boosted_derivative_market_ids */
        3:
          message.boostedDerivativeMarketIds.push(reader.string());
          break;
        case /* repeated injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers */
        4:
          message.derivativeMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.boostedSpotMarketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.boostedSpotMarketIds[i]);
    for (let i = 0; i < message.spotMarketMultipliers.length; i++)
      PointsMultiplier.internalBinaryWrite(message.spotMarketMultipliers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.boostedDerivativeMarketIds.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.boostedDerivativeMarketIds[i]);
    for (let i = 0; i < message.derivativeMarketMultipliers.length; i++)
      PointsMultiplier.internalBinaryWrite(message.derivativeMarketMultipliers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignBoostInfo = new TradingRewardCampaignBoostInfo$Type();
class CampaignRewardPool$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.CampaignRewardPool", [
      {
        no: 1,
        name: "start_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "max_campaign_rewards", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.startTimestamp = 0n;
    message.maxCampaignRewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 start_timestamp */
        1:
          message.startTimestamp = reader.int64().toBigInt();
          break;
        case /* repeated cosmos.base.v1beta1.Coin max_campaign_rewards */
        2:
          message.maxCampaignRewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.startTimestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.startTimestamp);
    for (let i = 0; i < message.maxCampaignRewards.length; i++)
      Coin.internalBinaryWrite(message.maxCampaignRewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CampaignRewardPool = new CampaignRewardPool$Type();
class TradingRewardCampaignInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.TradingRewardCampaignInfo", [
      {
        no: 1,
        name: "campaign_duration_seconds",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "quote_denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "trading_reward_boost_info", kind: "message", T: () => TradingRewardCampaignBoostInfo },
      {
        no: 4,
        name: "disqualified_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.campaignDurationSeconds = 0n;
    message.quoteDenoms = [];
    message.disqualifiedMarketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 campaign_duration_seconds */
        1:
          message.campaignDurationSeconds = reader.int64().toBigInt();
          break;
        case /* repeated string quote_denoms */
        2:
          message.quoteDenoms.push(reader.string());
          break;
        case /* injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info */
        3:
          message.tradingRewardBoostInfo = TradingRewardCampaignBoostInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardBoostInfo);
          break;
        case /* repeated string disqualified_market_ids */
        4:
          message.disqualifiedMarketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.campaignDurationSeconds !== 0n)
      writer.tag(1, WireType.Varint).int64(message.campaignDurationSeconds);
    for (let i = 0; i < message.quoteDenoms.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.quoteDenoms[i]);
    if (message.tradingRewardBoostInfo)
      TradingRewardCampaignBoostInfo.internalBinaryWrite(message.tradingRewardBoostInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradingRewardCampaignInfo = new TradingRewardCampaignInfo$Type();
class FeeDiscountTierInfo$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.FeeDiscountTierInfo", [
      { no: 1, name: "maker_discount_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "taker_discount_rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "staked_amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      { no: 4, name: "volume", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.makerDiscountRate = "";
    message.takerDiscountRate = "";
    message.stakedAmount = "";
    message.volume = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string maker_discount_rate */
        1:
          message.makerDiscountRate = reader.string();
          break;
        case /* string taker_discount_rate */
        2:
          message.takerDiscountRate = reader.string();
          break;
        case /* string staked_amount */
        3:
          message.stakedAmount = reader.string();
          break;
        case /* string volume */
        4:
          message.volume = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.makerDiscountRate !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.makerDiscountRate);
    if (message.takerDiscountRate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.takerDiscountRate);
    if (message.stakedAmount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.stakedAmount);
    if (message.volume !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.volume);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountTierInfo = new FeeDiscountTierInfo$Type();
class FeeDiscountSchedule$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.FeeDiscountSchedule", [
      {
        no: 1,
        name: "bucket_count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "bucket_duration",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "quote_denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "tier_infos", kind: "message", repeat: 2, T: () => FeeDiscountTierInfo },
      {
        no: 5,
        name: "disqualified_market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketCount = 0n;
    message.bucketDuration = 0n;
    message.quoteDenoms = [];
    message.tierInfos = [];
    message.disqualifiedMarketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucket_count */
        1:
          message.bucketCount = reader.uint64().toBigInt();
          break;
        case /* int64 bucket_duration */
        2:
          message.bucketDuration = reader.int64().toBigInt();
          break;
        case /* repeated string quote_denoms */
        3:
          message.quoteDenoms.push(reader.string());
          break;
        case /* repeated injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos */
        4:
          message.tierInfos.push(FeeDiscountTierInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated string disqualified_market_ids */
        5:
          message.disqualifiedMarketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bucketCount !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.bucketCount);
    if (message.bucketDuration !== 0n)
      writer.tag(2, WireType.Varint).int64(message.bucketDuration);
    for (let i = 0; i < message.quoteDenoms.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.quoteDenoms[i]);
    for (let i = 0; i < message.tierInfos.length; i++)
      FeeDiscountTierInfo.internalBinaryWrite(message.tierInfos[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountSchedule = new FeeDiscountSchedule$Type();
class FeeDiscountTierTTL$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.FeeDiscountTierTTL", [
      {
        no: 1,
        name: "tier",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "ttl_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tier = 0n;
    message.ttlTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 tier */
        1:
          message.tier = reader.uint64().toBigInt();
          break;
        case /* int64 ttl_timestamp */
        2:
          message.ttlTimestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tier !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.tier);
    if (message.ttlTimestamp !== 0n)
      writer.tag(2, WireType.Varint).int64(message.ttlTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeeDiscountTierTTL = new FeeDiscountTierTTL$Type();
class VolumeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.VolumeRecord", [
      { no: 1, name: "maker_volume", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "taker_volume", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.makerVolume = "";
    message.takerVolume = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string maker_volume */
        1:
          message.makerVolume = reader.string();
          break;
        case /* string taker_volume */
        2:
          message.takerVolume = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.makerVolume !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.makerVolume);
    if (message.takerVolume !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.takerVolume);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VolumeRecord = new VolumeRecord$Type();
class AccountRewards$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.AccountRewards", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "rewards", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.rewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* repeated cosmos.base.v1beta1.Coin rewards */
        2:
          message.rewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    for (let i = 0; i < message.rewards.length; i++)
      Coin.internalBinaryWrite(message.rewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AccountRewards = new AccountRewards$Type();
class TradeRecords$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.TradeRecords", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "latest_trade_records", kind: "message", repeat: 2, T: () => TradeRecord }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.latestTradeRecords = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.TradeRecord latest_trade_records */
        2:
          message.latestTradeRecords.push(TradeRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.latestTradeRecords.length; i++)
      TradeRecord.internalBinaryWrite(message.latestTradeRecords[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeRecords = new TradeRecords$Type();
class SubaccountIDs$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.SubaccountIDs", [
      {
        no: 1,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes subaccount_ids */
        1:
          message.subaccountIds.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountIDs = new SubaccountIDs$Type();
class TradeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.TradeRecord", [
      {
        no: 1,
        name: "timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    message.price = "";
    message.quantity = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 timestamp */
        1:
          message.timestamp = reader.int64().toBigInt();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        case /* string quantity */
        3:
          message.quantity = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.timestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.timestamp);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    if (message.quantity !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.quantity);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradeRecord = new TradeRecord$Type();
class Level$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.Level", [
      { no: 1, name: "p", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "q", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.p = "";
    message.q = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string p */
        1:
          message.p = reader.string();
          break;
        case /* string q */
        2:
          message.q = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.p !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.p);
    if (message.q !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.q);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Level = new Level$Type();
class AggregateSubaccountVolumeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.AggregateSubaccountVolumeRecord", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "market_volumes", kind: "message", repeat: 2, T: () => MarketVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.marketVolumes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.MarketVolume market_volumes */
        2:
          message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.marketVolumes.length; i++)
      MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AggregateSubaccountVolumeRecord = new AggregateSubaccountVolumeRecord$Type();
class AggregateAccountVolumeRecord$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.AggregateAccountVolumeRecord", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "market_volumes", kind: "message", repeat: 2, T: () => MarketVolume }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.marketVolumes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.MarketVolume market_volumes */
        2:
          message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    for (let i = 0; i < message.marketVolumes.length; i++)
      MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AggregateAccountVolumeRecord = new AggregateAccountVolumeRecord$Type();
class MarketVolume$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.MarketVolume", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "volume", kind: "message", T: () => VolumeRecord, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v1beta1.VolumeRecord volume */
        2:
          message.volume = VolumeRecord.internalBinaryRead(reader, reader.uint32(), options, message.volume);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.volume)
      VolumeRecord.internalBinaryWrite(message.volume, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MarketVolume = new MarketVolume$Type();
class DenomDecimals$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DenomDecimals", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "decimals",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.decimals = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* uint64 decimals */
        2:
          message.decimals = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.decimals !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.decimals);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomDecimals = new DenomDecimals$Type();
class GrantAuthorization$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.GrantAuthorization", [
      {
        no: 1,
        name: "grantee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.grantee = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string grantee */
        1:
          message.grantee = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.grantee !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.grantee);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GrantAuthorization = new GrantAuthorization$Type();
class ActiveGrant$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.ActiveGrant", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "amount", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    message.amount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        case /* string amount */
        2:
          message.amount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    if (message.amount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.amount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ActiveGrant = new ActiveGrant$Type();
class EffectiveGrant$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.EffectiveGrant", [
      {
        no: 1,
        name: "granter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "net_granted_stake", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 3,
        name: "is_valid",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.granter = "";
    message.netGrantedStake = "";
    message.isValid = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string granter */
        1:
          message.granter = reader.string();
          break;
        case /* string net_granted_stake */
        2:
          message.netGrantedStake = reader.string();
          break;
        case /* bool is_valid */
        3:
          message.isValid = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.granter !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.granter);
    if (message.netGrantedStake !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.netGrantedStake);
    if (message.isValid !== false)
      writer.tag(3, WireType.Varint).bool(message.isValid);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EffectiveGrant = new EffectiveGrant$Type();
class DenomMinNotional$Type extends MessageType {
  constructor() {
    super("injective.exchange.v1beta1.DenomMinNotional", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "min_notional", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.minNotional = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string min_notional */
        2:
          message.minNotional = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.minNotional !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.minNotional);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomMinNotional = new DenomMinNotional$Type();
export {
  AccountRewards,
  ActiveGrant,
  AggregateAccountVolumeRecord,
  AggregateSubaccountVolumeRecord,
  AtomicMarketOrderAccessLevel,
  BinaryOptionsMarket,
  CampaignRewardPool,
  DenomDecimals,
  DenomMinNotional,
  Deposit,
  DepositUpdate,
  DerivativeLimitOrder,
  DerivativeMarket,
  DerivativeMarketOrder,
  DerivativeMarketSettlementInfo,
  DerivativeOrder,
  DerivativeTradeLog,
  EffectiveGrant,
  ExecutionType,
  ExpiryFuturesMarketInfo,
  FeeDiscountSchedule,
  FeeDiscountTierInfo,
  FeeDiscountTierTTL,
  GrantAuthorization,
  Level,
  MarketFeeMultiplier,
  MarketOrderIndicator,
  MarketStatus,
  MarketVolume,
  MidPriceAndTOB,
  NextFundingTimestamp,
  OpenNotionalCap,
  OpenNotionalCapCapped,
  OpenNotionalCapUncapped,
  OrderInfo,
  OrderMask,
  OrderType,
  Params,
  PerpetualMarketFunding,
  PerpetualMarketInfo,
  PointsMultiplier,
  Position,
  PositionDelta,
  SpotLimitOrder,
  SpotMarket,
  SpotMarketOrder,
  SpotOrder,
  SubaccountDeposit,
  SubaccountIDs,
  SubaccountOrder,
  SubaccountOrderData,
  SubaccountOrderbookMetadata,
  SubaccountPosition,
  SubaccountTradeNonce,
  TradeLog,
  TradeRecord,
  TradeRecords,
  TradingRewardCampaignBoostInfo,
  TradingRewardCampaignInfo,
  VolumeRecord
};
