// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v1beta1/tx.proto" (package "injective.exchange.v1beta1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BatchExchangeModificationProposal } from "./proposal_pb";
import { GrantAuthorization } from "./exchange_pb";
import { MarketStatus } from "./exchange_pb";
import { PositionDelta } from "./exchange_pb";
import { DerivativeOrder } from "./exchange_pb";
import { OracleType } from "../../oracle/v1beta1/oracle_pb";
import { SpotOrder } from "./exchange_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
import { Params } from "./exchange_pb";
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgUpdateSpotMarket
 */
export interface MsgUpdateSpotMarket {
    /**
     * current admin address of the associated market
     *
     * @generated from protobuf field: string admin = 1
     */
    admin: string;
    /**
     * id of the market to be updated
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * (optional) updated ticker value
     *
     * @generated from protobuf field: string new_ticker = 3
     */
    newTicker: string;
    /**
     * (optional) updated min price tick size value
     *
     * @generated from protobuf field: string new_min_price_tick_size = 4
     */
    newMinPriceTickSize: string;
    /**
     * (optional) updated min quantity tick size value
     *
     * @generated from protobuf field: string new_min_quantity_tick_size = 5
     */
    newMinQuantityTickSize: string;
    /**
     * (optional) updated min notional
     *
     * @generated from protobuf field: string new_min_notional = 6
     */
    newMinNotional: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgUpdateSpotMarketResponse
 */
export interface MsgUpdateSpotMarketResponse {
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgUpdateDerivativeMarket
 */
export interface MsgUpdateDerivativeMarket {
    /**
     * current admin address of the associated market
     *
     * @generated from protobuf field: string admin = 1
     */
    admin: string;
    /**
     * id of the market to be updated
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * (optional) updated value for ticker
     *
     * @generated from protobuf field: string new_ticker = 3
     */
    newTicker: string;
    /**
     * (optional) updated value for min_price_tick_size
     *
     * @generated from protobuf field: string new_min_price_tick_size = 4
     */
    newMinPriceTickSize: string;
    /**
     * (optional) updated value min_quantity_tick_size
     *
     * @generated from protobuf field: string new_min_quantity_tick_size = 5
     */
    newMinQuantityTickSize: string;
    /**
     * (optional) updated min notional
     *
     * @generated from protobuf field: string new_min_notional = 6
     */
    newMinNotional: string;
    /**
     * (optional) updated value for initial_margin_ratio
     *
     * @generated from protobuf field: string new_initial_margin_ratio = 7
     */
    newInitialMarginRatio: string;
    /**
     * (optional) updated value for maintenance_margin_ratio
     *
     * @generated from protobuf field: string new_maintenance_margin_ratio = 8
     */
    newMaintenanceMarginRatio: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse
 */
export interface MsgUpdateDerivativeMarketResponse {
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the exchange parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: injective.exchange.v1beta1.Params params = 2
     */
    params?: Params;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgDeposit defines a SDK message for transferring coins from the sender's
 * bank balance into the subaccount's exchange deposits
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgDeposit
 */
export interface MsgDeposit {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin
     * will be deposited to the sender's default subaccount address
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the amount of the deposit (in chain format)
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * MsgDepositResponse defines the Msg/Deposit response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgDepositResponse
 */
export interface MsgDepositResponse {
}
/**
 * MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's
 * deposits to the user's bank balance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgWithdraw
 */
export interface MsgWithdraw {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID to withdraw funds from
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the amount of the withdrawal (in chain format)
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * MsgWithdraw defines the Msg/Withdraw response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgWithdrawResponse
 */
export interface MsgWithdrawResponse {
}
/**
 * MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit
 * order.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateSpotLimitOrder
 */
export interface MsgCreateSpotLimitOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the spot order to create
     *
     * @generated from protobuf field: injective.exchange.v1beta1.SpotOrder order = 2
     */
    order?: SpotOrder;
}
/**
 * MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response
 * type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse
 */
export interface MsgCreateSpotLimitOrderResponse {
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * the client order ID
     *
     * @generated from protobuf field: string cid = 2
     */
    cid: string;
}
/**
 * MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new batch
 * of spot limit orders.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders
 */
export interface MsgBatchCreateSpotLimitOrders {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the spot orders details
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotOrder orders = 2
     */
    orders: SpotOrder[];
}
/**
 * MsgBatchCreateSpotLimitOrdersResponse defines the
 * Msg/BatchCreateSpotLimitOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse
 */
export interface MsgBatchCreateSpotLimitOrdersResponse {
    /**
     * the order hashes
     *
     * @generated from protobuf field: repeated string order_hashes = 1
     */
    orderHashes: string[];
    /**
     * the client order IDs
     *
     * @generated from protobuf field: repeated string created_orders_cids = 2
     */
    createdOrdersCids: string[];
    /**
     * the failed client order IDs
     *
     * @generated from protobuf field: repeated string failed_orders_cids = 3
     */
    failedOrdersCids: string[];
}
/**
 * MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot
 * market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantSpotMarketLaunch
 */
export interface MsgInstantSpotMarketLaunch {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the ticker for the spot market
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * the type of coin to use as the base currency
     *
     * @generated from protobuf field: string base_denom = 3
     */
    baseDenom: string;
    /**
     * type of coin to use as the quote currency
     *
     * @generated from protobuf field: string quote_denom = 4
     */
    quoteDenom: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price
     *
     * @generated from protobuf field: string min_price_tick_size = 5
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 6
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 7
     */
    minNotional: string;
    /**
     * base token decimals
     *
     * @generated from protobuf field: uint32 base_decimals = 8
     */
    baseDecimals: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 9
     */
    quoteDecimals: number;
}
/**
 * MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse
 */
export interface MsgInstantSpotMarketLaunchResponse {
}
/**
 * MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new
 * perpetual futures market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch
 */
export interface MsgInstantPerpetualMarketLaunch {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Ticker for the derivative market.
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * type of coin to use as the base currency
     *
     * @generated from protobuf field: string quote_denom = 3
     */
    quoteDenom: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 4
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 5
     */
    oracleQuote: string;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 6
     */
    oracleScaleFactor: number;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 7
     */
    oracleType: OracleType;
    /**
     * maker_fee_rate defines the trade fee rate for makers on the perpetual
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 8
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the trade fee rate for takers on the perpetual
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 9
     */
    takerFeeRate: string;
    /**
     * initial_margin_ratio defines the initial margin ratio for the perpetual
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 10
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio for the
     * perpetual market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 11
     */
    maintenanceMarginRatio: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 12
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 13
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 14
     */
    minNotional: string;
}
/**
 * MsgInstantPerpetualMarketLaunchResponse defines the
 * Msg/InstantPerpetualMarketLaunchResponse response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse
 */
export interface MsgInstantPerpetualMarketLaunchResponse {
}
/**
 * MsgInstantBinaryOptionsMarketLaunch defines a SDK message for creating a new
 * perpetual futures market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch
 */
export interface MsgInstantBinaryOptionsMarketLaunch {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the ticker for the derivative contract
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * the oracle symbol
     *
     * @generated from protobuf field: string oracle_symbol = 3
     */
    oracleSymbol: string;
    /**
     * the oracle provider
     *
     * @generated from protobuf field: string oracle_provider = 4
     */
    oracleProvider: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 5
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 6
     */
    oracleScaleFactor: number;
    /**
     * maker_fee_rate defines the trade fee rate for makers on the perpetual
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 7
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the trade fee rate for takers on the perpetual
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 8
     */
    takerFeeRate: string;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 9
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 10
     */
    settlementTimestamp: bigint;
    /**
     * admin of the market
     *
     * @generated from protobuf field: string admin = 11
     */
    admin: string;
    /**
     * Address of the quote currency denomination for the binary options contract
     *
     * @generated from protobuf field: string quote_denom = 12
     */
    quoteDenom: string;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market
     *
     * @generated from protobuf field: string min_price_tick_size = 13
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market
     *
     * @generated from protobuf field: string min_quantity_tick_size = 14
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 15
     */
    minNotional: string;
}
/**
 * MsgInstantBinaryOptionsMarketLaunchResponse defines the
 * Msg/InstantBinaryOptionsMarketLaunchResponse response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse
 */
export interface MsgInstantBinaryOptionsMarketLaunchResponse {
}
/**
 * MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a new
 * expiry futures market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch
 */
export interface MsgInstantExpiryFuturesMarketLaunch {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Ticker for the derivative market.
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * type of coin to use as the quote currency
     *
     * @generated from protobuf field: string quote_denom = 3
     */
    quoteDenom: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 4
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 5
     */
    oracleQuote: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 6
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 7
     */
    oracleScaleFactor: number;
    /**
     * Expiration time of the market
     *
     * @generated from protobuf field: int64 expiry = 8
     */
    expiry: bigint;
    /**
     * maker_fee_rate defines the trade fee rate for makers on the expiry futures
     * market
     *
     * @generated from protobuf field: string maker_fee_rate = 9
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the trade fee rate for takers on the expiry futures
     * market
     *
     * @generated from protobuf field: string taker_fee_rate = 10
     */
    takerFeeRate: string;
    /**
     * initial_margin_ratio defines the initial margin ratio for the derivative
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 11
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio for the
     * derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 12
     */
    maintenanceMarginRatio: string;
    /**
     * min_price_tick_size defines the minimum tick size of the order's price and
     * margin
     *
     * @generated from protobuf field: string min_price_tick_size = 13
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the order's
     * quantity
     *
     * @generated from protobuf field: string min_quantity_tick_size = 14
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 15
     */
    minNotional: string;
}
/**
 * MsgInstantExpiryFuturesMarketLaunchResponse defines the
 * Msg/InstantExpiryFuturesMarketLaunch response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse
 */
export interface MsgInstantExpiryFuturesMarketLaunchResponse {
}
/**
 * MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market
 * order.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateSpotMarketOrder
 */
export interface MsgCreateSpotMarketOrder {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.SpotOrder order = 2
     */
    order?: SpotOrder;
}
/**
 * MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse
 */
export interface MsgCreateSpotMarketOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.SpotMarketOrderResults results = 2
     */
    results?: SpotMarketOrderResults;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SpotMarketOrderResults
 */
export interface SpotMarketOrderResults {
    /**
     * @generated from protobuf field: string quantity = 1
     */
    quantity: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * @generated from protobuf field: string fee = 3
     */
    fee: string;
}
/**
 * A Cosmos-SDK MsgCreateDerivativeLimitOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder
 */
export interface MsgCreateDerivativeLimitOrder {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateDerivativeLimitOrderResponse defines the
 * Msg/CreateDerivativeMarketOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse
 */
export interface MsgCreateDerivativeLimitOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 2
     */
    cid: string;
}
/**
 * A Cosmos-SDK MsgCreateBinaryOptionsLimitOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder
 */
export interface MsgCreateBinaryOptionsLimitOrder {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateBinaryOptionsLimitOrderResponse defines the
 * Msg/CreateBinaryOptionsLimitOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse
 */
export interface MsgCreateBinaryOptionsLimitOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 2
     */
    cid: string;
}
/**
 * A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders
 */
export interface MsgBatchCreateDerivativeLimitOrders {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeOrder orders = 2
     */
    orders: DerivativeOrder[];
}
/**
 * MsgBatchCreateDerivativeLimitOrdersResponse defines the
 * Msg/BatchCreateDerivativeLimitOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse
 */
export interface MsgBatchCreateDerivativeLimitOrdersResponse {
    /**
     * @generated from protobuf field: repeated string order_hashes = 1
     */
    orderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_orders_cids = 2
     */
    createdOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_orders_cids = 3
     */
    failedOrdersCids: string[];
}
/**
 * MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelSpotOrder
 */
export interface MsgCancelSpotOrder {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * @generated from protobuf field: string order_hash = 4
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 5
     */
    cid: string;
}
/**
 * MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelSpotOrderResponse
 */
export interface MsgCancelSpotOrderResponse {
}
/**
 * MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelSpotOrders
 */
export interface MsgBatchCancelSpotOrders {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData data = 2
     */
    data: OrderData[];
}
/**
 * MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse
 */
export interface MsgBatchCancelSpotOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool success = 1
     */
    success: boolean[];
}
/**
 * MsgBatchCancelBinaryOptionsOrders defines the
 * Msg/BatchCancelBinaryOptionsOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders
 */
export interface MsgBatchCancelBinaryOptionsOrders {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData data = 2
     */
    data: OrderData[];
}
/**
 * BatchCancelBinaryOptionsOrdersResponse defines the
 * Msg/BatchCancelBinaryOptionsOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse
 */
export interface MsgBatchCancelBinaryOptionsOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool success = 1
     */
    success: boolean[];
}
/**
 * MsgBatchUpdateOrders defines the Msg/BatchUpdateOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchUpdateOrders
 */
export interface MsgBatchUpdateOrders {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID only used for the spot_market_ids_to_cancel_all and
     * derivative_market_ids_to_cancel_all
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the spot market IDs to cancel all
     *
     * @generated from protobuf field: repeated string spot_market_ids_to_cancel_all = 3
     */
    spotMarketIdsToCancelAll: string[];
    /**
     * the derivative market IDs to cancel all
     *
     * @generated from protobuf field: repeated string derivative_market_ids_to_cancel_all = 4
     */
    derivativeMarketIdsToCancelAll: string[];
    /**
     * the spot orders to cancel
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData spot_orders_to_cancel = 5
     */
    spotOrdersToCancel: OrderData[];
    /**
     * the derivative orders to cancel
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData derivative_orders_to_cancel = 6
     */
    derivativeOrdersToCancel: OrderData[];
    /**
     * the spot orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotOrder spot_orders_to_create = 7
     */
    spotOrdersToCreate: SpotOrder[];
    /**
     * the derivative orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create = 8
     */
    derivativeOrdersToCreate: DerivativeOrder[];
    /**
     * the binary options orders to cancel
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel = 9
     */
    binaryOptionsOrdersToCancel: OrderData[];
    /**
     * the binary options market IDs to cancel all
     *
     * @generated from protobuf field: repeated string binary_options_market_ids_to_cancel_all = 10
     */
    binaryOptionsMarketIdsToCancelAll: string[];
    /**
     * the binary options orders to create
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create = 11
     */
    binaryOptionsOrdersToCreate: DerivativeOrder[];
}
/**
 * MsgBatchUpdateOrdersResponse defines the Msg/BatchUpdateOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse
 */
export interface MsgBatchUpdateOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool spot_cancel_success = 1
     */
    spotCancelSuccess: boolean[];
    /**
     * @generated from protobuf field: repeated bool derivative_cancel_success = 2
     */
    derivativeCancelSuccess: boolean[];
    /**
     * @generated from protobuf field: repeated string spot_order_hashes = 3
     */
    spotOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string derivative_order_hashes = 4
     */
    derivativeOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated bool binary_options_cancel_success = 5
     */
    binaryOptionsCancelSuccess: boolean[];
    /**
     * @generated from protobuf field: repeated string binary_options_order_hashes = 6
     */
    binaryOptionsOrderHashes: string[];
    /**
     * @generated from protobuf field: repeated string created_spot_orders_cids = 7
     */
    createdSpotOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_spot_orders_cids = 8
     */
    failedSpotOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string created_derivative_orders_cids = 9
     */
    createdDerivativeOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_derivative_orders_cids = 10
     */
    failedDerivativeOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string created_binary_options_orders_cids = 11
     */
    createdBinaryOptionsOrdersCids: string[];
    /**
     * @generated from protobuf field: repeated string failed_binary_options_orders_cids = 12
     */
    failedBinaryOptionsOrdersCids: string[];
}
/**
 * A Cosmos-SDK MsgCreateDerivativeMarketOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder
 */
export interface MsgCreateDerivativeMarketOrder {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateDerivativeMarketOrderResponse defines the
 * Msg/CreateDerivativeMarketOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse
 */
export interface MsgCreateDerivativeMarketOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2
     */
    results?: DerivativeMarketOrderResults;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarketOrderResults
 */
export interface DerivativeMarketOrderResults {
    /**
     * @generated from protobuf field: string quantity = 1
     */
    quantity: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * @generated from protobuf field: string fee = 3
     */
    fee: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.PositionDelta position_delta = 4
     */
    positionDelta?: PositionDelta;
    /**
     * @generated from protobuf field: string payout = 5
     */
    payout: string;
}
/**
 * A Cosmos-SDK MsgCreateBinaryOptionsMarketOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder
 */
export interface MsgCreateBinaryOptionsMarketOrder {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
}
/**
 * MsgCreateBinaryOptionsMarketOrderResponse defines the
 * Msg/CreateBinaryOptionsMarketOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse
 */
export interface MsgCreateBinaryOptionsMarketOrderResponse {
    /**
     * @generated from protobuf field: string order_hash = 1
     */
    orderHash: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2
     */
    results?: DerivativeMarketOrderResults;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
}
/**
 * MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelDerivativeOrder
 */
export interface MsgCancelDerivativeOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 4
     */
    orderHash: string;
    /**
     * the order mask
     *
     * @generated from protobuf field: int32 order_mask = 5
     */
    orderMask: number; // bitwise combination of OrderMask enum values
    /**
     * the client order ID
     *
     * @generated from protobuf field: string cid = 6
     */
    cid: string;
}
/**
 * MsgCancelDerivativeOrderResponse defines the
 * Msg/CancelDerivativeOrderResponse response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse
 */
export interface MsgCancelDerivativeOrderResponse {
}
/**
 * MsgCancelBinaryOptionsOrder defines the Msg/CancelBinaryOptionsOrder response
 * type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder
 */
export interface MsgCancelBinaryOptionsOrder {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 3
     */
    subaccountId: string;
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 4
     */
    orderHash: string;
    /**
     * the order mask (bitwise combination of OrderMask enum values)
     *
     * @generated from protobuf field: int32 order_mask = 5
     */
    orderMask: number;
    /**
     * the client order ID
     *
     * @generated from protobuf field: string cid = 6
     */
    cid: string;
}
/**
 * MsgCancelBinaryOptionsOrderResponse defines the
 * Msg/CancelBinaryOptionsOrderResponse response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse
 */
export interface MsgCancelBinaryOptionsOrderResponse {
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OrderData
 */
export interface OrderData {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 3
     */
    orderHash: string;
    /**
     * the order mask (bitwise combination of OrderMask enum values)
     *
     * @generated from protobuf field: int32 order_mask = 4
     */
    orderMask: number;
    /**
     * the client order ID
     *
     * @generated from protobuf field: string cid = 5
     */
    cid: string;
}
/**
 * MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders
 */
export interface MsgBatchCancelDerivativeOrders {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * orders details
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData data = 2
     */
    data: OrderData[];
}
/**
 * MsgBatchCancelDerivativeOrdersResponse defines the
 * Msg/CancelDerivativeOrderResponse response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse
 */
export interface MsgBatchCancelDerivativeOrdersResponse {
    /**
     * @generated from protobuf field: repeated bool success = 1
     */
    success: boolean[];
}
/**
 * A Cosmos-SDK MsgSubaccountTransfer
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgSubaccountTransfer
 */
export interface MsgSubaccountTransfer {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the source subaccount ID
     *
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * the destination subaccount ID
     *
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * the amount of the transfer
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 4
     */
    amount?: Coin;
}
/**
 * MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response
 * type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgSubaccountTransferResponse
 */
export interface MsgSubaccountTransferResponse {
}
/**
 * A Cosmos-SDK MsgExternalTransfer
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgExternalTransfer
 */
export interface MsgExternalTransfer {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 4
     */
    amount?: Coin;
}
/**
 * MsgExternalTransferResponse defines the Msg/ExternalTransfer response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgExternalTransferResponse
 */
export interface MsgExternalTransferResponse {
}
/**
 * A Cosmos-SDK MsgLiquidatePosition
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgLiquidatePosition
 */
export interface MsgLiquidatePosition {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * optional order to provide for liquidation
     *
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 4
     */
    order?: DerivativeOrder;
}
/**
 * MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgLiquidatePositionResponse
 */
export interface MsgLiquidatePositionResponse {
}
/**
 * A Cosmos-SDK MsgEmergencySettleMarket
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgEmergencySettleMarket
 */
export interface MsgEmergencySettleMarket {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
}
/**
 * MsgEmergencySettleMarketResponse defines the Msg/EmergencySettleMarket
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgEmergencySettleMarketResponse
 */
export interface MsgEmergencySettleMarketResponse {
}
/**
 * A Cosmos-SDK MsgIncreasePositionMargin
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgIncreasePositionMargin
 */
export interface MsgIncreasePositionMargin {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID sending the funds
     *
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * the subaccount ID the position belongs to
     *
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
    /**
     * amount defines the amount of margin to add to the position (in chain
     * format)
     *
     * @generated from protobuf field: string amount = 5
     */
    amount: string;
}
/**
 * MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgIncreasePositionMarginResponse
 */
export interface MsgIncreasePositionMarginResponse {
}
/**
 * A Cosmos-SDK MsgDecreasePositionMargin
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgDecreasePositionMargin
 */
export interface MsgDecreasePositionMargin {
    /**
     * the sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * the subaccount ID sending the funds
     *
     * @generated from protobuf field: string source_subaccount_id = 2
     */
    sourceSubaccountId: string;
    /**
     * the subaccount ID the position belongs to
     *
     * @generated from protobuf field: string destination_subaccount_id = 3
     */
    destinationSubaccountId: string;
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
    /**
     * amount defines the amount of margin to withdraw from the position (in chain
     * format)
     *
     * @generated from protobuf field: string amount = 5
     */
    amount: string;
}
/**
 * MsgDecreasePositionMarginResponse defines the Msg/MsgDecreasePositionMargin
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgDecreasePositionMarginResponse
 */
export interface MsgDecreasePositionMarginResponse {
}
/**
 * MsgPrivilegedExecuteContract defines the Msg/Exec message type
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgPrivilegedExecuteContract
 */
export interface MsgPrivilegedExecuteContract {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * funds defines the user's bank coins used to fund the execution (e.g.
     * 100inj).
     *
     * @generated from protobuf field: string funds = 2
     */
    funds: string;
    /**
     * contract_address defines the contract address to execute
     *
     * @generated from protobuf field: string contract_address = 3
     */
    contractAddress: string;
    /**
     * data defines the call data used when executing the contract
     *
     * @generated from protobuf field: string data = 4
     */
    data: string;
}
/**
 * MsgPrivilegedExecuteContractResponse defines the Msg/Exec response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse
 */
export interface MsgPrivilegedExecuteContractResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds_diff = 1
     */
    fundsDiff: Coin[];
}
/**
 * A Cosmos-SDK MsgRewardsOptOut
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgRewardsOptOut
 */
export interface MsgRewardsOptOut {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
}
/**
 * MsgRewardsOptOutResponse defines the Msg/RewardsOptOut response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgRewardsOptOutResponse
 */
export interface MsgRewardsOptOutResponse {
}
/**
 * A Cosmos-SDK MsgReclaimLockedFunds
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgReclaimLockedFunds
 */
export interface MsgReclaimLockedFunds {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: bytes lockedAccountPubKey = 2
     */
    lockedAccountPubKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes signature = 3
     */
    signature: Uint8Array;
}
/**
 * MsgReclaimLockedFundsResponse defines the Msg/ReclaimLockedFunds response
 * type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgReclaimLockedFundsResponse
 */
export interface MsgReclaimLockedFundsResponse {
}
/**
 * MsgSignData defines an arbitrary, general-purpose, off-chain message
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgSignData
 */
export interface MsgSignData {
    /**
     * Signer is the sdk.AccAddress of the message signer
     *
     * @generated from protobuf field: bytes Signer = 1
     */
    signer: Uint8Array;
    /**
     * Data represents the raw bytes of the content that is signed (text, json,
     * etc)
     *
     * @generated from protobuf field: bytes Data = 2
     */
    data: Uint8Array;
}
/**
 * MsgSignDoc defines an arbitrary, general-purpose, off-chain message
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgSignDoc
 */
export interface MsgSignDoc {
    /**
     * @generated from protobuf field: string sign_type = 1
     */
    signType: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.MsgSignData value = 2
     */
    value?: MsgSignData;
}
/**
 * MsgAdminUpdateBinaryOptionsMarket is used by the market Admin to operate the
 * market
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket
 */
export interface MsgAdminUpdateBinaryOptionsMarket {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * new price at which market will be settled
     *
     * @generated from protobuf field: string settlement_price = 3
     */
    settlementPrice: string;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 4
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 5
     */
    settlementTimestamp: bigint;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 6
     */
    status: MarketStatus;
}
/**
 * MsgAdminUpdateBinaryOptionsMarketResponse is the response for
 * AdminUpdateBinaryOptionsMarket rpc method
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse
 */
export interface MsgAdminUpdateBinaryOptionsMarketResponse {
}
/**
 * MsgAuthorizeStakeGrants grants stakes to grantees.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgAuthorizeStakeGrants
 */
export interface MsgAuthorizeStakeGrants {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.GrantAuthorization grants = 2
     */
    grants: GrantAuthorization[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse
 */
export interface MsgAuthorizeStakeGrantsResponse {
}
/**
 * MsgActivateStakeGrant allows a grantee to activate a stake grant.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgActivateStakeGrant
 */
export interface MsgActivateStakeGrant {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string granter = 2
     */
    granter: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgActivateStakeGrantResponse
 */
export interface MsgActivateStakeGrantResponse {
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchExchangeModification
 */
export interface MsgBatchExchangeModification {
    /**
     * message sender, that is also the TX signer
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.BatchExchangeModificationProposal proposal = 2
     */
    proposal?: BatchExchangeModificationProposal;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchExchangeModificationResponse
 */
export interface MsgBatchExchangeModificationResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateSpotMarket$Type extends MessageType<MsgUpdateSpotMarket> {
    constructor() {
        super("injective.exchange.v1beta1.MsgUpdateSpotMarket", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "new_min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "new_min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "new_min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.equal": false, "amino.name": "exchange/MsgUpdateSpotMarket", "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateSpotMarket>): MsgUpdateSpotMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.admin = "";
        message.marketId = "";
        message.newTicker = "";
        message.newMinPriceTickSize = "";
        message.newMinQuantityTickSize = "";
        message.newMinNotional = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateSpotMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateSpotMarket): MsgUpdateSpotMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string new_ticker */ 3:
                    message.newTicker = reader.string();
                    break;
                case /* string new_min_price_tick_size */ 4:
                    message.newMinPriceTickSize = reader.string();
                    break;
                case /* string new_min_quantity_tick_size */ 5:
                    message.newMinQuantityTickSize = reader.string();
                    break;
                case /* string new_min_notional */ 6:
                    message.newMinNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateSpotMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string new_ticker = 3; */
        if (message.newTicker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newTicker);
        /* string new_min_price_tick_size = 4; */
        if (message.newMinPriceTickSize !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.newMinPriceTickSize);
        /* string new_min_quantity_tick_size = 5; */
        if (message.newMinQuantityTickSize !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.newMinQuantityTickSize);
        /* string new_min_notional = 6; */
        if (message.newMinNotional !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.newMinNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgUpdateSpotMarket
 */
export const MsgUpdateSpotMarket = new MsgUpdateSpotMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateSpotMarketResponse$Type extends MessageType<MsgUpdateSpotMarketResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgUpdateSpotMarketResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateSpotMarketResponse>): MsgUpdateSpotMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateSpotMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateSpotMarketResponse): MsgUpdateSpotMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateSpotMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgUpdateSpotMarketResponse
 */
export const MsgUpdateSpotMarketResponse = new MsgUpdateSpotMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateDerivativeMarket$Type extends MessageType<MsgUpdateDerivativeMarket> {
    constructor() {
        super("injective.exchange.v1beta1.MsgUpdateDerivativeMarket", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "new_min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "new_min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "new_min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "new_initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "new_maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgUpdateDerivativeMarket", "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateDerivativeMarket>): MsgUpdateDerivativeMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.admin = "";
        message.marketId = "";
        message.newTicker = "";
        message.newMinPriceTickSize = "";
        message.newMinQuantityTickSize = "";
        message.newMinNotional = "";
        message.newInitialMarginRatio = "";
        message.newMaintenanceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateDerivativeMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateDerivativeMarket): MsgUpdateDerivativeMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string new_ticker */ 3:
                    message.newTicker = reader.string();
                    break;
                case /* string new_min_price_tick_size */ 4:
                    message.newMinPriceTickSize = reader.string();
                    break;
                case /* string new_min_quantity_tick_size */ 5:
                    message.newMinQuantityTickSize = reader.string();
                    break;
                case /* string new_min_notional */ 6:
                    message.newMinNotional = reader.string();
                    break;
                case /* string new_initial_margin_ratio */ 7:
                    message.newInitialMarginRatio = reader.string();
                    break;
                case /* string new_maintenance_margin_ratio */ 8:
                    message.newMaintenanceMarginRatio = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateDerivativeMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string new_ticker = 3; */
        if (message.newTicker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newTicker);
        /* string new_min_price_tick_size = 4; */
        if (message.newMinPriceTickSize !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.newMinPriceTickSize);
        /* string new_min_quantity_tick_size = 5; */
        if (message.newMinQuantityTickSize !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.newMinQuantityTickSize);
        /* string new_min_notional = 6; */
        if (message.newMinNotional !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.newMinNotional);
        /* string new_initial_margin_ratio = 7; */
        if (message.newInitialMarginRatio !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.newInitialMarginRatio);
        /* string new_maintenance_margin_ratio = 8; */
        if (message.newMaintenanceMarginRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.newMaintenanceMarginRatio);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgUpdateDerivativeMarket
 */
export const MsgUpdateDerivativeMarket = new MsgUpdateDerivativeMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateDerivativeMarketResponse$Type extends MessageType<MsgUpdateDerivativeMarketResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateDerivativeMarketResponse>): MsgUpdateDerivativeMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateDerivativeMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateDerivativeMarketResponse): MsgUpdateDerivativeMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateDerivativeMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse
 */
export const MsgUpdateDerivativeMarketResponse = new MsgUpdateDerivativeMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("injective.exchange.v1beta1.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "exchange/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* injective.exchange.v1beta1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* injective.exchange.v1beta1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDeposit$Type extends MessageType<MsgDeposit> {
    constructor() {
        super("injective.exchange.v1beta1.MsgDeposit", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgDeposit", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgDeposit>): MsgDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDeposit): MsgDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgDeposit
 */
export const MsgDeposit = new MsgDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositResponse$Type extends MessageType<MsgDepositResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgDepositResponse", []);
    }
    create(value?: PartialMessage<MsgDepositResponse>): MsgDepositResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgDepositResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositResponse): MsgDepositResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDepositResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgDepositResponse
 */
export const MsgDepositResponse = new MsgDepositResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdraw$Type extends MessageType<MsgWithdraw> {
    constructor() {
        super("injective.exchange.v1beta1.MsgWithdraw", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgWithdraw", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgWithdraw>): MsgWithdraw {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgWithdraw>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdraw): MsgWithdraw {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdraw, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgWithdraw
 */
export const MsgWithdraw = new MsgWithdraw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawResponse$Type extends MessageType<MsgWithdrawResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgWithdrawResponse", []);
    }
    create(value?: PartialMessage<MsgWithdrawResponse>): MsgWithdrawResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawResponse): MsgWithdrawResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgWithdrawResponse
 */
export const MsgWithdrawResponse = new MsgWithdrawResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotLimitOrder$Type extends MessageType<MsgCreateSpotLimitOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateSpotLimitOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => SpotOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgCreateSpotLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateSpotLimitOrder>): MsgCreateSpotLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotLimitOrder): MsgCreateSpotLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v1beta1.SpotOrder order */ 2:
                    message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v1beta1.SpotOrder order = 2; */
        if (message.order)
            SpotOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateSpotLimitOrder
 */
export const MsgCreateSpotLimitOrder = new MsgCreateSpotLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotLimitOrderResponse$Type extends MessageType<MsgCreateSpotLimitOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateSpotLimitOrderResponse>): MsgCreateSpotLimitOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotLimitOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotLimitOrderResponse): MsgCreateSpotLimitOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 2:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotLimitOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 2; */
        if (message.cid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse
 */
export const MsgCreateSpotLimitOrderResponse = new MsgCreateSpotLimitOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateSpotLimitOrders$Type extends MessageType<MsgBatchCreateSpotLimitOrders> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBatchCreateSpotLimitOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCreateSpotLimitOrders>): MsgBatchCreateSpotLimitOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateSpotLimitOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateSpotLimitOrders): MsgBatchCreateSpotLimitOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.SpotOrder orders */ 2:
                    message.orders.push(SpotOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateSpotLimitOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v1beta1.SpotOrder orders = 2; */
        for (let i = 0; i < message.orders.length; i++)
            SpotOrder.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders
 */
export const MsgBatchCreateSpotLimitOrders = new MsgBatchCreateSpotLimitOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateSpotLimitOrdersResponse$Type extends MessageType<MsgBatchCreateSpotLimitOrdersResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse", [
            { no: 1, name: "order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "failed_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCreateSpotLimitOrdersResponse>): MsgBatchCreateSpotLimitOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHashes = [];
        message.createdOrdersCids = [];
        message.failedOrdersCids = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateSpotLimitOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateSpotLimitOrdersResponse): MsgBatchCreateSpotLimitOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string order_hashes */ 1:
                    message.orderHashes.push(reader.string());
                    break;
                case /* repeated string created_orders_cids */ 2:
                    message.createdOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_orders_cids */ 3:
                    message.failedOrdersCids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateSpotLimitOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string order_hashes = 1; */
        for (let i = 0; i < message.orderHashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.orderHashes[i]);
        /* repeated string created_orders_cids = 2; */
        for (let i = 0; i < message.createdOrdersCids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.createdOrdersCids[i]);
        /* repeated string failed_orders_cids = 3; */
        for (let i = 0; i < message.failedOrdersCids.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.failedOrdersCids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse
 */
export const MsgBatchCreateSpotLimitOrdersResponse = new MsgBatchCreateSpotLimitOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantSpotMarketLaunch$Type extends MessageType<MsgInstantSpotMarketLaunch> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantSpotMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "base_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "base_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantSpotMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantSpotMarketLaunch>): MsgInstantSpotMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.baseDenom = "";
        message.quoteDenom = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.baseDecimals = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<MsgInstantSpotMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantSpotMarketLaunch): MsgInstantSpotMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string base_denom */ 3:
                    message.baseDenom = reader.string();
                    break;
                case /* string quote_denom */ 4:
                    message.quoteDenom = reader.string();
                    break;
                case /* string min_price_tick_size */ 5:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 6:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 7:
                    message.minNotional = reader.string();
                    break;
                case /* uint32 base_decimals */ 8:
                    message.baseDecimals = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 9:
                    message.quoteDecimals = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantSpotMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string base_denom = 3; */
        if (message.baseDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.baseDenom);
        /* string quote_denom = 4; */
        if (message.quoteDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
        /* string min_price_tick_size = 5; */
        if (message.minPriceTickSize !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 6; */
        if (message.minQuantityTickSize !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 7; */
        if (message.minNotional !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.minNotional);
        /* uint32 base_decimals = 8; */
        if (message.baseDecimals !== 0)
            writer.tag(8, WireType.Varint).uint32(message.baseDecimals);
        /* uint32 quote_decimals = 9; */
        if (message.quoteDecimals !== 0)
            writer.tag(9, WireType.Varint).uint32(message.quoteDecimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantSpotMarketLaunch
 */
export const MsgInstantSpotMarketLaunch = new MsgInstantSpotMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantSpotMarketLaunchResponse$Type extends MessageType<MsgInstantSpotMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantSpotMarketLaunchResponse>): MsgInstantSpotMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantSpotMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantSpotMarketLaunchResponse): MsgInstantSpotMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantSpotMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse
 */
export const MsgInstantSpotMarketLaunchResponse = new MsgInstantSpotMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantPerpetualMarketLaunch$Type extends MessageType<MsgInstantPerpetualMarketLaunch> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 8, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantPerpetualMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantPerpetualMarketLaunch>): MsgInstantPerpetualMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.quoteDenom = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleScaleFactor = 0;
        message.oracleType = 0;
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<MsgInstantPerpetualMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantPerpetualMarketLaunch): MsgInstantPerpetualMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string quote_denom */ 3:
                    message.quoteDenom = reader.string();
                    break;
                case /* string oracle_base */ 4:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 5:
                    message.oracleQuote = reader.string();
                    break;
                case /* uint32 oracle_scale_factor */ 6:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 7:
                    message.oracleType = reader.int32();
                    break;
                case /* string maker_fee_rate */ 8:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 9:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string initial_margin_ratio */ 10:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 11:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string min_price_tick_size */ 12:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 13:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 14:
                    message.minNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantPerpetualMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string quote_denom = 3; */
        if (message.quoteDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
        /* string oracle_base = 4; */
        if (message.oracleBase !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 5; */
        if (message.oracleQuote !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
        /* uint32 oracle_scale_factor = 6; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(6, WireType.Varint).uint32(message.oracleScaleFactor);
        /* injective.oracle.v1beta1.OracleType oracle_type = 7; */
        if (message.oracleType !== 0)
            writer.tag(7, WireType.Varint).int32(message.oracleType);
        /* string maker_fee_rate = 8; */
        if (message.makerFeeRate !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 9; */
        if (message.takerFeeRate !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string initial_margin_ratio = 10; */
        if (message.initialMarginRatio !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 11; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string min_price_tick_size = 12; */
        if (message.minPriceTickSize !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 13; */
        if (message.minQuantityTickSize !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 14; */
        if (message.minNotional !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch
 */
export const MsgInstantPerpetualMarketLaunch = new MsgInstantPerpetualMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantPerpetualMarketLaunchResponse$Type extends MessageType<MsgInstantPerpetualMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantPerpetualMarketLaunchResponse>): MsgInstantPerpetualMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantPerpetualMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantPerpetualMarketLaunchResponse): MsgInstantPerpetualMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantPerpetualMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse
 */
export const MsgInstantPerpetualMarketLaunchResponse = new MsgInstantPerpetualMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantBinaryOptionsMarketLaunch$Type extends MessageType<MsgInstantBinaryOptionsMarketLaunch> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 6, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantBinaryOptionsMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantBinaryOptionsMarketLaunch>): MsgInstantBinaryOptionsMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.oracleSymbol = "";
        message.oracleProvider = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.admin = "";
        message.quoteDenom = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<MsgInstantBinaryOptionsMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantBinaryOptionsMarketLaunch): MsgInstantBinaryOptionsMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_symbol */ 3:
                    message.oracleSymbol = reader.string();
                    break;
                case /* string oracle_provider */ 4:
                    message.oracleProvider = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 5:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 6:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* string maker_fee_rate */ 7:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 8:
                    message.takerFeeRate = reader.string();
                    break;
                case /* int64 expiration_timestamp */ 9:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 10:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* string admin */ 11:
                    message.admin = reader.string();
                    break;
                case /* string quote_denom */ 12:
                    message.quoteDenom = reader.string();
                    break;
                case /* string min_price_tick_size */ 13:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 14:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 15:
                    message.minNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantBinaryOptionsMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_symbol = 3; */
        if (message.oracleSymbol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oracleSymbol);
        /* string oracle_provider = 4; */
        if (message.oracleProvider !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleProvider);
        /* injective.oracle.v1beta1.OracleType oracle_type = 5; */
        if (message.oracleType !== 0)
            writer.tag(5, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 6; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(6, WireType.Varint).uint32(message.oracleScaleFactor);
        /* string maker_fee_rate = 7; */
        if (message.makerFeeRate !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 8; */
        if (message.takerFeeRate !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.takerFeeRate);
        /* int64 expiration_timestamp = 9; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(9, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 10; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(10, WireType.Varint).int64(message.settlementTimestamp);
        /* string admin = 11; */
        if (message.admin !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.admin);
        /* string quote_denom = 12; */
        if (message.quoteDenom !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.quoteDenom);
        /* string min_price_tick_size = 13; */
        if (message.minPriceTickSize !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 14; */
        if (message.minQuantityTickSize !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 15; */
        if (message.minNotional !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch
 */
export const MsgInstantBinaryOptionsMarketLaunch = new MsgInstantBinaryOptionsMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantBinaryOptionsMarketLaunchResponse$Type extends MessageType<MsgInstantBinaryOptionsMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantBinaryOptionsMarketLaunchResponse>): MsgInstantBinaryOptionsMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantBinaryOptionsMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantBinaryOptionsMarketLaunchResponse): MsgInstantBinaryOptionsMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantBinaryOptionsMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse
 */
export const MsgInstantBinaryOptionsMarketLaunchResponse = new MsgInstantBinaryOptionsMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantExpiryFuturesMarketLaunch$Type extends MessageType<MsgInstantExpiryFuturesMarketLaunch> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "expiry", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 15, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgInstantExpiryFuturesMarketLaunch", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantExpiryFuturesMarketLaunch>): MsgInstantExpiryFuturesMarketLaunch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ticker = "";
        message.quoteDenom = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.expiry = 0n;
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<MsgInstantExpiryFuturesMarketLaunch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantExpiryFuturesMarketLaunch): MsgInstantExpiryFuturesMarketLaunch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string quote_denom */ 3:
                    message.quoteDenom = reader.string();
                    break;
                case /* string oracle_base */ 4:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 5:
                    message.oracleQuote = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 6:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 7:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* int64 expiry */ 8:
                    message.expiry = reader.int64().toBigInt();
                    break;
                case /* string maker_fee_rate */ 9:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 10:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string initial_margin_ratio */ 11:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 12:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string min_price_tick_size */ 13:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 14:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 15:
                    message.minNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantExpiryFuturesMarketLaunch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string quote_denom = 3; */
        if (message.quoteDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
        /* string oracle_base = 4; */
        if (message.oracleBase !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 5; */
        if (message.oracleQuote !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.oracleQuote);
        /* injective.oracle.v1beta1.OracleType oracle_type = 6; */
        if (message.oracleType !== 0)
            writer.tag(6, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 7; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(7, WireType.Varint).uint32(message.oracleScaleFactor);
        /* int64 expiry = 8; */
        if (message.expiry !== 0n)
            writer.tag(8, WireType.Varint).int64(message.expiry);
        /* string maker_fee_rate = 9; */
        if (message.makerFeeRate !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 10; */
        if (message.takerFeeRate !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string initial_margin_ratio = 11; */
        if (message.initialMarginRatio !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 12; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string min_price_tick_size = 13; */
        if (message.minPriceTickSize !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 14; */
        if (message.minQuantityTickSize !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 15; */
        if (message.minNotional !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch
 */
export const MsgInstantExpiryFuturesMarketLaunch = new MsgInstantExpiryFuturesMarketLaunch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantExpiryFuturesMarketLaunchResponse$Type extends MessageType<MsgInstantExpiryFuturesMarketLaunchResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse", []);
    }
    create(value?: PartialMessage<MsgInstantExpiryFuturesMarketLaunchResponse>): MsgInstantExpiryFuturesMarketLaunchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgInstantExpiryFuturesMarketLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantExpiryFuturesMarketLaunchResponse): MsgInstantExpiryFuturesMarketLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantExpiryFuturesMarketLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse
 */
export const MsgInstantExpiryFuturesMarketLaunchResponse = new MsgInstantExpiryFuturesMarketLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotMarketOrder$Type extends MessageType<MsgCreateSpotMarketOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateSpotMarketOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => SpotOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgCreateSpotMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateSpotMarketOrder>): MsgCreateSpotMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotMarketOrder): MsgCreateSpotMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v1beta1.SpotOrder order */ 2:
                    message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v1beta1.SpotOrder order = 2; */
        if (message.order)
            SpotOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateSpotMarketOrder
 */
export const MsgCreateSpotMarketOrder = new MsgCreateSpotMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateSpotMarketOrderResponse$Type extends MessageType<MsgCreateSpotMarketOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", T: () => SpotMarketOrderResults, options: { "gogoproto.nullable": true } },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateSpotMarketOrderResponse>): MsgCreateSpotMarketOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateSpotMarketOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateSpotMarketOrderResponse): MsgCreateSpotMarketOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* injective.exchange.v1beta1.SpotMarketOrderResults results */ 2:
                    message.results = SpotMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateSpotMarketOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* injective.exchange.v1beta1.SpotMarketOrderResults results = 2; */
        if (message.results)
            SpotMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse
 */
export const MsgCreateSpotMarketOrderResponse = new MsgCreateSpotMarketOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketOrderResults$Type extends MessageType<SpotMarketOrderResults> {
    constructor() {
        super("injective.exchange.v1beta1.SpotMarketOrderResults", [
            { no: 1, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<SpotMarketOrderResults>): SpotMarketOrderResults {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = "";
        message.price = "";
        message.fee = "";
        if (value !== undefined)
            reflectionMergePartial<SpotMarketOrderResults>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketOrderResults): SpotMarketOrderResults {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string quantity */ 1:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* string fee */ 3:
                    message.fee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketOrderResults, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string quantity = 1; */
        if (message.quantity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.quantity);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* string fee = 3; */
        if (message.fee !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotMarketOrderResults
 */
export const SpotMarketOrderResults = new SpotMarketOrderResults$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeLimitOrder$Type extends MessageType<MsgCreateDerivativeLimitOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateDerivativeLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateDerivativeLimitOrder>): MsgCreateDerivativeLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeLimitOrder): MsgCreateDerivativeLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v1beta1.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder
 */
export const MsgCreateDerivativeLimitOrder = new MsgCreateDerivativeLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeLimitOrderResponse$Type extends MessageType<MsgCreateDerivativeLimitOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateDerivativeLimitOrderResponse>): MsgCreateDerivativeLimitOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeLimitOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeLimitOrderResponse): MsgCreateDerivativeLimitOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 2:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeLimitOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 2; */
        if (message.cid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse
 */
export const MsgCreateDerivativeLimitOrderResponse = new MsgCreateDerivativeLimitOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsLimitOrder$Type extends MessageType<MsgCreateBinaryOptionsLimitOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateBinaryOptionsLimitOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsLimitOrder>): MsgCreateBinaryOptionsLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsLimitOrder): MsgCreateBinaryOptionsLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v1beta1.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder
 */
export const MsgCreateBinaryOptionsLimitOrder = new MsgCreateBinaryOptionsLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsLimitOrderResponse$Type extends MessageType<MsgCreateBinaryOptionsLimitOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsLimitOrderResponse>): MsgCreateBinaryOptionsLimitOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsLimitOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsLimitOrderResponse): MsgCreateBinaryOptionsLimitOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 2:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsLimitOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 2; */
        if (message.cid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse
 */
export const MsgCreateBinaryOptionsLimitOrderResponse = new MsgCreateBinaryOptionsLimitOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateDerivativeLimitOrders$Type extends MessageType<MsgBatchCreateDerivativeLimitOrders> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCreateDerivativeLimitOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCreateDerivativeLimitOrders>): MsgBatchCreateDerivativeLimitOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.orders = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateDerivativeLimitOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateDerivativeLimitOrders): MsgBatchCreateDerivativeLimitOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.DerivativeOrder orders */ 2:
                    message.orders.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateDerivativeLimitOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v1beta1.DerivativeOrder orders = 2; */
        for (let i = 0; i < message.orders.length; i++)
            DerivativeOrder.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders
 */
export const MsgBatchCreateDerivativeLimitOrders = new MsgBatchCreateDerivativeLimitOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCreateDerivativeLimitOrdersResponse$Type extends MessageType<MsgBatchCreateDerivativeLimitOrdersResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse", [
            { no: 1, name: "order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "failed_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCreateDerivativeLimitOrdersResponse>): MsgBatchCreateDerivativeLimitOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHashes = [];
        message.createdOrdersCids = [];
        message.failedOrdersCids = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCreateDerivativeLimitOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCreateDerivativeLimitOrdersResponse): MsgBatchCreateDerivativeLimitOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string order_hashes */ 1:
                    message.orderHashes.push(reader.string());
                    break;
                case /* repeated string created_orders_cids */ 2:
                    message.createdOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_orders_cids */ 3:
                    message.failedOrdersCids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCreateDerivativeLimitOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string order_hashes = 1; */
        for (let i = 0; i < message.orderHashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.orderHashes[i]);
        /* repeated string created_orders_cids = 2; */
        for (let i = 0; i < message.createdOrdersCids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.createdOrdersCids[i]);
        /* repeated string failed_orders_cids = 3; */
        for (let i = 0; i < message.failedOrdersCids.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.failedOrdersCids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse
 */
export const MsgBatchCreateDerivativeLimitOrdersResponse = new MsgBatchCreateDerivativeLimitOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelSpotOrder$Type extends MessageType<MsgCancelSpotOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCancelSpotOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelSpotOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelSpotOrder>): MsgCancelSpotOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelSpotOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelSpotOrder): MsgCancelSpotOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 4:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 5:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelSpotOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 4; */
        if (message.orderHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 5; */
        if (message.cid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelSpotOrder
 */
export const MsgCancelSpotOrder = new MsgCancelSpotOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelSpotOrderResponse$Type extends MessageType<MsgCancelSpotOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCancelSpotOrderResponse", []);
    }
    create(value?: PartialMessage<MsgCancelSpotOrderResponse>): MsgCancelSpotOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelSpotOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelSpotOrderResponse): MsgCancelSpotOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelSpotOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelSpotOrderResponse
 */
export const MsgCancelSpotOrderResponse = new MsgCancelSpotOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelSpotOrders$Type extends MessageType<MsgBatchCancelSpotOrders> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCancelSpotOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelSpotOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCancelSpotOrders>): MsgBatchCancelSpotOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelSpotOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelSpotOrders): MsgBatchCancelSpotOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.OrderData data */ 2:
                    message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelSpotOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v1beta1.OrderData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelSpotOrders
 */
export const MsgBatchCancelSpotOrders = new MsgBatchCancelSpotOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelSpotOrdersResponse$Type extends MessageType<MsgBatchCancelSpotOrdersResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse", [
            { no: 1, name: "success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCancelSpotOrdersResponse>): MsgBatchCancelSpotOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelSpotOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelSpotOrdersResponse): MsgBatchCancelSpotOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.success.push(reader.bool());
                    else
                        message.success.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelSpotOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool success = 1; */
        if (message.success.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.success.length; i++)
                writer.bool(message.success[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse
 */
export const MsgBatchCancelSpotOrdersResponse = new MsgBatchCancelSpotOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelBinaryOptionsOrders$Type extends MessageType<MsgBatchCancelBinaryOptionsOrders> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelBinaryOptionsOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCancelBinaryOptionsOrders>): MsgBatchCancelBinaryOptionsOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelBinaryOptionsOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelBinaryOptionsOrders): MsgBatchCancelBinaryOptionsOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.OrderData data */ 2:
                    message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelBinaryOptionsOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v1beta1.OrderData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders
 */
export const MsgBatchCancelBinaryOptionsOrders = new MsgBatchCancelBinaryOptionsOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelBinaryOptionsOrdersResponse$Type extends MessageType<MsgBatchCancelBinaryOptionsOrdersResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse", [
            { no: 1, name: "success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCancelBinaryOptionsOrdersResponse>): MsgBatchCancelBinaryOptionsOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelBinaryOptionsOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelBinaryOptionsOrdersResponse): MsgBatchCancelBinaryOptionsOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.success.push(reader.bool());
                    else
                        message.success.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelBinaryOptionsOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool success = 1; */
        if (message.success.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.success.length; i++)
                writer.bool(message.success[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse
 */
export const MsgBatchCancelBinaryOptionsOrdersResponse = new MsgBatchCancelBinaryOptionsOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchUpdateOrders$Type extends MessageType<MsgBatchUpdateOrders> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchUpdateOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spot_market_ids_to_cancel_all", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "derivative_market_ids_to_cancel_all", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "spot_orders_to_cancel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": true } },
            { no: 6, name: "derivative_orders_to_cancel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": true } },
            { no: 7, name: "spot_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrder, options: { "gogoproto.nullable": true } },
            { no: 8, name: "derivative_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } },
            { no: 9, name: "binary_options_orders_to_cancel", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": true } },
            { no: 10, name: "binary_options_market_ids_to_cancel_all", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "binary_options_orders_to_create", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrder, options: { "gogoproto.nullable": true } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchUpdateOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchUpdateOrders>): MsgBatchUpdateOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        message.spotMarketIdsToCancelAll = [];
        message.derivativeMarketIdsToCancelAll = [];
        message.spotOrdersToCancel = [];
        message.derivativeOrdersToCancel = [];
        message.spotOrdersToCreate = [];
        message.derivativeOrdersToCreate = [];
        message.binaryOptionsOrdersToCancel = [];
        message.binaryOptionsMarketIdsToCancelAll = [];
        message.binaryOptionsOrdersToCreate = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchUpdateOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchUpdateOrders): MsgBatchUpdateOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated string spot_market_ids_to_cancel_all */ 3:
                    message.spotMarketIdsToCancelAll.push(reader.string());
                    break;
                case /* repeated string derivative_market_ids_to_cancel_all */ 4:
                    message.derivativeMarketIdsToCancelAll.push(reader.string());
                    break;
                case /* repeated injective.exchange.v1beta1.OrderData spot_orders_to_cancel */ 5:
                    message.spotOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.OrderData derivative_orders_to_cancel */ 6:
                    message.derivativeOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.SpotOrder spot_orders_to_create */ 7:
                    message.spotOrdersToCreate.push(SpotOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create */ 8:
                    message.derivativeOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel */ 9:
                    message.binaryOptionsOrdersToCancel.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string binary_options_market_ids_to_cancel_all */ 10:
                    message.binaryOptionsMarketIdsToCancelAll.push(reader.string());
                    break;
                case /* repeated injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create */ 11:
                    message.binaryOptionsOrdersToCreate.push(DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchUpdateOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated string spot_market_ids_to_cancel_all = 3; */
        for (let i = 0; i < message.spotMarketIdsToCancelAll.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.spotMarketIdsToCancelAll[i]);
        /* repeated string derivative_market_ids_to_cancel_all = 4; */
        for (let i = 0; i < message.derivativeMarketIdsToCancelAll.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.derivativeMarketIdsToCancelAll[i]);
        /* repeated injective.exchange.v1beta1.OrderData spot_orders_to_cancel = 5; */
        for (let i = 0; i < message.spotOrdersToCancel.length; i++)
            OrderData.internalBinaryWrite(message.spotOrdersToCancel[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.OrderData derivative_orders_to_cancel = 6; */
        for (let i = 0; i < message.derivativeOrdersToCancel.length; i++)
            OrderData.internalBinaryWrite(message.derivativeOrdersToCancel[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.SpotOrder spot_orders_to_create = 7; */
        for (let i = 0; i < message.spotOrdersToCreate.length; i++)
            SpotOrder.internalBinaryWrite(message.spotOrdersToCreate[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create = 8; */
        for (let i = 0; i < message.derivativeOrdersToCreate.length; i++)
            DerivativeOrder.internalBinaryWrite(message.derivativeOrdersToCreate[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel = 9; */
        for (let i = 0; i < message.binaryOptionsOrdersToCancel.length; i++)
            OrderData.internalBinaryWrite(message.binaryOptionsOrdersToCancel[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string binary_options_market_ids_to_cancel_all = 10; */
        for (let i = 0; i < message.binaryOptionsMarketIdsToCancelAll.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.binaryOptionsMarketIdsToCancelAll[i]);
        /* repeated injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create = 11; */
        for (let i = 0; i < message.binaryOptionsOrdersToCreate.length; i++)
            DerivativeOrder.internalBinaryWrite(message.binaryOptionsOrdersToCreate[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchUpdateOrders
 */
export const MsgBatchUpdateOrders = new MsgBatchUpdateOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchUpdateOrdersResponse$Type extends MessageType<MsgBatchUpdateOrdersResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse", [
            { no: 1, name: "spot_cancel_success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "derivative_cancel_success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "spot_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "derivative_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "binary_options_cancel_success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "binary_options_order_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_spot_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "failed_spot_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "created_derivative_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "failed_derivative_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "created_binary_options_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "failed_binary_options_orders_cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchUpdateOrdersResponse>): MsgBatchUpdateOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spotCancelSuccess = [];
        message.derivativeCancelSuccess = [];
        message.spotOrderHashes = [];
        message.derivativeOrderHashes = [];
        message.binaryOptionsCancelSuccess = [];
        message.binaryOptionsOrderHashes = [];
        message.createdSpotOrdersCids = [];
        message.failedSpotOrdersCids = [];
        message.createdDerivativeOrdersCids = [];
        message.failedDerivativeOrdersCids = [];
        message.createdBinaryOptionsOrdersCids = [];
        message.failedBinaryOptionsOrdersCids = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchUpdateOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchUpdateOrdersResponse): MsgBatchUpdateOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool spot_cancel_success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.spotCancelSuccess.push(reader.bool());
                    else
                        message.spotCancelSuccess.push(reader.bool());
                    break;
                case /* repeated bool derivative_cancel_success */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.derivativeCancelSuccess.push(reader.bool());
                    else
                        message.derivativeCancelSuccess.push(reader.bool());
                    break;
                case /* repeated string spot_order_hashes */ 3:
                    message.spotOrderHashes.push(reader.string());
                    break;
                case /* repeated string derivative_order_hashes */ 4:
                    message.derivativeOrderHashes.push(reader.string());
                    break;
                case /* repeated bool binary_options_cancel_success */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.binaryOptionsCancelSuccess.push(reader.bool());
                    else
                        message.binaryOptionsCancelSuccess.push(reader.bool());
                    break;
                case /* repeated string binary_options_order_hashes */ 6:
                    message.binaryOptionsOrderHashes.push(reader.string());
                    break;
                case /* repeated string created_spot_orders_cids */ 7:
                    message.createdSpotOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_spot_orders_cids */ 8:
                    message.failedSpotOrdersCids.push(reader.string());
                    break;
                case /* repeated string created_derivative_orders_cids */ 9:
                    message.createdDerivativeOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_derivative_orders_cids */ 10:
                    message.failedDerivativeOrdersCids.push(reader.string());
                    break;
                case /* repeated string created_binary_options_orders_cids */ 11:
                    message.createdBinaryOptionsOrdersCids.push(reader.string());
                    break;
                case /* repeated string failed_binary_options_orders_cids */ 12:
                    message.failedBinaryOptionsOrdersCids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchUpdateOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool spot_cancel_success = 1; */
        if (message.spotCancelSuccess.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.spotCancelSuccess.length; i++)
                writer.bool(message.spotCancelSuccess[i]);
            writer.join();
        }
        /* repeated bool derivative_cancel_success = 2; */
        if (message.derivativeCancelSuccess.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.derivativeCancelSuccess.length; i++)
                writer.bool(message.derivativeCancelSuccess[i]);
            writer.join();
        }
        /* repeated string spot_order_hashes = 3; */
        for (let i = 0; i < message.spotOrderHashes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.spotOrderHashes[i]);
        /* repeated string derivative_order_hashes = 4; */
        for (let i = 0; i < message.derivativeOrderHashes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.derivativeOrderHashes[i]);
        /* repeated bool binary_options_cancel_success = 5; */
        if (message.binaryOptionsCancelSuccess.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.binaryOptionsCancelSuccess.length; i++)
                writer.bool(message.binaryOptionsCancelSuccess[i]);
            writer.join();
        }
        /* repeated string binary_options_order_hashes = 6; */
        for (let i = 0; i < message.binaryOptionsOrderHashes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.binaryOptionsOrderHashes[i]);
        /* repeated string created_spot_orders_cids = 7; */
        for (let i = 0; i < message.createdSpotOrdersCids.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.createdSpotOrdersCids[i]);
        /* repeated string failed_spot_orders_cids = 8; */
        for (let i = 0; i < message.failedSpotOrdersCids.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.failedSpotOrdersCids[i]);
        /* repeated string created_derivative_orders_cids = 9; */
        for (let i = 0; i < message.createdDerivativeOrdersCids.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.createdDerivativeOrdersCids[i]);
        /* repeated string failed_derivative_orders_cids = 10; */
        for (let i = 0; i < message.failedDerivativeOrdersCids.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.failedDerivativeOrdersCids[i]);
        /* repeated string created_binary_options_orders_cids = 11; */
        for (let i = 0; i < message.createdBinaryOptionsOrdersCids.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.createdBinaryOptionsOrdersCids[i]);
        /* repeated string failed_binary_options_orders_cids = 12; */
        for (let i = 0; i < message.failedBinaryOptionsOrdersCids.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.failedBinaryOptionsOrdersCids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse
 */
export const MsgBatchUpdateOrdersResponse = new MsgBatchUpdateOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeMarketOrder$Type extends MessageType<MsgCreateDerivativeMarketOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateDerivativeMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateDerivativeMarketOrder>): MsgCreateDerivativeMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeMarketOrder): MsgCreateDerivativeMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v1beta1.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder
 */
export const MsgCreateDerivativeMarketOrder = new MsgCreateDerivativeMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateDerivativeMarketOrderResponse$Type extends MessageType<MsgCreateDerivativeMarketOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", T: () => DerivativeMarketOrderResults, options: { "gogoproto.nullable": true } },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateDerivativeMarketOrderResponse>): MsgCreateDerivativeMarketOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateDerivativeMarketOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateDerivativeMarketOrderResponse): MsgCreateDerivativeMarketOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeMarketOrderResults results */ 2:
                    message.results = DerivativeMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateDerivativeMarketOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2; */
        if (message.results)
            DerivativeMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse
 */
export const MsgCreateDerivativeMarketOrderResponse = new MsgCreateDerivativeMarketOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketOrderResults$Type extends MessageType<DerivativeMarketOrderResults> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeMarketOrderResults", [
            { no: 1, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "position_delta", kind: "message", T: () => PositionDelta, options: { "gogoproto.nullable": false } },
            { no: 5, name: "payout", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<DerivativeMarketOrderResults>): DerivativeMarketOrderResults {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = "";
        message.price = "";
        message.fee = "";
        message.payout = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketOrderResults>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketOrderResults): DerivativeMarketOrderResults {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string quantity */ 1:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* string fee */ 3:
                    message.fee = reader.string();
                    break;
                case /* injective.exchange.v1beta1.PositionDelta position_delta */ 4:
                    message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
                    break;
                case /* string payout */ 5:
                    message.payout = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketOrderResults, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string quantity = 1; */
        if (message.quantity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.quantity);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* string fee = 3; */
        if (message.fee !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fee);
        /* injective.exchange.v1beta1.PositionDelta position_delta = 4; */
        if (message.positionDelta)
            PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string payout = 5; */
        if (message.payout !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.payout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarketOrderResults
 */
export const DerivativeMarketOrderResults = new DerivativeMarketOrderResults$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsMarketOrder$Type extends MessageType<MsgCreateBinaryOptionsMarketOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCreateBinaryOptionsMarketOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsMarketOrder>): MsgCreateBinaryOptionsMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsMarketOrder): MsgCreateBinaryOptionsMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v1beta1.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder
 */
export const MsgCreateBinaryOptionsMarketOrder = new MsgCreateBinaryOptionsMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateBinaryOptionsMarketOrderResponse$Type extends MessageType<MsgCreateBinaryOptionsMarketOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse", [
            { no: 1, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", T: () => DerivativeMarketOrderResults, options: { "gogoproto.nullable": true } },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgCreateBinaryOptionsMarketOrderResponse>): MsgCreateBinaryOptionsMarketOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateBinaryOptionsMarketOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateBinaryOptionsMarketOrderResponse): MsgCreateBinaryOptionsMarketOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_hash */ 1:
                    message.orderHash = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeMarketOrderResults results */ 2:
                    message.results = DerivativeMarketOrderResults.internalBinaryRead(reader, reader.uint32(), options, message.results);
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateBinaryOptionsMarketOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_hash = 1; */
        if (message.orderHash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderHash);
        /* injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2; */
        if (message.results)
            DerivativeMarketOrderResults.internalBinaryWrite(message.results, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse
 */
export const MsgCreateBinaryOptionsMarketOrderResponse = new MsgCreateBinaryOptionsMarketOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelDerivativeOrder$Type extends MessageType<MsgCancelDerivativeOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCancelDerivativeOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "order_mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelDerivativeOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelDerivativeOrder>): MsgCancelDerivativeOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.orderMask = 0;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelDerivativeOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelDerivativeOrder): MsgCancelDerivativeOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 4:
                    message.orderHash = reader.string();
                    break;
                case /* int32 order_mask */ 5:
                    message.orderMask = reader.int32();
                    break;
                case /* string cid */ 6:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelDerivativeOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 4; */
        if (message.orderHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
        /* int32 order_mask = 5; */
        if (message.orderMask !== 0)
            writer.tag(5, WireType.Varint).int32(message.orderMask);
        /* string cid = 6; */
        if (message.cid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelDerivativeOrder
 */
export const MsgCancelDerivativeOrder = new MsgCancelDerivativeOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelDerivativeOrderResponse$Type extends MessageType<MsgCancelDerivativeOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse", []);
    }
    create(value?: PartialMessage<MsgCancelDerivativeOrderResponse>): MsgCancelDerivativeOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelDerivativeOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelDerivativeOrderResponse): MsgCancelDerivativeOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelDerivativeOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse
 */
export const MsgCancelDerivativeOrderResponse = new MsgCancelDerivativeOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelBinaryOptionsOrder$Type extends MessageType<MsgCancelBinaryOptionsOrder> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "order_mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgCancelBinaryOptionsOrder", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelBinaryOptionsOrder>): MsgCancelBinaryOptionsOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.orderMask = 0;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelBinaryOptionsOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelBinaryOptionsOrder): MsgCancelBinaryOptionsOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 3:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 4:
                    message.orderHash = reader.string();
                    break;
                case /* int32 order_mask */ 5:
                    message.orderMask = reader.int32();
                    break;
                case /* string cid */ 6:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelBinaryOptionsOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 3; */
        if (message.subaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 4; */
        if (message.orderHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orderHash);
        /* int32 order_mask = 5; */
        if (message.orderMask !== 0)
            writer.tag(5, WireType.Varint).int32(message.orderMask);
        /* string cid = 6; */
        if (message.cid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder
 */
export const MsgCancelBinaryOptionsOrder = new MsgCancelBinaryOptionsOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelBinaryOptionsOrderResponse$Type extends MessageType<MsgCancelBinaryOptionsOrderResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse", []);
    }
    create(value?: PartialMessage<MsgCancelBinaryOptionsOrderResponse>): MsgCancelBinaryOptionsOrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelBinaryOptionsOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelBinaryOptionsOrderResponse): MsgCancelBinaryOptionsOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelBinaryOptionsOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse
 */
export const MsgCancelBinaryOptionsOrderResponse = new MsgCancelBinaryOptionsOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderData$Type extends MessageType<OrderData> {
    constructor() {
        super("injective.exchange.v1beta1.OrderData", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order_mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderData>): OrderData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.orderMask = 0;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<OrderData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderData): OrderData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 3:
                    message.orderHash = reader.string();
                    break;
                case /* int32 order_mask */ 4:
                    message.orderMask = reader.int32();
                    break;
                case /* string cid */ 5:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 3; */
        if (message.orderHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.orderHash);
        /* int32 order_mask = 4; */
        if (message.orderMask !== 0)
            writer.tag(4, WireType.Varint).int32(message.orderMask);
        /* string cid = 5; */
        if (message.cid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OrderData
 */
export const OrderData = new OrderData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelDerivativeOrders$Type extends MessageType<MsgBatchCancelDerivativeOrders> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderData, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false, "amino.name": "exchange/MsgBatchCancelDerivativeOrders", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchCancelDerivativeOrders>): MsgBatchCancelDerivativeOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelDerivativeOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelDerivativeOrders): MsgBatchCancelDerivativeOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.OrderData data */ 2:
                    message.data.push(OrderData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelDerivativeOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v1beta1.OrderData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            OrderData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders
 */
export const MsgBatchCancelDerivativeOrders = new MsgBatchCancelDerivativeOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchCancelDerivativeOrdersResponse$Type extends MessageType<MsgBatchCancelDerivativeOrdersResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse", [
            { no: 1, name: "success", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBatchCancelDerivativeOrdersResponse>): MsgBatchCancelDerivativeOrdersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBatchCancelDerivativeOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchCancelDerivativeOrdersResponse): MsgBatchCancelDerivativeOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool success */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.success.push(reader.bool());
                    else
                        message.success.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchCancelDerivativeOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool success = 1; */
        if (message.success.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.success.length; i++)
                writer.bool(message.success[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse
 */
export const MsgBatchCancelDerivativeOrdersResponse = new MsgBatchCancelDerivativeOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubaccountTransfer$Type extends MessageType<MsgSubaccountTransfer> {
    constructor() {
        super("injective.exchange.v1beta1.MsgSubaccountTransfer", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "exchange/MsgSubaccountTransfer", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgSubaccountTransfer>): MsgSubaccountTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSubaccountTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubaccountTransfer): MsgSubaccountTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 4:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubaccountTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* cosmos.base.v1beta1.Coin amount = 4; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgSubaccountTransfer
 */
export const MsgSubaccountTransfer = new MsgSubaccountTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubaccountTransferResponse$Type extends MessageType<MsgSubaccountTransferResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgSubaccountTransferResponse", []);
    }
    create(value?: PartialMessage<MsgSubaccountTransferResponse>): MsgSubaccountTransferResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSubaccountTransferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubaccountTransferResponse): MsgSubaccountTransferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubaccountTransferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgSubaccountTransferResponse
 */
export const MsgSubaccountTransferResponse = new MsgSubaccountTransferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExternalTransfer$Type extends MessageType<MsgExternalTransfer> {
    constructor() {
        super("injective.exchange.v1beta1.MsgExternalTransfer", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "exchange/MsgExternalTransfer", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgExternalTransfer>): MsgExternalTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgExternalTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExternalTransfer): MsgExternalTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 4:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExternalTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* cosmos.base.v1beta1.Coin amount = 4; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgExternalTransfer
 */
export const MsgExternalTransfer = new MsgExternalTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExternalTransferResponse$Type extends MessageType<MsgExternalTransferResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgExternalTransferResponse", []);
    }
    create(value?: PartialMessage<MsgExternalTransferResponse>): MsgExternalTransferResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgExternalTransferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExternalTransferResponse): MsgExternalTransferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExternalTransferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgExternalTransferResponse
 */
export const MsgExternalTransferResponse = new MsgExternalTransferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLiquidatePosition$Type extends MessageType<MsgLiquidatePosition> {
    constructor() {
        super("injective.exchange.v1beta1.MsgLiquidatePosition", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order", kind: "message", T: () => DerivativeOrder, options: { "gogoproto.nullable": true } }
        ], { "amino.name": "exchange/MsgLiquidatePosition", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgLiquidatePosition>): MsgLiquidatePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgLiquidatePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLiquidatePosition): MsgLiquidatePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeOrder order */ 4:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgLiquidatePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.DerivativeOrder order = 4; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgLiquidatePosition
 */
export const MsgLiquidatePosition = new MsgLiquidatePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLiquidatePositionResponse$Type extends MessageType<MsgLiquidatePositionResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgLiquidatePositionResponse", []);
    }
    create(value?: PartialMessage<MsgLiquidatePositionResponse>): MsgLiquidatePositionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgLiquidatePositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLiquidatePositionResponse): MsgLiquidatePositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgLiquidatePositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgLiquidatePositionResponse
 */
export const MsgLiquidatePositionResponse = new MsgLiquidatePositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgEmergencySettleMarket$Type extends MessageType<MsgEmergencySettleMarket> {
    constructor() {
        super("injective.exchange.v1beta1.MsgEmergencySettleMarket", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "exchange/MsgEmergencySettleMarket", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgEmergencySettleMarket>): MsgEmergencySettleMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.subaccountId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MsgEmergencySettleMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgEmergencySettleMarket): MsgEmergencySettleMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgEmergencySettleMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgEmergencySettleMarket
 */
export const MsgEmergencySettleMarket = new MsgEmergencySettleMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgEmergencySettleMarketResponse$Type extends MessageType<MsgEmergencySettleMarketResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgEmergencySettleMarketResponse", []);
    }
    create(value?: PartialMessage<MsgEmergencySettleMarketResponse>): MsgEmergencySettleMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgEmergencySettleMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgEmergencySettleMarketResponse): MsgEmergencySettleMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgEmergencySettleMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgEmergencySettleMarketResponse
 */
export const MsgEmergencySettleMarketResponse = new MsgEmergencySettleMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgIncreasePositionMargin$Type extends MessageType<MsgIncreasePositionMargin> {
    constructor() {
        super("injective.exchange.v1beta1.MsgIncreasePositionMargin", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "amino.name": "exchange/MsgIncreasePositionMargin", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgIncreasePositionMargin>): MsgIncreasePositionMargin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        message.marketId = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<MsgIncreasePositionMargin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgIncreasePositionMargin): MsgIncreasePositionMargin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgIncreasePositionMargin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgIncreasePositionMargin
 */
export const MsgIncreasePositionMargin = new MsgIncreasePositionMargin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgIncreasePositionMarginResponse$Type extends MessageType<MsgIncreasePositionMarginResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgIncreasePositionMarginResponse", []);
    }
    create(value?: PartialMessage<MsgIncreasePositionMarginResponse>): MsgIncreasePositionMarginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgIncreasePositionMarginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgIncreasePositionMarginResponse): MsgIncreasePositionMarginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgIncreasePositionMarginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgIncreasePositionMarginResponse
 */
export const MsgIncreasePositionMarginResponse = new MsgIncreasePositionMarginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDecreasePositionMargin$Type extends MessageType<MsgDecreasePositionMargin> {
    constructor() {
        super("injective.exchange.v1beta1.MsgDecreasePositionMargin", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "destination_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "amino.name": "exchange/MsgDecreasePositionMargin", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgDecreasePositionMargin>): MsgDecreasePositionMargin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.sourceSubaccountId = "";
        message.destinationSubaccountId = "";
        message.marketId = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<MsgDecreasePositionMargin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDecreasePositionMargin): MsgDecreasePositionMargin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string source_subaccount_id */ 2:
                    message.sourceSubaccountId = reader.string();
                    break;
                case /* string destination_subaccount_id */ 3:
                    message.destinationSubaccountId = reader.string();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDecreasePositionMargin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string source_subaccount_id = 2; */
        if (message.sourceSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceSubaccountId);
        /* string destination_subaccount_id = 3; */
        if (message.destinationSubaccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destinationSubaccountId);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgDecreasePositionMargin
 */
export const MsgDecreasePositionMargin = new MsgDecreasePositionMargin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDecreasePositionMarginResponse$Type extends MessageType<MsgDecreasePositionMarginResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgDecreasePositionMarginResponse", []);
    }
    create(value?: PartialMessage<MsgDecreasePositionMarginResponse>): MsgDecreasePositionMarginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgDecreasePositionMarginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDecreasePositionMarginResponse): MsgDecreasePositionMarginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDecreasePositionMarginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgDecreasePositionMarginResponse
 */
export const MsgDecreasePositionMarginResponse = new MsgDecreasePositionMarginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPrivilegedExecuteContract$Type extends MessageType<MsgPrivilegedExecuteContract> {
    constructor() {
        super("injective.exchange.v1beta1.MsgPrivilegedExecuteContract", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "funds", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgPrivilegedExecuteContract", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgPrivilegedExecuteContract>): MsgPrivilegedExecuteContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.funds = "";
        message.contractAddress = "";
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<MsgPrivilegedExecuteContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPrivilegedExecuteContract): MsgPrivilegedExecuteContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string funds */ 2:
                    message.funds = reader.string();
                    break;
                case /* string contract_address */ 3:
                    message.contractAddress = reader.string();
                    break;
                case /* string data */ 4:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPrivilegedExecuteContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string funds = 2; */
        if (message.funds !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.funds);
        /* string contract_address = 3; */
        if (message.contractAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contractAddress);
        /* string data = 4; */
        if (message.data !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgPrivilegedExecuteContract
 */
export const MsgPrivilegedExecuteContract = new MsgPrivilegedExecuteContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPrivilegedExecuteContractResponse$Type extends MessageType<MsgPrivilegedExecuteContractResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse", [
            { no: 1, name: "funds_diff", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgPrivilegedExecuteContractResponse>): MsgPrivilegedExecuteContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fundsDiff = [];
        if (value !== undefined)
            reflectionMergePartial<MsgPrivilegedExecuteContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPrivilegedExecuteContractResponse): MsgPrivilegedExecuteContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin funds_diff */ 1:
                    message.fundsDiff.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPrivilegedExecuteContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin funds_diff = 1; */
        for (let i = 0; i < message.fundsDiff.length; i++)
            Coin.internalBinaryWrite(message.fundsDiff[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse
 */
export const MsgPrivilegedExecuteContractResponse = new MsgPrivilegedExecuteContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRewardsOptOut$Type extends MessageType<MsgRewardsOptOut> {
    constructor() {
        super("injective.exchange.v1beta1.MsgRewardsOptOut", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgRewardsOptOut", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRewardsOptOut>): MsgRewardsOptOut {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgRewardsOptOut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRewardsOptOut): MsgRewardsOptOut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRewardsOptOut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgRewardsOptOut
 */
export const MsgRewardsOptOut = new MsgRewardsOptOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRewardsOptOutResponse$Type extends MessageType<MsgRewardsOptOutResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgRewardsOptOutResponse", []);
    }
    create(value?: PartialMessage<MsgRewardsOptOutResponse>): MsgRewardsOptOutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRewardsOptOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRewardsOptOutResponse): MsgRewardsOptOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRewardsOptOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgRewardsOptOutResponse
 */
export const MsgRewardsOptOutResponse = new MsgRewardsOptOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgReclaimLockedFunds$Type extends MessageType<MsgReclaimLockedFunds> {
    constructor() {
        super("injective.exchange.v1beta1.MsgReclaimLockedFunds", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "lockedAccountPubKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "amino.name": "exchange/MsgReclaimLockedFunds", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgReclaimLockedFunds>): MsgReclaimLockedFunds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.lockedAccountPubKey = new Uint8Array(0);
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgReclaimLockedFunds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgReclaimLockedFunds): MsgReclaimLockedFunds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* bytes lockedAccountPubKey */ 2:
                    message.lockedAccountPubKey = reader.bytes();
                    break;
                case /* bytes signature */ 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgReclaimLockedFunds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* bytes lockedAccountPubKey = 2; */
        if (message.lockedAccountPubKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.lockedAccountPubKey);
        /* bytes signature = 3; */
        if (message.signature.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgReclaimLockedFunds
 */
export const MsgReclaimLockedFunds = new MsgReclaimLockedFunds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgReclaimLockedFundsResponse$Type extends MessageType<MsgReclaimLockedFundsResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgReclaimLockedFundsResponse", []);
    }
    create(value?: PartialMessage<MsgReclaimLockedFundsResponse>): MsgReclaimLockedFundsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgReclaimLockedFundsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgReclaimLockedFundsResponse): MsgReclaimLockedFundsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgReclaimLockedFundsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgReclaimLockedFundsResponse
 */
export const MsgReclaimLockedFundsResponse = new MsgReclaimLockedFundsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSignData$Type extends MessageType<MsgSignData> {
    constructor() {
        super("injective.exchange.v1beta1.MsgSignData", [
            { no: 1, name: "Signer", kind: "scalar", jsonName: "Signer", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "signer", "gogoproto.casttype": "github.com/cosmos/cosmos-sdk/types.AccAddress" } },
            { no: 2, name: "Data", kind: "scalar", jsonName: "Data", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "data" } }
        ]);
    }
    create(value?: PartialMessage<MsgSignData>): MsgSignData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signer = new Uint8Array(0);
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgSignData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSignData): MsgSignData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes Signer */ 1:
                    message.signer = reader.bytes();
                    break;
                case /* bytes Data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSignData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes Signer = 1; */
        if (message.signer.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signer);
        /* bytes Data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgSignData
 */
export const MsgSignData = new MsgSignData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSignDoc$Type extends MessageType<MsgSignDoc> {
    constructor() {
        super("injective.exchange.v1beta1.MsgSignDoc", [
            { no: 1, name: "sign_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "value", kind: "message", T: () => MsgSignData, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<MsgSignDoc>): MsgSignDoc {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signType = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSignDoc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSignDoc): MsgSignDoc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sign_type */ 1:
                    message.signType = reader.string();
                    break;
                case /* injective.exchange.v1beta1.MsgSignData value */ 2:
                    message.value = MsgSignData.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSignDoc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sign_type = 1; */
        if (message.signType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signType);
        /* injective.exchange.v1beta1.MsgSignData value = 2; */
        if (message.value)
            MsgSignData.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgSignDoc
 */
export const MsgSignDoc = new MsgSignDoc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAdminUpdateBinaryOptionsMarket$Type extends MessageType<MsgAdminUpdateBinaryOptionsMarket> {
    constructor() {
        super("injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] }
        ], { "amino.name": "exchange/MsgAdminUpdateBinaryOptionsMarket", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgAdminUpdateBinaryOptionsMarket>): MsgAdminUpdateBinaryOptionsMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.marketId = "";
        message.settlementPrice = "";
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<MsgAdminUpdateBinaryOptionsMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAdminUpdateBinaryOptionsMarket): MsgAdminUpdateBinaryOptionsMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string settlement_price */ 3:
                    message.settlementPrice = reader.string();
                    break;
                case /* int64 expiration_timestamp */ 4:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 5:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* injective.exchange.v1beta1.MarketStatus status */ 6:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAdminUpdateBinaryOptionsMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string settlement_price = 3; */
        if (message.settlementPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.settlementPrice);
        /* int64 expiration_timestamp = 4; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 5; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(5, WireType.Varint).int64(message.settlementTimestamp);
        /* injective.exchange.v1beta1.MarketStatus status = 6; */
        if (message.status !== 0)
            writer.tag(6, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket
 */
export const MsgAdminUpdateBinaryOptionsMarket = new MsgAdminUpdateBinaryOptionsMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAdminUpdateBinaryOptionsMarketResponse$Type extends MessageType<MsgAdminUpdateBinaryOptionsMarketResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse", []);
    }
    create(value?: PartialMessage<MsgAdminUpdateBinaryOptionsMarketResponse>): MsgAdminUpdateBinaryOptionsMarketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgAdminUpdateBinaryOptionsMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAdminUpdateBinaryOptionsMarketResponse): MsgAdminUpdateBinaryOptionsMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAdminUpdateBinaryOptionsMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse
 */
export const MsgAdminUpdateBinaryOptionsMarketResponse = new MsgAdminUpdateBinaryOptionsMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAuthorizeStakeGrants$Type extends MessageType<MsgAuthorizeStakeGrants> {
    constructor() {
        super("injective.exchange.v1beta1.MsgAuthorizeStakeGrants", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grants", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GrantAuthorization }
        ], { "amino.name": "exchange/MsgAuthorizeStakeGrants", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgAuthorizeStakeGrants>): MsgAuthorizeStakeGrants {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.grants = [];
        if (value !== undefined)
            reflectionMergePartial<MsgAuthorizeStakeGrants>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAuthorizeStakeGrants): MsgAuthorizeStakeGrants {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.GrantAuthorization grants */ 2:
                    message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAuthorizeStakeGrants, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.exchange.v1beta1.GrantAuthorization grants = 2; */
        for (let i = 0; i < message.grants.length; i++)
            GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgAuthorizeStakeGrants
 */
export const MsgAuthorizeStakeGrants = new MsgAuthorizeStakeGrants$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAuthorizeStakeGrantsResponse$Type extends MessageType<MsgAuthorizeStakeGrantsResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse", []);
    }
    create(value?: PartialMessage<MsgAuthorizeStakeGrantsResponse>): MsgAuthorizeStakeGrantsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgAuthorizeStakeGrantsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAuthorizeStakeGrantsResponse): MsgAuthorizeStakeGrantsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAuthorizeStakeGrantsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse
 */
export const MsgAuthorizeStakeGrantsResponse = new MsgAuthorizeStakeGrantsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgActivateStakeGrant$Type extends MessageType<MsgActivateStakeGrant> {
    constructor() {
        super("injective.exchange.v1beta1.MsgActivateStakeGrant", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "exchange/MsgActivateStakeGrant", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgActivateStakeGrant>): MsgActivateStakeGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.granter = "";
        if (value !== undefined)
            reflectionMergePartial<MsgActivateStakeGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgActivateStakeGrant): MsgActivateStakeGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string granter */ 2:
                    message.granter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgActivateStakeGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string granter = 2; */
        if (message.granter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.granter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgActivateStakeGrant
 */
export const MsgActivateStakeGrant = new MsgActivateStakeGrant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgActivateStakeGrantResponse$Type extends MessageType<MsgActivateStakeGrantResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgActivateStakeGrantResponse", []);
    }
    create(value?: PartialMessage<MsgActivateStakeGrantResponse>): MsgActivateStakeGrantResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgActivateStakeGrantResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgActivateStakeGrantResponse): MsgActivateStakeGrantResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgActivateStakeGrantResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgActivateStakeGrantResponse
 */
export const MsgActivateStakeGrantResponse = new MsgActivateStakeGrantResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchExchangeModification$Type extends MessageType<MsgBatchExchangeModification> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchExchangeModification", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proposal", kind: "message", T: () => BatchExchangeModificationProposal }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "exchange/MsgBatchExchangeModification", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgBatchExchangeModification>): MsgBatchExchangeModification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgBatchExchangeModification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchExchangeModification): MsgBatchExchangeModification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.exchange.v1beta1.BatchExchangeModificationProposal proposal */ 2:
                    message.proposal = BatchExchangeModificationProposal.internalBinaryRead(reader, reader.uint32(), options, message.proposal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchExchangeModification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.exchange.v1beta1.BatchExchangeModificationProposal proposal = 2; */
        if (message.proposal)
            BatchExchangeModificationProposal.internalBinaryWrite(message.proposal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchExchangeModification
 */
export const MsgBatchExchangeModification = new MsgBatchExchangeModification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBatchExchangeModificationResponse$Type extends MessageType<MsgBatchExchangeModificationResponse> {
    constructor() {
        super("injective.exchange.v1beta1.MsgBatchExchangeModificationResponse", []);
    }
    create(value?: PartialMessage<MsgBatchExchangeModificationResponse>): MsgBatchExchangeModificationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgBatchExchangeModificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBatchExchangeModificationResponse): MsgBatchExchangeModificationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBatchExchangeModificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchExchangeModificationResponse
 */
export const MsgBatchExchangeModificationResponse = new MsgBatchExchangeModificationResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.exchange.v1beta1.Msg
 */
export const Msg = new ServiceType("injective.exchange.v1beta1.Msg", [
    { name: "Deposit", options: {}, I: MsgDeposit, O: MsgDepositResponse },
    { name: "Withdraw", options: {}, I: MsgWithdraw, O: MsgWithdrawResponse },
    { name: "InstantSpotMarketLaunch", options: {}, I: MsgInstantSpotMarketLaunch, O: MsgInstantSpotMarketLaunchResponse },
    { name: "CreateSpotLimitOrder", options: {}, I: MsgCreateSpotLimitOrder, O: MsgCreateSpotLimitOrderResponse },
    { name: "BatchCreateSpotLimitOrders", options: {}, I: MsgBatchCreateSpotLimitOrders, O: MsgBatchCreateSpotLimitOrdersResponse },
    { name: "CreateSpotMarketOrder", options: {}, I: MsgCreateSpotMarketOrder, O: MsgCreateSpotMarketOrderResponse },
    { name: "CancelSpotOrder", options: {}, I: MsgCancelSpotOrder, O: MsgCancelSpotOrderResponse },
    { name: "BatchCancelSpotOrders", options: {}, I: MsgBatchCancelSpotOrders, O: MsgBatchCancelSpotOrdersResponse },
    { name: "BatchUpdateOrders", options: {}, I: MsgBatchUpdateOrders, O: MsgBatchUpdateOrdersResponse },
    { name: "PrivilegedExecuteContract", options: {}, I: MsgPrivilegedExecuteContract, O: MsgPrivilegedExecuteContractResponse },
    { name: "CreateDerivativeLimitOrder", options: {}, I: MsgCreateDerivativeLimitOrder, O: MsgCreateDerivativeLimitOrderResponse },
    { name: "BatchCreateDerivativeLimitOrders", options: {}, I: MsgBatchCreateDerivativeLimitOrders, O: MsgBatchCreateDerivativeLimitOrdersResponse },
    { name: "CreateDerivativeMarketOrder", options: {}, I: MsgCreateDerivativeMarketOrder, O: MsgCreateDerivativeMarketOrderResponse },
    { name: "CancelDerivativeOrder", options: {}, I: MsgCancelDerivativeOrder, O: MsgCancelDerivativeOrderResponse },
    { name: "BatchCancelDerivativeOrders", options: {}, I: MsgBatchCancelDerivativeOrders, O: MsgBatchCancelDerivativeOrdersResponse },
    { name: "InstantBinaryOptionsMarketLaunch", options: {}, I: MsgInstantBinaryOptionsMarketLaunch, O: MsgInstantBinaryOptionsMarketLaunchResponse },
    { name: "CreateBinaryOptionsLimitOrder", options: {}, I: MsgCreateBinaryOptionsLimitOrder, O: MsgCreateBinaryOptionsLimitOrderResponse },
    { name: "CreateBinaryOptionsMarketOrder", options: {}, I: MsgCreateBinaryOptionsMarketOrder, O: MsgCreateBinaryOptionsMarketOrderResponse },
    { name: "CancelBinaryOptionsOrder", options: {}, I: MsgCancelBinaryOptionsOrder, O: MsgCancelBinaryOptionsOrderResponse },
    { name: "BatchCancelBinaryOptionsOrders", options: {}, I: MsgBatchCancelBinaryOptionsOrders, O: MsgBatchCancelBinaryOptionsOrdersResponse },
    { name: "SubaccountTransfer", options: {}, I: MsgSubaccountTransfer, O: MsgSubaccountTransferResponse },
    { name: "ExternalTransfer", options: {}, I: MsgExternalTransfer, O: MsgExternalTransferResponse },
    { name: "LiquidatePosition", options: {}, I: MsgLiquidatePosition, O: MsgLiquidatePositionResponse },
    { name: "EmergencySettleMarket", options: {}, I: MsgEmergencySettleMarket, O: MsgEmergencySettleMarketResponse },
    { name: "IncreasePositionMargin", options: {}, I: MsgIncreasePositionMargin, O: MsgIncreasePositionMarginResponse },
    { name: "DecreasePositionMargin", options: {}, I: MsgDecreasePositionMargin, O: MsgDecreasePositionMarginResponse },
    { name: "RewardsOptOut", options: {}, I: MsgRewardsOptOut, O: MsgRewardsOptOutResponse },
    { name: "AdminUpdateBinaryOptionsMarket", options: {}, I: MsgAdminUpdateBinaryOptionsMarket, O: MsgAdminUpdateBinaryOptionsMarketResponse },
    { name: "UpdateSpotMarket", options: {}, I: MsgUpdateSpotMarket, O: MsgUpdateSpotMarketResponse },
    { name: "UpdateDerivativeMarket", options: {}, I: MsgUpdateDerivativeMarket, O: MsgUpdateDerivativeMarketResponse },
    { name: "AuthorizeStakeGrants", options: {}, I: MsgAuthorizeStakeGrants, O: MsgAuthorizeStakeGrantsResponse },
    { name: "ActivateStakeGrant", options: {}, I: MsgActivateStakeGrant, O: MsgActivateStakeGrantResponse },
    { name: "BatchExchangeModification", options: {}, I: MsgBatchExchangeModification, O: MsgBatchExchangeModificationResponse }
], { "cosmos.msg.v1.service": true });
