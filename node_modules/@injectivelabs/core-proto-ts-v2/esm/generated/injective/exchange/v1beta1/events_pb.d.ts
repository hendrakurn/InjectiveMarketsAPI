// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v1beta1/events.proto" (package "injective.exchange.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GrantAuthorization } from "./exchange_pb";
import { Level } from "./exchange_pb";
import { MarketFeeMultiplier } from "./exchange_pb";
import { DerivativeOrder } from "./exchange_pb";
import { AccountRewards } from "./exchange_pb";
import { CampaignRewardPool } from "./exchange_pb";
import { TradingRewardCampaignInfo } from "./exchange_pb";
import { FeeDiscountSchedule } from "./exchange_pb";
import { DerivativeMarketOrder } from "./exchange_pb";
import { DepositUpdate } from "./exchange_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
import { ExpiryFuturesMarketInfo } from "./exchange_pb";
import { PerpetualMarketFunding } from "./exchange_pb";
import { PerpetualMarketInfo } from "./exchange_pb";
import { DerivativeMarket } from "./exchange_pb";
import { SpotMarket } from "./exchange_pb";
import { DerivativeLimitOrder } from "./exchange_pb";
import { SpotLimitOrder } from "./exchange_pb";
import { BinaryOptionsMarket } from "./exchange_pb";
import { SubaccountPosition } from "./exchange_pb";
import { DerivativeTradeLog } from "./exchange_pb";
import { TradeLog } from "./exchange_pb";
import { ExecutionType } from "./exchange_pb";
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventBatchSpotExecution
 */
export interface EventBatchSpotExecution {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: bool is_buy = 2
     */
    isBuy: boolean;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.ExecutionType executionType = 3
     */
    executionType: ExecutionType;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.TradeLog trades = 4
     */
    trades: TradeLog[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventBatchDerivativeExecution
 */
export interface EventBatchDerivativeExecution {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: bool is_buy = 2
     */
    isBuy: boolean;
    /**
     * @generated from protobuf field: bool is_liquidation = 3
     */
    isLiquidation: boolean;
    /**
     * nil for time expiry futures
     *
     * @generated from protobuf field: string cumulative_funding = 4
     */
    cumulativeFunding: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.ExecutionType executionType = 5
     */
    executionType: ExecutionType;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeTradeLog trades = 6
     */
    trades: DerivativeTradeLog[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventLostFundsFromLiquidation
 */
export interface EventLostFundsFromLiquidation {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: bytes subaccount_id = 2
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: string lost_funds_from_available_during_payout = 3
     */
    lostFundsFromAvailableDuringPayout: string;
    /**
     * @generated from protobuf field: string lost_funds_from_order_cancels = 4
     */
    lostFundsFromOrderCancels: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventBatchDerivativePosition
 */
export interface EventBatchDerivativePosition {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.SubaccountPosition positions = 2
     */
    positions: SubaccountPosition[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventDerivativeMarketPaused
 */
export interface EventDerivativeMarketPaused {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string settle_price = 2
     */
    settlePrice: string;
    /**
     * @generated from protobuf field: string total_missing_funds = 3
     */
    totalMissingFunds: string;
    /**
     * @generated from protobuf field: string missing_funds_rate = 4
     */
    missingFundsRate: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventSettledMarketBalance
 */
export interface EventSettledMarketBalance {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventNotSettledMarketBalance
 */
export interface EventNotSettledMarketBalance {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventMarketBeyondBankruptcy
 */
export interface EventMarketBeyondBankruptcy {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string settle_price = 2
     */
    settlePrice: string;
    /**
     * @generated from protobuf field: string missing_market_funds = 3
     */
    missingMarketFunds: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventAllPositionsHaircut
 */
export interface EventAllPositionsHaircut {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string settle_price = 2
     */
    settlePrice: string;
    /**
     * @generated from protobuf field: string missing_funds_rate = 3
     */
    missingFundsRate: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate
 */
export interface EventBinaryOptionsMarketUpdate {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.BinaryOptionsMarket market = 1
     */
    market?: BinaryOptionsMarket;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventNewSpotOrders
 */
export interface EventNewSpotOrders {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2
     */
    buyOrders: SpotLimitOrder[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3
     */
    sellOrders: SpotLimitOrder[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventNewDerivativeOrders
 */
export interface EventNewDerivativeOrders {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2
     */
    buyOrders: DerivativeLimitOrder[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3
     */
    sellOrders: DerivativeLimitOrder[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventCancelSpotOrder
 */
export interface EventCancelSpotOrder {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.SpotLimitOrder order = 2
     */
    order?: SpotLimitOrder;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventSpotMarketUpdate
 */
export interface EventSpotMarketUpdate {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.SpotMarket market = 1
     */
    market?: SpotMarket;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventPerpetualMarketUpdate
 */
export interface EventPerpetualMarketUpdate {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarket market = 1
     */
    market?: DerivativeMarket;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2
     */
    perpetualMarketInfo?: PerpetualMarketInfo;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.PerpetualMarketFunding funding = 3
     */
    funding?: PerpetualMarketFunding;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate
 */
export interface EventExpiryFuturesMarketUpdate {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarket market = 1
     */
    market?: DerivativeMarket;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3
     */
    expiryFuturesMarketInfo?: ExpiryFuturesMarketInfo;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate
 */
export interface EventPerpetualMarketFundingUpdate {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.PerpetualMarketFunding funding = 2
     */
    funding?: PerpetualMarketFunding;
    /**
     * @generated from protobuf field: bool is_hourly_funding = 3
     */
    isHourlyFunding: boolean;
    /**
     * @generated from protobuf field: string funding_rate = 4
     */
    fundingRate: string;
    /**
     * @generated from protobuf field: string mark_price = 5
     */
    markPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventSubaccountDeposit
 */
export interface EventSubaccountDeposit {
    /**
     * @generated from protobuf field: string src_address = 1
     */
    srcAddress: string;
    /**
     * @generated from protobuf field: bytes subaccount_id = 2
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventSubaccountWithdraw
 */
export interface EventSubaccountWithdraw {
    /**
     * @generated from protobuf field: bytes subaccount_id = 1
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: string dst_address = 2
     */
    dstAddress: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventSubaccountBalanceTransfer
 */
export interface EventSubaccountBalanceTransfer {
    /**
     * @generated from protobuf field: string src_subaccount_id = 1
     */
    srcSubaccountId: string;
    /**
     * @generated from protobuf field: string dst_subaccount_id = 2
     */
    dstSubaccountId: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventBatchDepositUpdate
 */
export interface EventBatchDepositUpdate {
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.DepositUpdate deposit_updates = 1
     */
    depositUpdates: DepositUpdate[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarketOrderCancel
 */
export interface DerivativeMarketOrderCancel {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1
     */
    marketOrder?: DerivativeMarketOrder;
    /**
     * @generated from protobuf field: string cancel_quantity = 2
     */
    cancelQuantity: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventCancelDerivativeOrder
 */
export interface EventCancelDerivativeOrder {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: bool isLimitCancel = 2
     */
    isLimitCancel: boolean;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3
     */
    limitOrder?: DerivativeLimitOrder;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4
     */
    marketOrderCancel?: DerivativeMarketOrderCancel;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventFeeDiscountSchedule
 */
export interface EventFeeDiscountSchedule {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1
     */
    schedule?: FeeDiscountSchedule;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventTradingRewardCampaignUpdate
 */
export interface EventTradingRewardCampaignUpdate {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1
     */
    campaignInfo?: TradingRewardCampaignInfo;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2
     */
    campaignRewardPools: CampaignRewardPool[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventTradingRewardDistribution
 */
export interface EventTradingRewardDistribution {
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.AccountRewards account_rewards = 1
     */
    accountRewards: AccountRewards[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventNewConditionalDerivativeOrder
 */
export interface EventNewConditionalDerivativeOrder {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
     */
    order?: DerivativeOrder;
    /**
     * @generated from protobuf field: bytes hash = 3
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: bool is_market = 4
     */
    isMarket: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder
 */
export interface EventCancelConditionalDerivativeOrder {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: bool isLimitCancel = 2
     */
    isLimitCancel: boolean;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3
     */
    limitOrder?: DerivativeLimitOrder;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4
     */
    marketOrder?: DerivativeMarketOrder;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger
 */
export interface EventConditionalDerivativeOrderTrigger {
    /**
     * @generated from protobuf field: bytes market_id = 1
     */
    marketId: Uint8Array;
    /**
     * @generated from protobuf field: bool isLimitTrigger = 2
     */
    isLimitTrigger: boolean;
    /**
     * @generated from protobuf field: bytes triggered_order_hash = 3
     */
    triggeredOrderHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes placed_order_hash = 4
     */
    placedOrderHash: Uint8Array;
    /**
     * @generated from protobuf field: string triggered_order_cid = 5
     */
    triggeredOrderCid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventOrderFail
 */
export interface EventOrderFail {
    /**
     * @generated from protobuf field: bytes account = 1
     */
    account: Uint8Array;
    /**
     * @generated from protobuf field: repeated bytes hashes = 2
     */
    hashes: Uint8Array[];
    /**
     * @generated from protobuf field: repeated uint32 flags = 3
     */
    flags: number[];
    /**
     * @generated from protobuf field: repeated string cids = 4
     */
    cids: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated
 */
export interface EventAtomicMarketOrderFeeMultipliersUpdated {
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1
     */
    marketFeeMultipliers: MarketFeeMultiplier[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventOrderbookUpdate
 */
export interface EventOrderbookUpdate {
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1
     */
    spotUpdates: OrderbookUpdate[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2
     */
    derivativeUpdates: OrderbookUpdate[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OrderbookUpdate
 */
export interface OrderbookUpdate {
    /**
     * @generated from protobuf field: uint64 seq = 1
     */
    seq: bigint;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.Orderbook orderbook = 2
     */
    orderbook?: Orderbook;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.Orderbook
 */
export interface Orderbook {
    /**
     * @generated from protobuf field: bytes market_id = 1
     */
    marketId: Uint8Array;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.Level buy_levels = 2
     */
    buyLevels: Level[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.Level sell_levels = 3
     */
    sellLevels: Level[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventGrantAuthorizations
 */
export interface EventGrantAuthorizations {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.GrantAuthorization grants = 2
     */
    grants: GrantAuthorization[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventGrantActivation
 */
export interface EventGrantActivation {
    /**
     * @generated from protobuf field: string grantee = 1
     */
    grantee: string;
    /**
     * @generated from protobuf field: string granter = 2
     */
    granter: string;
    /**
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventInvalidGrant
 */
export interface EventInvalidGrant {
    /**
     * @generated from protobuf field: string grantee = 1
     */
    grantee: string;
    /**
     * @generated from protobuf field: string granter = 2
     */
    granter: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EventOrderCancelFail
 */
export interface EventOrderCancelFail {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * @generated from protobuf field: string order_hash = 3
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 4
     */
    cid: string;
    /**
     * @generated from protobuf field: string description = 5
     */
    description: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class EventBatchSpotExecution$Type extends MessageType<EventBatchSpotExecution> {
    constructor() {
        super("injective.exchange.v1beta1.EventBatchSpotExecution", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "executionType", kind: "enum", T: () => ["injective.exchange.v1beta1.ExecutionType", ExecutionType] },
            { no: 4, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradeLog }
        ]);
    }
    create(value?: PartialMessage<EventBatchSpotExecution>): EventBatchSpotExecution {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isBuy = false;
        message.executionType = 0;
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<EventBatchSpotExecution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBatchSpotExecution): EventBatchSpotExecution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool is_buy */ 2:
                    message.isBuy = reader.bool();
                    break;
                case /* injective.exchange.v1beta1.ExecutionType executionType */ 3:
                    message.executionType = reader.int32();
                    break;
                case /* repeated injective.exchange.v1beta1.TradeLog trades */ 4:
                    message.trades.push(TradeLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBatchSpotExecution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool is_buy = 2; */
        if (message.isBuy !== false)
            writer.tag(2, WireType.Varint).bool(message.isBuy);
        /* injective.exchange.v1beta1.ExecutionType executionType = 3; */
        if (message.executionType !== 0)
            writer.tag(3, WireType.Varint).int32(message.executionType);
        /* repeated injective.exchange.v1beta1.TradeLog trades = 4; */
        for (let i = 0; i < message.trades.length; i++)
            TradeLog.internalBinaryWrite(message.trades[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventBatchSpotExecution
 */
export const EventBatchSpotExecution = new EventBatchSpotExecution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBatchDerivativeExecution$Type extends MessageType<EventBatchDerivativeExecution> {
    constructor() {
        super("injective.exchange.v1beta1.EventBatchDerivativeExecution", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_liquidation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cumulative_funding", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "executionType", kind: "enum", T: () => ["injective.exchange.v1beta1.ExecutionType", ExecutionType] },
            { no: 6, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeTradeLog }
        ]);
    }
    create(value?: PartialMessage<EventBatchDerivativeExecution>): EventBatchDerivativeExecution {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isBuy = false;
        message.isLiquidation = false;
        message.cumulativeFunding = "";
        message.executionType = 0;
        message.trades = [];
        if (value !== undefined)
            reflectionMergePartial<EventBatchDerivativeExecution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBatchDerivativeExecution): EventBatchDerivativeExecution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool is_buy */ 2:
                    message.isBuy = reader.bool();
                    break;
                case /* bool is_liquidation */ 3:
                    message.isLiquidation = reader.bool();
                    break;
                case /* string cumulative_funding */ 4:
                    message.cumulativeFunding = reader.string();
                    break;
                case /* injective.exchange.v1beta1.ExecutionType executionType */ 5:
                    message.executionType = reader.int32();
                    break;
                case /* repeated injective.exchange.v1beta1.DerivativeTradeLog trades */ 6:
                    message.trades.push(DerivativeTradeLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBatchDerivativeExecution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool is_buy = 2; */
        if (message.isBuy !== false)
            writer.tag(2, WireType.Varint).bool(message.isBuy);
        /* bool is_liquidation = 3; */
        if (message.isLiquidation !== false)
            writer.tag(3, WireType.Varint).bool(message.isLiquidation);
        /* string cumulative_funding = 4; */
        if (message.cumulativeFunding !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cumulativeFunding);
        /* injective.exchange.v1beta1.ExecutionType executionType = 5; */
        if (message.executionType !== 0)
            writer.tag(5, WireType.Varint).int32(message.executionType);
        /* repeated injective.exchange.v1beta1.DerivativeTradeLog trades = 6; */
        for (let i = 0; i < message.trades.length; i++)
            DerivativeTradeLog.internalBinaryWrite(message.trades[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventBatchDerivativeExecution
 */
export const EventBatchDerivativeExecution = new EventBatchDerivativeExecution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventLostFundsFromLiquidation$Type extends MessageType<EventLostFundsFromLiquidation> {
    constructor() {
        super("injective.exchange.v1beta1.EventLostFundsFromLiquidation", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "lost_funds_from_available_during_payout", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "lost_funds_from_order_cancels", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<EventLostFundsFromLiquidation>): EventLostFundsFromLiquidation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = new Uint8Array(0);
        message.lostFundsFromAvailableDuringPayout = "";
        message.lostFundsFromOrderCancels = "";
        if (value !== undefined)
            reflectionMergePartial<EventLostFundsFromLiquidation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventLostFundsFromLiquidation): EventLostFundsFromLiquidation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bytes subaccount_id */ 2:
                    message.subaccountId = reader.bytes();
                    break;
                case /* string lost_funds_from_available_during_payout */ 3:
                    message.lostFundsFromAvailableDuringPayout = reader.string();
                    break;
                case /* string lost_funds_from_order_cancels */ 4:
                    message.lostFundsFromOrderCancels = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventLostFundsFromLiquidation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bytes subaccount_id = 2; */
        if (message.subaccountId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
        /* string lost_funds_from_available_during_payout = 3; */
        if (message.lostFundsFromAvailableDuringPayout !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lostFundsFromAvailableDuringPayout);
        /* string lost_funds_from_order_cancels = 4; */
        if (message.lostFundsFromOrderCancels !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.lostFundsFromOrderCancels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventLostFundsFromLiquidation
 */
export const EventLostFundsFromLiquidation = new EventLostFundsFromLiquidation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBatchDerivativePosition$Type extends MessageType<EventBatchDerivativePosition> {
    constructor() {
        super("injective.exchange.v1beta1.EventBatchDerivativePosition", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "positions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountPosition }
        ]);
    }
    create(value?: PartialMessage<EventBatchDerivativePosition>): EventBatchDerivativePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.positions = [];
        if (value !== undefined)
            reflectionMergePartial<EventBatchDerivativePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBatchDerivativePosition): EventBatchDerivativePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.SubaccountPosition positions */ 2:
                    message.positions.push(SubaccountPosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBatchDerivativePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* repeated injective.exchange.v1beta1.SubaccountPosition positions = 2; */
        for (let i = 0; i < message.positions.length; i++)
            SubaccountPosition.internalBinaryWrite(message.positions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventBatchDerivativePosition
 */
export const EventBatchDerivativePosition = new EventBatchDerivativePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventDerivativeMarketPaused$Type extends MessageType<EventDerivativeMarketPaused> {
    constructor() {
        super("injective.exchange.v1beta1.EventDerivativeMarketPaused", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settle_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total_missing_funds", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "missing_funds_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventDerivativeMarketPaused>): EventDerivativeMarketPaused {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.settlePrice = "";
        message.totalMissingFunds = "";
        message.missingFundsRate = "";
        if (value !== undefined)
            reflectionMergePartial<EventDerivativeMarketPaused>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventDerivativeMarketPaused): EventDerivativeMarketPaused {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string settle_price */ 2:
                    message.settlePrice = reader.string();
                    break;
                case /* string total_missing_funds */ 3:
                    message.totalMissingFunds = reader.string();
                    break;
                case /* string missing_funds_rate */ 4:
                    message.missingFundsRate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventDerivativeMarketPaused, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string settle_price = 2; */
        if (message.settlePrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settlePrice);
        /* string total_missing_funds = 3; */
        if (message.totalMissingFunds !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.totalMissingFunds);
        /* string missing_funds_rate = 4; */
        if (message.missingFundsRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.missingFundsRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventDerivativeMarketPaused
 */
export const EventDerivativeMarketPaused = new EventDerivativeMarketPaused$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSettledMarketBalance$Type extends MessageType<EventSettledMarketBalance> {
    constructor() {
        super("injective.exchange.v1beta1.EventSettledMarketBalance", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventSettledMarketBalance>): EventSettledMarketBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<EventSettledMarketBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSettledMarketBalance): EventSettledMarketBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSettledMarketBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventSettledMarketBalance
 */
export const EventSettledMarketBalance = new EventSettledMarketBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventNotSettledMarketBalance$Type extends MessageType<EventNotSettledMarketBalance> {
    constructor() {
        super("injective.exchange.v1beta1.EventNotSettledMarketBalance", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventNotSettledMarketBalance>): EventNotSettledMarketBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<EventNotSettledMarketBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventNotSettledMarketBalance): EventNotSettledMarketBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventNotSettledMarketBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventNotSettledMarketBalance
 */
export const EventNotSettledMarketBalance = new EventNotSettledMarketBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventMarketBeyondBankruptcy$Type extends MessageType<EventMarketBeyondBankruptcy> {
    constructor() {
        super("injective.exchange.v1beta1.EventMarketBeyondBankruptcy", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settle_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_market_funds", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventMarketBeyondBankruptcy>): EventMarketBeyondBankruptcy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.settlePrice = "";
        message.missingMarketFunds = "";
        if (value !== undefined)
            reflectionMergePartial<EventMarketBeyondBankruptcy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventMarketBeyondBankruptcy): EventMarketBeyondBankruptcy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string settle_price */ 2:
                    message.settlePrice = reader.string();
                    break;
                case /* string missing_market_funds */ 3:
                    message.missingMarketFunds = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventMarketBeyondBankruptcy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string settle_price = 2; */
        if (message.settlePrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settlePrice);
        /* string missing_market_funds = 3; */
        if (message.missingMarketFunds !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.missingMarketFunds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventMarketBeyondBankruptcy
 */
export const EventMarketBeyondBankruptcy = new EventMarketBeyondBankruptcy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAllPositionsHaircut$Type extends MessageType<EventAllPositionsHaircut> {
    constructor() {
        super("injective.exchange.v1beta1.EventAllPositionsHaircut", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settle_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_funds_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventAllPositionsHaircut>): EventAllPositionsHaircut {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.settlePrice = "";
        message.missingFundsRate = "";
        if (value !== undefined)
            reflectionMergePartial<EventAllPositionsHaircut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAllPositionsHaircut): EventAllPositionsHaircut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string settle_price */ 2:
                    message.settlePrice = reader.string();
                    break;
                case /* string missing_funds_rate */ 3:
                    message.missingFundsRate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAllPositionsHaircut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string settle_price = 2; */
        if (message.settlePrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settlePrice);
        /* string missing_funds_rate = 3; */
        if (message.missingFundsRate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.missingFundsRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventAllPositionsHaircut
 */
export const EventAllPositionsHaircut = new EventAllPositionsHaircut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBinaryOptionsMarketUpdate$Type extends MessageType<EventBinaryOptionsMarketUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate", [
            { no: 1, name: "market", kind: "message", T: () => BinaryOptionsMarket, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EventBinaryOptionsMarketUpdate>): EventBinaryOptionsMarketUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventBinaryOptionsMarketUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBinaryOptionsMarketUpdate): EventBinaryOptionsMarketUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.BinaryOptionsMarket market */ 1:
                    message.market = BinaryOptionsMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBinaryOptionsMarketUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.BinaryOptionsMarket market = 1; */
        if (message.market)
            BinaryOptionsMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate
 */
export const EventBinaryOptionsMarketUpdate = new EventBinaryOptionsMarketUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventNewSpotOrders$Type extends MessageType<EventNewSpotOrders> {
    constructor() {
        super("injective.exchange.v1beta1.EventNewSpotOrders", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "buy_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotLimitOrder },
            { no: 3, name: "sell_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotLimitOrder }
        ]);
    }
    create(value?: PartialMessage<EventNewSpotOrders>): EventNewSpotOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.buyOrders = [];
        message.sellOrders = [];
        if (value !== undefined)
            reflectionMergePartial<EventNewSpotOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventNewSpotOrders): EventNewSpotOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.SpotLimitOrder buy_orders */ 2:
                    message.buyOrders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.SpotLimitOrder sell_orders */ 3:
                    message.sellOrders.push(SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventNewSpotOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* repeated injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2; */
        for (let i = 0; i < message.buyOrders.length; i++)
            SpotLimitOrder.internalBinaryWrite(message.buyOrders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3; */
        for (let i = 0; i < message.sellOrders.length; i++)
            SpotLimitOrder.internalBinaryWrite(message.sellOrders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventNewSpotOrders
 */
export const EventNewSpotOrders = new EventNewSpotOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventNewDerivativeOrders$Type extends MessageType<EventNewDerivativeOrders> {
    constructor() {
        super("injective.exchange.v1beta1.EventNewDerivativeOrders", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "buy_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeLimitOrder },
            { no: 3, name: "sell_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeLimitOrder }
        ]);
    }
    create(value?: PartialMessage<EventNewDerivativeOrders>): EventNewDerivativeOrders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.buyOrders = [];
        message.sellOrders = [];
        if (value !== undefined)
            reflectionMergePartial<EventNewDerivativeOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventNewDerivativeOrders): EventNewDerivativeOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.DerivativeLimitOrder buy_orders */ 2:
                    message.buyOrders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.DerivativeLimitOrder sell_orders */ 3:
                    message.sellOrders.push(DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventNewDerivativeOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* repeated injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2; */
        for (let i = 0; i < message.buyOrders.length; i++)
            DerivativeLimitOrder.internalBinaryWrite(message.buyOrders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3; */
        for (let i = 0; i < message.sellOrders.length; i++)
            DerivativeLimitOrder.internalBinaryWrite(message.sellOrders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventNewDerivativeOrders
 */
export const EventNewDerivativeOrders = new EventNewDerivativeOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventCancelSpotOrder$Type extends MessageType<EventCancelSpotOrder> {
    constructor() {
        super("injective.exchange.v1beta1.EventCancelSpotOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => SpotLimitOrder, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EventCancelSpotOrder>): EventCancelSpotOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<EventCancelSpotOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventCancelSpotOrder): EventCancelSpotOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.SpotLimitOrder order */ 2:
                    message.order = SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventCancelSpotOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.SpotLimitOrder order = 2; */
        if (message.order)
            SpotLimitOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventCancelSpotOrder
 */
export const EventCancelSpotOrder = new EventCancelSpotOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSpotMarketUpdate$Type extends MessageType<EventSpotMarketUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventSpotMarketUpdate", [
            { no: 1, name: "market", kind: "message", T: () => SpotMarket, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EventSpotMarketUpdate>): EventSpotMarketUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventSpotMarketUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSpotMarketUpdate): EventSpotMarketUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.SpotMarket market */ 1:
                    message.market = SpotMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSpotMarketUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.SpotMarket market = 1; */
        if (message.market)
            SpotMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventSpotMarketUpdate
 */
export const EventSpotMarketUpdate = new EventSpotMarketUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventPerpetualMarketUpdate$Type extends MessageType<EventPerpetualMarketUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventPerpetualMarketUpdate", [
            { no: 1, name: "market", kind: "message", T: () => DerivativeMarket, options: { "gogoproto.nullable": false } },
            { no: 2, name: "perpetual_market_info", kind: "message", T: () => PerpetualMarketInfo, options: { "gogoproto.nullable": true } },
            { no: 3, name: "funding", kind: "message", T: () => PerpetualMarketFunding, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<EventPerpetualMarketUpdate>): EventPerpetualMarketUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventPerpetualMarketUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventPerpetualMarketUpdate): EventPerpetualMarketUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.DerivativeMarket market */ 1:
                    message.market = DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info */ 2:
                    message.perpetualMarketInfo = PerpetualMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.perpetualMarketInfo);
                    break;
                case /* injective.exchange.v1beta1.PerpetualMarketFunding funding */ 3:
                    message.funding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.funding);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventPerpetualMarketUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.DerivativeMarket market = 1; */
        if (message.market)
            DerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2; */
        if (message.perpetualMarketInfo)
            PerpetualMarketInfo.internalBinaryWrite(message.perpetualMarketInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.PerpetualMarketFunding funding = 3; */
        if (message.funding)
            PerpetualMarketFunding.internalBinaryWrite(message.funding, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventPerpetualMarketUpdate
 */
export const EventPerpetualMarketUpdate = new EventPerpetualMarketUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventExpiryFuturesMarketUpdate$Type extends MessageType<EventExpiryFuturesMarketUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate", [
            { no: 1, name: "market", kind: "message", T: () => DerivativeMarket, options: { "gogoproto.nullable": false } },
            { no: 3, name: "expiry_futures_market_info", kind: "message", T: () => ExpiryFuturesMarketInfo, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<EventExpiryFuturesMarketUpdate>): EventExpiryFuturesMarketUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventExpiryFuturesMarketUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventExpiryFuturesMarketUpdate): EventExpiryFuturesMarketUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.DerivativeMarket market */ 1:
                    message.market = DerivativeMarket.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info */ 3:
                    message.expiryFuturesMarketInfo = ExpiryFuturesMarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.expiryFuturesMarketInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventExpiryFuturesMarketUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.DerivativeMarket market = 1; */
        if (message.market)
            DerivativeMarket.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3; */
        if (message.expiryFuturesMarketInfo)
            ExpiryFuturesMarketInfo.internalBinaryWrite(message.expiryFuturesMarketInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate
 */
export const EventExpiryFuturesMarketUpdate = new EventExpiryFuturesMarketUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventPerpetualMarketFundingUpdate$Type extends MessageType<EventPerpetualMarketFundingUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "funding", kind: "message", T: () => PerpetualMarketFunding, options: { "gogoproto.nullable": false } },
            { no: 3, name: "is_hourly_funding", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "funding_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "mark_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<EventPerpetualMarketFundingUpdate>): EventPerpetualMarketFundingUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isHourlyFunding = false;
        message.fundingRate = "";
        message.markPrice = "";
        if (value !== undefined)
            reflectionMergePartial<EventPerpetualMarketFundingUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventPerpetualMarketFundingUpdate): EventPerpetualMarketFundingUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.PerpetualMarketFunding funding */ 2:
                    message.funding = PerpetualMarketFunding.internalBinaryRead(reader, reader.uint32(), options, message.funding);
                    break;
                case /* bool is_hourly_funding */ 3:
                    message.isHourlyFunding = reader.bool();
                    break;
                case /* string funding_rate */ 4:
                    message.fundingRate = reader.string();
                    break;
                case /* string mark_price */ 5:
                    message.markPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventPerpetualMarketFundingUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.PerpetualMarketFunding funding = 2; */
        if (message.funding)
            PerpetualMarketFunding.internalBinaryWrite(message.funding, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool is_hourly_funding = 3; */
        if (message.isHourlyFunding !== false)
            writer.tag(3, WireType.Varint).bool(message.isHourlyFunding);
        /* string funding_rate = 4; */
        if (message.fundingRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fundingRate);
        /* string mark_price = 5; */
        if (message.markPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.markPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate
 */
export const EventPerpetualMarketFundingUpdate = new EventPerpetualMarketFundingUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSubaccountDeposit$Type extends MessageType<EventSubaccountDeposit> {
    constructor() {
        super("injective.exchange.v1beta1.EventSubaccountDeposit", [
            { no: 1, name: "src_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EventSubaccountDeposit>): EventSubaccountDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srcAddress = "";
        message.subaccountId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<EventSubaccountDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSubaccountDeposit): EventSubaccountDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string src_address */ 1:
                    message.srcAddress = reader.string();
                    break;
                case /* bytes subaccount_id */ 2:
                    message.subaccountId = reader.bytes();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSubaccountDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string src_address = 1; */
        if (message.srcAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.srcAddress);
        /* bytes subaccount_id = 2; */
        if (message.subaccountId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventSubaccountDeposit
 */
export const EventSubaccountDeposit = new EventSubaccountDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSubaccountWithdraw$Type extends MessageType<EventSubaccountWithdraw> {
    constructor() {
        super("injective.exchange.v1beta1.EventSubaccountWithdraw", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "dst_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EventSubaccountWithdraw>): EventSubaccountWithdraw {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = new Uint8Array(0);
        message.dstAddress = "";
        if (value !== undefined)
            reflectionMergePartial<EventSubaccountWithdraw>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSubaccountWithdraw): EventSubaccountWithdraw {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes subaccount_id */ 1:
                    message.subaccountId = reader.bytes();
                    break;
                case /* string dst_address */ 2:
                    message.dstAddress = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSubaccountWithdraw, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes subaccount_id = 1; */
        if (message.subaccountId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
        /* string dst_address = 2; */
        if (message.dstAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dstAddress);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventSubaccountWithdraw
 */
export const EventSubaccountWithdraw = new EventSubaccountWithdraw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSubaccountBalanceTransfer$Type extends MessageType<EventSubaccountBalanceTransfer> {
    constructor() {
        super("injective.exchange.v1beta1.EventSubaccountBalanceTransfer", [
            { no: 1, name: "src_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dst_subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EventSubaccountBalanceTransfer>): EventSubaccountBalanceTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srcSubaccountId = "";
        message.dstSubaccountId = "";
        if (value !== undefined)
            reflectionMergePartial<EventSubaccountBalanceTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSubaccountBalanceTransfer): EventSubaccountBalanceTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string src_subaccount_id */ 1:
                    message.srcSubaccountId = reader.string();
                    break;
                case /* string dst_subaccount_id */ 2:
                    message.dstSubaccountId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSubaccountBalanceTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string src_subaccount_id = 1; */
        if (message.srcSubaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.srcSubaccountId);
        /* string dst_subaccount_id = 2; */
        if (message.dstSubaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dstSubaccountId);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventSubaccountBalanceTransfer
 */
export const EventSubaccountBalanceTransfer = new EventSubaccountBalanceTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBatchDepositUpdate$Type extends MessageType<EventBatchDepositUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventBatchDepositUpdate", [
            { no: 1, name: "deposit_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DepositUpdate }
        ]);
    }
    create(value?: PartialMessage<EventBatchDepositUpdate>): EventBatchDepositUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.depositUpdates = [];
        if (value !== undefined)
            reflectionMergePartial<EventBatchDepositUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBatchDepositUpdate): EventBatchDepositUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v1beta1.DepositUpdate deposit_updates */ 1:
                    message.depositUpdates.push(DepositUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBatchDepositUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v1beta1.DepositUpdate deposit_updates = 1; */
        for (let i = 0; i < message.depositUpdates.length; i++)
            DepositUpdate.internalBinaryWrite(message.depositUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventBatchDepositUpdate
 */
export const EventBatchDepositUpdate = new EventBatchDepositUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketOrderCancel$Type extends MessageType<DerivativeMarketOrderCancel> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeMarketOrderCancel", [
            { no: 1, name: "market_order", kind: "message", T: () => DerivativeMarketOrder, options: { "gogoproto.nullable": true } },
            { no: 2, name: "cancel_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketOrderCancel>): DerivativeMarketOrderCancel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancelQuantity = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketOrderCancel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketOrderCancel): DerivativeMarketOrderCancel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.DerivativeMarketOrder market_order */ 1:
                    message.marketOrder = DerivativeMarketOrder.internalBinaryRead(reader, reader.uint32(), options, message.marketOrder);
                    break;
                case /* string cancel_quantity */ 2:
                    message.cancelQuantity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketOrderCancel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1; */
        if (message.marketOrder)
            DerivativeMarketOrder.internalBinaryWrite(message.marketOrder, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string cancel_quantity = 2; */
        if (message.cancelQuantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cancelQuantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarketOrderCancel
 */
export const DerivativeMarketOrderCancel = new DerivativeMarketOrderCancel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventCancelDerivativeOrder$Type extends MessageType<EventCancelDerivativeOrder> {
    constructor() {
        super("injective.exchange.v1beta1.EventCancelDerivativeOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isLimitCancel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "limit_order", kind: "message", T: () => DerivativeLimitOrder, options: { "gogoproto.nullable": true } },
            { no: 4, name: "market_order_cancel", kind: "message", T: () => DerivativeMarketOrderCancel, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<EventCancelDerivativeOrder>): EventCancelDerivativeOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isLimitCancel = false;
        if (value !== undefined)
            reflectionMergePartial<EventCancelDerivativeOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventCancelDerivativeOrder): EventCancelDerivativeOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool isLimitCancel */ 2:
                    message.isLimitCancel = reader.bool();
                    break;
                case /* injective.exchange.v1beta1.DerivativeLimitOrder limit_order */ 3:
                    message.limitOrder = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.limitOrder);
                    break;
                case /* injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel */ 4:
                    message.marketOrderCancel = DerivativeMarketOrderCancel.internalBinaryRead(reader, reader.uint32(), options, message.marketOrderCancel);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventCancelDerivativeOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool isLimitCancel = 2; */
        if (message.isLimitCancel !== false)
            writer.tag(2, WireType.Varint).bool(message.isLimitCancel);
        /* injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3; */
        if (message.limitOrder)
            DerivativeLimitOrder.internalBinaryWrite(message.limitOrder, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4; */
        if (message.marketOrderCancel)
            DerivativeMarketOrderCancel.internalBinaryWrite(message.marketOrderCancel, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventCancelDerivativeOrder
 */
export const EventCancelDerivativeOrder = new EventCancelDerivativeOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventFeeDiscountSchedule$Type extends MessageType<EventFeeDiscountSchedule> {
    constructor() {
        super("injective.exchange.v1beta1.EventFeeDiscountSchedule", [
            { no: 1, name: "schedule", kind: "message", T: () => FeeDiscountSchedule }
        ]);
    }
    create(value?: PartialMessage<EventFeeDiscountSchedule>): EventFeeDiscountSchedule {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventFeeDiscountSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventFeeDiscountSchedule): EventFeeDiscountSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.FeeDiscountSchedule schedule */ 1:
                    message.schedule = FeeDiscountSchedule.internalBinaryRead(reader, reader.uint32(), options, message.schedule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventFeeDiscountSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1; */
        if (message.schedule)
            FeeDiscountSchedule.internalBinaryWrite(message.schedule, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventFeeDiscountSchedule
 */
export const EventFeeDiscountSchedule = new EventFeeDiscountSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventTradingRewardCampaignUpdate$Type extends MessageType<EventTradingRewardCampaignUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventTradingRewardCampaignUpdate", [
            { no: 1, name: "campaign_info", kind: "message", T: () => TradingRewardCampaignInfo },
            { no: 2, name: "campaign_reward_pools", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CampaignRewardPool }
        ]);
    }
    create(value?: PartialMessage<EventTradingRewardCampaignUpdate>): EventTradingRewardCampaignUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.campaignRewardPools = [];
        if (value !== undefined)
            reflectionMergePartial<EventTradingRewardCampaignUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventTradingRewardCampaignUpdate): EventTradingRewardCampaignUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info */ 1:
                    message.campaignInfo = TradingRewardCampaignInfo.internalBinaryRead(reader, reader.uint32(), options, message.campaignInfo);
                    break;
                case /* repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools */ 2:
                    message.campaignRewardPools.push(CampaignRewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventTradingRewardCampaignUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1; */
        if (message.campaignInfo)
            TradingRewardCampaignInfo.internalBinaryWrite(message.campaignInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2; */
        for (let i = 0; i < message.campaignRewardPools.length; i++)
            CampaignRewardPool.internalBinaryWrite(message.campaignRewardPools[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventTradingRewardCampaignUpdate
 */
export const EventTradingRewardCampaignUpdate = new EventTradingRewardCampaignUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventTradingRewardDistribution$Type extends MessageType<EventTradingRewardDistribution> {
    constructor() {
        super("injective.exchange.v1beta1.EventTradingRewardDistribution", [
            { no: 1, name: "account_rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AccountRewards }
        ]);
    }
    create(value?: PartialMessage<EventTradingRewardDistribution>): EventTradingRewardDistribution {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountRewards = [];
        if (value !== undefined)
            reflectionMergePartial<EventTradingRewardDistribution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventTradingRewardDistribution): EventTradingRewardDistribution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v1beta1.AccountRewards account_rewards */ 1:
                    message.accountRewards.push(AccountRewards.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventTradingRewardDistribution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v1beta1.AccountRewards account_rewards = 1; */
        for (let i = 0; i < message.accountRewards.length; i++)
            AccountRewards.internalBinaryWrite(message.accountRewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventTradingRewardDistribution
 */
export const EventTradingRewardDistribution = new EventTradingRewardDistribution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventNewConditionalDerivativeOrder$Type extends MessageType<EventNewConditionalDerivativeOrder> {
    constructor() {
        super("injective.exchange.v1beta1.EventNewConditionalDerivativeOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeOrder },
            { no: 3, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "is_market", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EventNewConditionalDerivativeOrder>): EventNewConditionalDerivativeOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.hash = new Uint8Array(0);
        message.isMarket = false;
        if (value !== undefined)
            reflectionMergePartial<EventNewConditionalDerivativeOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventNewConditionalDerivativeOrder): EventNewConditionalDerivativeOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeOrder order */ 2:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* bytes hash */ 3:
                    message.hash = reader.bytes();
                    break;
                case /* bool is_market */ 4:
                    message.isMarket = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventNewConditionalDerivativeOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.DerivativeOrder order = 2; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes hash = 3; */
        if (message.hash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.hash);
        /* bool is_market = 4; */
        if (message.isMarket !== false)
            writer.tag(4, WireType.Varint).bool(message.isMarket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventNewConditionalDerivativeOrder
 */
export const EventNewConditionalDerivativeOrder = new EventNewConditionalDerivativeOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventCancelConditionalDerivativeOrder$Type extends MessageType<EventCancelConditionalDerivativeOrder> {
    constructor() {
        super("injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isLimitCancel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "limit_order", kind: "message", T: () => DerivativeLimitOrder, options: { "gogoproto.nullable": true } },
            { no: 4, name: "market_order", kind: "message", T: () => DerivativeMarketOrder, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<EventCancelConditionalDerivativeOrder>): EventCancelConditionalDerivativeOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isLimitCancel = false;
        if (value !== undefined)
            reflectionMergePartial<EventCancelConditionalDerivativeOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventCancelConditionalDerivativeOrder): EventCancelConditionalDerivativeOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool isLimitCancel */ 2:
                    message.isLimitCancel = reader.bool();
                    break;
                case /* injective.exchange.v1beta1.DerivativeLimitOrder limit_order */ 3:
                    message.limitOrder = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.limitOrder);
                    break;
                case /* injective.exchange.v1beta1.DerivativeMarketOrder market_order */ 4:
                    message.marketOrder = DerivativeMarketOrder.internalBinaryRead(reader, reader.uint32(), options, message.marketOrder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventCancelConditionalDerivativeOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool isLimitCancel = 2; */
        if (message.isLimitCancel !== false)
            writer.tag(2, WireType.Varint).bool(message.isLimitCancel);
        /* injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3; */
        if (message.limitOrder)
            DerivativeLimitOrder.internalBinaryWrite(message.limitOrder, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4; */
        if (message.marketOrder)
            DerivativeMarketOrder.internalBinaryWrite(message.marketOrder, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder
 */
export const EventCancelConditionalDerivativeOrder = new EventCancelConditionalDerivativeOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventConditionalDerivativeOrderTrigger$Type extends MessageType<EventConditionalDerivativeOrderTrigger> {
    constructor() {
        super("injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger", [
            { no: 1, name: "market_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "isLimitTrigger", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "triggered_order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "placed_order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "triggered_order_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventConditionalDerivativeOrderTrigger>): EventConditionalDerivativeOrderTrigger {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = new Uint8Array(0);
        message.isLimitTrigger = false;
        message.triggeredOrderHash = new Uint8Array(0);
        message.placedOrderHash = new Uint8Array(0);
        message.triggeredOrderCid = "";
        if (value !== undefined)
            reflectionMergePartial<EventConditionalDerivativeOrderTrigger>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventConditionalDerivativeOrderTrigger): EventConditionalDerivativeOrderTrigger {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes market_id */ 1:
                    message.marketId = reader.bytes();
                    break;
                case /* bool isLimitTrigger */ 2:
                    message.isLimitTrigger = reader.bool();
                    break;
                case /* bytes triggered_order_hash */ 3:
                    message.triggeredOrderHash = reader.bytes();
                    break;
                case /* bytes placed_order_hash */ 4:
                    message.placedOrderHash = reader.bytes();
                    break;
                case /* string triggered_order_cid */ 5:
                    message.triggeredOrderCid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventConditionalDerivativeOrderTrigger, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes market_id = 1; */
        if (message.marketId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.marketId);
        /* bool isLimitTrigger = 2; */
        if (message.isLimitTrigger !== false)
            writer.tag(2, WireType.Varint).bool(message.isLimitTrigger);
        /* bytes triggered_order_hash = 3; */
        if (message.triggeredOrderHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.triggeredOrderHash);
        /* bytes placed_order_hash = 4; */
        if (message.placedOrderHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.placedOrderHash);
        /* string triggered_order_cid = 5; */
        if (message.triggeredOrderCid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.triggeredOrderCid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger
 */
export const EventConditionalDerivativeOrderTrigger = new EventConditionalDerivativeOrderTrigger$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventOrderFail$Type extends MessageType<EventOrderFail> {
    constructor() {
        super("injective.exchange.v1beta1.EventOrderFail", [
            { no: 1, name: "account", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "flags", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventOrderFail>): EventOrderFail {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = new Uint8Array(0);
        message.hashes = [];
        message.flags = [];
        message.cids = [];
        if (value !== undefined)
            reflectionMergePartial<EventOrderFail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventOrderFail): EventOrderFail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes account */ 1:
                    message.account = reader.bytes();
                    break;
                case /* repeated bytes hashes */ 2:
                    message.hashes.push(reader.bytes());
                    break;
                case /* repeated uint32 flags */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.flags.push(reader.uint32());
                    else
                        message.flags.push(reader.uint32());
                    break;
                case /* repeated string cids */ 4:
                    message.cids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventOrderFail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes account = 1; */
        if (message.account.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.account);
        /* repeated bytes hashes = 2; */
        for (let i = 0; i < message.hashes.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.hashes[i]);
        /* repeated uint32 flags = 3; */
        if (message.flags.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.flags.length; i++)
                writer.uint32(message.flags[i]);
            writer.join();
        }
        /* repeated string cids = 4; */
        for (let i = 0; i < message.cids.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.cids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventOrderFail
 */
export const EventOrderFail = new EventOrderFail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAtomicMarketOrderFeeMultipliersUpdated$Type extends MessageType<EventAtomicMarketOrderFeeMultipliersUpdated> {
    constructor() {
        super("injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated", [
            { no: 1, name: "market_fee_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketFeeMultiplier }
        ]);
    }
    create(value?: PartialMessage<EventAtomicMarketOrderFeeMultipliersUpdated>): EventAtomicMarketOrderFeeMultipliersUpdated {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketFeeMultipliers = [];
        if (value !== undefined)
            reflectionMergePartial<EventAtomicMarketOrderFeeMultipliersUpdated>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAtomicMarketOrderFeeMultipliersUpdated): EventAtomicMarketOrderFeeMultipliersUpdated {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers */ 1:
                    message.marketFeeMultipliers.push(MarketFeeMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAtomicMarketOrderFeeMultipliersUpdated, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1; */
        for (let i = 0; i < message.marketFeeMultipliers.length; i++)
            MarketFeeMultiplier.internalBinaryWrite(message.marketFeeMultipliers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated
 */
export const EventAtomicMarketOrderFeeMultipliersUpdated = new EventAtomicMarketOrderFeeMultipliersUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventOrderbookUpdate$Type extends MessageType<EventOrderbookUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.EventOrderbookUpdate", [
            { no: 1, name: "spot_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderbookUpdate },
            { no: 2, name: "derivative_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderbookUpdate }
        ]);
    }
    create(value?: PartialMessage<EventOrderbookUpdate>): EventOrderbookUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spotUpdates = [];
        message.derivativeUpdates = [];
        if (value !== undefined)
            reflectionMergePartial<EventOrderbookUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventOrderbookUpdate): EventOrderbookUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.exchange.v1beta1.OrderbookUpdate spot_updates */ 1:
                    message.spotUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.OrderbookUpdate derivative_updates */ 2:
                    message.derivativeUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventOrderbookUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1; */
        for (let i = 0; i < message.spotUpdates.length; i++)
            OrderbookUpdate.internalBinaryWrite(message.spotUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2; */
        for (let i = 0; i < message.derivativeUpdates.length; i++)
            OrderbookUpdate.internalBinaryWrite(message.derivativeUpdates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventOrderbookUpdate
 */
export const EventOrderbookUpdate = new EventOrderbookUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookUpdate$Type extends MessageType<OrderbookUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.OrderbookUpdate", [
            { no: 1, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "orderbook", kind: "message", T: () => Orderbook }
        ]);
    }
    create(value?: PartialMessage<OrderbookUpdate>): OrderbookUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seq = 0n;
        if (value !== undefined)
            reflectionMergePartial<OrderbookUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookUpdate): OrderbookUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 seq */ 1:
                    message.seq = reader.uint64().toBigInt();
                    break;
                case /* injective.exchange.v1beta1.Orderbook orderbook */ 2:
                    message.orderbook = Orderbook.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 seq = 1; */
        if (message.seq !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.seq);
        /* injective.exchange.v1beta1.Orderbook orderbook = 2; */
        if (message.orderbook)
            Orderbook.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OrderbookUpdate
 */
export const OrderbookUpdate = new OrderbookUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Orderbook$Type extends MessageType<Orderbook> {
    constructor() {
        super("injective.exchange.v1beta1.Orderbook", [
            { no: 1, name: "market_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "buy_levels", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level },
            { no: 3, name: "sell_levels", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level }
        ]);
    }
    create(value?: PartialMessage<Orderbook>): Orderbook {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = new Uint8Array(0);
        message.buyLevels = [];
        message.sellLevels = [];
        if (value !== undefined)
            reflectionMergePartial<Orderbook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Orderbook): Orderbook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes market_id */ 1:
                    message.marketId = reader.bytes();
                    break;
                case /* repeated injective.exchange.v1beta1.Level buy_levels */ 2:
                    message.buyLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.Level sell_levels */ 3:
                    message.sellLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Orderbook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes market_id = 1; */
        if (message.marketId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.marketId);
        /* repeated injective.exchange.v1beta1.Level buy_levels = 2; */
        for (let i = 0; i < message.buyLevels.length; i++)
            Level.internalBinaryWrite(message.buyLevels[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.Level sell_levels = 3; */
        for (let i = 0; i < message.sellLevels.length; i++)
            Level.internalBinaryWrite(message.sellLevels[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Orderbook
 */
export const Orderbook = new Orderbook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventGrantAuthorizations$Type extends MessageType<EventGrantAuthorizations> {
    constructor() {
        super("injective.exchange.v1beta1.EventGrantAuthorizations", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grants", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GrantAuthorization }
        ]);
    }
    create(value?: PartialMessage<EventGrantAuthorizations>): EventGrantAuthorizations {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        message.grants = [];
        if (value !== undefined)
            reflectionMergePartial<EventGrantAuthorizations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventGrantAuthorizations): EventGrantAuthorizations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.GrantAuthorization grants */ 2:
                    message.grants.push(GrantAuthorization.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventGrantAuthorizations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        /* repeated injective.exchange.v1beta1.GrantAuthorization grants = 2; */
        for (let i = 0; i < message.grants.length; i++)
            GrantAuthorization.internalBinaryWrite(message.grants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventGrantAuthorizations
 */
export const EventGrantAuthorizations = new EventGrantAuthorizations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventGrantActivation$Type extends MessageType<EventGrantActivation> {
    constructor() {
        super("injective.exchange.v1beta1.EventGrantActivation", [
            { no: 1, name: "grantee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
        ]);
    }
    create(value?: PartialMessage<EventGrantActivation>): EventGrantActivation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantee = "";
        message.granter = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<EventGrantActivation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventGrantActivation): EventGrantActivation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grantee */ 1:
                    message.grantee = reader.string();
                    break;
                case /* string granter */ 2:
                    message.granter = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventGrantActivation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grantee = 1; */
        if (message.grantee !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantee);
        /* string granter = 2; */
        if (message.granter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.granter);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventGrantActivation
 */
export const EventGrantActivation = new EventGrantActivation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventInvalidGrant$Type extends MessageType<EventInvalidGrant> {
    constructor() {
        super("injective.exchange.v1beta1.EventInvalidGrant", [
            { no: 1, name: "grantee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventInvalidGrant>): EventInvalidGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantee = "";
        message.granter = "";
        if (value !== undefined)
            reflectionMergePartial<EventInvalidGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventInvalidGrant): EventInvalidGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grantee */ 1:
                    message.grantee = reader.string();
                    break;
                case /* string granter */ 2:
                    message.granter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventInvalidGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grantee = 1; */
        if (message.grantee !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantee);
        /* string granter = 2; */
        if (message.granter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.granter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventInvalidGrant
 */
export const EventInvalidGrant = new EventInvalidGrant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventOrderCancelFail$Type extends MessageType<EventOrderCancelFail> {
    constructor() {
        super("injective.exchange.v1beta1.EventOrderCancelFail", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventOrderCancelFail>): EventOrderCancelFail {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.orderHash = "";
        message.cid = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<EventOrderCancelFail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventOrderCancelFail): EventOrderCancelFail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* string order_hash */ 3:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 4:
                    message.cid = reader.string();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventOrderCancelFail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* string order_hash = 3; */
        if (message.orderHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 4; */
        if (message.cid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cid);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EventOrderCancelFail
 */
export const EventOrderCancelFail = new EventOrderCancelFail$Type();
