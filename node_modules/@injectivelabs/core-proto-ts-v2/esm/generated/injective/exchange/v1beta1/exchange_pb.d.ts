// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/exchange/v1beta1/exchange.proto" (package "injective.exchange.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { OracleType } from "../../oracle/v1beta1/oracle_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
/**
 * @generated from protobuf message injective.exchange.v1beta1.OpenNotionalCap
 */
export interface OpenNotionalCap {
    /**
     * @generated from protobuf oneof: cap
     */
    cap: {
        oneofKind: "uncapped";
        /**
         * @generated from protobuf field: injective.exchange.v1beta1.OpenNotionalCapUncapped uncapped = 1
         */
        uncapped: OpenNotionalCapUncapped;
    } | {
        oneofKind: "capped";
        /**
         * @generated from protobuf field: injective.exchange.v1beta1.OpenNotionalCapCapped capped = 2
         */
        capped: OpenNotionalCapCapped;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OpenNotionalCapUncapped
 */
export interface OpenNotionalCapUncapped {
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OpenNotionalCapCapped
 */
export interface OpenNotionalCapCapped {
    /**
     * @generated from protobuf field: string value = 1
     */
    value: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.Params
 */
export interface Params {
    /**
     * spot_market_instant_listing_fee defines the expedited fee in INJ required
     * to create a spot market by bypassing governance
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1
     */
    spotMarketInstantListingFee?: Coin;
    /**
     * derivative_market_instant_listing_fee defines the expedited fee in INJ
     * required to create a derivative market by bypassing governance
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2
     */
    derivativeMarketInstantListingFee?: Coin;
    /**
     * default_spot_maker_fee defines the default exchange trade fee for makers on
     * a spot market
     *
     * @generated from protobuf field: string default_spot_maker_fee_rate = 3
     */
    defaultSpotMakerFeeRate: string;
    /**
     * default_spot_taker_fee_rate defines the default exchange trade fee rate for
     * takers on a new spot market
     *
     * @generated from protobuf field: string default_spot_taker_fee_rate = 4
     */
    defaultSpotTakerFeeRate: string;
    /**
     * default_derivative_maker_fee defines the default exchange trade fee for
     * makers on a new derivative market
     *
     * @generated from protobuf field: string default_derivative_maker_fee_rate = 5
     */
    defaultDerivativeMakerFeeRate: string;
    /**
     * default_derivative_taker_fee defines the default exchange trade fee for
     * takers on a new derivative market
     *
     * @generated from protobuf field: string default_derivative_taker_fee_rate = 6
     */
    defaultDerivativeTakerFeeRate: string;
    /**
     * default_initial_margin_ratio defines the default initial margin ratio on a
     * new derivative market
     *
     * @generated from protobuf field: string default_initial_margin_ratio = 7
     */
    defaultInitialMarginRatio: string;
    /**
     * default_maintenance_margin_ratio defines the default maintenance margin
     * ratio on a new derivative market
     *
     * @generated from protobuf field: string default_maintenance_margin_ratio = 8
     */
    defaultMaintenanceMarginRatio: string;
    /**
     * default_funding_interval defines the default funding interval on a
     * derivative market
     *
     * @generated from protobuf field: int64 default_funding_interval = 9
     */
    defaultFundingInterval: bigint;
    /**
     * funding_multiple defines the timestamp multiple that the funding timestamp
     * should be a multiple of
     *
     * @generated from protobuf field: int64 funding_multiple = 10
     */
    fundingMultiple: bigint;
    /**
     * relayer_fee_share_rate defines the trade fee share percentage that goes to
     * relayers
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 11
     */
    relayerFeeShareRate: string;
    /**
     * default_hourly_funding_rate_cap defines the default maximum absolute value
     * of the hourly funding rate
     *
     * @generated from protobuf field: string default_hourly_funding_rate_cap = 12
     */
    defaultHourlyFundingRateCap: string;
    /**
     * hourly_interest_rate defines the hourly interest rate
     *
     * @generated from protobuf field: string default_hourly_interest_rate = 13
     */
    defaultHourlyInterestRate: string;
    /**
     * max_derivative_order_side_count defines the maximum number of derivative
     * active orders a subaccount can have for a given orderbook side
     *
     * @generated from protobuf field: uint32 max_derivative_order_side_count = 14
     */
    maxDerivativeOrderSideCount: number;
    /**
     * inj_reward_staked_requirement_threshold defines the threshold on INJ
     * rewards after which one also needs staked INJ to receive more
     *
     * @generated from protobuf field: string inj_reward_staked_requirement_threshold = 15
     */
    injRewardStakedRequirementThreshold: string;
    /**
     * the trading_rewards_vesting_duration defines the vesting times for trading
     * rewards
     *
     * @generated from protobuf field: int64 trading_rewards_vesting_duration = 16
     */
    tradingRewardsVestingDuration: bigint;
    /**
     * liquidator_reward_share_rate defines the ratio of the split of the surplus
     * collateral that goes to the liquidator
     *
     * @generated from protobuf field: string liquidator_reward_share_rate = 17
     */
    liquidatorRewardShareRate: string;
    /**
     * binary_options_market_instant_listing_fee defines the expedited fee in INJ
     * required to create a derivative market by bypassing governance
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18
     */
    binaryOptionsMarketInstantListingFee?: Coin;
    /**
     * atomic_market_order_access_level defines the required access permissions
     * for executing atomic market orders
     *
     * @generated from protobuf field: injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19
     */
    atomicMarketOrderAccessLevel: AtomicMarketOrderAccessLevel;
    /**
     * spot_atomic_market_order_fee_multiplier defines the default multiplier for
     * executing atomic market orders in spot markets
     *
     * @generated from protobuf field: string spot_atomic_market_order_fee_multiplier = 20
     */
    spotAtomicMarketOrderFeeMultiplier: string;
    /**
     * derivative_atomic_market_order_fee_multiplier defines the default
     * multiplier for executing atomic market orders in derivative markets
     *
     * @generated from protobuf field: string derivative_atomic_market_order_fee_multiplier = 21
     */
    derivativeAtomicMarketOrderFeeMultiplier: string;
    /**
     * binary_options_atomic_market_order_fee_multiplier defines the default
     * multiplier for executing atomic market orders in binary markets
     *
     * @generated from protobuf field: string binary_options_atomic_market_order_fee_multiplier = 22
     */
    binaryOptionsAtomicMarketOrderFeeMultiplier: string;
    /**
     * minimal_protocol_fee_rate defines the minimal protocol fee rate
     *
     * @generated from protobuf field: string minimal_protocol_fee_rate = 23
     */
    minimalProtocolFeeRate: string;
    /**
     * is_instant_derivative_market_launch_enabled defines whether instant
     * derivative market launch is enabled
     *
     * @generated from protobuf field: bool is_instant_derivative_market_launch_enabled = 24
     */
    isInstantDerivativeMarketLaunchEnabled: boolean;
    /**
     * @generated from protobuf field: int64 post_only_mode_height_threshold = 25
     */
    postOnlyModeHeightThreshold: bigint;
    /**
     * Maximum time in seconds since the last mark price update to allow a
     * decrease in margin
     *
     * @generated from protobuf field: int64 margin_decrease_price_timestamp_threshold_seconds = 26
     */
    marginDecreasePriceTimestampThresholdSeconds: bigint;
    /**
     * List of addresses that are allowed to perform exchange admin operations
     *
     * @generated from protobuf field: repeated string exchange_admins = 27
     */
    exchangeAdmins: string[];
    /**
     * inj_auction_max_cap defines the maximum cap for INJ sent to auction
     *
     * @generated from protobuf field: string inj_auction_max_cap = 28
     */
    injAuctionMaxCap: string;
    /**
     * fixed_gas_enabled indicates if msg server will consume fixed gas amount for
     * certain msg types
     *
     * @generated from protobuf field: bool fixed_gas_enabled = 29
     */
    fixedGasEnabled: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MarketFeeMultiplier
 */
export interface MarketFeeMultiplier {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: string fee_multiplier = 2
     */
    feeMultiplier: string;
}
/**
 * An object describing a derivative market in the Injective Futures Protocol.
 *
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarket
 */
export interface DerivativeMarket {
    /**
     * Ticker for the derivative contract.
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Oracle base currency
     *
     * @generated from protobuf field: string oracle_base = 2
     */
    oracleBase: string;
    /**
     * Oracle quote currency
     *
     * @generated from protobuf field: string oracle_quote = 3
     */
    oracleQuote: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 5
     */
    oracleScaleFactor: number;
    /**
     * Address of the quote currency denomination for the derivative contract
     *
     * @generated from protobuf field: string quote_denom = 6
     */
    quoteDenom: string;
    /**
     * Unique market ID.
     *
     * @generated from protobuf field: string market_id = 7
     */
    marketId: string;
    /**
     * initial_margin_ratio defines the initial margin ratio of a derivative
     * market
     *
     * @generated from protobuf field: string initial_margin_ratio = 8
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio of a
     * derivative market
     *
     * @generated from protobuf field: string maintenance_margin_ratio = 9
     */
    maintenanceMarginRatio: string;
    /**
     * maker_fee_rate defines the maker fee rate of a derivative market
     *
     * @generated from protobuf field: string maker_fee_rate = 10
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the taker fee rate of a derivative market
     *
     * @generated from protobuf field: string taker_fee_rate = 11
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 12
     */
    relayerFeeShareRate: string;
    /**
     * true if the market is a perpetual market. false if the market is an expiry
     * futures market
     *
     * @generated from protobuf field: bool isPerpetual = 13
     */
    isPerpetual: boolean;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 14
     */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market (in chain format)
     *
     * @generated from protobuf field: string min_price_tick_size = 15
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in chain format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 16
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in chain format)
     *
     * @generated from protobuf field: string min_notional = 17
     */
    minNotional: string;
    /**
     * current market admin
     *
     * @generated from protobuf field: string admin = 18
     */
    admin: string;
    /**
     * level of admin permissions
     *
     * @generated from protobuf field: uint32 admin_permissions = 19
     */
    adminPermissions: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 20
     */
    quoteDecimals: number;
    /**
     * reduce_margin_ratio defines the ratio of the margin that is reduced
     *
     * @generated from protobuf field: string reduce_margin_ratio = 21
     */
    reduceMarginRatio: string;
    /**
     * open_notional_cap defines the maximum open notional for the market
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OpenNotionalCap open_notional_cap = 22
     */
    openNotionalCap?: OpenNotionalCap;
}
/**
 * An object describing a binary options market in Injective Protocol.
 *
 * @generated from protobuf message injective.exchange.v1beta1.BinaryOptionsMarket
 */
export interface BinaryOptionsMarket {
    /**
     * Ticker for the derivative contract.
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Oracle symbol
     *
     * @generated from protobuf field: string oracle_symbol = 2
     */
    oracleSymbol: string;
    /**
     * Oracle Provider
     *
     * @generated from protobuf field: string oracle_provider = 3
     */
    oracleProvider: string;
    /**
     * Oracle type
     *
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
     */
    oracleType: OracleType;
    /**
     * Scale factor for oracle prices.
     *
     * @generated from protobuf field: uint32 oracle_scale_factor = 5
     */
    oracleScaleFactor: number;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 expiration_timestamp = 6
     */
    expirationTimestamp: bigint;
    /**
     * expiration timestamp
     *
     * @generated from protobuf field: int64 settlement_timestamp = 7
     */
    settlementTimestamp: bigint;
    /**
     * admin of the market
     *
     * @generated from protobuf field: string admin = 8
     */
    admin: string;
    /**
     * Address of the quote currency denomination for the binary options contract
     *
     * @generated from protobuf field: string quote_denom = 9
     */
    quoteDenom: string;
    /**
     * Unique market ID.
     *
     * @generated from protobuf field: string market_id = 10
     */
    marketId: string;
    /**
     * maker_fee_rate defines the maker fee rate of a binary options market
     *
     * @generated from protobuf field: string maker_fee_rate = 11
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the taker fee rate of a derivative market
     *
     * @generated from protobuf field: string taker_fee_rate = 12
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 13
     */
    relayerFeeShareRate: string;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 14
     */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market
     *
     * @generated from protobuf field: string min_price_tick_size = 15
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market
     *
     * @generated from protobuf field: string min_quantity_tick_size = 16
     */
    minQuantityTickSize: string;
    /**
     * @generated from protobuf field: string settlement_price = 17
     */
    settlementPrice: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market
     *
     * @generated from protobuf field: string min_notional = 18
     */
    minNotional: string;
    /**
     * level of admin permissions
     *
     * @generated from protobuf field: uint32 admin_permissions = 19
     */
    adminPermissions: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 20
     */
    quoteDecimals: number;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketInfo
 */
export interface ExpiryFuturesMarketInfo {
    /**
     * market ID.
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * expiration_timestamp defines the expiration time for a time expiry futures
     * market.
     *
     * @generated from protobuf field: int64 expiration_timestamp = 2
     */
    expirationTimestamp: bigint;
    /**
     * expiration_twap_start_timestamp defines the start time of the TWAP
     * calculation window
     *
     * @generated from protobuf field: int64 twap_start_timestamp = 3
     */
    twapStartTimestamp: bigint;
    /**
     * expiration_twap_start_price_cumulative defines the cumulative price for the
     * start of the TWAP window (in chain format)
     *
     * @generated from protobuf field: string expiration_twap_start_price_cumulative = 4
     */
    expirationTwapStartPriceCumulative: string;
    /**
     * settlement_price defines the settlement price for a time expiry futures
     * market (in chain format)
     *
     * @generated from protobuf field: string settlement_price = 5
     */
    settlementPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PerpetualMarketInfo
 */
export interface PerpetualMarketInfo {
    /**
     * market ID.
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * hourly_funding_rate_cap defines the maximum absolute value of the hourly
     * funding rate
     *
     * @generated from protobuf field: string hourly_funding_rate_cap = 2
     */
    hourlyFundingRateCap: string;
    /**
     * hourly_interest_rate defines the hourly interest rate
     *
     * @generated from protobuf field: string hourly_interest_rate = 3
     */
    hourlyInterestRate: string;
    /**
     * next_funding_timestamp defines the next funding timestamp in seconds of a
     * perpetual market
     *
     * @generated from protobuf field: int64 next_funding_timestamp = 4
     */
    nextFundingTimestamp: bigint;
    /**
     * funding_interval defines the next funding interval in seconds of a
     * perpetual market.
     *
     * @generated from protobuf field: int64 funding_interval = 5
     */
    fundingInterval: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PerpetualMarketFunding
 */
export interface PerpetualMarketFunding {
    /**
     * cumulative_funding defines the cumulative funding of a perpetual market.
     *
     * @generated from protobuf field: string cumulative_funding = 1
     */
    cumulativeFunding: string;
    /**
     * cumulative_price defines the running time-integral of the perp premium
     * ((VWAP - mark_price) / mark_price) i.e., sum(premium * seconds)
     * used to compute the intervalâ€™s average premium for funding
     *
     * @generated from protobuf field: string cumulative_price = 2
     */
    cumulativePrice: string;
    /**
     * the last timestamp in seconds
     *
     * @generated from protobuf field: int64 last_timestamp = 3
     */
    lastTimestamp: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarketSettlementInfo
 */
export interface DerivativeMarketSettlementInfo {
    /**
     * market ID.
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * settlement_price defines the settlement price
     *
     * @generated from protobuf field: string settlement_price = 2
     */
    settlementPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.NextFundingTimestamp
 */
export interface NextFundingTimestamp {
    /**
     * @generated from protobuf field: int64 next_timestamp = 1
     */
    nextTimestamp: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MidPriceAndTOB
 */
export interface MidPriceAndTOB {
    /**
     * mid price of the market (in chain format)
     *
     * @generated from protobuf field: string mid_price = 1
     */
    midPrice: string;
    /**
     * best buy price of the market (in chain format)
     *
     * @generated from protobuf field: string best_buy_price = 2
     */
    bestBuyPrice: string;
    /**
     * best sell price of the market (in chain format)
     *
     * @generated from protobuf field: string best_sell_price = 3
     */
    bestSellPrice: string;
}
/**
 * An object describing trade pair of two assets.
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotMarket
 */
export interface SpotMarket {
    /**
     * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
     * asset.
     *
     * @generated from protobuf field: string ticker = 1
     */
    ticker: string;
    /**
     * Coin denom used for the base asset
     *
     * @generated from protobuf field: string base_denom = 2
     */
    baseDenom: string;
    /**
     * Coin used for the quote asset
     *
     * @generated from protobuf field: string quote_denom = 3
     */
    quoteDenom: string;
    /**
     * maker_fee_rate defines the fee percentage makers pay when trading
     *
     * @generated from protobuf field: string maker_fee_rate = 4
     */
    makerFeeRate: string;
    /**
     * taker_fee_rate defines the fee percentage takers pay when trading
     *
     * @generated from protobuf field: string taker_fee_rate = 5
     */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     *
     * @generated from protobuf field: string relayer_fee_share_rate = 6
     */
    relayerFeeShareRate: string;
    /**
     * Unique market ID.
     *
     * @generated from protobuf field: string market_id = 7
     */
    marketId: string;
    /**
     * Status of the market
     *
     * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 8
     */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price required
     * for orders in the market (in chain format)
     *
     * @generated from protobuf field: string min_price_tick_size = 9
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in chain format)
     *
     * @generated from protobuf field: string min_quantity_tick_size = 10
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in chain format)
     *
     * @generated from protobuf field: string min_notional = 11
     */
    minNotional: string;
    /**
     * current market admin
     *
     * @generated from protobuf field: string admin = 12
     */
    admin: string;
    /**
     * level of admin permissions
     *
     * @generated from protobuf field: uint32 admin_permissions = 13
     */
    adminPermissions: number;
    /**
     * base token decimals
     *
     * @generated from protobuf field: uint32 base_decimals = 14
     */
    baseDecimals: number;
    /**
     * quote token decimals
     *
     * @generated from protobuf field: uint32 quote_decimals = 15
     */
    quoteDecimals: number;
}
/**
 * A subaccount's deposit for a given base currency
 *
 * @generated from protobuf message injective.exchange.v1beta1.Deposit
 */
export interface Deposit {
    /**
     * @generated from protobuf field: string available_balance = 1
     */
    availableBalance: string;
    /**
     * @generated from protobuf field: string total_balance = 2
     */
    totalBalance: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountTradeNonce
 */
export interface SubaccountTradeNonce {
    /**
     * @generated from protobuf field: uint32 nonce = 1
     */
    nonce: number;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OrderInfo
 */
export interface OrderInfo {
    /**
     * bytes32 subaccount ID that created the order
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * address fee_recipient address that will receive fees for the order
     *
     * @generated from protobuf field: string fee_recipient = 2
     */
    feeRecipient: string;
    /**
     * price of the order
     *
     * @generated from protobuf field: string price = 3
     */
    price: string;
    /**
     * quantity of the order
     *
     * @generated from protobuf field: string quantity = 4
     */
    quantity: string;
    /**
     * @generated from protobuf field: string cid = 5
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SpotOrder
 */
export interface SpotOrder {
    /**
     * market_id represents the unique ID of the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * order_info contains the information of the order
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 2
     */
    orderInfo?: OrderInfo;
    /**
     * order types
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 3
     */
    orderType: OrderType;
    /**
     * trigger_price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 4
     */
    triggerPrice: string;
}
/**
 * A valid Spot limit order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotLimitOrder
 */
export interface SpotLimitOrder {
    /**
     * order_info contains the information of the order
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
     */
    orderInfo?: OrderInfo;
    /**
     * order types
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 2
     */
    orderType: OrderType;
    /**
     * the amount of the quantity remaining fillable
     *
     * @generated from protobuf field: string fillable = 3
     */
    fillable: string;
    /**
     * trigger_price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 4
     */
    triggerPrice: string;
    /**
     * @generated from protobuf field: bytes order_hash = 5
     */
    orderHash: Uint8Array;
}
/**
 * A valid Spot market order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotMarketOrder
 */
export interface SpotMarketOrder {
    /**
     * order_info contains the information of the order
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
     */
    orderInfo?: OrderInfo;
    /**
     * @generated from protobuf field: string balance_hold = 2
     */
    balanceHold: string;
    /**
     * @generated from protobuf field: bytes order_hash = 3
     */
    orderHash: Uint8Array;
    /**
     * order types
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 4
     */
    orderType: OrderType;
    /**
     * trigger_price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 5
     */
    triggerPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeOrder
 */
export interface DerivativeOrder {
    /**
     * market_id represents the unique ID of the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * order_info contains the information of the order
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 2
     */
    orderInfo?: OrderInfo;
    /**
     * order types
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 3
     */
    orderType: OrderType;
    /**
     * margin is the margin used by the limit order
     *
     * @generated from protobuf field: string margin = 4
     */
    margin: string;
    /**
     * trigger_price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 5
     */
    triggerPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountOrderbookMetadata
 */
export interface SubaccountOrderbookMetadata {
    /**
     * The number of vanilla limit orders
     *
     * @generated from protobuf field: uint32 vanilla_limit_order_count = 1
     */
    vanillaLimitOrderCount: number;
    /**
     * The number of reduce-only limit orders
     *
     * @generated from protobuf field: uint32 reduce_only_limit_order_count = 2
     */
    reduceOnlyLimitOrderCount: number;
    /**
     * The aggregate quantity of the subaccount's reduce-only limit orders (in
     * chain format)
     *
     * @generated from protobuf field: string aggregate_reduce_only_quantity = 3
     */
    aggregateReduceOnlyQuantity: string;
    /**
     * The aggregate quantity of the subaccount's vanilla limit orders (in chain
     * format)
     *
     * @generated from protobuf field: string aggregate_vanilla_quantity = 4
     */
    aggregateVanillaQuantity: string;
    /**
     * The number of vanilla conditional orders
     *
     * @generated from protobuf field: uint32 vanilla_conditional_order_count = 5
     */
    vanillaConditionalOrderCount: number;
    /**
     * The number of reduce-only conditional orders
     *
     * @generated from protobuf field: uint32 reduce_only_conditional_order_count = 6
     */
    reduceOnlyConditionalOrderCount: number;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountOrder
 */
export interface SubaccountOrder {
    /**
     * price of the order
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * the amount of the quantity remaining fillable
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * @generated from protobuf field: bool isReduceOnly = 3
     */
    isReduceOnly: boolean;
    /**
     * @generated from protobuf field: string cid = 4
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountOrderData
 */
export interface SubaccountOrderData {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.SubaccountOrder order = 1
     */
    order?: SubaccountOrder;
    /**
     * @generated from protobuf field: bytes order_hash = 2
     */
    orderHash: Uint8Array;
}
/**
 * A valid Derivative limit order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeLimitOrder
 */
export interface DerivativeLimitOrder {
    /**
     * order_info contains the information of the order
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
     */
    orderInfo?: OrderInfo;
    /**
     * order types
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 2
     */
    orderType: OrderType;
    /**
     * margin is the margin used by the limit order
     *
     * @generated from protobuf field: string margin = 3
     */
    margin: string;
    /**
     * the amount of the quantity remaining fillable
     *
     * @generated from protobuf field: string fillable = 4
     */
    fillable: string;
    /**
     * trigger_price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 5
     */
    triggerPrice: string;
    /**
     * @generated from protobuf field: bytes order_hash = 6
     */
    orderHash: Uint8Array;
}
/**
 * A valid Derivative market order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarketOrder
 */
export interface DerivativeMarketOrder {
    /**
     * order_info contains the information of the order
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
     */
    orderInfo?: OrderInfo;
    /**
     * order types
     *
     * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 2
     */
    orderType: OrderType;
    /**
     * @generated from protobuf field: string margin = 3
     */
    margin: string;
    /**
     * @generated from protobuf field: string margin_hold = 4
     */
    marginHold: string;
    /**
     * trigger_price is the trigger price used by stop/take orders
     *
     * @generated from protobuf field: string trigger_price = 5
     */
    triggerPrice: string;
    /**
     * @generated from protobuf field: bytes order_hash = 6
     */
    orderHash: Uint8Array;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.Position
 */
export interface Position {
    /**
     * True if the position is long. False if the position is short.
     *
     * @generated from protobuf field: bool isLong = 1
     */
    isLong: boolean;
    /**
     * The quantity of the position (in chain format)
     *
     * @generated from protobuf field: string quantity = 2
     */
    quantity: string;
    /**
     * The entry price of the position (in chain format)
     *
     * @generated from protobuf field: string entry_price = 3
     */
    entryPrice: string;
    /**
     * The margin of the position (in chain format)
     *
     * @generated from protobuf field: string margin = 4
     */
    margin: string;
    /**
     * The cumulative funding
     *
     * @generated from protobuf field: string cumulative_funding_entry = 5
     */
    cumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MarketOrderIndicator
 */
export interface MarketOrderIndicator {
    /**
     * market_id represents the unique ID of the market
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: bool isBuy = 2
     */
    isBuy: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradeLog
 */
export interface TradeLog {
    /**
     * @generated from protobuf field: string quantity = 1
     */
    quantity: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * bytes32 subaccount ID that executed the trade
     *
     * @generated from protobuf field: bytes subaccount_id = 3
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: string fee = 4
     */
    fee: string;
    /**
     * @generated from protobuf field: bytes order_hash = 5
     */
    orderHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes fee_recipient_address = 6
     */
    feeRecipientAddress: Uint8Array;
    /**
     * @generated from protobuf field: string cid = 7
     */
    cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PositionDelta
 */
export interface PositionDelta {
    /**
     * @generated from protobuf field: bool is_long = 1
     */
    isLong: boolean;
    /**
     * @generated from protobuf field: string execution_quantity = 2
     */
    executionQuantity: string;
    /**
     * @generated from protobuf field: string execution_margin = 3
     */
    executionMargin: string;
    /**
     * @generated from protobuf field: string execution_price = 4
     */
    executionPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeTradeLog
 */
export interface DerivativeTradeLog {
    /**
     * @generated from protobuf field: bytes subaccount_id = 1
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.PositionDelta position_delta = 2
     */
    positionDelta?: PositionDelta;
    /**
     * @generated from protobuf field: string payout = 3
     */
    payout: string;
    /**
     * @generated from protobuf field: string fee = 4
     */
    fee: string;
    /**
     * @generated from protobuf field: bytes order_hash = 5
     */
    orderHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes fee_recipient_address = 6
     */
    feeRecipientAddress: Uint8Array;
    /**
     * @generated from protobuf field: string cid = 7
     */
    cid: string;
    /**
     * @generated from protobuf field: string pnl = 8
     */
    pnl: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountPosition
 */
export interface SubaccountPosition {
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.Position position = 1
     */
    position?: Position;
    /**
     * @generated from protobuf field: bytes subaccount_id = 2
     */
    subaccountId: Uint8Array;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountDeposit
 */
export interface SubaccountDeposit {
    /**
     * @generated from protobuf field: bytes subaccount_id = 1
     */
    subaccountId: Uint8Array;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.Deposit deposit = 2
     */
    deposit?: Deposit;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DepositUpdate
 */
export interface DepositUpdate {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.SubaccountDeposit deposits = 2
     */
    deposits: SubaccountDeposit[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PointsMultiplier
 */
export interface PointsMultiplier {
    /**
     * @generated from protobuf field: string maker_points_multiplier = 1
     */
    makerPointsMultiplier: string;
    /**
     * @generated from protobuf field: string taker_points_multiplier = 2
     */
    takerPointsMultiplier: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
 */
export interface TradingRewardCampaignBoostInfo {
    /**
     * @generated from protobuf field: repeated string boosted_spot_market_ids = 1
     */
    boostedSpotMarketIds: string[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2
     */
    spotMarketMultipliers: PointsMultiplier[];
    /**
     * @generated from protobuf field: repeated string boosted_derivative_market_ids = 3
     */
    boostedDerivativeMarketIds: string[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4
     */
    derivativeMarketMultipliers: PointsMultiplier[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.CampaignRewardPool
 */
export interface CampaignRewardPool {
    /**
     * @generated from protobuf field: int64 start_timestamp = 1
     */
    startTimestamp: bigint;
    /**
     * max_campaign_rewards are the maximum reward amounts to be disbursed at the
     * end of the campaign
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2
     */
    maxCampaignRewards: Coin[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignInfo
 */
export interface TradingRewardCampaignInfo {
    /**
     * number of seconds of the duration of each campaign
     *
     * @generated from protobuf field: int64 campaign_duration_seconds = 1
     */
    campaignDurationSeconds: bigint;
    /**
     * the trading fee quote denoms which will be counted for the rewards
     *
     * @generated from protobuf field: repeated string quote_denoms = 2
     */
    quoteDenoms: string[];
    /**
     * the optional boost info for markets
     *
     * @generated from protobuf field: injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3
     */
    tradingRewardBoostInfo?: TradingRewardCampaignBoostInfo;
    /**
     * the marketIDs which are disqualified from being rewarded
     *
     * @generated from protobuf field: repeated string disqualified_market_ids = 4
     */
    disqualifiedMarketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountTierInfo
 */
export interface FeeDiscountTierInfo {
    /**
     * the maker discount rate
     *
     * @generated from protobuf field: string maker_discount_rate = 1
     */
    makerDiscountRate: string;
    /**
     * the taker discount rate
     *
     * @generated from protobuf field: string taker_discount_rate = 2
     */
    takerDiscountRate: string;
    /**
     * the staked amount required to qualify for the discount (in chain format)
     *
     * @generated from protobuf field: string staked_amount = 3
     */
    stakedAmount: string;
    /**
     * the volume required to qualify for the discount (in chain format)
     *
     * @generated from protobuf field: string volume = 4
     */
    volume: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountSchedule
 */
export interface FeeDiscountSchedule {
    /**
     * @generated from protobuf field: uint64 bucket_count = 1
     */
    bucketCount: bigint;
    /**
     * @generated from protobuf field: int64 bucket_duration = 2
     */
    bucketDuration: bigint;
    /**
     * the trading fee quote denoms which will be counted for the fee paid
     * contribution
     *
     * @generated from protobuf field: repeated string quote_denoms = 3
     */
    quoteDenoms: string[];
    /**
     * the fee discount tiers
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4
     */
    tierInfos: FeeDiscountTierInfo[];
    /**
     * the marketIDs which are disqualified from contributing to the fee paid
     * amount
     *
     * @generated from protobuf field: repeated string disqualified_market_ids = 5
     */
    disqualifiedMarketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountTierTTL
 */
export interface FeeDiscountTierTTL {
    /**
     * @generated from protobuf field: uint64 tier = 1
     */
    tier: bigint;
    /**
     * @generated from protobuf field: int64 ttl_timestamp = 2
     */
    ttlTimestamp: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.VolumeRecord
 */
export interface VolumeRecord {
    /**
     * @generated from protobuf field: string maker_volume = 1
     */
    makerVolume: string;
    /**
     * @generated from protobuf field: string taker_volume = 2
     */
    takerVolume: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.AccountRewards
 */
export interface AccountRewards {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin rewards = 2
     */
    rewards: Coin[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradeRecords
 */
export interface TradeRecords {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.TradeRecord latest_trade_records = 2
     */
    latestTradeRecords: TradeRecord[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountIDs
 */
export interface SubaccountIDs {
    /**
     * @generated from protobuf field: repeated bytes subaccount_ids = 1
     */
    subaccountIds: Uint8Array[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradeRecord
 */
export interface TradeRecord {
    /**
     * the timestamp of the trade
     *
     * @generated from protobuf field: int64 timestamp = 1
     */
    timestamp: bigint;
    /**
     * the price of the trade (in chain format)
     *
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * the quantity of the trade (in chain format)
     *
     * @generated from protobuf field: string quantity = 3
     */
    quantity: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.Level
 */
export interface Level {
    /**
     * price (in chain format)
     *
     * @generated from protobuf field: string p = 1
     */
    p: string;
    /**
     * quantity (in chain format)
     *
     * @generated from protobuf field: string q = 2
     */
    q: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.AggregateSubaccountVolumeRecord
 */
export interface AggregateSubaccountVolumeRecord {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the subaccount volumes for each market
     *
     * @generated from protobuf field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2
     */
    marketVolumes: MarketVolume[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.AggregateAccountVolumeRecord
 */
export interface AggregateAccountVolumeRecord {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2
     */
    marketVolumes: MarketVolume[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MarketVolume
 */
export interface MarketVolume {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.VolumeRecord volume = 2
     */
    volume?: VolumeRecord;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DenomDecimals
 */
export interface DenomDecimals {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: uint64 decimals = 2
     */
    decimals: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.GrantAuthorization
 */
export interface GrantAuthorization {
    /**
     * @generated from protobuf field: string grantee = 1
     */
    grantee: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.ActiveGrant
 */
export interface ActiveGrant {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
    /**
     * @generated from protobuf field: string amount = 2
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EffectiveGrant
 */
export interface EffectiveGrant {
    /**
     * @generated from protobuf field: string granter = 1
     */
    granter: string;
    /**
     * @generated from protobuf field: string net_granted_stake = 2
     */
    netGrantedStake: string;
    /**
     * @generated from protobuf field: bool is_valid = 3
     */
    isValid: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DenomMinNotional
 */
export interface DenomMinNotional {
    /**
     * the denom of the token
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * the minimum notional value for the token (in chain format)
     *
     * @generated from protobuf field: string min_notional = 2
     */
    minNotional: string;
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.AtomicMarketOrderAccessLevel
 */
export enum AtomicMarketOrderAccessLevel {
    /**
     * @generated from protobuf enum value: Nobody = 0;
     */
    Nobody = 0,
    /**
     * currently unsupported
     *
     * @generated from protobuf enum value: BeginBlockerSmartContractsOnly = 1;
     */
    BeginBlockerSmartContractsOnly = 1,
    /**
     * @generated from protobuf enum value: SmartContractsOnly = 2;
     */
    SmartContractsOnly = 2,
    /**
     * @generated from protobuf enum value: Everyone = 3;
     */
    Everyone = 3
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.MarketStatus
 */
export enum MarketStatus {
    /**
     * @generated from protobuf enum value: Unspecified = 0;
     */
    Unspecified = 0,
    /**
     * @generated from protobuf enum value: Active = 1;
     */
    Active = 1,
    /**
     * @generated from protobuf enum value: Paused = 2;
     */
    Paused = 2,
    /**
     * @generated from protobuf enum value: Demolished = 3;
     */
    Demolished = 3,
    /**
     * @generated from protobuf enum value: Expired = 4;
     */
    Expired = 4
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.OrderType
 */
export enum OrderType {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: BUY = 1;
     */
    BUY = 1,
    /**
     * @generated from protobuf enum value: SELL = 2;
     */
    SELL = 2,
    /**
     * @generated from protobuf enum value: STOP_BUY = 3;
     */
    STOP_BUY = 3,
    /**
     * @generated from protobuf enum value: STOP_SELL = 4;
     */
    STOP_SELL = 4,
    /**
     * @generated from protobuf enum value: TAKE_BUY = 5;
     */
    TAKE_BUY = 5,
    /**
     * @generated from protobuf enum value: TAKE_SELL = 6;
     */
    TAKE_SELL = 6,
    /**
     * @generated from protobuf enum value: BUY_PO = 7;
     */
    BUY_PO = 7,
    /**
     * @generated from protobuf enum value: SELL_PO = 8;
     */
    SELL_PO = 8,
    /**
     * @generated from protobuf enum value: BUY_ATOMIC = 9;
     */
    BUY_ATOMIC = 9,
    /**
     * @generated from protobuf enum value: SELL_ATOMIC = 10;
     */
    SELL_ATOMIC = 10
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.ExecutionType
 */
export enum ExecutionType {
    /**
     * @generated from protobuf enum value: UnspecifiedExecutionType = 0;
     */
    UnspecifiedExecutionType = 0,
    /**
     * @generated from protobuf enum value: Market = 1;
     */
    Market = 1,
    /**
     * @generated from protobuf enum value: LimitFill = 2;
     */
    LimitFill = 2,
    /**
     * @generated from protobuf enum value: LimitMatchRestingOrder = 3;
     */
    LimitMatchRestingOrder = 3,
    /**
     * @generated from protobuf enum value: LimitMatchNewOrder = 4;
     */
    LimitMatchNewOrder = 4,
    /**
     * @generated from protobuf enum value: MarketLiquidation = 5;
     */
    MarketLiquidation = 5,
    /**
     * @generated from protobuf enum value: ExpiryMarketSettlement = 6;
     */
    ExpiryMarketSettlement = 6
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.OrderMask
 */
export enum OrderMask {
    /**
     * @generated from protobuf enum value: UNUSED = 0;
     */
    UNUSED = 0,
    /**
     * @generated from protobuf enum value: ANY = 1;
     */
    ANY = 1,
    /**
     * @generated from protobuf enum value: REGULAR = 2;
     */
    REGULAR = 2,
    /**
     * @generated from protobuf enum value: CONDITIONAL = 4;
     */
    CONDITIONAL = 4,
    /**
     * for conditional orders means HIGHER
     *
     * @generated from protobuf enum value: DIRECTION_BUY_OR_HIGHER = 8;
     */
    DIRECTION_BUY_OR_HIGHER = 8,
    /**
     * for conditional orders means LOWER
     *
     * @generated from protobuf enum value: DIRECTION_SELL_OR_LOWER = 16;
     */
    DIRECTION_SELL_OR_LOWER = 16,
    /**
     * @generated from protobuf enum value: TYPE_MARKET = 32;
     */
    TYPE_MARKET = 32,
    /**
     * @generated from protobuf enum value: TYPE_LIMIT = 64;
     */
    TYPE_LIMIT = 64
}
// @generated message type with reflection information, may provide speed optimized methods
class OpenNotionalCap$Type extends MessageType<OpenNotionalCap> {
    constructor() {
        super("injective.exchange.v1beta1.OpenNotionalCap", [
            { no: 1, name: "uncapped", kind: "message", oneof: "cap", T: () => OpenNotionalCapUncapped, options: { "amino.oneof_name": "injective.exchange.v1beta1.OpenNotionalCapUncapped" } },
            { no: 2, name: "capped", kind: "message", oneof: "cap", T: () => OpenNotionalCapCapped, options: { "amino.oneof_name": "injective.exchange.v1beta1.OpenNotionalCapCapped" } }
        ]);
    }
    create(value?: PartialMessage<OpenNotionalCap>): OpenNotionalCap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cap = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OpenNotionalCap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenNotionalCap): OpenNotionalCap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.OpenNotionalCapUncapped uncapped */ 1:
                    message.cap = {
                        oneofKind: "uncapped",
                        uncapped: OpenNotionalCapUncapped.internalBinaryRead(reader, reader.uint32(), options, (message.cap as any).uncapped)
                    };
                    break;
                case /* injective.exchange.v1beta1.OpenNotionalCapCapped capped */ 2:
                    message.cap = {
                        oneofKind: "capped",
                        capped: OpenNotionalCapCapped.internalBinaryRead(reader, reader.uint32(), options, (message.cap as any).capped)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenNotionalCap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.OpenNotionalCapUncapped uncapped = 1; */
        if (message.cap.oneofKind === "uncapped")
            OpenNotionalCapUncapped.internalBinaryWrite(message.cap.uncapped, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.OpenNotionalCapCapped capped = 2; */
        if (message.cap.oneofKind === "capped")
            OpenNotionalCapCapped.internalBinaryWrite(message.cap.capped, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OpenNotionalCap
 */
export const OpenNotionalCap = new OpenNotionalCap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenNotionalCapUncapped$Type extends MessageType<OpenNotionalCapUncapped> {
    constructor() {
        super("injective.exchange.v1beta1.OpenNotionalCapUncapped", []);
    }
    create(value?: PartialMessage<OpenNotionalCapUncapped>): OpenNotionalCapUncapped {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OpenNotionalCapUncapped>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenNotionalCapUncapped): OpenNotionalCapUncapped {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenNotionalCapUncapped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OpenNotionalCapUncapped
 */
export const OpenNotionalCapUncapped = new OpenNotionalCapUncapped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenNotionalCapCapped$Type extends MessageType<OpenNotionalCapCapped> {
    constructor() {
        super("injective.exchange.v1beta1.OpenNotionalCapCapped", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<OpenNotionalCapCapped>): OpenNotionalCapCapped {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<OpenNotionalCapCapped>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenNotionalCapCapped): OpenNotionalCapCapped {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenNotionalCapCapped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OpenNotionalCapCapped
 */
export const OpenNotionalCapCapped = new OpenNotionalCapCapped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Params$Type extends MessageType<Params> {
    constructor() {
        super("injective.exchange.v1beta1.Params", [
            { no: 1, name: "spot_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "derivative_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "default_spot_maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "default_spot_taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "default_derivative_maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "default_derivative_taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "default_initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "default_maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "default_funding_interval", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "funding_multiple", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "default_hourly_funding_rate_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "default_hourly_interest_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "max_derivative_order_side_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "inj_reward_staked_requirement_threshold", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 16, name: "trading_rewards_vesting_duration", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "liquidator_reward_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 18, name: "binary_options_market_instant_listing_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 19, name: "atomic_market_order_access_level", kind: "enum", T: () => ["injective.exchange.v1beta1.AtomicMarketOrderAccessLevel", AtomicMarketOrderAccessLevel] },
            { no: 20, name: "spot_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 21, name: "derivative_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 22, name: "binary_options_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 23, name: "minimal_protocol_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 24, name: "is_instant_derivative_market_launch_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "post_only_mode_height_threshold", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 26, name: "margin_decrease_price_timestamp_threshold_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 27, name: "exchange_admins", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "inj_auction_max_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 29, name: "fixed_gas_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.equal": true, "amino.name": "exchange/Params" });
    }
    create(value?: PartialMessage<Params>): Params {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultSpotMakerFeeRate = "";
        message.defaultSpotTakerFeeRate = "";
        message.defaultDerivativeMakerFeeRate = "";
        message.defaultDerivativeTakerFeeRate = "";
        message.defaultInitialMarginRatio = "";
        message.defaultMaintenanceMarginRatio = "";
        message.defaultFundingInterval = 0n;
        message.fundingMultiple = 0n;
        message.relayerFeeShareRate = "";
        message.defaultHourlyFundingRateCap = "";
        message.defaultHourlyInterestRate = "";
        message.maxDerivativeOrderSideCount = 0;
        message.injRewardStakedRequirementThreshold = "";
        message.tradingRewardsVestingDuration = 0n;
        message.liquidatorRewardShareRate = "";
        message.atomicMarketOrderAccessLevel = 0;
        message.spotAtomicMarketOrderFeeMultiplier = "";
        message.derivativeAtomicMarketOrderFeeMultiplier = "";
        message.binaryOptionsAtomicMarketOrderFeeMultiplier = "";
        message.minimalProtocolFeeRate = "";
        message.isInstantDerivativeMarketLaunchEnabled = false;
        message.postOnlyModeHeightThreshold = 0n;
        message.marginDecreasePriceTimestampThresholdSeconds = 0n;
        message.exchangeAdmins = [];
        message.injAuctionMaxCap = "";
        message.fixedGasEnabled = false;
        if (value !== undefined)
            reflectionMergePartial<Params>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin spot_market_instant_listing_fee */ 1:
                    message.spotMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.spotMarketInstantListingFee);
                    break;
                case /* cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee */ 2:
                    message.derivativeMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.derivativeMarketInstantListingFee);
                    break;
                case /* string default_spot_maker_fee_rate */ 3:
                    message.defaultSpotMakerFeeRate = reader.string();
                    break;
                case /* string default_spot_taker_fee_rate */ 4:
                    message.defaultSpotTakerFeeRate = reader.string();
                    break;
                case /* string default_derivative_maker_fee_rate */ 5:
                    message.defaultDerivativeMakerFeeRate = reader.string();
                    break;
                case /* string default_derivative_taker_fee_rate */ 6:
                    message.defaultDerivativeTakerFeeRate = reader.string();
                    break;
                case /* string default_initial_margin_ratio */ 7:
                    message.defaultInitialMarginRatio = reader.string();
                    break;
                case /* string default_maintenance_margin_ratio */ 8:
                    message.defaultMaintenanceMarginRatio = reader.string();
                    break;
                case /* int64 default_funding_interval */ 9:
                    message.defaultFundingInterval = reader.int64().toBigInt();
                    break;
                case /* int64 funding_multiple */ 10:
                    message.fundingMultiple = reader.int64().toBigInt();
                    break;
                case /* string relayer_fee_share_rate */ 11:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* string default_hourly_funding_rate_cap */ 12:
                    message.defaultHourlyFundingRateCap = reader.string();
                    break;
                case /* string default_hourly_interest_rate */ 13:
                    message.defaultHourlyInterestRate = reader.string();
                    break;
                case /* uint32 max_derivative_order_side_count */ 14:
                    message.maxDerivativeOrderSideCount = reader.uint32();
                    break;
                case /* string inj_reward_staked_requirement_threshold */ 15:
                    message.injRewardStakedRequirementThreshold = reader.string();
                    break;
                case /* int64 trading_rewards_vesting_duration */ 16:
                    message.tradingRewardsVestingDuration = reader.int64().toBigInt();
                    break;
                case /* string liquidator_reward_share_rate */ 17:
                    message.liquidatorRewardShareRate = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee */ 18:
                    message.binaryOptionsMarketInstantListingFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.binaryOptionsMarketInstantListingFee);
                    break;
                case /* injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level */ 19:
                    message.atomicMarketOrderAccessLevel = reader.int32();
                    break;
                case /* string spot_atomic_market_order_fee_multiplier */ 20:
                    message.spotAtomicMarketOrderFeeMultiplier = reader.string();
                    break;
                case /* string derivative_atomic_market_order_fee_multiplier */ 21:
                    message.derivativeAtomicMarketOrderFeeMultiplier = reader.string();
                    break;
                case /* string binary_options_atomic_market_order_fee_multiplier */ 22:
                    message.binaryOptionsAtomicMarketOrderFeeMultiplier = reader.string();
                    break;
                case /* string minimal_protocol_fee_rate */ 23:
                    message.minimalProtocolFeeRate = reader.string();
                    break;
                case /* bool is_instant_derivative_market_launch_enabled */ 24:
                    message.isInstantDerivativeMarketLaunchEnabled = reader.bool();
                    break;
                case /* int64 post_only_mode_height_threshold */ 25:
                    message.postOnlyModeHeightThreshold = reader.int64().toBigInt();
                    break;
                case /* int64 margin_decrease_price_timestamp_threshold_seconds */ 26:
                    message.marginDecreasePriceTimestampThresholdSeconds = reader.int64().toBigInt();
                    break;
                case /* repeated string exchange_admins */ 27:
                    message.exchangeAdmins.push(reader.string());
                    break;
                case /* string inj_auction_max_cap */ 28:
                    message.injAuctionMaxCap = reader.string();
                    break;
                case /* bool fixed_gas_enabled */ 29:
                    message.fixedGasEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1; */
        if (message.spotMarketInstantListingFee)
            Coin.internalBinaryWrite(message.spotMarketInstantListingFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2; */
        if (message.derivativeMarketInstantListingFee)
            Coin.internalBinaryWrite(message.derivativeMarketInstantListingFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string default_spot_maker_fee_rate = 3; */
        if (message.defaultSpotMakerFeeRate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.defaultSpotMakerFeeRate);
        /* string default_spot_taker_fee_rate = 4; */
        if (message.defaultSpotTakerFeeRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.defaultSpotTakerFeeRate);
        /* string default_derivative_maker_fee_rate = 5; */
        if (message.defaultDerivativeMakerFeeRate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.defaultDerivativeMakerFeeRate);
        /* string default_derivative_taker_fee_rate = 6; */
        if (message.defaultDerivativeTakerFeeRate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.defaultDerivativeTakerFeeRate);
        /* string default_initial_margin_ratio = 7; */
        if (message.defaultInitialMarginRatio !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.defaultInitialMarginRatio);
        /* string default_maintenance_margin_ratio = 8; */
        if (message.defaultMaintenanceMarginRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.defaultMaintenanceMarginRatio);
        /* int64 default_funding_interval = 9; */
        if (message.defaultFundingInterval !== 0n)
            writer.tag(9, WireType.Varint).int64(message.defaultFundingInterval);
        /* int64 funding_multiple = 10; */
        if (message.fundingMultiple !== 0n)
            writer.tag(10, WireType.Varint).int64(message.fundingMultiple);
        /* string relayer_fee_share_rate = 11; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* string default_hourly_funding_rate_cap = 12; */
        if (message.defaultHourlyFundingRateCap !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.defaultHourlyFundingRateCap);
        /* string default_hourly_interest_rate = 13; */
        if (message.defaultHourlyInterestRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.defaultHourlyInterestRate);
        /* uint32 max_derivative_order_side_count = 14; */
        if (message.maxDerivativeOrderSideCount !== 0)
            writer.tag(14, WireType.Varint).uint32(message.maxDerivativeOrderSideCount);
        /* string inj_reward_staked_requirement_threshold = 15; */
        if (message.injRewardStakedRequirementThreshold !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.injRewardStakedRequirementThreshold);
        /* int64 trading_rewards_vesting_duration = 16; */
        if (message.tradingRewardsVestingDuration !== 0n)
            writer.tag(16, WireType.Varint).int64(message.tradingRewardsVestingDuration);
        /* string liquidator_reward_share_rate = 17; */
        if (message.liquidatorRewardShareRate !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.liquidatorRewardShareRate);
        /* cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18; */
        if (message.binaryOptionsMarketInstantListingFee)
            Coin.internalBinaryWrite(message.binaryOptionsMarketInstantListingFee, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19; */
        if (message.atomicMarketOrderAccessLevel !== 0)
            writer.tag(19, WireType.Varint).int32(message.atomicMarketOrderAccessLevel);
        /* string spot_atomic_market_order_fee_multiplier = 20; */
        if (message.spotAtomicMarketOrderFeeMultiplier !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.spotAtomicMarketOrderFeeMultiplier);
        /* string derivative_atomic_market_order_fee_multiplier = 21; */
        if (message.derivativeAtomicMarketOrderFeeMultiplier !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.derivativeAtomicMarketOrderFeeMultiplier);
        /* string binary_options_atomic_market_order_fee_multiplier = 22; */
        if (message.binaryOptionsAtomicMarketOrderFeeMultiplier !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.binaryOptionsAtomicMarketOrderFeeMultiplier);
        /* string minimal_protocol_fee_rate = 23; */
        if (message.minimalProtocolFeeRate !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.minimalProtocolFeeRate);
        /* bool is_instant_derivative_market_launch_enabled = 24; */
        if (message.isInstantDerivativeMarketLaunchEnabled !== false)
            writer.tag(24, WireType.Varint).bool(message.isInstantDerivativeMarketLaunchEnabled);
        /* int64 post_only_mode_height_threshold = 25; */
        if (message.postOnlyModeHeightThreshold !== 0n)
            writer.tag(25, WireType.Varint).int64(message.postOnlyModeHeightThreshold);
        /* int64 margin_decrease_price_timestamp_threshold_seconds = 26; */
        if (message.marginDecreasePriceTimestampThresholdSeconds !== 0n)
            writer.tag(26, WireType.Varint).int64(message.marginDecreasePriceTimestampThresholdSeconds);
        /* repeated string exchange_admins = 27; */
        for (let i = 0; i < message.exchangeAdmins.length; i++)
            writer.tag(27, WireType.LengthDelimited).string(message.exchangeAdmins[i]);
        /* string inj_auction_max_cap = 28; */
        if (message.injAuctionMaxCap !== "")
            writer.tag(28, WireType.LengthDelimited).string(message.injAuctionMaxCap);
        /* bool fixed_gas_enabled = 29; */
        if (message.fixedGasEnabled !== false)
            writer.tag(29, WireType.Varint).bool(message.fixedGasEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Params
 */
export const Params = new Params$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketFeeMultiplier$Type extends MessageType<MarketFeeMultiplier> {
    constructor() {
        super("injective.exchange.v1beta1.MarketFeeMultiplier", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fee_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<MarketFeeMultiplier>): MarketFeeMultiplier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.feeMultiplier = "";
        if (value !== undefined)
            reflectionMergePartial<MarketFeeMultiplier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketFeeMultiplier): MarketFeeMultiplier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string fee_multiplier */ 2:
                    message.feeMultiplier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketFeeMultiplier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string fee_multiplier = 2; */
        if (message.feeMultiplier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.feeMultiplier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MarketFeeMultiplier
 */
export const MarketFeeMultiplier = new MarketFeeMultiplier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarket$Type extends MessageType<DerivativeMarket> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeMarket", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "oracle_base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "isPerpetual", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] },
            { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 18, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "reduce_margin_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 22, name: "open_notional_cap", kind: "message", T: () => OpenNotionalCap, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<DerivativeMarket>): DerivativeMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.oracleBase = "";
        message.oracleQuote = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.quoteDenom = "";
        message.marketId = "";
        message.initialMarginRatio = "";
        message.maintenanceMarginRatio = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.isPerpetual = false;
        message.status = 0;
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.admin = "";
        message.adminPermissions = 0;
        message.quoteDecimals = 0;
        message.reduceMarginRatio = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarket): DerivativeMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_base */ 2:
                    message.oracleBase = reader.string();
                    break;
                case /* string oracle_quote */ 3:
                    message.oracleQuote = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 4:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 5:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* string quote_denom */ 6:
                    message.quoteDenom = reader.string();
                    break;
                case /* string market_id */ 7:
                    message.marketId = reader.string();
                    break;
                case /* string initial_margin_ratio */ 8:
                    message.initialMarginRatio = reader.string();
                    break;
                case /* string maintenance_margin_ratio */ 9:
                    message.maintenanceMarginRatio = reader.string();
                    break;
                case /* string maker_fee_rate */ 10:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 11:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 12:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* bool isPerpetual */ 13:
                    message.isPerpetual = reader.bool();
                    break;
                case /* injective.exchange.v1beta1.MarketStatus status */ 14:
                    message.status = reader.int32();
                    break;
                case /* string min_price_tick_size */ 15:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 16:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 17:
                    message.minNotional = reader.string();
                    break;
                case /* string admin */ 18:
                    message.admin = reader.string();
                    break;
                case /* uint32 admin_permissions */ 19:
                    message.adminPermissions = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 20:
                    message.quoteDecimals = reader.uint32();
                    break;
                case /* string reduce_margin_ratio */ 21:
                    message.reduceMarginRatio = reader.string();
                    break;
                case /* injective.exchange.v1beta1.OpenNotionalCap open_notional_cap */ 22:
                    message.openNotionalCap = OpenNotionalCap.internalBinaryRead(reader, reader.uint32(), options, message.openNotionalCap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_base = 2; */
        if (message.oracleBase !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oracleBase);
        /* string oracle_quote = 3; */
        if (message.oracleQuote !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oracleQuote);
        /* injective.oracle.v1beta1.OracleType oracle_type = 4; */
        if (message.oracleType !== 0)
            writer.tag(4, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 5; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
        /* string quote_denom = 6; */
        if (message.quoteDenom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.quoteDenom);
        /* string market_id = 7; */
        if (message.marketId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.marketId);
        /* string initial_margin_ratio = 8; */
        if (message.initialMarginRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.initialMarginRatio);
        /* string maintenance_margin_ratio = 9; */
        if (message.maintenanceMarginRatio !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.maintenanceMarginRatio);
        /* string maker_fee_rate = 10; */
        if (message.makerFeeRate !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 11; */
        if (message.takerFeeRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 12; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* bool isPerpetual = 13; */
        if (message.isPerpetual !== false)
            writer.tag(13, WireType.Varint).bool(message.isPerpetual);
        /* injective.exchange.v1beta1.MarketStatus status = 14; */
        if (message.status !== 0)
            writer.tag(14, WireType.Varint).int32(message.status);
        /* string min_price_tick_size = 15; */
        if (message.minPriceTickSize !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 16; */
        if (message.minQuantityTickSize !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 17; */
        if (message.minNotional !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.minNotional);
        /* string admin = 18; */
        if (message.admin !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.admin);
        /* uint32 admin_permissions = 19; */
        if (message.adminPermissions !== 0)
            writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
        /* uint32 quote_decimals = 20; */
        if (message.quoteDecimals !== 0)
            writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
        /* string reduce_margin_ratio = 21; */
        if (message.reduceMarginRatio !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.reduceMarginRatio);
        /* injective.exchange.v1beta1.OpenNotionalCap open_notional_cap = 22; */
        if (message.openNotionalCap)
            OpenNotionalCap.internalBinaryWrite(message.openNotionalCap, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarket
 */
export const DerivativeMarket = new DerivativeMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryOptionsMarket$Type extends MessageType<BinaryOptionsMarket> {
    constructor() {
        super("injective.exchange.v1beta1.BinaryOptionsMarket", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "oracle_symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oracle_provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "settlement_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 13, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 14, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] },
            { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 17, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 18, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 19, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<BinaryOptionsMarket>): BinaryOptionsMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.oracleSymbol = "";
        message.oracleProvider = "";
        message.oracleType = 0;
        message.oracleScaleFactor = 0;
        message.expirationTimestamp = 0n;
        message.settlementTimestamp = 0n;
        message.admin = "";
        message.quoteDenom = "";
        message.marketId = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.status = 0;
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.settlementPrice = "";
        message.minNotional = "";
        message.adminPermissions = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<BinaryOptionsMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryOptionsMarket): BinaryOptionsMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string oracle_symbol */ 2:
                    message.oracleSymbol = reader.string();
                    break;
                case /* string oracle_provider */ 3:
                    message.oracleProvider = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 4:
                    message.oracleType = reader.int32();
                    break;
                case /* uint32 oracle_scale_factor */ 5:
                    message.oracleScaleFactor = reader.uint32();
                    break;
                case /* int64 expiration_timestamp */ 6:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 settlement_timestamp */ 7:
                    message.settlementTimestamp = reader.int64().toBigInt();
                    break;
                case /* string admin */ 8:
                    message.admin = reader.string();
                    break;
                case /* string quote_denom */ 9:
                    message.quoteDenom = reader.string();
                    break;
                case /* string market_id */ 10:
                    message.marketId = reader.string();
                    break;
                case /* string maker_fee_rate */ 11:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 12:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 13:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* injective.exchange.v1beta1.MarketStatus status */ 14:
                    message.status = reader.int32();
                    break;
                case /* string min_price_tick_size */ 15:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 16:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string settlement_price */ 17:
                    message.settlementPrice = reader.string();
                    break;
                case /* string min_notional */ 18:
                    message.minNotional = reader.string();
                    break;
                case /* uint32 admin_permissions */ 19:
                    message.adminPermissions = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 20:
                    message.quoteDecimals = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryOptionsMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string oracle_symbol = 2; */
        if (message.oracleSymbol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oracleSymbol);
        /* string oracle_provider = 3; */
        if (message.oracleProvider !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oracleProvider);
        /* injective.oracle.v1beta1.OracleType oracle_type = 4; */
        if (message.oracleType !== 0)
            writer.tag(4, WireType.Varint).int32(message.oracleType);
        /* uint32 oracle_scale_factor = 5; */
        if (message.oracleScaleFactor !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oracleScaleFactor);
        /* int64 expiration_timestamp = 6; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(6, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 settlement_timestamp = 7; */
        if (message.settlementTimestamp !== 0n)
            writer.tag(7, WireType.Varint).int64(message.settlementTimestamp);
        /* string admin = 8; */
        if (message.admin !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.admin);
        /* string quote_denom = 9; */
        if (message.quoteDenom !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.quoteDenom);
        /* string market_id = 10; */
        if (message.marketId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.marketId);
        /* string maker_fee_rate = 11; */
        if (message.makerFeeRate !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 12; */
        if (message.takerFeeRate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 13; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* injective.exchange.v1beta1.MarketStatus status = 14; */
        if (message.status !== 0)
            writer.tag(14, WireType.Varint).int32(message.status);
        /* string min_price_tick_size = 15; */
        if (message.minPriceTickSize !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 16; */
        if (message.minQuantityTickSize !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string settlement_price = 17; */
        if (message.settlementPrice !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.settlementPrice);
        /* string min_notional = 18; */
        if (message.minNotional !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.minNotional);
        /* uint32 admin_permissions = 19; */
        if (message.adminPermissions !== 0)
            writer.tag(19, WireType.Varint).uint32(message.adminPermissions);
        /* uint32 quote_decimals = 20; */
        if (message.quoteDecimals !== 0)
            writer.tag(20, WireType.Varint).uint32(message.quoteDecimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.BinaryOptionsMarket
 */
export const BinaryOptionsMarket = new BinaryOptionsMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpiryFuturesMarketInfo$Type extends MessageType<ExpiryFuturesMarketInfo> {
    constructor() {
        super("injective.exchange.v1beta1.ExpiryFuturesMarketInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "expiration_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "twap_start_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "expiration_twap_start_price_cumulative", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.expirationTimestamp = 0n;
        message.twapStartTimestamp = 0n;
        message.expirationTwapStartPriceCumulative = "";
        message.settlementPrice = "";
        if (value !== undefined)
            reflectionMergePartial<ExpiryFuturesMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpiryFuturesMarketInfo): ExpiryFuturesMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* int64 expiration_timestamp */ 2:
                    message.expirationTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 twap_start_timestamp */ 3:
                    message.twapStartTimestamp = reader.int64().toBigInt();
                    break;
                case /* string expiration_twap_start_price_cumulative */ 4:
                    message.expirationTwapStartPriceCumulative = reader.string();
                    break;
                case /* string settlement_price */ 5:
                    message.settlementPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpiryFuturesMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* int64 expiration_timestamp = 2; */
        if (message.expirationTimestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.expirationTimestamp);
        /* int64 twap_start_timestamp = 3; */
        if (message.twapStartTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.twapStartTimestamp);
        /* string expiration_twap_start_price_cumulative = 4; */
        if (message.expirationTwapStartPriceCumulative !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.expirationTwapStartPriceCumulative);
        /* string settlement_price = 5; */
        if (message.settlementPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.settlementPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketInfo
 */
export const ExpiryFuturesMarketInfo = new ExpiryFuturesMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketInfo$Type extends MessageType<PerpetualMarketInfo> {
    constructor() {
        super("injective.exchange.v1beta1.PerpetualMarketInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hourly_funding_rate_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "hourly_interest_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "next_funding_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "funding_interval", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketInfo>): PerpetualMarketInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.hourlyFundingRateCap = "";
        message.hourlyInterestRate = "";
        message.nextFundingTimestamp = 0n;
        message.fundingInterval = 0n;
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketInfo): PerpetualMarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string hourly_funding_rate_cap */ 2:
                    message.hourlyFundingRateCap = reader.string();
                    break;
                case /* string hourly_interest_rate */ 3:
                    message.hourlyInterestRate = reader.string();
                    break;
                case /* int64 next_funding_timestamp */ 4:
                    message.nextFundingTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 funding_interval */ 5:
                    message.fundingInterval = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string hourly_funding_rate_cap = 2; */
        if (message.hourlyFundingRateCap !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hourlyFundingRateCap);
        /* string hourly_interest_rate = 3; */
        if (message.hourlyInterestRate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hourlyInterestRate);
        /* int64 next_funding_timestamp = 4; */
        if (message.nextFundingTimestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.nextFundingTimestamp);
        /* int64 funding_interval = 5; */
        if (message.fundingInterval !== 0n)
            writer.tag(5, WireType.Varint).int64(message.fundingInterval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PerpetualMarketInfo
 */
export const PerpetualMarketInfo = new PerpetualMarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerpetualMarketFunding$Type extends MessageType<PerpetualMarketFunding> {
    constructor() {
        super("injective.exchange.v1beta1.PerpetualMarketFunding", [
            { no: 1, name: "cumulative_funding", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "last_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PerpetualMarketFunding>): PerpetualMarketFunding {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cumulativeFunding = "";
        message.cumulativePrice = "";
        message.lastTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PerpetualMarketFunding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerpetualMarketFunding): PerpetualMarketFunding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cumulative_funding */ 1:
                    message.cumulativeFunding = reader.string();
                    break;
                case /* string cumulative_price */ 2:
                    message.cumulativePrice = reader.string();
                    break;
                case /* int64 last_timestamp */ 3:
                    message.lastTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerpetualMarketFunding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cumulative_funding = 1; */
        if (message.cumulativeFunding !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cumulativeFunding);
        /* string cumulative_price = 2; */
        if (message.cumulativePrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
        /* int64 last_timestamp = 3; */
        if (message.lastTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.lastTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PerpetualMarketFunding
 */
export const PerpetualMarketFunding = new PerpetualMarketFunding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketSettlementInfo$Type extends MessageType<DerivativeMarketSettlementInfo> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeMarketSettlementInfo", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settlement_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketSettlementInfo>): DerivativeMarketSettlementInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.settlementPrice = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketSettlementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketSettlementInfo): DerivativeMarketSettlementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string settlement_price */ 2:
                    message.settlementPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketSettlementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string settlement_price = 2; */
        if (message.settlementPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settlementPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarketSettlementInfo
 */
export const DerivativeMarketSettlementInfo = new DerivativeMarketSettlementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NextFundingTimestamp$Type extends MessageType<NextFundingTimestamp> {
    constructor() {
        super("injective.exchange.v1beta1.NextFundingTimestamp", [
            { no: 1, name: "next_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<NextFundingTimestamp>): NextFundingTimestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nextTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<NextFundingTimestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NextFundingTimestamp): NextFundingTimestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 next_timestamp */ 1:
                    message.nextTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NextFundingTimestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 next_timestamp = 1; */
        if (message.nextTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.nextTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.NextFundingTimestamp
 */
export const NextFundingTimestamp = new NextFundingTimestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidPriceAndTOB$Type extends MessageType<MidPriceAndTOB> {
    constructor() {
        super("injective.exchange.v1beta1.MidPriceAndTOB", [
            { no: 1, name: "mid_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<MidPriceAndTOB>): MidPriceAndTOB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.midPrice = "";
        message.bestBuyPrice = "";
        message.bestSellPrice = "";
        if (value !== undefined)
            reflectionMergePartial<MidPriceAndTOB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidPriceAndTOB): MidPriceAndTOB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mid_price */ 1:
                    message.midPrice = reader.string();
                    break;
                case /* string best_buy_price */ 2:
                    message.bestBuyPrice = reader.string();
                    break;
                case /* string best_sell_price */ 3:
                    message.bestSellPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidPriceAndTOB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mid_price = 1; */
        if (message.midPrice !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.midPrice);
        /* string best_buy_price = 2; */
        if (message.bestBuyPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bestBuyPrice);
        /* string best_sell_price = 3; */
        if (message.bestSellPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bestSellPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MidPriceAndTOB
 */
export const MidPriceAndTOB = new MidPriceAndTOB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarket$Type extends MessageType<SpotMarket> {
    constructor() {
        super("injective.exchange.v1beta1.SpotMarket", [
            { no: 1, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "base_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "status", kind: "enum", T: () => ["injective.exchange.v1beta1.MarketStatus", MarketStatus] },
            { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 11, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 12, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "admin_permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "base_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "quote_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpotMarket>): SpotMarket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticker = "";
        message.baseDenom = "";
        message.quoteDenom = "";
        message.makerFeeRate = "";
        message.takerFeeRate = "";
        message.relayerFeeShareRate = "";
        message.marketId = "";
        message.status = 0;
        message.minPriceTickSize = "";
        message.minQuantityTickSize = "";
        message.minNotional = "";
        message.admin = "";
        message.adminPermissions = 0;
        message.baseDecimals = 0;
        message.quoteDecimals = 0;
        if (value !== undefined)
            reflectionMergePartial<SpotMarket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarket): SpotMarket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ticker */ 1:
                    message.ticker = reader.string();
                    break;
                case /* string base_denom */ 2:
                    message.baseDenom = reader.string();
                    break;
                case /* string quote_denom */ 3:
                    message.quoteDenom = reader.string();
                    break;
                case /* string maker_fee_rate */ 4:
                    message.makerFeeRate = reader.string();
                    break;
                case /* string taker_fee_rate */ 5:
                    message.takerFeeRate = reader.string();
                    break;
                case /* string relayer_fee_share_rate */ 6:
                    message.relayerFeeShareRate = reader.string();
                    break;
                case /* string market_id */ 7:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.MarketStatus status */ 8:
                    message.status = reader.int32();
                    break;
                case /* string min_price_tick_size */ 9:
                    message.minPriceTickSize = reader.string();
                    break;
                case /* string min_quantity_tick_size */ 10:
                    message.minQuantityTickSize = reader.string();
                    break;
                case /* string min_notional */ 11:
                    message.minNotional = reader.string();
                    break;
                case /* string admin */ 12:
                    message.admin = reader.string();
                    break;
                case /* uint32 admin_permissions */ 13:
                    message.adminPermissions = reader.uint32();
                    break;
                case /* uint32 base_decimals */ 14:
                    message.baseDecimals = reader.uint32();
                    break;
                case /* uint32 quote_decimals */ 15:
                    message.quoteDecimals = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ticker = 1; */
        if (message.ticker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ticker);
        /* string base_denom = 2; */
        if (message.baseDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.baseDenom);
        /* string quote_denom = 3; */
        if (message.quoteDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenom);
        /* string maker_fee_rate = 4; */
        if (message.makerFeeRate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.makerFeeRate);
        /* string taker_fee_rate = 5; */
        if (message.takerFeeRate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.takerFeeRate);
        /* string relayer_fee_share_rate = 6; */
        if (message.relayerFeeShareRate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.relayerFeeShareRate);
        /* string market_id = 7; */
        if (message.marketId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.MarketStatus status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        /* string min_price_tick_size = 9; */
        if (message.minPriceTickSize !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.minPriceTickSize);
        /* string min_quantity_tick_size = 10; */
        if (message.minQuantityTickSize !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.minQuantityTickSize);
        /* string min_notional = 11; */
        if (message.minNotional !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.minNotional);
        /* string admin = 12; */
        if (message.admin !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.admin);
        /* uint32 admin_permissions = 13; */
        if (message.adminPermissions !== 0)
            writer.tag(13, WireType.Varint).uint32(message.adminPermissions);
        /* uint32 base_decimals = 14; */
        if (message.baseDecimals !== 0)
            writer.tag(14, WireType.Varint).uint32(message.baseDecimals);
        /* uint32 quote_decimals = 15; */
        if (message.quoteDecimals !== 0)
            writer.tag(15, WireType.Varint).uint32(message.quoteDecimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotMarket
 */
export const SpotMarket = new SpotMarket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Deposit$Type extends MessageType<Deposit> {
    constructor() {
        super("injective.exchange.v1beta1.Deposit", [
            { no: 1, name: "available_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "total_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Deposit>): Deposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.availableBalance = "";
        message.totalBalance = "";
        if (value !== undefined)
            reflectionMergePartial<Deposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Deposit): Deposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string available_balance */ 1:
                    message.availableBalance = reader.string();
                    break;
                case /* string total_balance */ 2:
                    message.totalBalance = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Deposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string available_balance = 1; */
        if (message.availableBalance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.availableBalance);
        /* string total_balance = 2; */
        if (message.totalBalance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.totalBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Deposit
 */
export const Deposit = new Deposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountTradeNonce$Type extends MessageType<SubaccountTradeNonce> {
    constructor() {
        super("injective.exchange.v1beta1.SubaccountTradeNonce", [
            { no: 1, name: "nonce", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountTradeNonce>): SubaccountTradeNonce {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0;
        if (value !== undefined)
            reflectionMergePartial<SubaccountTradeNonce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountTradeNonce): SubaccountTradeNonce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 nonce */ 1:
                    message.nonce = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountTradeNonce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 nonce = 1; */
        if (message.nonce !== 0)
            writer.tag(1, WireType.Varint).uint32(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountTradeNonce
 */
export const SubaccountTradeNonce = new SubaccountTradeNonce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderInfo$Type extends MessageType<OrderInfo> {
    constructor() {
        super("injective.exchange.v1beta1.OrderInfo", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fee_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderInfo>): OrderInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.feeRecipient = "";
        message.price = "";
        message.quantity = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<OrderInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderInfo): OrderInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* string fee_recipient */ 2:
                    message.feeRecipient = reader.string();
                    break;
                case /* string price */ 3:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 4:
                    message.quantity = reader.string();
                    break;
                case /* string cid */ 5:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* string fee_recipient = 2; */
        if (message.feeRecipient !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.feeRecipient);
        /* string price = 3; */
        if (message.price !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.price);
        /* string quantity = 4; */
        if (message.quantity !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quantity);
        /* string cid = 5; */
        if (message.cid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OrderInfo
 */
export const OrderInfo = new OrderInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotOrder$Type extends MessageType<SpotOrder> {
    constructor() {
        super("injective.exchange.v1beta1.SpotOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
            { no: 3, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
            { no: 4, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<SpotOrder>): SpotOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.orderType = 0;
        message.triggerPrice = "";
        if (value !== undefined)
            reflectionMergePartial<SpotOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotOrder): SpotOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.OrderInfo order_info */ 2:
                    message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
                    break;
                case /* injective.exchange.v1beta1.OrderType order_type */ 3:
                    message.orderType = reader.int32();
                    break;
                case /* string trigger_price */ 4:
                    message.triggerPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.OrderInfo order_info = 2; */
        if (message.orderInfo)
            OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.OrderType order_type = 3; */
        if (message.orderType !== 0)
            writer.tag(3, WireType.Varint).int32(message.orderType);
        /* string trigger_price = 4; */
        if (message.triggerPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotOrder
 */
export const SpotOrder = new SpotOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotLimitOrder$Type extends MessageType<SpotLimitOrder> {
    constructor() {
        super("injective.exchange.v1beta1.SpotLimitOrder", [
            { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
            { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
            { no: 3, name: "fillable", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SpotLimitOrder>): SpotLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderType = 0;
        message.fillable = "";
        message.triggerPrice = "";
        message.orderHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SpotLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotLimitOrder): SpotLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.OrderInfo order_info */ 1:
                    message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
                    break;
                case /* injective.exchange.v1beta1.OrderType order_type */ 2:
                    message.orderType = reader.int32();
                    break;
                case /* string fillable */ 3:
                    message.fillable = reader.string();
                    break;
                case /* string trigger_price */ 4:
                    message.triggerPrice = reader.string();
                    break;
                case /* bytes order_hash */ 5:
                    message.orderHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.OrderInfo order_info = 1; */
        if (message.orderInfo)
            OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.OrderType order_type = 2; */
        if (message.orderType !== 0)
            writer.tag(2, WireType.Varint).int32(message.orderType);
        /* string fillable = 3; */
        if (message.fillable !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fillable);
        /* string trigger_price = 4; */
        if (message.triggerPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.triggerPrice);
        /* bytes order_hash = 5; */
        if (message.orderHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotLimitOrder
 */
export const SpotLimitOrder = new SpotLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotMarketOrder$Type extends MessageType<SpotMarketOrder> {
    constructor() {
        super("injective.exchange.v1beta1.SpotMarketOrder", [
            { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
            { no: 2, name: "balance_hold", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
            { no: 5, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<SpotMarketOrder>): SpotMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balanceHold = "";
        message.orderHash = new Uint8Array(0);
        message.orderType = 0;
        message.triggerPrice = "";
        if (value !== undefined)
            reflectionMergePartial<SpotMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotMarketOrder): SpotMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.OrderInfo order_info */ 1:
                    message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
                    break;
                case /* string balance_hold */ 2:
                    message.balanceHold = reader.string();
                    break;
                case /* bytes order_hash */ 3:
                    message.orderHash = reader.bytes();
                    break;
                case /* injective.exchange.v1beta1.OrderType order_type */ 4:
                    message.orderType = reader.int32();
                    break;
                case /* string trigger_price */ 5:
                    message.triggerPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.OrderInfo order_info = 1; */
        if (message.orderInfo)
            OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string balance_hold = 2; */
        if (message.balanceHold !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.balanceHold);
        /* bytes order_hash = 3; */
        if (message.orderHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.orderHash);
        /* injective.exchange.v1beta1.OrderType order_type = 4; */
        if (message.orderType !== 0)
            writer.tag(4, WireType.Varint).int32(message.orderType);
        /* string trigger_price = 5; */
        if (message.triggerPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotMarketOrder
 */
export const SpotMarketOrder = new SpotMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeOrder$Type extends MessageType<DerivativeOrder> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
            { no: 3, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
            { no: 4, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DerivativeOrder>): DerivativeOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.orderType = 0;
        message.margin = "";
        message.triggerPrice = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeOrder): DerivativeOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.OrderInfo order_info */ 2:
                    message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
                    break;
                case /* injective.exchange.v1beta1.OrderType order_type */ 3:
                    message.orderType = reader.int32();
                    break;
                case /* string margin */ 4:
                    message.margin = reader.string();
                    break;
                case /* string trigger_price */ 5:
                    message.triggerPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.OrderInfo order_info = 2; */
        if (message.orderInfo)
            OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.OrderType order_type = 3; */
        if (message.orderType !== 0)
            writer.tag(3, WireType.Varint).int32(message.orderType);
        /* string margin = 4; */
        if (message.margin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.margin);
        /* string trigger_price = 5; */
        if (message.triggerPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeOrder
 */
export const DerivativeOrder = new DerivativeOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrderbookMetadata$Type extends MessageType<SubaccountOrderbookMetadata> {
    constructor() {
        super("injective.exchange.v1beta1.SubaccountOrderbookMetadata", [
            { no: 1, name: "vanilla_limit_order_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "reduce_only_limit_order_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "aggregate_reduce_only_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "aggregate_vanilla_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "vanilla_conditional_order_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "reduce_only_conditional_order_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrderbookMetadata>): SubaccountOrderbookMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vanillaLimitOrderCount = 0;
        message.reduceOnlyLimitOrderCount = 0;
        message.aggregateReduceOnlyQuantity = "";
        message.aggregateVanillaQuantity = "";
        message.vanillaConditionalOrderCount = 0;
        message.reduceOnlyConditionalOrderCount = 0;
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrderbookMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrderbookMetadata): SubaccountOrderbookMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 vanilla_limit_order_count */ 1:
                    message.vanillaLimitOrderCount = reader.uint32();
                    break;
                case /* uint32 reduce_only_limit_order_count */ 2:
                    message.reduceOnlyLimitOrderCount = reader.uint32();
                    break;
                case /* string aggregate_reduce_only_quantity */ 3:
                    message.aggregateReduceOnlyQuantity = reader.string();
                    break;
                case /* string aggregate_vanilla_quantity */ 4:
                    message.aggregateVanillaQuantity = reader.string();
                    break;
                case /* uint32 vanilla_conditional_order_count */ 5:
                    message.vanillaConditionalOrderCount = reader.uint32();
                    break;
                case /* uint32 reduce_only_conditional_order_count */ 6:
                    message.reduceOnlyConditionalOrderCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrderbookMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 vanilla_limit_order_count = 1; */
        if (message.vanillaLimitOrderCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.vanillaLimitOrderCount);
        /* uint32 reduce_only_limit_order_count = 2; */
        if (message.reduceOnlyLimitOrderCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.reduceOnlyLimitOrderCount);
        /* string aggregate_reduce_only_quantity = 3; */
        if (message.aggregateReduceOnlyQuantity !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.aggregateReduceOnlyQuantity);
        /* string aggregate_vanilla_quantity = 4; */
        if (message.aggregateVanillaQuantity !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.aggregateVanillaQuantity);
        /* uint32 vanilla_conditional_order_count = 5; */
        if (message.vanillaConditionalOrderCount !== 0)
            writer.tag(5, WireType.Varint).uint32(message.vanillaConditionalOrderCount);
        /* uint32 reduce_only_conditional_order_count = 6; */
        if (message.reduceOnlyConditionalOrderCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.reduceOnlyConditionalOrderCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountOrderbookMetadata
 */
export const SubaccountOrderbookMetadata = new SubaccountOrderbookMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrder$Type extends MessageType<SubaccountOrder> {
    constructor() {
        super("injective.exchange.v1beta1.SubaccountOrder", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "isReduceOnly", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrder>): SubaccountOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.quantity = "";
        message.isReduceOnly = false;
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrder): SubaccountOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* bool isReduceOnly */ 3:
                    message.isReduceOnly = reader.bool();
                    break;
                case /* string cid */ 4:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* bool isReduceOnly = 3; */
        if (message.isReduceOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.isReduceOnly);
        /* string cid = 4; */
        if (message.cid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountOrder
 */
export const SubaccountOrder = new SubaccountOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountOrderData$Type extends MessageType<SubaccountOrderData> {
    constructor() {
        super("injective.exchange.v1beta1.SubaccountOrderData", [
            { no: 1, name: "order", kind: "message", T: () => SubaccountOrder },
            { no: 2, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountOrderData>): SubaccountOrderData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubaccountOrderData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountOrderData): SubaccountOrderData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.SubaccountOrder order */ 1:
                    message.order = SubaccountOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* bytes order_hash */ 2:
                    message.orderHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountOrderData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.SubaccountOrder order = 1; */
        if (message.order)
            SubaccountOrder.internalBinaryWrite(message.order, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes order_hash = 2; */
        if (message.orderHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.orderHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountOrderData
 */
export const SubaccountOrderData = new SubaccountOrderData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeLimitOrder$Type extends MessageType<DerivativeLimitOrder> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeLimitOrder", [
            { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
            { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
            { no: 3, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "fillable", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeLimitOrder>): DerivativeLimitOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderType = 0;
        message.margin = "";
        message.fillable = "";
        message.triggerPrice = "";
        message.orderHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<DerivativeLimitOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeLimitOrder): DerivativeLimitOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.OrderInfo order_info */ 1:
                    message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
                    break;
                case /* injective.exchange.v1beta1.OrderType order_type */ 2:
                    message.orderType = reader.int32();
                    break;
                case /* string margin */ 3:
                    message.margin = reader.string();
                    break;
                case /* string fillable */ 4:
                    message.fillable = reader.string();
                    break;
                case /* string trigger_price */ 5:
                    message.triggerPrice = reader.string();
                    break;
                case /* bytes order_hash */ 6:
                    message.orderHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeLimitOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.OrderInfo order_info = 1; */
        if (message.orderInfo)
            OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.OrderType order_type = 2; */
        if (message.orderType !== 0)
            writer.tag(2, WireType.Varint).int32(message.orderType);
        /* string margin = 3; */
        if (message.margin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.margin);
        /* string fillable = 4; */
        if (message.fillable !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fillable);
        /* string trigger_price = 5; */
        if (message.triggerPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
        /* bytes order_hash = 6; */
        if (message.orderHash.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.orderHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeLimitOrder
 */
export const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeMarketOrder$Type extends MessageType<DerivativeMarketOrder> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeMarketOrder", [
            { no: 1, name: "order_info", kind: "message", T: () => OrderInfo, options: { "gogoproto.nullable": false } },
            { no: 2, name: "order_type", kind: "enum", T: () => ["injective.exchange.v1beta1.OrderType", OrderType] },
            { no: 3, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "margin_hold", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "trigger_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeMarketOrder>): DerivativeMarketOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orderType = 0;
        message.margin = "";
        message.marginHold = "";
        message.triggerPrice = "";
        message.orderHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<DerivativeMarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeMarketOrder): DerivativeMarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.OrderInfo order_info */ 1:
                    message.orderInfo = OrderInfo.internalBinaryRead(reader, reader.uint32(), options, message.orderInfo);
                    break;
                case /* injective.exchange.v1beta1.OrderType order_type */ 2:
                    message.orderType = reader.int32();
                    break;
                case /* string margin */ 3:
                    message.margin = reader.string();
                    break;
                case /* string margin_hold */ 4:
                    message.marginHold = reader.string();
                    break;
                case /* string trigger_price */ 5:
                    message.triggerPrice = reader.string();
                    break;
                case /* bytes order_hash */ 6:
                    message.orderHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeMarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.OrderInfo order_info = 1; */
        if (message.orderInfo)
            OrderInfo.internalBinaryWrite(message.orderInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.exchange.v1beta1.OrderType order_type = 2; */
        if (message.orderType !== 0)
            writer.tag(2, WireType.Varint).int32(message.orderType);
        /* string margin = 3; */
        if (message.margin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.margin);
        /* string margin_hold = 4; */
        if (message.marginHold !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marginHold);
        /* string trigger_price = 5; */
        if (message.triggerPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.triggerPrice);
        /* bytes order_hash = 6; */
        if (message.orderHash.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.orderHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarketOrder
 */
export const DerivativeMarketOrder = new DerivativeMarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("injective.exchange.v1beta1.Position", [
            { no: 1, name: "isLong", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLong = false;
        message.quantity = "";
        message.entryPrice = "";
        message.margin = "";
        message.cumulativeFundingEntry = "";
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isLong */ 1:
                    message.isLong = reader.bool();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 3:
                    message.entryPrice = reader.string();
                    break;
                case /* string margin */ 4:
                    message.margin = reader.string();
                    break;
                case /* string cumulative_funding_entry */ 5:
                    message.cumulativeFundingEntry = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isLong = 1; */
        if (message.isLong !== false)
            writer.tag(1, WireType.Varint).bool(message.isLong);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 3; */
        if (message.entryPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.entryPrice);
        /* string margin = 4; */
        if (message.margin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.margin);
        /* string cumulative_funding_entry = 5; */
        if (message.cumulativeFundingEntry !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketOrderIndicator$Type extends MessageType<MarketOrderIndicator> {
    constructor() {
        super("injective.exchange.v1beta1.MarketOrderIndicator", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isBuy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MarketOrderIndicator>): MarketOrderIndicator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isBuy = false;
        if (value !== undefined)
            reflectionMergePartial<MarketOrderIndicator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketOrderIndicator): MarketOrderIndicator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool isBuy */ 2:
                    message.isBuy = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketOrderIndicator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool isBuy = 2; */
        if (message.isBuy !== false)
            writer.tag(2, WireType.Varint).bool(message.isBuy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MarketOrderIndicator
 */
export const MarketOrderIndicator = new MarketOrderIndicator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeLog$Type extends MessageType<TradeLog> {
    constructor() {
        super("injective.exchange.v1beta1.TradeLog", [
            { no: 1, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.nullable": true } },
            { no: 7, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradeLog>): TradeLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = "";
        message.price = "";
        message.subaccountId = new Uint8Array(0);
        message.fee = "";
        message.orderHash = new Uint8Array(0);
        message.feeRecipientAddress = new Uint8Array(0);
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<TradeLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeLog): TradeLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string quantity */ 1:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* bytes subaccount_id */ 3:
                    message.subaccountId = reader.bytes();
                    break;
                case /* string fee */ 4:
                    message.fee = reader.string();
                    break;
                case /* bytes order_hash */ 5:
                    message.orderHash = reader.bytes();
                    break;
                case /* bytes fee_recipient_address */ 6:
                    message.feeRecipientAddress = reader.bytes();
                    break;
                case /* string cid */ 7:
                    message.cid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string quantity = 1; */
        if (message.quantity !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.quantity);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* bytes subaccount_id = 3; */
        if (message.subaccountId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.subaccountId);
        /* string fee = 4; */
        if (message.fee !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fee);
        /* bytes order_hash = 5; */
        if (message.orderHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
        /* bytes fee_recipient_address = 6; */
        if (message.feeRecipientAddress.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
        /* string cid = 7; */
        if (message.cid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradeLog
 */
export const TradeLog = new TradeLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionDelta$Type extends MessageType<PositionDelta> {
    constructor() {
        super("injective.exchange.v1beta1.PositionDelta", [
            { no: 1, name: "is_long", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "execution_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "execution_margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "execution_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<PositionDelta>): PositionDelta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLong = false;
        message.executionQuantity = "";
        message.executionMargin = "";
        message.executionPrice = "";
        if (value !== undefined)
            reflectionMergePartial<PositionDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionDelta): PositionDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_long */ 1:
                    message.isLong = reader.bool();
                    break;
                case /* string execution_quantity */ 2:
                    message.executionQuantity = reader.string();
                    break;
                case /* string execution_margin */ 3:
                    message.executionMargin = reader.string();
                    break;
                case /* string execution_price */ 4:
                    message.executionPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_long = 1; */
        if (message.isLong !== false)
            writer.tag(1, WireType.Varint).bool(message.isLong);
        /* string execution_quantity = 2; */
        if (message.executionQuantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.executionQuantity);
        /* string execution_margin = 3; */
        if (message.executionMargin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionMargin);
        /* string execution_price = 4; */
        if (message.executionPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.executionPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PositionDelta
 */
export const PositionDelta = new PositionDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeTradeLog$Type extends MessageType<DerivativeTradeLog> {
    constructor() {
        super("injective.exchange.v1beta1.DerivativeTradeLog", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "position_delta", kind: "message", T: () => PositionDelta },
            { no: 3, name: "payout", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "order_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.nullable": true } },
            { no: 7, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pnl", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DerivativeTradeLog>): DerivativeTradeLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = new Uint8Array(0);
        message.payout = "";
        message.fee = "";
        message.orderHash = new Uint8Array(0);
        message.feeRecipientAddress = new Uint8Array(0);
        message.cid = "";
        message.pnl = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeTradeLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeTradeLog): DerivativeTradeLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes subaccount_id */ 1:
                    message.subaccountId = reader.bytes();
                    break;
                case /* injective.exchange.v1beta1.PositionDelta position_delta */ 2:
                    message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
                    break;
                case /* string payout */ 3:
                    message.payout = reader.string();
                    break;
                case /* string fee */ 4:
                    message.fee = reader.string();
                    break;
                case /* bytes order_hash */ 5:
                    message.orderHash = reader.bytes();
                    break;
                case /* bytes fee_recipient_address */ 6:
                    message.feeRecipientAddress = reader.bytes();
                    break;
                case /* string cid */ 7:
                    message.cid = reader.string();
                    break;
                case /* string pnl */ 8:
                    message.pnl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeTradeLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes subaccount_id = 1; */
        if (message.subaccountId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
        /* injective.exchange.v1beta1.PositionDelta position_delta = 2; */
        if (message.positionDelta)
            PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string payout = 3; */
        if (message.payout !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payout);
        /* string fee = 4; */
        if (message.fee !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fee);
        /* bytes order_hash = 5; */
        if (message.orderHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.orderHash);
        /* bytes fee_recipient_address = 6; */
        if (message.feeRecipientAddress.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.feeRecipientAddress);
        /* string cid = 7; */
        if (message.cid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cid);
        /* string pnl = 8; */
        if (message.pnl !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.pnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeTradeLog
 */
export const DerivativeTradeLog = new DerivativeTradeLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountPosition$Type extends MessageType<SubaccountPosition> {
    constructor() {
        super("injective.exchange.v1beta1.SubaccountPosition", [
            { no: 1, name: "position", kind: "message", T: () => Position },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountPosition>): SubaccountPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubaccountPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountPosition): SubaccountPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.exchange.v1beta1.Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* bytes subaccount_id */ 2:
                    message.subaccountId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.exchange.v1beta1.Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes subaccount_id = 2; */
        if (message.subaccountId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.subaccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountPosition
 */
export const SubaccountPosition = new SubaccountPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountDeposit$Type extends MessageType<SubaccountDeposit> {
    constructor() {
        super("injective.exchange.v1beta1.SubaccountDeposit", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "deposit", kind: "message", T: () => Deposit }
        ]);
    }
    create(value?: PartialMessage<SubaccountDeposit>): SubaccountDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubaccountDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountDeposit): SubaccountDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes subaccount_id */ 1:
                    message.subaccountId = reader.bytes();
                    break;
                case /* injective.exchange.v1beta1.Deposit deposit */ 2:
                    message.deposit = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes subaccount_id = 1; */
        if (message.subaccountId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountId);
        /* injective.exchange.v1beta1.Deposit deposit = 2; */
        if (message.deposit)
            Deposit.internalBinaryWrite(message.deposit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountDeposit
 */
export const SubaccountDeposit = new SubaccountDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DepositUpdate$Type extends MessageType<DepositUpdate> {
    constructor() {
        super("injective.exchange.v1beta1.DepositUpdate", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deposits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountDeposit }
        ]);
    }
    create(value?: PartialMessage<DepositUpdate>): DepositUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.deposits = [];
        if (value !== undefined)
            reflectionMergePartial<DepositUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DepositUpdate): DepositUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.SubaccountDeposit deposits */ 2:
                    message.deposits.push(SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DepositUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* repeated injective.exchange.v1beta1.SubaccountDeposit deposits = 2; */
        for (let i = 0; i < message.deposits.length; i++)
            SubaccountDeposit.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DepositUpdate
 */
export const DepositUpdate = new DepositUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointsMultiplier$Type extends MessageType<PointsMultiplier> {
    constructor() {
        super("injective.exchange.v1beta1.PointsMultiplier", [
            { no: 1, name: "maker_points_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "taker_points_multiplier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<PointsMultiplier>): PointsMultiplier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.makerPointsMultiplier = "";
        message.takerPointsMultiplier = "";
        if (value !== undefined)
            reflectionMergePartial<PointsMultiplier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointsMultiplier): PointsMultiplier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string maker_points_multiplier */ 1:
                    message.makerPointsMultiplier = reader.string();
                    break;
                case /* string taker_points_multiplier */ 2:
                    message.takerPointsMultiplier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointsMultiplier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string maker_points_multiplier = 1; */
        if (message.makerPointsMultiplier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.makerPointsMultiplier);
        /* string taker_points_multiplier = 2; */
        if (message.takerPointsMultiplier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.takerPointsMultiplier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PointsMultiplier
 */
export const PointsMultiplier = new PointsMultiplier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignBoostInfo$Type extends MessageType<TradingRewardCampaignBoostInfo> {
    constructor() {
        super("injective.exchange.v1beta1.TradingRewardCampaignBoostInfo", [
            { no: 1, name: "boosted_spot_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spot_market_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } },
            { no: 3, name: "boosted_derivative_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "derivative_market_multipliers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PointsMultiplier, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<TradingRewardCampaignBoostInfo>): TradingRewardCampaignBoostInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boostedSpotMarketIds = [];
        message.spotMarketMultipliers = [];
        message.boostedDerivativeMarketIds = [];
        message.derivativeMarketMultipliers = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignBoostInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignBoostInfo): TradingRewardCampaignBoostInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string boosted_spot_market_ids */ 1:
                    message.boostedSpotMarketIds.push(reader.string());
                    break;
                case /* repeated injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers */ 2:
                    message.spotMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string boosted_derivative_market_ids */ 3:
                    message.boostedDerivativeMarketIds.push(reader.string());
                    break;
                case /* repeated injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers */ 4:
                    message.derivativeMarketMultipliers.push(PointsMultiplier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignBoostInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string boosted_spot_market_ids = 1; */
        for (let i = 0; i < message.boostedSpotMarketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.boostedSpotMarketIds[i]);
        /* repeated injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2; */
        for (let i = 0; i < message.spotMarketMultipliers.length; i++)
            PointsMultiplier.internalBinaryWrite(message.spotMarketMultipliers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string boosted_derivative_market_ids = 3; */
        for (let i = 0; i < message.boostedDerivativeMarketIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.boostedDerivativeMarketIds[i]);
        /* repeated injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4; */
        for (let i = 0; i < message.derivativeMarketMultipliers.length; i++)
            PointsMultiplier.internalBinaryWrite(message.derivativeMarketMultipliers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
 */
export const TradingRewardCampaignBoostInfo = new TradingRewardCampaignBoostInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CampaignRewardPool$Type extends MessageType<CampaignRewardPool> {
    constructor() {
        super("injective.exchange.v1beta1.CampaignRewardPool", [
            { no: 1, name: "start_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_campaign_rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<CampaignRewardPool>): CampaignRewardPool {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startTimestamp = 0n;
        message.maxCampaignRewards = [];
        if (value !== undefined)
            reflectionMergePartial<CampaignRewardPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CampaignRewardPool): CampaignRewardPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 start_timestamp */ 1:
                    message.startTimestamp = reader.int64().toBigInt();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin max_campaign_rewards */ 2:
                    message.maxCampaignRewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CampaignRewardPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 start_timestamp = 1; */
        if (message.startTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.startTimestamp);
        /* repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2; */
        for (let i = 0; i < message.maxCampaignRewards.length; i++)
            Coin.internalBinaryWrite(message.maxCampaignRewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CampaignRewardPool
 */
export const CampaignRewardPool = new CampaignRewardPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingRewardCampaignInfo$Type extends MessageType<TradingRewardCampaignInfo> {
    constructor() {
        super("injective.exchange.v1beta1.TradingRewardCampaignInfo", [
            { no: 1, name: "campaign_duration_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "quote_denoms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "trading_reward_boost_info", kind: "message", T: () => TradingRewardCampaignBoostInfo },
            { no: 4, name: "disqualified_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradingRewardCampaignInfo>): TradingRewardCampaignInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.campaignDurationSeconds = 0n;
        message.quoteDenoms = [];
        message.disqualifiedMarketIds = [];
        if (value !== undefined)
            reflectionMergePartial<TradingRewardCampaignInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingRewardCampaignInfo): TradingRewardCampaignInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 campaign_duration_seconds */ 1:
                    message.campaignDurationSeconds = reader.int64().toBigInt();
                    break;
                case /* repeated string quote_denoms */ 2:
                    message.quoteDenoms.push(reader.string());
                    break;
                case /* injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info */ 3:
                    message.tradingRewardBoostInfo = TradingRewardCampaignBoostInfo.internalBinaryRead(reader, reader.uint32(), options, message.tradingRewardBoostInfo);
                    break;
                case /* repeated string disqualified_market_ids */ 4:
                    message.disqualifiedMarketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingRewardCampaignInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 campaign_duration_seconds = 1; */
        if (message.campaignDurationSeconds !== 0n)
            writer.tag(1, WireType.Varint).int64(message.campaignDurationSeconds);
        /* repeated string quote_denoms = 2; */
        for (let i = 0; i < message.quoteDenoms.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.quoteDenoms[i]);
        /* injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3; */
        if (message.tradingRewardBoostInfo)
            TradingRewardCampaignBoostInfo.internalBinaryWrite(message.tradingRewardBoostInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string disqualified_market_ids = 4; */
        for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignInfo
 */
export const TradingRewardCampaignInfo = new TradingRewardCampaignInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountTierInfo$Type extends MessageType<FeeDiscountTierInfo> {
    constructor() {
        super("injective.exchange.v1beta1.FeeDiscountTierInfo", [
            { no: 1, name: "maker_discount_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "taker_discount_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "staked_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 4, name: "volume", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountTierInfo>): FeeDiscountTierInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.makerDiscountRate = "";
        message.takerDiscountRate = "";
        message.stakedAmount = "";
        message.volume = "";
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountTierInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountTierInfo): FeeDiscountTierInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string maker_discount_rate */ 1:
                    message.makerDiscountRate = reader.string();
                    break;
                case /* string taker_discount_rate */ 2:
                    message.takerDiscountRate = reader.string();
                    break;
                case /* string staked_amount */ 3:
                    message.stakedAmount = reader.string();
                    break;
                case /* string volume */ 4:
                    message.volume = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountTierInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string maker_discount_rate = 1; */
        if (message.makerDiscountRate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.makerDiscountRate);
        /* string taker_discount_rate = 2; */
        if (message.takerDiscountRate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.takerDiscountRate);
        /* string staked_amount = 3; */
        if (message.stakedAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stakedAmount);
        /* string volume = 4; */
        if (message.volume !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountTierInfo
 */
export const FeeDiscountTierInfo = new FeeDiscountTierInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountSchedule$Type extends MessageType<FeeDiscountSchedule> {
    constructor() {
        super("injective.exchange.v1beta1.FeeDiscountSchedule", [
            { no: 1, name: "bucket_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bucket_duration", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "quote_denoms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tier_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeeDiscountTierInfo },
            { no: 5, name: "disqualified_market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountSchedule>): FeeDiscountSchedule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketCount = 0n;
        message.bucketDuration = 0n;
        message.quoteDenoms = [];
        message.tierInfos = [];
        message.disqualifiedMarketIds = [];
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountSchedule): FeeDiscountSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 bucket_count */ 1:
                    message.bucketCount = reader.uint64().toBigInt();
                    break;
                case /* int64 bucket_duration */ 2:
                    message.bucketDuration = reader.int64().toBigInt();
                    break;
                case /* repeated string quote_denoms */ 3:
                    message.quoteDenoms.push(reader.string());
                    break;
                case /* repeated injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos */ 4:
                    message.tierInfos.push(FeeDiscountTierInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string disqualified_market_ids */ 5:
                    message.disqualifiedMarketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 bucket_count = 1; */
        if (message.bucketCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.bucketCount);
        /* int64 bucket_duration = 2; */
        if (message.bucketDuration !== 0n)
            writer.tag(2, WireType.Varint).int64(message.bucketDuration);
        /* repeated string quote_denoms = 3; */
        for (let i = 0; i < message.quoteDenoms.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.quoteDenoms[i]);
        /* repeated injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4; */
        for (let i = 0; i < message.tierInfos.length; i++)
            FeeDiscountTierInfo.internalBinaryWrite(message.tierInfos[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string disqualified_market_ids = 5; */
        for (let i = 0; i < message.disqualifiedMarketIds.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.disqualifiedMarketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountSchedule
 */
export const FeeDiscountSchedule = new FeeDiscountSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeDiscountTierTTL$Type extends MessageType<FeeDiscountTierTTL> {
    constructor() {
        super("injective.exchange.v1beta1.FeeDiscountTierTTL", [
            { no: 1, name: "tier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ttl_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FeeDiscountTierTTL>): FeeDiscountTierTTL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tier = 0n;
        message.ttlTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<FeeDiscountTierTTL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeDiscountTierTTL): FeeDiscountTierTTL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 tier */ 1:
                    message.tier = reader.uint64().toBigInt();
                    break;
                case /* int64 ttl_timestamp */ 2:
                    message.ttlTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeDiscountTierTTL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 tier = 1; */
        if (message.tier !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.tier);
        /* int64 ttl_timestamp = 2; */
        if (message.ttlTimestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.ttlTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountTierTTL
 */
export const FeeDiscountTierTTL = new FeeDiscountTierTTL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolumeRecord$Type extends MessageType<VolumeRecord> {
    constructor() {
        super("injective.exchange.v1beta1.VolumeRecord", [
            { no: 1, name: "maker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "taker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<VolumeRecord>): VolumeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.makerVolume = "";
        message.takerVolume = "";
        if (value !== undefined)
            reflectionMergePartial<VolumeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VolumeRecord): VolumeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string maker_volume */ 1:
                    message.makerVolume = reader.string();
                    break;
                case /* string taker_volume */ 2:
                    message.takerVolume = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VolumeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string maker_volume = 1; */
        if (message.makerVolume !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.makerVolume);
        /* string taker_volume = 2; */
        if (message.takerVolume !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.takerVolume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.VolumeRecord
 */
export const VolumeRecord = new VolumeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountRewards$Type extends MessageType<AccountRewards> {
    constructor() {
        super("injective.exchange.v1beta1.AccountRewards", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<AccountRewards>): AccountRewards {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.rewards = [];
        if (value !== undefined)
            reflectionMergePartial<AccountRewards>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountRewards): AccountRewards {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin rewards */ 2:
                    message.rewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountRewards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* repeated cosmos.base.v1beta1.Coin rewards = 2; */
        for (let i = 0; i < message.rewards.length; i++)
            Coin.internalBinaryWrite(message.rewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.AccountRewards
 */
export const AccountRewards = new AccountRewards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeRecords$Type extends MessageType<TradeRecords> {
    constructor() {
        super("injective.exchange.v1beta1.TradeRecords", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "latest_trade_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TradeRecord }
        ]);
    }
    create(value?: PartialMessage<TradeRecords>): TradeRecords {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.latestTradeRecords = [];
        if (value !== undefined)
            reflectionMergePartial<TradeRecords>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeRecords): TradeRecords {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.TradeRecord latest_trade_records */ 2:
                    message.latestTradeRecords.push(TradeRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeRecords, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* repeated injective.exchange.v1beta1.TradeRecord latest_trade_records = 2; */
        for (let i = 0; i < message.latestTradeRecords.length; i++)
            TradeRecord.internalBinaryWrite(message.latestTradeRecords[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradeRecords
 */
export const TradeRecords = new TradeRecords$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountIDs$Type extends MessageType<SubaccountIDs> {
    constructor() {
        super("injective.exchange.v1beta1.SubaccountIDs", [
            { no: 1, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountIDs>): SubaccountIDs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountIds = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountIDs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountIDs): SubaccountIDs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes subaccount_ids */ 1:
                    message.subaccountIds.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountIDs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes subaccount_ids = 1; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.subaccountIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountIDs
 */
export const SubaccountIDs = new SubaccountIDs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeRecord$Type extends MessageType<TradeRecord> {
    constructor() {
        super("injective.exchange.v1beta1.TradeRecord", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<TradeRecord>): TradeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        message.price = "";
        message.quantity = "";
        if (value !== undefined)
            reflectionMergePartial<TradeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeRecord): TradeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 3:
                    message.quantity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* string quantity = 3; */
        if (message.quantity !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradeRecord
 */
export const TradeRecord = new TradeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Level$Type extends MessageType<Level> {
    constructor() {
        super("injective.exchange.v1beta1.Level", [
            { no: 1, name: "p", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "q", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Level>): Level {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.p = "";
        message.q = "";
        if (value !== undefined)
            reflectionMergePartial<Level>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Level): Level {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string p */ 1:
                    message.p = reader.string();
                    break;
                case /* string q */ 2:
                    message.q = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Level, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string p = 1; */
        if (message.p !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.p);
        /* string q = 2; */
        if (message.q !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.q);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Level
 */
export const Level = new Level$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateSubaccountVolumeRecord$Type extends MessageType<AggregateSubaccountVolumeRecord> {
    constructor() {
        super("injective.exchange.v1beta1.AggregateSubaccountVolumeRecord", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<AggregateSubaccountVolumeRecord>): AggregateSubaccountVolumeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.marketVolumes = [];
        if (value !== undefined)
            reflectionMergePartial<AggregateSubaccountVolumeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateSubaccountVolumeRecord): AggregateSubaccountVolumeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.MarketVolume market_volumes */ 2:
                    message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateSubaccountVolumeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2; */
        for (let i = 0; i < message.marketVolumes.length; i++)
            MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.AggregateSubaccountVolumeRecord
 */
export const AggregateSubaccountVolumeRecord = new AggregateSubaccountVolumeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateAccountVolumeRecord$Type extends MessageType<AggregateAccountVolumeRecord> {
    constructor() {
        super("injective.exchange.v1beta1.AggregateAccountVolumeRecord", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<AggregateAccountVolumeRecord>): AggregateAccountVolumeRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.marketVolumes = [];
        if (value !== undefined)
            reflectionMergePartial<AggregateAccountVolumeRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateAccountVolumeRecord): AggregateAccountVolumeRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.MarketVolume market_volumes */ 2:
                    message.marketVolumes.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateAccountVolumeRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2; */
        for (let i = 0; i < message.marketVolumes.length; i++)
            MarketVolume.internalBinaryWrite(message.marketVolumes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.AggregateAccountVolumeRecord
 */
export const AggregateAccountVolumeRecord = new AggregateAccountVolumeRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketVolume$Type extends MessageType<MarketVolume> {
    constructor() {
        super("injective.exchange.v1beta1.MarketVolume", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "volume", kind: "message", T: () => VolumeRecord, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<MarketVolume>): MarketVolume {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<MarketVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketVolume): MarketVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.VolumeRecord volume */ 2:
                    message.volume = VolumeRecord.internalBinaryRead(reader, reader.uint32(), options, message.volume);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.VolumeRecord volume = 2; */
        if (message.volume)
            VolumeRecord.internalBinaryWrite(message.volume, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MarketVolume
 */
export const MarketVolume = new MarketVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomDecimals$Type extends MessageType<DenomDecimals> {
    constructor() {
        super("injective.exchange.v1beta1.DenomDecimals", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "decimals", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DenomDecimals>): DenomDecimals {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.decimals = 0n;
        if (value !== undefined)
            reflectionMergePartial<DenomDecimals>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomDecimals): DenomDecimals {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* uint64 decimals */ 2:
                    message.decimals = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomDecimals, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* uint64 decimals = 2; */
        if (message.decimals !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.decimals);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DenomDecimals
 */
export const DenomDecimals = new DenomDecimals$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrantAuthorization$Type extends MessageType<GrantAuthorization> {
    constructor() {
        super("injective.exchange.v1beta1.GrantAuthorization", [
            { no: 1, name: "grantee", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
        ]);
    }
    create(value?: PartialMessage<GrantAuthorization>): GrantAuthorization {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantee = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<GrantAuthorization>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrantAuthorization): GrantAuthorization {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grantee */ 1:
                    message.grantee = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GrantAuthorization, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grantee = 1; */
        if (message.grantee !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantee);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.GrantAuthorization
 */
export const GrantAuthorization = new GrantAuthorization$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveGrant$Type extends MessageType<ActiveGrant> {
    constructor() {
        super("injective.exchange.v1beta1.ActiveGrant", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
        ]);
    }
    create(value?: PartialMessage<ActiveGrant>): ActiveGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<ActiveGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveGrant): ActiveGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                case /* string amount */ 2:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        /* string amount = 2; */
        if (message.amount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ActiveGrant
 */
export const ActiveGrant = new ActiveGrant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EffectiveGrant$Type extends MessageType<EffectiveGrant> {
    constructor() {
        super("injective.exchange.v1beta1.EffectiveGrant", [
            { no: 1, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "net_granted_stake", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 3, name: "is_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EffectiveGrant>): EffectiveGrant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.granter = "";
        message.netGrantedStake = "";
        message.isValid = false;
        if (value !== undefined)
            reflectionMergePartial<EffectiveGrant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffectiveGrant): EffectiveGrant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string granter */ 1:
                    message.granter = reader.string();
                    break;
                case /* string net_granted_stake */ 2:
                    message.netGrantedStake = reader.string();
                    break;
                case /* bool is_valid */ 3:
                    message.isValid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EffectiveGrant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string granter = 1; */
        if (message.granter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.granter);
        /* string net_granted_stake = 2; */
        if (message.netGrantedStake !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.netGrantedStake);
        /* bool is_valid = 3; */
        if (message.isValid !== false)
            writer.tag(3, WireType.Varint).bool(message.isValid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EffectiveGrant
 */
export const EffectiveGrant = new EffectiveGrant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomMinNotional$Type extends MessageType<DenomMinNotional> {
    constructor() {
        super("injective.exchange.v1beta1.DenomMinNotional", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "min_notional", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<DenomMinNotional>): DenomMinNotional {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.minNotional = "";
        if (value !== undefined)
            reflectionMergePartial<DenomMinNotional>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomMinNotional): DenomMinNotional {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string min_notional */ 2:
                    message.minNotional = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomMinNotional, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string min_notional = 2; */
        if (message.minNotional !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.minNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DenomMinNotional
 */
export const DenomMinNotional = new DenomMinNotional$Type();
