// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/oracle/v1beta1/oracle.proto" (package "injective.oracle.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
/**
 * @generated from protobuf message injective.oracle.v1beta1.Params
 */
export interface Params {
    /**
     * @generated from protobuf field: string pyth_contract = 1
     */
    pythContract: string;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.OracleInfo
 */
export interface OracleInfo {
    /**
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 2
     */
    oracleType: OracleType;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.ChainlinkPriceState
 */
export interface ChainlinkPriceState {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: string answer = 2
     */
    answer: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 3
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.PriceState price_state = 4
     */
    priceState?: PriceState;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.BandPriceState
 */
export interface BandPriceState {
    /**
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * @generated from protobuf field: string rate = 2
     */
    rate: string;
    /**
     * @generated from protobuf field: uint64 resolve_time = 3
     */
    resolveTime: bigint;
    /**
     * @generated from protobuf field: uint64 request_ID = 4
     */
    requestID: bigint;
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.PriceState price_state = 5
     */
    priceState?: PriceState;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PriceFeedState
 */
export interface PriceFeedState {
    /**
     * @generated from protobuf field: string base = 1
     */
    base: string;
    /**
     * @generated from protobuf field: string quote = 2
     */
    quote: string;
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.PriceState price_state = 3
     */
    priceState?: PriceState;
    /**
     * @generated from protobuf field: repeated string relayers = 4
     */
    relayers: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.ProviderInfo
 */
export interface ProviderInfo {
    /**
     * @generated from protobuf field: string provider = 1
     */
    provider: string;
    /**
     * @generated from protobuf field: repeated string relayers = 2
     */
    relayers: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.ProviderState
 */
export interface ProviderState {
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.ProviderInfo provider_info = 1
     */
    providerInfo?: ProviderInfo;
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2
     */
    providerPriceStates: ProviderPriceState[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.ProviderPriceState
 */
export interface ProviderPriceState {
    /**
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.PriceState state = 2
     */
    state?: PriceState;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PriceFeedInfo
 */
export interface PriceFeedInfo {
    /**
     * @generated from protobuf field: string base = 1
     */
    base: string;
    /**
     * @generated from protobuf field: string quote = 2
     */
    quote: string;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PriceFeedPrice
 */
export interface PriceFeedPrice {
    /**
     * @generated from protobuf field: string price = 1
     */
    price: string;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.CoinbasePriceState
 */
export interface CoinbasePriceState {
    /**
     * kind should always be "prices"
     *
     * @generated from protobuf field: string kind = 1
     */
    kind: string;
    /**
     * timestamp of the when the price was signed by coinbase
     *
     * @generated from protobuf field: uint64 timestamp = 2
     */
    timestamp: bigint;
    /**
     * the symbol of the price, e.g. BTC
     *
     * @generated from protobuf field: string key = 3
     */
    key: string;
    /**
     * the value of the price scaled by 1e6
     *
     * @generated from protobuf field: uint64 value = 4
     */
    value: bigint;
    /**
     * the price state
     *
     * @generated from protobuf field: injective.oracle.v1beta1.PriceState price_state = 5
     */
    priceState?: PriceState;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.StorkPriceState
 */
export interface StorkPriceState {
    /**
     * timestamp of the when the price was signed by stork
     *
     * @generated from protobuf field: uint64 timestamp = 1
     */
    timestamp: bigint;
    /**
     * the symbol of the price, e.g. BTC
     *
     * @generated from protobuf field: string symbol = 2
     */
    symbol: string;
    /**
     * the value of the price scaled by 1e18
     *
     * @generated from protobuf field: string value = 3
     */
    value: string;
    /**
     * the price state
     *
     * @generated from protobuf field: injective.oracle.v1beta1.PriceState price_state = 5
     */
    priceState?: PriceState;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PriceState
 */
export interface PriceState {
    /**
     * @generated from protobuf field: string price = 1
     */
    price: string;
    /**
     * @generated from protobuf field: string cumulative_price = 2
     */
    cumulativePrice: string;
    /**
     * @generated from protobuf field: int64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PythPriceState
 */
export interface PythPriceState {
    /**
     * @generated from protobuf field: string price_id = 1
     */
    priceId: string;
    /**
     * @generated from protobuf field: string ema_price = 2
     */
    emaPrice: string;
    /**
     * @generated from protobuf field: string ema_conf = 3
     */
    emaConf: string;
    /**
     * @generated from protobuf field: string conf = 4
     */
    conf: string;
    /**
     * @generated from protobuf field: uint64 publish_time = 5
     */
    publishTime: bigint;
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.PriceState price_state = 6
     */
    priceState?: PriceState;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.BandOracleRequest
 */
export interface BandOracleRequest {
    /**
     * Unique Identifier for band ibc oracle request
     *
     * @generated from protobuf field: uint64 request_id = 1
     */
    requestId: bigint;
    /**
     * OracleScriptID is the unique identifier of the oracle script to be
     * executed.
     *
     * @generated from protobuf field: int64 oracle_script_id = 2
     */
    oracleScriptId: bigint;
    /**
     * Symbols is the list of symbols to prepare in the calldata
     *
     * @generated from protobuf field: repeated string symbols = 3
     */
    symbols: string[];
    /**
     * AskCount is the number of validators that are requested to respond to this
     * oracle request. Higher value means more security, at a higher gas cost.
     *
     * @generated from protobuf field: uint64 ask_count = 4
     */
    askCount: bigint;
    /**
     * MinCount is the minimum number of validators necessary for the request to
     * proceed to the execution phase. Higher value means more security, at the
     * cost of liveness.
     *
     * @generated from protobuf field: uint64 min_count = 5
     */
    minCount: bigint;
    /**
     * FeeLimit is the maximum tokens that will be paid to all data source
     * providers.
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin fee_limit = 6
     */
    feeLimit: Coin[];
    /**
     * PrepareGas is amount of gas to pay to prepare raw requests
     *
     * @generated from protobuf field: uint64 prepare_gas = 7
     */
    prepareGas: bigint;
    /**
     * ExecuteGas is amount of gas to reserve for executing
     *
     * @generated from protobuf field: uint64 execute_gas = 8
     */
    executeGas: bigint;
    /**
     * MinSourceCount is the minimum number of data sources that must be used by
     * each validator
     *
     * @generated from protobuf field: uint64 min_source_count = 9
     */
    minSourceCount: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.BandIBCParams
 */
export interface BandIBCParams {
    /**
     * true if Band IBC should be enabled
     *
     * @generated from protobuf field: bool band_ibc_enabled = 1
     */
    bandIbcEnabled: boolean;
    /**
     * block request interval to send Band IBC prices
     *
     * @generated from protobuf field: int64 ibc_request_interval = 2
     */
    ibcRequestInterval: bigint;
    /**
     * band IBC source channel
     *
     * @generated from protobuf field: string ibc_source_channel = 3
     */
    ibcSourceChannel: string;
    /**
     * band IBC version
     *
     * @generated from protobuf field: string ibc_version = 4
     */
    ibcVersion: string;
    /**
     * band IBC portID
     *
     * @generated from protobuf field: string ibc_port_id = 5
     */
    ibcPortId: string;
    /**
     *  legacy oracle scheme ids
     *
     * @generated from protobuf field: repeated int64 legacy_oracle_ids = 6
     */
    legacyOracleIds: bigint[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.SymbolPriceTimestamp
 */
export interface SymbolPriceTimestamp {
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle = 1
     */
    oracle: OracleType;
    /**
     * @generated from protobuf field: string symbol_id = 2
     */
    symbolId: string;
    /**
     * @generated from protobuf field: int64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.LastPriceTimestamps
 */
export interface LastPriceTimestamps {
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1
     */
    lastPriceTimestamps: SymbolPriceTimestamp[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PriceRecords
 */
export interface PriceRecords {
    /**
     * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle = 1
     */
    oracle: OracleType;
    /**
     * @generated from protobuf field: string symbol_id = 2
     */
    symbolId: string;
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.PriceRecord latest_price_records = 3
     */
    latestPriceRecords: PriceRecord[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PriceRecord
 */
export interface PriceRecord {
    /**
     * @generated from protobuf field: int64 timestamp = 1
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
}
/**
 * MetadataStatistics refers to the metadata summary statistics of the
 * historical sample considered
 *
 * @generated from protobuf message injective.oracle.v1beta1.MetadataStatistics
 */
export interface MetadataStatistics {
    /**
     * GroupCount refers to the number of groups used. Equals RecordsSampleSize if
     * no grouping is used
     *
     * @generated from protobuf field: uint32 group_count = 1
     */
    groupCount: number;
    /**
     * RecordsSampleSize refers to the total number of records used.
     *
     * @generated from protobuf field: uint32 records_sample_size = 2
     */
    recordsSampleSize: number;
    /**
     * Mean refers to the arithmetic mean
     * For trades, the mean is the VWAP computed over the grouped trade records ∑
     * (price * quantity) / ∑ quantity For oracle prices, the mean is computed
     * over the price records ∑ (price) / prices_count
     *
     * @generated from protobuf field: string mean = 3
     */
    mean: string;
    /**
     * TWAP refers to the time-weighted average price which equals ∑ (price_i *
     * ∆t_i) / ∑ ∆t_i where ∆t_i = t_i - t_{i-1}
     *
     * @generated from protobuf field: string twap = 4
     */
    twap: string;
    /**
     * FirstTimestamp is the timestamp of the oldest record considered
     *
     * @generated from protobuf field: int64 first_timestamp = 5
     */
    firstTimestamp: bigint;
    /**
     * LastTimestamp is the timestamp of the youngest record considered
     *
     * @generated from protobuf field: int64 last_timestamp = 6
     */
    lastTimestamp: bigint;
    /**
     * MinPrice refers to the smallest individual raw price considered
     *
     * @generated from protobuf field: string min_price = 7
     */
    minPrice: string;
    /**
     * MaxPrice refers to the largest individual raw price considered
     *
     * @generated from protobuf field: string max_price = 8
     */
    maxPrice: string;
    /**
     * MedianPrice refers to the median individual raw price considered
     *
     * @generated from protobuf field: string median_price = 9
     */
    medianPrice: string;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.PriceAttestation
 */
export interface PriceAttestation {
    /**
     * @generated from protobuf field: string price_id = 1
     */
    priceId: string;
    /**
     * MaxPrice refers to the largest individual raw price considered
     *
     * @generated from protobuf field: int64 price = 2
     */
    price: bigint;
    /**
     * @generated from protobuf field: uint64 conf = 3
     */
    conf: bigint;
    /**
     * @generated from protobuf field: int32 expo = 4
     */
    expo: number;
    /**
     * @generated from protobuf field: int64 ema_price = 5
     */
    emaPrice: bigint;
    /**
     * @generated from protobuf field: uint64 ema_conf = 6
     */
    emaConf: bigint;
    /**
     * @generated from protobuf field: int32 ema_expo = 7
     */
    emaExpo: number;
    /**
     * @generated from protobuf field: int64 publish_time = 8
     */
    publishTime: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.AssetPair
 */
export interface AssetPair {
    /**
     * @generated from protobuf field: string asset_id = 1
     */
    assetId: string;
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.SignedPriceOfAssetPair signed_prices = 2
     */
    signedPrices: SignedPriceOfAssetPair[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.SignedPriceOfAssetPair
 */
export interface SignedPriceOfAssetPair {
    /**
     * @generated from protobuf field: string publisher_key = 1
     */
    publisherKey: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 2
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: string price = 3
     */
    price: string;
    /**
     * @generated from protobuf field: bytes signature = 4
     */
    signature: Uint8Array;
}
/**
 * @generated from protobuf enum injective.oracle.v1beta1.OracleType
 */
export enum OracleType {
    /**
     * @generated from protobuf enum value: Unspecified = 0;
     */
    Unspecified = 0,
    /**
     * @generated from protobuf enum value: Band = 1;
     */
    Band = 1,
    /**
     * @generated from protobuf enum value: PriceFeed = 2;
     */
    PriceFeed = 2,
    /**
     * @generated from protobuf enum value: Coinbase = 3;
     */
    Coinbase = 3,
    /**
     * @generated from protobuf enum value: Chainlink = 4;
     */
    Chainlink = 4,
    /**
     * @generated from protobuf enum value: Razor = 5;
     */
    Razor = 5,
    /**
     * @generated from protobuf enum value: Dia = 6;
     */
    Dia = 6,
    /**
     * @generated from protobuf enum value: API3 = 7;
     */
    API3 = 7,
    /**
     * @generated from protobuf enum value: Uma = 8;
     */
    Uma = 8,
    /**
     * @generated from protobuf enum value: Pyth = 9;
     */
    Pyth = 9,
    /**
     * @generated from protobuf enum value: BandIBC = 10;
     */
    BandIBC = 10,
    /**
     * @generated from protobuf enum value: Provider = 11;
     */
    Provider = 11,
    /**
     * @generated from protobuf enum value: Stork = 12;
     */
    Stork = 12
}
// @generated message type with reflection information, may provide speed optimized methods
class Params$Type extends MessageType<Params> {
    constructor() {
        super("injective.oracle.v1beta1.Params", [
            { no: 1, name: "pyth_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true, "amino.name": "oracle/Params" });
    }
    create(value?: PartialMessage<Params>): Params {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pythContract = "";
        if (value !== undefined)
            reflectionMergePartial<Params>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pyth_contract */ 1:
                    message.pythContract = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pyth_contract = 1; */
        if (message.pythContract !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pythContract);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.Params
 */
export const Params = new Params$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OracleInfo$Type extends MessageType<OracleInfo> {
    constructor() {
        super("injective.oracle.v1beta1.OracleInfo", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] }
        ]);
    }
    create(value?: PartialMessage<OracleInfo>): OracleInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        message.oracleType = 0;
        if (value !== undefined)
            reflectionMergePartial<OracleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OracleInfo): OracleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* injective.oracle.v1beta1.OracleType oracle_type */ 2:
                    message.oracleType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OracleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* injective.oracle.v1beta1.OracleType oracle_type = 2; */
        if (message.oracleType !== 0)
            writer.tag(2, WireType.Varint).int32(message.oracleType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.OracleInfo
 */
export const OracleInfo = new OracleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChainlinkPriceState$Type extends MessageType<ChainlinkPriceState> {
    constructor() {
        super("injective.oracle.v1beta1.ChainlinkPriceState", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<ChainlinkPriceState>): ChainlinkPriceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.answer = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<ChainlinkPriceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChainlinkPriceState): ChainlinkPriceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* string answer */ 2:
                    message.answer = reader.string();
                    break;
                case /* uint64 timestamp */ 3:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* injective.oracle.v1beta1.PriceState price_state */ 4:
                    message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChainlinkPriceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* string answer = 2; */
        if (message.answer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.answer);
        /* uint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.timestamp);
        /* injective.oracle.v1beta1.PriceState price_state = 4; */
        if (message.priceState)
            PriceState.internalBinaryWrite(message.priceState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.ChainlinkPriceState
 */
export const ChainlinkPriceState = new ChainlinkPriceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BandPriceState$Type extends MessageType<BandPriceState> {
    constructor() {
        super("injective.oracle.v1beta1.BandPriceState", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 3, name: "resolve_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "request_ID", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<BandPriceState>): BandPriceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        message.rate = "";
        message.resolveTime = 0n;
        message.requestID = 0n;
        if (value !== undefined)
            reflectionMergePartial<BandPriceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BandPriceState): BandPriceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* string rate */ 2:
                    message.rate = reader.string();
                    break;
                case /* uint64 resolve_time */ 3:
                    message.resolveTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 request_ID */ 4:
                    message.requestID = reader.uint64().toBigInt();
                    break;
                case /* injective.oracle.v1beta1.PriceState price_state */ 5:
                    message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BandPriceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* string rate = 2; */
        if (message.rate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.rate);
        /* uint64 resolve_time = 3; */
        if (message.resolveTime !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.resolveTime);
        /* uint64 request_ID = 4; */
        if (message.requestID !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.requestID);
        /* injective.oracle.v1beta1.PriceState price_state = 5; */
        if (message.priceState)
            PriceState.internalBinaryWrite(message.priceState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.BandPriceState
 */
export const BandPriceState = new BandPriceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceFeedState$Type extends MessageType<PriceFeedState> {
    constructor() {
        super("injective.oracle.v1beta1.PriceFeedState", [
            { no: 1, name: "base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price_state", kind: "message", T: () => PriceState },
            { no: 4, name: "relayers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PriceFeedState>): PriceFeedState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.base = "";
        message.quote = "";
        message.relayers = [];
        if (value !== undefined)
            reflectionMergePartial<PriceFeedState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceFeedState): PriceFeedState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base */ 1:
                    message.base = reader.string();
                    break;
                case /* string quote */ 2:
                    message.quote = reader.string();
                    break;
                case /* injective.oracle.v1beta1.PriceState price_state */ 3:
                    message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
                    break;
                case /* repeated string relayers */ 4:
                    message.relayers.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceFeedState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base = 1; */
        if (message.base !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.base);
        /* string quote = 2; */
        if (message.quote !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quote);
        /* injective.oracle.v1beta1.PriceState price_state = 3; */
        if (message.priceState)
            PriceState.internalBinaryWrite(message.priceState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string relayers = 4; */
        for (let i = 0; i < message.relayers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.relayers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PriceFeedState
 */
export const PriceFeedState = new PriceFeedState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProviderInfo$Type extends MessageType<ProviderInfo> {
    constructor() {
        super("injective.oracle.v1beta1.ProviderInfo", [
            { no: 1, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relayers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProviderInfo>): ProviderInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.provider = "";
        message.relayers = [];
        if (value !== undefined)
            reflectionMergePartial<ProviderInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProviderInfo): ProviderInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider */ 1:
                    message.provider = reader.string();
                    break;
                case /* repeated string relayers */ 2:
                    message.relayers.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProviderInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider = 1; */
        if (message.provider !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.provider);
        /* repeated string relayers = 2; */
        for (let i = 0; i < message.relayers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.relayers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.ProviderInfo
 */
export const ProviderInfo = new ProviderInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProviderState$Type extends MessageType<ProviderState> {
    constructor() {
        super("injective.oracle.v1beta1.ProviderState", [
            { no: 1, name: "provider_info", kind: "message", T: () => ProviderInfo },
            { no: 2, name: "provider_price_states", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProviderPriceState }
        ]);
    }
    create(value?: PartialMessage<ProviderState>): ProviderState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerPriceStates = [];
        if (value !== undefined)
            reflectionMergePartial<ProviderState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProviderState): ProviderState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.oracle.v1beta1.ProviderInfo provider_info */ 1:
                    message.providerInfo = ProviderInfo.internalBinaryRead(reader, reader.uint32(), options, message.providerInfo);
                    break;
                case /* repeated injective.oracle.v1beta1.ProviderPriceState provider_price_states */ 2:
                    message.providerPriceStates.push(ProviderPriceState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProviderState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.oracle.v1beta1.ProviderInfo provider_info = 1; */
        if (message.providerInfo)
            ProviderInfo.internalBinaryWrite(message.providerInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2; */
        for (let i = 0; i < message.providerPriceStates.length; i++)
            ProviderPriceState.internalBinaryWrite(message.providerPriceStates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.ProviderState
 */
export const ProviderState = new ProviderState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProviderPriceState$Type extends MessageType<ProviderPriceState> {
    constructor() {
        super("injective.oracle.v1beta1.ProviderPriceState", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "message", T: () => PriceState }
        ]);
    }
    create(value?: PartialMessage<ProviderPriceState>): ProviderPriceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        if (value !== undefined)
            reflectionMergePartial<ProviderPriceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProviderPriceState): ProviderPriceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* injective.oracle.v1beta1.PriceState state */ 2:
                    message.state = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProviderPriceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* injective.oracle.v1beta1.PriceState state = 2; */
        if (message.state)
            PriceState.internalBinaryWrite(message.state, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.ProviderPriceState
 */
export const ProviderPriceState = new ProviderPriceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceFeedInfo$Type extends MessageType<PriceFeedInfo> {
    constructor() {
        super("injective.oracle.v1beta1.PriceFeedInfo", [
            { no: 1, name: "base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PriceFeedInfo>): PriceFeedInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.base = "";
        message.quote = "";
        if (value !== undefined)
            reflectionMergePartial<PriceFeedInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceFeedInfo): PriceFeedInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base */ 1:
                    message.base = reader.string();
                    break;
                case /* string quote */ 2:
                    message.quote = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceFeedInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base = 1; */
        if (message.base !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.base);
        /* string quote = 2; */
        if (message.quote !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quote);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PriceFeedInfo
 */
export const PriceFeedInfo = new PriceFeedInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceFeedPrice$Type extends MessageType<PriceFeedPrice> {
    constructor() {
        super("injective.oracle.v1beta1.PriceFeedPrice", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<PriceFeedPrice>): PriceFeedPrice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        if (value !== undefined)
            reflectionMergePartial<PriceFeedPrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceFeedPrice): PriceFeedPrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceFeedPrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PriceFeedPrice
 */
export const PriceFeedPrice = new PriceFeedPrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoinbasePriceState$Type extends MessageType<CoinbasePriceState> {
    constructor() {
        super("injective.oracle.v1beta1.CoinbasePriceState", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<CoinbasePriceState>): CoinbasePriceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.timestamp = 0n;
        message.key = "";
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<CoinbasePriceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoinbasePriceState): CoinbasePriceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* uint64 timestamp */ 2:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* string key */ 3:
                    message.key = reader.string();
                    break;
                case /* uint64 value */ 4:
                    message.value = reader.uint64().toBigInt();
                    break;
                case /* injective.oracle.v1beta1.PriceState price_state */ 5:
                    message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoinbasePriceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* uint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestamp);
        /* string key = 3; */
        if (message.key !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.key);
        /* uint64 value = 4; */
        if (message.value !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.value);
        /* injective.oracle.v1beta1.PriceState price_state = 5; */
        if (message.priceState)
            PriceState.internalBinaryWrite(message.priceState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.CoinbasePriceState
 */
export const CoinbasePriceState = new CoinbasePriceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorkPriceState$Type extends MessageType<StorkPriceState> {
    constructor() {
        super("injective.oracle.v1beta1.StorkPriceState", [
            { no: 1, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<StorkPriceState>): StorkPriceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        message.symbol = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<StorkPriceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorkPriceState): StorkPriceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp */ 1:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* string symbol */ 2:
                    message.symbol = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                case /* injective.oracle.v1beta1.PriceState price_state */ 5:
                    message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorkPriceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestamp);
        /* string symbol = 2; */
        if (message.symbol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.symbol);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        /* injective.oracle.v1beta1.PriceState price_state = 5; */
        if (message.priceState)
            PriceState.internalBinaryWrite(message.priceState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.StorkPriceState
 */
export const StorkPriceState = new StorkPriceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceState$Type extends MessageType<PriceState> {
    constructor() {
        super("injective.oracle.v1beta1.PriceState", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceState>): PriceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        message.cumulativePrice = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceState): PriceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string cumulative_price */ 2:
                    message.cumulativePrice = reader.string();
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string cumulative_price = 2; */
        if (message.cumulativePrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PriceState
 */
export const PriceState = new PriceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PythPriceState$Type extends MessageType<PythPriceState> {
    constructor() {
        super("injective.oracle.v1beta1.PythPriceState", [
            { no: 1, name: "price_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ema_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "ema_conf", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "conf", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "publish_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<PythPriceState>): PythPriceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.priceId = "";
        message.emaPrice = "";
        message.emaConf = "";
        message.conf = "";
        message.publishTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<PythPriceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PythPriceState): PythPriceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price_id */ 1:
                    message.priceId = reader.string();
                    break;
                case /* string ema_price */ 2:
                    message.emaPrice = reader.string();
                    break;
                case /* string ema_conf */ 3:
                    message.emaConf = reader.string();
                    break;
                case /* string conf */ 4:
                    message.conf = reader.string();
                    break;
                case /* uint64 publish_time */ 5:
                    message.publishTime = reader.uint64().toBigInt();
                    break;
                case /* injective.oracle.v1beta1.PriceState price_state */ 6:
                    message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PythPriceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price_id = 1; */
        if (message.priceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.priceId);
        /* string ema_price = 2; */
        if (message.emaPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.emaPrice);
        /* string ema_conf = 3; */
        if (message.emaConf !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.emaConf);
        /* string conf = 4; */
        if (message.conf !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.conf);
        /* uint64 publish_time = 5; */
        if (message.publishTime !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.publishTime);
        /* injective.oracle.v1beta1.PriceState price_state = 6; */
        if (message.priceState)
            PriceState.internalBinaryWrite(message.priceState, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PythPriceState
 */
export const PythPriceState = new PythPriceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BandOracleRequest$Type extends MessageType<BandOracleRequest> {
    constructor() {
        super("injective.oracle.v1beta1.BandOracleRequest", [
            { no: 1, name: "request_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "oracle_script_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "symbols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ask_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "min_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "fee_limit", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } },
            { no: 7, name: "prepare_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "execute_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "min_source_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BandOracleRequest>): BandOracleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestId = 0n;
        message.oracleScriptId = 0n;
        message.symbols = [];
        message.askCount = 0n;
        message.minCount = 0n;
        message.feeLimit = [];
        message.prepareGas = 0n;
        message.executeGas = 0n;
        message.minSourceCount = 0n;
        if (value !== undefined)
            reflectionMergePartial<BandOracleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BandOracleRequest): BandOracleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 request_id */ 1:
                    message.requestId = reader.uint64().toBigInt();
                    break;
                case /* int64 oracle_script_id */ 2:
                    message.oracleScriptId = reader.int64().toBigInt();
                    break;
                case /* repeated string symbols */ 3:
                    message.symbols.push(reader.string());
                    break;
                case /* uint64 ask_count */ 4:
                    message.askCount = reader.uint64().toBigInt();
                    break;
                case /* uint64 min_count */ 5:
                    message.minCount = reader.uint64().toBigInt();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin fee_limit */ 6:
                    message.feeLimit.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 prepare_gas */ 7:
                    message.prepareGas = reader.uint64().toBigInt();
                    break;
                case /* uint64 execute_gas */ 8:
                    message.executeGas = reader.uint64().toBigInt();
                    break;
                case /* uint64 min_source_count */ 9:
                    message.minSourceCount = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BandOracleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 request_id = 1; */
        if (message.requestId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.requestId);
        /* int64 oracle_script_id = 2; */
        if (message.oracleScriptId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.oracleScriptId);
        /* repeated string symbols = 3; */
        for (let i = 0; i < message.symbols.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.symbols[i]);
        /* uint64 ask_count = 4; */
        if (message.askCount !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.askCount);
        /* uint64 min_count = 5; */
        if (message.minCount !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.minCount);
        /* repeated cosmos.base.v1beta1.Coin fee_limit = 6; */
        for (let i = 0; i < message.feeLimit.length; i++)
            Coin.internalBinaryWrite(message.feeLimit[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 prepare_gas = 7; */
        if (message.prepareGas !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.prepareGas);
        /* uint64 execute_gas = 8; */
        if (message.executeGas !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.executeGas);
        /* uint64 min_source_count = 9; */
        if (message.minSourceCount !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.minSourceCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.BandOracleRequest
 */
export const BandOracleRequest = new BandOracleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BandIBCParams$Type extends MessageType<BandIBCParams> {
    constructor() {
        super("injective.oracle.v1beta1.BandIBCParams", [
            { no: 1, name: "band_ibc_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "ibc_request_interval", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "ibc_source_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ibc_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "ibc_port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "legacy_oracle_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BandIBCParams>): BandIBCParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bandIbcEnabled = false;
        message.ibcRequestInterval = 0n;
        message.ibcSourceChannel = "";
        message.ibcVersion = "";
        message.ibcPortId = "";
        message.legacyOracleIds = [];
        if (value !== undefined)
            reflectionMergePartial<BandIBCParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BandIBCParams): BandIBCParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool band_ibc_enabled */ 1:
                    message.bandIbcEnabled = reader.bool();
                    break;
                case /* int64 ibc_request_interval */ 2:
                    message.ibcRequestInterval = reader.int64().toBigInt();
                    break;
                case /* string ibc_source_channel */ 3:
                    message.ibcSourceChannel = reader.string();
                    break;
                case /* string ibc_version */ 4:
                    message.ibcVersion = reader.string();
                    break;
                case /* string ibc_port_id */ 5:
                    message.ibcPortId = reader.string();
                    break;
                case /* repeated int64 legacy_oracle_ids */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyOracleIds.push(reader.int64().toBigInt());
                    else
                        message.legacyOracleIds.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BandIBCParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool band_ibc_enabled = 1; */
        if (message.bandIbcEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.bandIbcEnabled);
        /* int64 ibc_request_interval = 2; */
        if (message.ibcRequestInterval !== 0n)
            writer.tag(2, WireType.Varint).int64(message.ibcRequestInterval);
        /* string ibc_source_channel = 3; */
        if (message.ibcSourceChannel !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ibcSourceChannel);
        /* string ibc_version = 4; */
        if (message.ibcVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ibcVersion);
        /* string ibc_port_id = 5; */
        if (message.ibcPortId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ibcPortId);
        /* repeated int64 legacy_oracle_ids = 6; */
        if (message.legacyOracleIds.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.legacyOracleIds.length; i++)
                writer.int64(message.legacyOracleIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.BandIBCParams
 */
export const BandIBCParams = new BandIBCParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SymbolPriceTimestamp$Type extends MessageType<SymbolPriceTimestamp> {
    constructor() {
        super("injective.oracle.v1beta1.SymbolPriceTimestamp", [
            { no: 1, name: "oracle", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 2, name: "symbol_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SymbolPriceTimestamp>): SymbolPriceTimestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oracle = 0;
        message.symbolId = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<SymbolPriceTimestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SymbolPriceTimestamp): SymbolPriceTimestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.oracle.v1beta1.OracleType oracle */ 1:
                    message.oracle = reader.int32();
                    break;
                case /* string symbol_id */ 2:
                    message.symbolId = reader.string();
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SymbolPriceTimestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.oracle.v1beta1.OracleType oracle = 1; */
        if (message.oracle !== 0)
            writer.tag(1, WireType.Varint).int32(message.oracle);
        /* string symbol_id = 2; */
        if (message.symbolId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.symbolId);
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SymbolPriceTimestamp
 */
export const SymbolPriceTimestamp = new SymbolPriceTimestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastPriceTimestamps$Type extends MessageType<LastPriceTimestamps> {
    constructor() {
        super("injective.oracle.v1beta1.LastPriceTimestamps", [
            { no: 1, name: "last_price_timestamps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SymbolPriceTimestamp }
        ]);
    }
    create(value?: PartialMessage<LastPriceTimestamps>): LastPriceTimestamps {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lastPriceTimestamps = [];
        if (value !== undefined)
            reflectionMergePartial<LastPriceTimestamps>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastPriceTimestamps): LastPriceTimestamps {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps */ 1:
                    message.lastPriceTimestamps.push(SymbolPriceTimestamp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastPriceTimestamps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1; */
        for (let i = 0; i < message.lastPriceTimestamps.length; i++)
            SymbolPriceTimestamp.internalBinaryWrite(message.lastPriceTimestamps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.LastPriceTimestamps
 */
export const LastPriceTimestamps = new LastPriceTimestamps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceRecords$Type extends MessageType<PriceRecords> {
    constructor() {
        super("injective.oracle.v1beta1.PriceRecords", [
            { no: 1, name: "oracle", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
            { no: 2, name: "symbol_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "latest_price_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceRecord }
        ]);
    }
    create(value?: PartialMessage<PriceRecords>): PriceRecords {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oracle = 0;
        message.symbolId = "";
        message.latestPriceRecords = [];
        if (value !== undefined)
            reflectionMergePartial<PriceRecords>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceRecords): PriceRecords {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.oracle.v1beta1.OracleType oracle */ 1:
                    message.oracle = reader.int32();
                    break;
                case /* string symbol_id */ 2:
                    message.symbolId = reader.string();
                    break;
                case /* repeated injective.oracle.v1beta1.PriceRecord latest_price_records */ 3:
                    message.latestPriceRecords.push(PriceRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceRecords, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.oracle.v1beta1.OracleType oracle = 1; */
        if (message.oracle !== 0)
            writer.tag(1, WireType.Varint).int32(message.oracle);
        /* string symbol_id = 2; */
        if (message.symbolId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.symbolId);
        /* repeated injective.oracle.v1beta1.PriceRecord latest_price_records = 3; */
        for (let i = 0; i < message.latestPriceRecords.length; i++)
            PriceRecord.internalBinaryWrite(message.latestPriceRecords[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PriceRecords
 */
export const PriceRecords = new PriceRecords$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceRecord$Type extends MessageType<PriceRecord> {
    constructor() {
        super("injective.oracle.v1beta1.PriceRecord", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<PriceRecord>): PriceRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        message.price = "";
        if (value !== undefined)
            reflectionMergePartial<PriceRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceRecord): PriceRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PriceRecord
 */
export const PriceRecord = new PriceRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetadataStatistics$Type extends MessageType<MetadataStatistics> {
    constructor() {
        super("injective.oracle.v1beta1.MetadataStatistics", [
            { no: 1, name: "group_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "records_sample_size", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "mean", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "twap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "first_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "last_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "min_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "max_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 9, name: "median_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<MetadataStatistics>): MetadataStatistics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupCount = 0;
        message.recordsSampleSize = 0;
        message.mean = "";
        message.twap = "";
        message.firstTimestamp = 0n;
        message.lastTimestamp = 0n;
        message.minPrice = "";
        message.maxPrice = "";
        message.medianPrice = "";
        if (value !== undefined)
            reflectionMergePartial<MetadataStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetadataStatistics): MetadataStatistics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 group_count */ 1:
                    message.groupCount = reader.uint32();
                    break;
                case /* uint32 records_sample_size */ 2:
                    message.recordsSampleSize = reader.uint32();
                    break;
                case /* string mean */ 3:
                    message.mean = reader.string();
                    break;
                case /* string twap */ 4:
                    message.twap = reader.string();
                    break;
                case /* int64 first_timestamp */ 5:
                    message.firstTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 last_timestamp */ 6:
                    message.lastTimestamp = reader.int64().toBigInt();
                    break;
                case /* string min_price */ 7:
                    message.minPrice = reader.string();
                    break;
                case /* string max_price */ 8:
                    message.maxPrice = reader.string();
                    break;
                case /* string median_price */ 9:
                    message.medianPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetadataStatistics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 group_count = 1; */
        if (message.groupCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.groupCount);
        /* uint32 records_sample_size = 2; */
        if (message.recordsSampleSize !== 0)
            writer.tag(2, WireType.Varint).uint32(message.recordsSampleSize);
        /* string mean = 3; */
        if (message.mean !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.mean);
        /* string twap = 4; */
        if (message.twap !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.twap);
        /* int64 first_timestamp = 5; */
        if (message.firstTimestamp !== 0n)
            writer.tag(5, WireType.Varint).int64(message.firstTimestamp);
        /* int64 last_timestamp = 6; */
        if (message.lastTimestamp !== 0n)
            writer.tag(6, WireType.Varint).int64(message.lastTimestamp);
        /* string min_price = 7; */
        if (message.minPrice !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.minPrice);
        /* string max_price = 8; */
        if (message.maxPrice !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.maxPrice);
        /* string median_price = 9; */
        if (message.medianPrice !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.medianPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MetadataStatistics
 */
export const MetadataStatistics = new MetadataStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceAttestation$Type extends MessageType<PriceAttestation> {
    constructor() {
        super("injective.oracle.v1beta1.PriceAttestation", [
            { no: 1, name: "price_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "conf", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "expo", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "ema_price", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "ema_conf", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "ema_expo", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "publish_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceAttestation>): PriceAttestation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.priceId = "";
        message.price = 0n;
        message.conf = 0n;
        message.expo = 0;
        message.emaPrice = 0n;
        message.emaConf = 0n;
        message.emaExpo = 0;
        message.publishTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceAttestation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceAttestation): PriceAttestation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price_id */ 1:
                    message.priceId = reader.string();
                    break;
                case /* int64 price */ 2:
                    message.price = reader.int64().toBigInt();
                    break;
                case /* uint64 conf */ 3:
                    message.conf = reader.uint64().toBigInt();
                    break;
                case /* int32 expo */ 4:
                    message.expo = reader.int32();
                    break;
                case /* int64 ema_price */ 5:
                    message.emaPrice = reader.int64().toBigInt();
                    break;
                case /* uint64 ema_conf */ 6:
                    message.emaConf = reader.uint64().toBigInt();
                    break;
                case /* int32 ema_expo */ 7:
                    message.emaExpo = reader.int32();
                    break;
                case /* int64 publish_time */ 8:
                    message.publishTime = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceAttestation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price_id = 1; */
        if (message.priceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.priceId);
        /* int64 price = 2; */
        if (message.price !== 0n)
            writer.tag(2, WireType.Varint).int64(message.price);
        /* uint64 conf = 3; */
        if (message.conf !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.conf);
        /* int32 expo = 4; */
        if (message.expo !== 0)
            writer.tag(4, WireType.Varint).int32(message.expo);
        /* int64 ema_price = 5; */
        if (message.emaPrice !== 0n)
            writer.tag(5, WireType.Varint).int64(message.emaPrice);
        /* uint64 ema_conf = 6; */
        if (message.emaConf !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.emaConf);
        /* int32 ema_expo = 7; */
        if (message.emaExpo !== 0)
            writer.tag(7, WireType.Varint).int32(message.emaExpo);
        /* int64 publish_time = 8; */
        if (message.publishTime !== 0n)
            writer.tag(8, WireType.Varint).int64(message.publishTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.PriceAttestation
 */
export const PriceAttestation = new PriceAttestation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetPair$Type extends MessageType<AssetPair> {
    constructor() {
        super("injective.oracle.v1beta1.AssetPair", [
            { no: 1, name: "asset_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "signed_prices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SignedPriceOfAssetPair }
        ]);
    }
    create(value?: PartialMessage<AssetPair>): AssetPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.assetId = "";
        message.signedPrices = [];
        if (value !== undefined)
            reflectionMergePartial<AssetPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetPair): AssetPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string asset_id */ 1:
                    message.assetId = reader.string();
                    break;
                case /* repeated injective.oracle.v1beta1.SignedPriceOfAssetPair signed_prices */ 2:
                    message.signedPrices.push(SignedPriceOfAssetPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string asset_id = 1; */
        if (message.assetId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.assetId);
        /* repeated injective.oracle.v1beta1.SignedPriceOfAssetPair signed_prices = 2; */
        for (let i = 0; i < message.signedPrices.length; i++)
            SignedPriceOfAssetPair.internalBinaryWrite(message.signedPrices[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.AssetPair
 */
export const AssetPair = new AssetPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignedPriceOfAssetPair$Type extends MessageType<SignedPriceOfAssetPair> {
    constructor() {
        super("injective.oracle.v1beta1.SignedPriceOfAssetPair", [
            { no: 1, name: "publisher_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SignedPriceOfAssetPair>): SignedPriceOfAssetPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publisherKey = "";
        message.timestamp = 0n;
        message.price = "";
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SignedPriceOfAssetPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignedPriceOfAssetPair): SignedPriceOfAssetPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string publisher_key */ 1:
                    message.publisherKey = reader.string();
                    break;
                case /* uint64 timestamp */ 2:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* string price */ 3:
                    message.price = reader.string();
                    break;
                case /* bytes signature */ 4:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignedPriceOfAssetPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string publisher_key = 1; */
        if (message.publisherKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.publisherKey);
        /* uint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestamp);
        /* string price = 3; */
        if (message.price !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.price);
        /* bytes signature = 4; */
        if (message.signature.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SignedPriceOfAssetPair
 */
export const SignedPriceOfAssetPair = new SignedPriceOfAssetPair$Type();
