// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/oracle/v1beta1/events.proto" (package "injective.oracle.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PythPriceState } from "./oracle_pb";
import { StorkPriceState } from "./oracle_pb";
/**
 * @generated from protobuf message injective.oracle.v1beta1.SetChainlinkPriceEvent
 */
export interface SetChainlinkPriceEvent {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: string answer = 2
     */
    answer: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * Event type upon set ref
 *
 * @generated from protobuf message injective.oracle.v1beta1.SetBandPriceEvent
 */
export interface SetBandPriceEvent {
    /**
     * @generated from protobuf field: string relayer = 1
     */
    relayer: string;
    /**
     * @generated from protobuf field: string symbol = 2
     */
    symbol: string;
    /**
     * @generated from protobuf field: string price = 3
     */
    price: string;
    /**
     * @generated from protobuf field: uint64 resolve_time = 4
     */
    resolveTime: bigint;
    /**
     * @generated from protobuf field: uint64 request_id = 5
     */
    requestId: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.SetBandIBCPriceEvent
 */
export interface SetBandIBCPriceEvent {
    /**
     * @generated from protobuf field: string relayer = 1
     */
    relayer: string;
    /**
     * @generated from protobuf field: repeated string symbols = 2
     */
    symbols: string[];
    /**
     * @generated from protobuf field: repeated string prices = 3
     */
    prices: string[];
    /**
     * @generated from protobuf field: uint64 resolve_time = 4
     */
    resolveTime: bigint;
    /**
     * @generated from protobuf field: uint64 request_id = 5
     */
    requestId: bigint;
    /**
     * @generated from protobuf field: int64 client_id = 6
     */
    clientId: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.EventBandIBCAckSuccess
 */
export interface EventBandIBCAckSuccess {
    /**
     * @generated from protobuf field: string ack_result = 1
     */
    ackResult: string;
    /**
     * @generated from protobuf field: int64 client_id = 2
     */
    clientId: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.EventBandIBCAckError
 */
export interface EventBandIBCAckError {
    /**
     * @generated from protobuf field: string ack_error = 1
     */
    ackError: string;
    /**
     * @generated from protobuf field: int64 client_id = 2
     */
    clientId: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.EventBandIBCResponseTimeout
 */
export interface EventBandIBCResponseTimeout {
    /**
     * @generated from protobuf field: int64 client_id = 1
     */
    clientId: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.SetPriceFeedPriceEvent
 */
export interface SetPriceFeedPriceEvent {
    /**
     * @generated from protobuf field: string relayer = 1
     */
    relayer: string;
    /**
     * @generated from protobuf field: string base = 2
     */
    base: string;
    /**
     * @generated from protobuf field: string quote = 3
     */
    quote: string;
    /**
     * price defines the price of the oracle base and quote
     *
     * @generated from protobuf field: string price = 4
     */
    price: string;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.SetProviderPriceEvent
 */
export interface SetProviderPriceEvent {
    /**
     * @generated from protobuf field: string provider = 1
     */
    provider: string;
    /**
     * @generated from protobuf field: string relayer = 2
     */
    relayer: string;
    /**
     * @generated from protobuf field: string symbol = 3
     */
    symbol: string;
    /**
     * @generated from protobuf field: string price = 4
     */
    price: string;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.SetCoinbasePriceEvent
 */
export interface SetCoinbasePriceEvent {
    /**
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 3
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.EventSetStorkPrices
 */
export interface EventSetStorkPrices {
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.StorkPriceState prices = 1
     */
    prices: StorkPriceState[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.EventSetPythPrices
 */
export interface EventSetPythPrices {
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.PythPriceState prices = 1
     */
    prices: PythPriceState[];
}
// @generated message type with reflection information, may provide speed optimized methods
class SetChainlinkPriceEvent$Type extends MessageType<SetChainlinkPriceEvent> {
    constructor() {
        super("injective.oracle.v1beta1.SetChainlinkPriceEvent", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetChainlinkPriceEvent>): SetChainlinkPriceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.answer = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<SetChainlinkPriceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetChainlinkPriceEvent): SetChainlinkPriceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* string answer */ 2:
                    message.answer = reader.string();
                    break;
                case /* uint64 timestamp */ 3:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetChainlinkPriceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* string answer = 2; */
        if (message.answer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.answer);
        /* uint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SetChainlinkPriceEvent
 */
export const SetChainlinkPriceEvent = new SetChainlinkPriceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetBandPriceEvent$Type extends MessageType<SetBandPriceEvent> {
    constructor() {
        super("injective.oracle.v1beta1.SetBandPriceEvent", [
            { no: 1, name: "relayer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "resolve_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "request_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetBandPriceEvent>): SetBandPriceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relayer = "";
        message.symbol = "";
        message.price = "";
        message.resolveTime = 0n;
        message.requestId = 0n;
        if (value !== undefined)
            reflectionMergePartial<SetBandPriceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetBandPriceEvent): SetBandPriceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relayer */ 1:
                    message.relayer = reader.string();
                    break;
                case /* string symbol */ 2:
                    message.symbol = reader.string();
                    break;
                case /* string price */ 3:
                    message.price = reader.string();
                    break;
                case /* uint64 resolve_time */ 4:
                    message.resolveTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 request_id */ 5:
                    message.requestId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetBandPriceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string relayer = 1; */
        if (message.relayer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relayer);
        /* string symbol = 2; */
        if (message.symbol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.symbol);
        /* string price = 3; */
        if (message.price !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.price);
        /* uint64 resolve_time = 4; */
        if (message.resolveTime !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.resolveTime);
        /* uint64 request_id = 5; */
        if (message.requestId !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.requestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SetBandPriceEvent
 */
export const SetBandPriceEvent = new SetBandPriceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetBandIBCPriceEvent$Type extends MessageType<SetBandIBCPriceEvent> {
    constructor() {
        super("injective.oracle.v1beta1.SetBandIBCPriceEvent", [
            { no: 1, name: "relayer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "symbols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "prices", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "resolve_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "request_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "client_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetBandIBCPriceEvent>): SetBandIBCPriceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relayer = "";
        message.symbols = [];
        message.prices = [];
        message.resolveTime = 0n;
        message.requestId = 0n;
        message.clientId = 0n;
        if (value !== undefined)
            reflectionMergePartial<SetBandIBCPriceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetBandIBCPriceEvent): SetBandIBCPriceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relayer */ 1:
                    message.relayer = reader.string();
                    break;
                case /* repeated string symbols */ 2:
                    message.symbols.push(reader.string());
                    break;
                case /* repeated string prices */ 3:
                    message.prices.push(reader.string());
                    break;
                case /* uint64 resolve_time */ 4:
                    message.resolveTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 request_id */ 5:
                    message.requestId = reader.uint64().toBigInt();
                    break;
                case /* int64 client_id */ 6:
                    message.clientId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetBandIBCPriceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string relayer = 1; */
        if (message.relayer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relayer);
        /* repeated string symbols = 2; */
        for (let i = 0; i < message.symbols.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.symbols[i]);
        /* repeated string prices = 3; */
        for (let i = 0; i < message.prices.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.prices[i]);
        /* uint64 resolve_time = 4; */
        if (message.resolveTime !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.resolveTime);
        /* uint64 request_id = 5; */
        if (message.requestId !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.requestId);
        /* int64 client_id = 6; */
        if (message.clientId !== 0n)
            writer.tag(6, WireType.Varint).int64(message.clientId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SetBandIBCPriceEvent
 */
export const SetBandIBCPriceEvent = new SetBandIBCPriceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBandIBCAckSuccess$Type extends MessageType<EventBandIBCAckSuccess> {
    constructor() {
        super("injective.oracle.v1beta1.EventBandIBCAckSuccess", [
            { no: 1, name: "ack_result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventBandIBCAckSuccess>): EventBandIBCAckSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackResult = "";
        message.clientId = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventBandIBCAckSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBandIBCAckSuccess): EventBandIBCAckSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ack_result */ 1:
                    message.ackResult = reader.string();
                    break;
                case /* int64 client_id */ 2:
                    message.clientId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBandIBCAckSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ack_result = 1; */
        if (message.ackResult !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ackResult);
        /* int64 client_id = 2; */
        if (message.clientId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.clientId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.EventBandIBCAckSuccess
 */
export const EventBandIBCAckSuccess = new EventBandIBCAckSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBandIBCAckError$Type extends MessageType<EventBandIBCAckError> {
    constructor() {
        super("injective.oracle.v1beta1.EventBandIBCAckError", [
            { no: 1, name: "ack_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventBandIBCAckError>): EventBandIBCAckError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackError = "";
        message.clientId = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventBandIBCAckError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBandIBCAckError): EventBandIBCAckError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ack_error */ 1:
                    message.ackError = reader.string();
                    break;
                case /* int64 client_id */ 2:
                    message.clientId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBandIBCAckError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ack_error = 1; */
        if (message.ackError !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ackError);
        /* int64 client_id = 2; */
        if (message.clientId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.clientId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.EventBandIBCAckError
 */
export const EventBandIBCAckError = new EventBandIBCAckError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBandIBCResponseTimeout$Type extends MessageType<EventBandIBCResponseTimeout> {
    constructor() {
        super("injective.oracle.v1beta1.EventBandIBCResponseTimeout", [
            { no: 1, name: "client_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventBandIBCResponseTimeout>): EventBandIBCResponseTimeout {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventBandIBCResponseTimeout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBandIBCResponseTimeout): EventBandIBCResponseTimeout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 client_id */ 1:
                    message.clientId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBandIBCResponseTimeout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 client_id = 1; */
        if (message.clientId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.clientId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.EventBandIBCResponseTimeout
 */
export const EventBandIBCResponseTimeout = new EventBandIBCResponseTimeout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPriceFeedPriceEvent$Type extends MessageType<SetPriceFeedPriceEvent> {
    constructor() {
        super("injective.oracle.v1beta1.SetPriceFeedPriceEvent", [
            { no: 1, name: "relayer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "base", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<SetPriceFeedPriceEvent>): SetPriceFeedPriceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relayer = "";
        message.base = "";
        message.quote = "";
        message.price = "";
        if (value !== undefined)
            reflectionMergePartial<SetPriceFeedPriceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPriceFeedPriceEvent): SetPriceFeedPriceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relayer */ 1:
                    message.relayer = reader.string();
                    break;
                case /* string base */ 2:
                    message.base = reader.string();
                    break;
                case /* string quote */ 3:
                    message.quote = reader.string();
                    break;
                case /* string price */ 4:
                    message.price = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPriceFeedPriceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string relayer = 1; */
        if (message.relayer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relayer);
        /* string base = 2; */
        if (message.base !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.base);
        /* string quote = 3; */
        if (message.quote !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.quote);
        /* string price = 4; */
        if (message.price !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SetPriceFeedPriceEvent
 */
export const SetPriceFeedPriceEvent = new SetPriceFeedPriceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetProviderPriceEvent$Type extends MessageType<SetProviderPriceEvent> {
    constructor() {
        super("injective.oracle.v1beta1.SetProviderPriceEvent", [
            { no: 1, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relayer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<SetProviderPriceEvent>): SetProviderPriceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.provider = "";
        message.relayer = "";
        message.symbol = "";
        message.price = "";
        if (value !== undefined)
            reflectionMergePartial<SetProviderPriceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetProviderPriceEvent): SetProviderPriceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider */ 1:
                    message.provider = reader.string();
                    break;
                case /* string relayer */ 2:
                    message.relayer = reader.string();
                    break;
                case /* string symbol */ 3:
                    message.symbol = reader.string();
                    break;
                case /* string price */ 4:
                    message.price = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetProviderPriceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider = 1; */
        if (message.provider !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.provider);
        /* string relayer = 2; */
        if (message.relayer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relayer);
        /* string symbol = 3; */
        if (message.symbol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.symbol);
        /* string price = 4; */
        if (message.price !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SetProviderPriceEvent
 */
export const SetProviderPriceEvent = new SetProviderPriceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetCoinbasePriceEvent$Type extends MessageType<SetCoinbasePriceEvent> {
    constructor() {
        super("injective.oracle.v1beta1.SetCoinbasePriceEvent", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetCoinbasePriceEvent>): SetCoinbasePriceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        message.price = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<SetCoinbasePriceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetCoinbasePriceEvent): SetCoinbasePriceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* uint64 timestamp */ 3:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetCoinbasePriceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* uint64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.SetCoinbasePriceEvent
 */
export const SetCoinbasePriceEvent = new SetCoinbasePriceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSetStorkPrices$Type extends MessageType<EventSetStorkPrices> {
    constructor() {
        super("injective.oracle.v1beta1.EventSetStorkPrices", [
            { no: 1, name: "prices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StorkPriceState }
        ]);
    }
    create(value?: PartialMessage<EventSetStorkPrices>): EventSetStorkPrices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prices = [];
        if (value !== undefined)
            reflectionMergePartial<EventSetStorkPrices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSetStorkPrices): EventSetStorkPrices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.oracle.v1beta1.StorkPriceState prices */ 1:
                    message.prices.push(StorkPriceState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSetStorkPrices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.oracle.v1beta1.StorkPriceState prices = 1; */
        for (let i = 0; i < message.prices.length; i++)
            StorkPriceState.internalBinaryWrite(message.prices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.EventSetStorkPrices
 */
export const EventSetStorkPrices = new EventSetStorkPrices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSetPythPrices$Type extends MessageType<EventSetPythPrices> {
    constructor() {
        super("injective.oracle.v1beta1.EventSetPythPrices", [
            { no: 1, name: "prices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PythPriceState }
        ]);
    }
    create(value?: PartialMessage<EventSetPythPrices>): EventSetPythPrices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prices = [];
        if (value !== undefined)
            reflectionMergePartial<EventSetPythPrices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSetPythPrices): EventSetPythPrices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.oracle.v1beta1.PythPriceState prices */ 1:
                    message.prices.push(PythPriceState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSetPythPrices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.oracle.v1beta1.PythPriceState prices = 1; */
        for (let i = 0; i < message.prices.length; i++)
            PythPriceState.internalBinaryWrite(message.prices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.EventSetPythPrices
 */
export const EventSetPythPrices = new EventSetPythPrices$Type();
