import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
var OracleType = /* @__PURE__ */ ((OracleType2) => {
  OracleType2[OracleType2["Unspecified"] = 0] = "Unspecified";
  OracleType2[OracleType2["Band"] = 1] = "Band";
  OracleType2[OracleType2["PriceFeed"] = 2] = "PriceFeed";
  OracleType2[OracleType2["Coinbase"] = 3] = "Coinbase";
  OracleType2[OracleType2["Chainlink"] = 4] = "Chainlink";
  OracleType2[OracleType2["Razor"] = 5] = "Razor";
  OracleType2[OracleType2["Dia"] = 6] = "Dia";
  OracleType2[OracleType2["API3"] = 7] = "API3";
  OracleType2[OracleType2["Uma"] = 8] = "Uma";
  OracleType2[OracleType2["Pyth"] = 9] = "Pyth";
  OracleType2[OracleType2["BandIBC"] = 10] = "BandIBC";
  OracleType2[OracleType2["Provider"] = 11] = "Provider";
  OracleType2[OracleType2["Stork"] = 12] = "Stork";
  return OracleType2;
})(OracleType || {});
class Params$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.Params", [
      {
        no: 1,
        name: "pyth_contract",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.equal": true, "amino.name": "oracle/Params" });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.pythContract = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string pyth_contract */
        1:
          message.pythContract = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.pythContract !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.pythContract);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Params = new Params$Type();
class OracleInfo$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.OracleInfo", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "oracle_type", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = "";
    message.oracleType = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string symbol */
        1:
          message.symbol = reader.string();
          break;
        case /* injective.oracle.v1beta1.OracleType oracle_type */
        2:
          message.oracleType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.symbol !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.symbol);
    if (message.oracleType !== 0)
      writer.tag(2, WireType.Varint).int32(message.oracleType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OracleInfo = new OracleInfo$Type();
class ChainlinkPriceState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.ChainlinkPriceState", [
      {
        no: 1,
        name: "feed_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "answer", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedId = "";
    message.answer = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string feed_id */
        1:
          message.feedId = reader.string();
          break;
        case /* string answer */
        2:
          message.answer = reader.string();
          break;
        case /* uint64 timestamp */
        3:
          message.timestamp = reader.uint64().toBigInt();
          break;
        case /* injective.oracle.v1beta1.PriceState price_state */
        4:
          message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feedId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.feedId);
    if (message.answer !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.answer);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.timestamp);
    if (message.priceState)
      PriceState.internalBinaryWrite(message.priceState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ChainlinkPriceState = new ChainlinkPriceState$Type();
class BandPriceState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.BandPriceState", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "rate", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
      {
        no: 3,
        name: "resolve_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "request_ID",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 5, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = "";
    message.rate = "";
    message.resolveTime = 0n;
    message.requestID = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string symbol */
        1:
          message.symbol = reader.string();
          break;
        case /* string rate */
        2:
          message.rate = reader.string();
          break;
        case /* uint64 resolve_time */
        3:
          message.resolveTime = reader.uint64().toBigInt();
          break;
        case /* uint64 request_ID */
        4:
          message.requestID = reader.uint64().toBigInt();
          break;
        case /* injective.oracle.v1beta1.PriceState price_state */
        5:
          message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.symbol !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.symbol);
    if (message.rate !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.rate);
    if (message.resolveTime !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.resolveTime);
    if (message.requestID !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.requestID);
    if (message.priceState)
      PriceState.internalBinaryWrite(message.priceState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BandPriceState = new BandPriceState$Type();
class PriceFeedState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PriceFeedState", [
      {
        no: 1,
        name: "base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "price_state", kind: "message", T: () => PriceState },
      {
        no: 4,
        name: "relayers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.base = "";
    message.quote = "";
    message.relayers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string base */
        1:
          message.base = reader.string();
          break;
        case /* string quote */
        2:
          message.quote = reader.string();
          break;
        case /* injective.oracle.v1beta1.PriceState price_state */
        3:
          message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
          break;
        case /* repeated string relayers */
        4:
          message.relayers.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.base !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.base);
    if (message.quote !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quote);
    if (message.priceState)
      PriceState.internalBinaryWrite(message.priceState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.relayers.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.relayers[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceFeedState = new PriceFeedState$Type();
class ProviderInfo$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.ProviderInfo", [
      {
        no: 1,
        name: "provider",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "relayers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.provider = "";
    message.relayers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string provider */
        1:
          message.provider = reader.string();
          break;
        case /* repeated string relayers */
        2:
          message.relayers.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.provider !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.provider);
    for (let i = 0; i < message.relayers.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.relayers[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProviderInfo = new ProviderInfo$Type();
class ProviderState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.ProviderState", [
      { no: 1, name: "provider_info", kind: "message", T: () => ProviderInfo },
      { no: 2, name: "provider_price_states", kind: "message", repeat: 2, T: () => ProviderPriceState }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.providerPriceStates = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.oracle.v1beta1.ProviderInfo provider_info */
        1:
          message.providerInfo = ProviderInfo.internalBinaryRead(reader, reader.uint32(), options, message.providerInfo);
          break;
        case /* repeated injective.oracle.v1beta1.ProviderPriceState provider_price_states */
        2:
          message.providerPriceStates.push(ProviderPriceState.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.providerInfo)
      ProviderInfo.internalBinaryWrite(message.providerInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.providerPriceStates.length; i++)
      ProviderPriceState.internalBinaryWrite(message.providerPriceStates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProviderState = new ProviderState$Type();
class ProviderPriceState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.ProviderPriceState", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "state", kind: "message", T: () => PriceState }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string symbol */
        1:
          message.symbol = reader.string();
          break;
        case /* injective.oracle.v1beta1.PriceState state */
        2:
          message.state = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.symbol !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.symbol);
    if (message.state)
      PriceState.internalBinaryWrite(message.state, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProviderPriceState = new ProviderPriceState$Type();
class PriceFeedInfo$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PriceFeedInfo", [
      {
        no: 1,
        name: "base",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "quote",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.base = "";
    message.quote = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string base */
        1:
          message.base = reader.string();
          break;
        case /* string quote */
        2:
          message.quote = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.base !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.base);
    if (message.quote !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.quote);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceFeedInfo = new PriceFeedInfo$Type();
class PriceFeedPrice$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PriceFeedPrice", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceFeedPrice = new PriceFeedPrice$Type();
class CoinbasePriceState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.CoinbasePriceState", [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "value",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 5, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.kind = "";
    message.timestamp = 0n;
    message.key = "";
    message.value = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string kind */
        1:
          message.kind = reader.string();
          break;
        case /* uint64 timestamp */
        2:
          message.timestamp = reader.uint64().toBigInt();
          break;
        case /* string key */
        3:
          message.key = reader.string();
          break;
        case /* uint64 value */
        4:
          message.value = reader.uint64().toBigInt();
          break;
        case /* injective.oracle.v1beta1.PriceState price_state */
        5:
          message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kind !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.kind);
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.timestamp);
    if (message.key !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.key);
    if (message.value !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.value);
    if (message.priceState)
      PriceState.internalBinaryWrite(message.priceState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CoinbasePriceState = new CoinbasePriceState$Type();
class StorkPriceState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.StorkPriceState", [
      {
        no: 1,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "value", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    message.symbol = "";
    message.value = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 timestamp */
        1:
          message.timestamp = reader.uint64().toBigInt();
          break;
        case /* string symbol */
        2:
          message.symbol = reader.string();
          break;
        case /* string value */
        3:
          message.value = reader.string();
          break;
        case /* injective.oracle.v1beta1.PriceState price_state */
        5:
          message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.timestamp !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.timestamp);
    if (message.symbol !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.symbol);
    if (message.value !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.value);
    if (message.priceState)
      PriceState.internalBinaryWrite(message.priceState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StorkPriceState = new StorkPriceState$Type();
class PriceState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PriceState", [
      { no: 1, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 2, name: "cumulative_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    message.cumulativePrice = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        case /* string cumulative_price */
        2:
          message.cumulativePrice = reader.string();
          break;
        case /* int64 timestamp */
        3:
          message.timestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    if (message.cumulativePrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cumulativePrice);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).int64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceState = new PriceState$Type();
class PythPriceState$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PythPriceState", [
      {
        no: 1,
        name: "price_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "ema_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 3, name: "ema_conf", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "conf", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "publish_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "price_state", kind: "message", T: () => PriceState, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.priceId = "";
    message.emaPrice = "";
    message.emaConf = "";
    message.conf = "";
    message.publishTime = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price_id */
        1:
          message.priceId = reader.string();
          break;
        case /* string ema_price */
        2:
          message.emaPrice = reader.string();
          break;
        case /* string ema_conf */
        3:
          message.emaConf = reader.string();
          break;
        case /* string conf */
        4:
          message.conf = reader.string();
          break;
        case /* uint64 publish_time */
        5:
          message.publishTime = reader.uint64().toBigInt();
          break;
        case /* injective.oracle.v1beta1.PriceState price_state */
        6:
          message.priceState = PriceState.internalBinaryRead(reader, reader.uint32(), options, message.priceState);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.priceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.priceId);
    if (message.emaPrice !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.emaPrice);
    if (message.emaConf !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.emaConf);
    if (message.conf !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.conf);
    if (message.publishTime !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.publishTime);
    if (message.priceState)
      PriceState.internalBinaryWrite(message.priceState, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PythPriceState = new PythPriceState$Type();
class BandOracleRequest$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.BandOracleRequest", [
      {
        no: 1,
        name: "request_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "oracle_script_id",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "symbols",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "ask_count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "min_count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "fee_limit", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } },
      {
        no: 7,
        name: "prepare_gas",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "execute_gas",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "min_source_count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.requestId = 0n;
    message.oracleScriptId = 0n;
    message.symbols = [];
    message.askCount = 0n;
    message.minCount = 0n;
    message.feeLimit = [];
    message.prepareGas = 0n;
    message.executeGas = 0n;
    message.minSourceCount = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 request_id */
        1:
          message.requestId = reader.uint64().toBigInt();
          break;
        case /* int64 oracle_script_id */
        2:
          message.oracleScriptId = reader.int64().toBigInt();
          break;
        case /* repeated string symbols */
        3:
          message.symbols.push(reader.string());
          break;
        case /* uint64 ask_count */
        4:
          message.askCount = reader.uint64().toBigInt();
          break;
        case /* uint64 min_count */
        5:
          message.minCount = reader.uint64().toBigInt();
          break;
        case /* repeated cosmos.base.v1beta1.Coin fee_limit */
        6:
          message.feeLimit.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 prepare_gas */
        7:
          message.prepareGas = reader.uint64().toBigInt();
          break;
        case /* uint64 execute_gas */
        8:
          message.executeGas = reader.uint64().toBigInt();
          break;
        case /* uint64 min_source_count */
        9:
          message.minSourceCount = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.requestId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.requestId);
    if (message.oracleScriptId !== 0n)
      writer.tag(2, WireType.Varint).int64(message.oracleScriptId);
    for (let i = 0; i < message.symbols.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.symbols[i]);
    if (message.askCount !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.askCount);
    if (message.minCount !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.minCount);
    for (let i = 0; i < message.feeLimit.length; i++)
      Coin.internalBinaryWrite(message.feeLimit[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.prepareGas !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.prepareGas);
    if (message.executeGas !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.executeGas);
    if (message.minSourceCount !== 0n)
      writer.tag(9, WireType.Varint).uint64(message.minSourceCount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BandOracleRequest = new BandOracleRequest$Type();
class BandIBCParams$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.BandIBCParams", [
      {
        no: 1,
        name: "band_ibc_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "ibc_request_interval",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "ibc_source_channel",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "ibc_version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "ibc_port_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "legacy_oracle_ids",
        kind: "scalar",
        repeat: 1,
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bandIbcEnabled = false;
    message.ibcRequestInterval = 0n;
    message.ibcSourceChannel = "";
    message.ibcVersion = "";
    message.ibcPortId = "";
    message.legacyOracleIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool band_ibc_enabled */
        1:
          message.bandIbcEnabled = reader.bool();
          break;
        case /* int64 ibc_request_interval */
        2:
          message.ibcRequestInterval = reader.int64().toBigInt();
          break;
        case /* string ibc_source_channel */
        3:
          message.ibcSourceChannel = reader.string();
          break;
        case /* string ibc_version */
        4:
          message.ibcVersion = reader.string();
          break;
        case /* string ibc_port_id */
        5:
          message.ibcPortId = reader.string();
          break;
        case /* repeated int64 legacy_oracle_ids */
        6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.legacyOracleIds.push(reader.int64().toBigInt());
          else
            message.legacyOracleIds.push(reader.int64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bandIbcEnabled !== false)
      writer.tag(1, WireType.Varint).bool(message.bandIbcEnabled);
    if (message.ibcRequestInterval !== 0n)
      writer.tag(2, WireType.Varint).int64(message.ibcRequestInterval);
    if (message.ibcSourceChannel !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ibcSourceChannel);
    if (message.ibcVersion !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.ibcVersion);
    if (message.ibcPortId !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.ibcPortId);
    if (message.legacyOracleIds.length) {
      writer.tag(6, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.legacyOracleIds.length; i++)
        writer.int64(message.legacyOracleIds[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BandIBCParams = new BandIBCParams$Type();
class SymbolPriceTimestamp$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.SymbolPriceTimestamp", [
      { no: 1, name: "oracle", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 2,
        name: "symbol_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.oracle = 0;
    message.symbolId = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.oracle.v1beta1.OracleType oracle */
        1:
          message.oracle = reader.int32();
          break;
        case /* string symbol_id */
        2:
          message.symbolId = reader.string();
          break;
        case /* int64 timestamp */
        3:
          message.timestamp = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.oracle !== 0)
      writer.tag(1, WireType.Varint).int32(message.oracle);
    if (message.symbolId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.symbolId);
    if (message.timestamp !== 0n)
      writer.tag(3, WireType.Varint).int64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SymbolPriceTimestamp = new SymbolPriceTimestamp$Type();
class LastPriceTimestamps$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.LastPriceTimestamps", [
      { no: 1, name: "last_price_timestamps", kind: "message", repeat: 2, T: () => SymbolPriceTimestamp }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.lastPriceTimestamps = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps */
        1:
          message.lastPriceTimestamps.push(SymbolPriceTimestamp.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.lastPriceTimestamps.length; i++)
      SymbolPriceTimestamp.internalBinaryWrite(message.lastPriceTimestamps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LastPriceTimestamps = new LastPriceTimestamps$Type();
class PriceRecords$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PriceRecords", [
      { no: 1, name: "oracle", kind: "enum", T: () => ["injective.oracle.v1beta1.OracleType", OracleType] },
      {
        no: 2,
        name: "symbol_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "latest_price_records", kind: "message", repeat: 2, T: () => PriceRecord }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.oracle = 0;
    message.symbolId = "";
    message.latestPriceRecords = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.oracle.v1beta1.OracleType oracle */
        1:
          message.oracle = reader.int32();
          break;
        case /* string symbol_id */
        2:
          message.symbolId = reader.string();
          break;
        case /* repeated injective.oracle.v1beta1.PriceRecord latest_price_records */
        3:
          message.latestPriceRecords.push(PriceRecord.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.oracle !== 0)
      writer.tag(1, WireType.Varint).int32(message.oracle);
    if (message.symbolId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.symbolId);
    for (let i = 0; i < message.latestPriceRecords.length; i++)
      PriceRecord.internalBinaryWrite(message.latestPriceRecords[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceRecords = new PriceRecords$Type();
class PriceRecord$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PriceRecord", [
      {
        no: 1,
        name: "timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.timestamp = 0n;
    message.price = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 timestamp */
        1:
          message.timestamp = reader.int64().toBigInt();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.timestamp !== 0n)
      writer.tag(1, WireType.Varint).int64(message.timestamp);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceRecord = new PriceRecord$Type();
class MetadataStatistics$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.MetadataStatistics", [
      {
        no: 1,
        name: "group_count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "records_sample_size",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "mean", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 4, name: "twap", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 5,
        name: "first_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "last_timestamp",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 7, name: "min_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 8, name: "max_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 9, name: "median_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.groupCount = 0;
    message.recordsSampleSize = 0;
    message.mean = "";
    message.twap = "";
    message.firstTimestamp = 0n;
    message.lastTimestamp = 0n;
    message.minPrice = "";
    message.maxPrice = "";
    message.medianPrice = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 group_count */
        1:
          message.groupCount = reader.uint32();
          break;
        case /* uint32 records_sample_size */
        2:
          message.recordsSampleSize = reader.uint32();
          break;
        case /* string mean */
        3:
          message.mean = reader.string();
          break;
        case /* string twap */
        4:
          message.twap = reader.string();
          break;
        case /* int64 first_timestamp */
        5:
          message.firstTimestamp = reader.int64().toBigInt();
          break;
        case /* int64 last_timestamp */
        6:
          message.lastTimestamp = reader.int64().toBigInt();
          break;
        case /* string min_price */
        7:
          message.minPrice = reader.string();
          break;
        case /* string max_price */
        8:
          message.maxPrice = reader.string();
          break;
        case /* string median_price */
        9:
          message.medianPrice = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.groupCount !== 0)
      writer.tag(1, WireType.Varint).uint32(message.groupCount);
    if (message.recordsSampleSize !== 0)
      writer.tag(2, WireType.Varint).uint32(message.recordsSampleSize);
    if (message.mean !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.mean);
    if (message.twap !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.twap);
    if (message.firstTimestamp !== 0n)
      writer.tag(5, WireType.Varint).int64(message.firstTimestamp);
    if (message.lastTimestamp !== 0n)
      writer.tag(6, WireType.Varint).int64(message.lastTimestamp);
    if (message.minPrice !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.minPrice);
    if (message.maxPrice !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.maxPrice);
    if (message.medianPrice !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.medianPrice);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MetadataStatistics = new MetadataStatistics$Type();
class PriceAttestation$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.PriceAttestation", [
      {
        no: 1,
        name: "price_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "price",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "conf",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "expo",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "ema_price",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "ema_conf",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "ema_expo",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 8,
        name: "publish_time",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.priceId = "";
    message.price = 0n;
    message.conf = 0n;
    message.expo = 0;
    message.emaPrice = 0n;
    message.emaConf = 0n;
    message.emaExpo = 0;
    message.publishTime = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price_id */
        1:
          message.priceId = reader.string();
          break;
        case /* int64 price */
        2:
          message.price = reader.int64().toBigInt();
          break;
        case /* uint64 conf */
        3:
          message.conf = reader.uint64().toBigInt();
          break;
        case /* int32 expo */
        4:
          message.expo = reader.int32();
          break;
        case /* int64 ema_price */
        5:
          message.emaPrice = reader.int64().toBigInt();
          break;
        case /* uint64 ema_conf */
        6:
          message.emaConf = reader.uint64().toBigInt();
          break;
        case /* int32 ema_expo */
        7:
          message.emaExpo = reader.int32();
          break;
        case /* int64 publish_time */
        8:
          message.publishTime = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.priceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.priceId);
    if (message.price !== 0n)
      writer.tag(2, WireType.Varint).int64(message.price);
    if (message.conf !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.conf);
    if (message.expo !== 0)
      writer.tag(4, WireType.Varint).int32(message.expo);
    if (message.emaPrice !== 0n)
      writer.tag(5, WireType.Varint).int64(message.emaPrice);
    if (message.emaConf !== 0n)
      writer.tag(6, WireType.Varint).uint64(message.emaConf);
    if (message.emaExpo !== 0)
      writer.tag(7, WireType.Varint).int32(message.emaExpo);
    if (message.publishTime !== 0n)
      writer.tag(8, WireType.Varint).int64(message.publishTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceAttestation = new PriceAttestation$Type();
class AssetPair$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.AssetPair", [
      {
        no: 1,
        name: "asset_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "signed_prices", kind: "message", repeat: 2, T: () => SignedPriceOfAssetPair }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.assetId = "";
    message.signedPrices = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string asset_id */
        1:
          message.assetId = reader.string();
          break;
        case /* repeated injective.oracle.v1beta1.SignedPriceOfAssetPair signed_prices */
        2:
          message.signedPrices.push(SignedPriceOfAssetPair.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.assetId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.assetId);
    for (let i = 0; i < message.signedPrices.length; i++)
      SignedPriceOfAssetPair.internalBinaryWrite(message.signedPrices[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AssetPair = new AssetPair$Type();
class SignedPriceOfAssetPair$Type extends MessageType {
  constructor() {
    super("injective.oracle.v1beta1.SignedPriceOfAssetPair", [
      {
        no: 1,
        name: "publisher_key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 4,
        name: "signature",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.publisherKey = "";
    message.timestamp = 0n;
    message.price = "";
    message.signature = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string publisher_key */
        1:
          message.publisherKey = reader.string();
          break;
        case /* uint64 timestamp */
        2:
          message.timestamp = reader.uint64().toBigInt();
          break;
        case /* string price */
        3:
          message.price = reader.string();
          break;
        case /* bytes signature */
        4:
          message.signature = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.publisherKey !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.publisherKey);
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.timestamp);
    if (message.price !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.price);
    if (message.signature.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.signature);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SignedPriceOfAssetPair = new SignedPriceOfAssetPair$Type();
export {
  AssetPair,
  BandIBCParams,
  BandOracleRequest,
  BandPriceState,
  ChainlinkPriceState,
  CoinbasePriceState,
  LastPriceTimestamps,
  MetadataStatistics,
  OracleInfo,
  OracleType,
  Params,
  PriceAttestation,
  PriceFeedInfo,
  PriceFeedPrice,
  PriceFeedState,
  PriceRecord,
  PriceRecords,
  PriceState,
  ProviderInfo,
  ProviderPriceState,
  ProviderState,
  PythPriceState,
  SignedPriceOfAssetPair,
  StorkPriceState,
  SymbolPriceTimestamp
};
