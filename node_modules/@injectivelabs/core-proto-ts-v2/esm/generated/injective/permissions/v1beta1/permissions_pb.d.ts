// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/permissions/v1beta1/permissions.proto" (package "injective.permissions.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
/**
 * Namespace defines a permissions namespace
 *
 * @generated from protobuf message injective.permissions.v1beta1.Namespace
 */
export interface Namespace {
    /**
     * The tokenfactory denom to which this namespace applies to
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * The address of smart contract to apply code-based restrictions
     *
     * @generated from protobuf field: string contract_hook = 2
     */
    contractHook: string;
    /**
     * permissions for each role
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.Role role_permissions = 3
     */
    rolePermissions: Role[];
    /**
     * roles for each actor
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.ActorRoles actor_roles = 4
     */
    actorRoles: ActorRoles[];
    /**
     * managers for each role
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleManager role_managers = 5
     */
    roleManagers: RoleManager[];
    /**
     * status for each policy
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 6
     */
    policyStatuses: PolicyStatus[];
    /**
     * capabilities for each manager for each policy
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 7
     */
    policyManagerCapabilities: PolicyManagerCapability[];
}
/**
 * AddressRoles defines roles for an actor
 *
 * @generated from protobuf message injective.permissions.v1beta1.ActorRoles
 */
export interface ActorRoles {
    /**
     * The actor name
     *
     * @generated from protobuf field: string actor = 1
     */
    actor: string;
    /**
     * The roles for the actor
     *
     * @generated from protobuf field: repeated string roles = 2
     */
    roles: string[];
}
/**
 * RoleActors defines actors for a role
 *
 * @generated from protobuf message injective.permissions.v1beta1.RoleActors
 */
export interface RoleActors {
    /**
     * The role name
     *
     * @generated from protobuf field: string role = 1
     */
    role: string;
    /**
     * List of actor names associated with the role
     *
     * @generated from protobuf field: repeated string actors = 2
     */
    actors: string[];
}
/**
 * RoleManager defines roles for a manager address
 *
 * @generated from protobuf message injective.permissions.v1beta1.RoleManager
 */
export interface RoleManager {
    /**
     * The manager name
     *
     * @generated from protobuf field: string manager = 1
     */
    manager: string;
    /**
     * List of roles associated with the manager
     *
     * @generated from protobuf field: repeated string roles = 2
     */
    roles: string[];
}
/**
 * PolicyStatus defines the status of a policy
 *
 * @generated from protobuf message injective.permissions.v1beta1.PolicyStatus
 */
export interface PolicyStatus {
    /**
     * The action code number
     *
     * @generated from protobuf field: injective.permissions.v1beta1.Action action = 1
     */
    action: Action;
    /**
     * Whether the policy is disabled
     *
     * @generated from protobuf field: bool is_disabled = 2
     */
    isDisabled: boolean;
    /**
     * Whether the policy is sealed
     *
     * @generated from protobuf field: bool is_sealed = 3
     */
    isSealed: boolean;
}
/**
 * Role is only used for storage
 *
 * @generated from protobuf message injective.permissions.v1beta1.Role
 */
export interface Role {
    /**
     * The role name
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * The role ID
     *
     * @generated from protobuf field: uint32 role_id = 2
     */
    roleId: number;
    /**
     * Integer representing the bitwise combination of all actions assigned to the
     * role
     *
     * @generated from protobuf field: uint32 permissions = 3
     */
    permissions: number;
}
/**
 * PolicyManagerCapability defines the capabilities of a manager for a policy
 *
 * @generated from protobuf message injective.permissions.v1beta1.PolicyManagerCapability
 */
export interface PolicyManagerCapability {
    /**
     * The manager name
     *
     * @generated from protobuf field: string manager = 1
     */
    manager: string;
    /**
     * The action code number
     *
     * @generated from protobuf field: injective.permissions.v1beta1.Action action = 2
     */
    action: Action;
    /**
     * Whether the manager can disable the policy
     *
     * @generated from protobuf field: bool can_disable = 3
     */
    canDisable: boolean;
    /**
     * Whether the manager can seal the policy
     *
     * @generated from protobuf field: bool can_seal = 4
     */
    canSeal: boolean;
}
/**
 * used in storage
 *
 * @generated from protobuf message injective.permissions.v1beta1.RoleIDs
 */
export interface RoleIDs {
    /**
     * @generated from protobuf field: repeated uint32 role_ids = 1
     */
    roleIds: number[];
}
/**
 * AddressVoucher is used to represent a voucher for a specific address
 *
 * @generated from protobuf message injective.permissions.v1beta1.AddressVoucher
 */
export interface AddressVoucher {
    /**
     * The Injective address that the voucher is for
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * The voucher amount
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin voucher = 2
     */
    voucher?: Coin;
}
/**
 * each Action enum value should be a power of two
 *
 * @generated from protobuf enum injective.permissions.v1beta1.Action
 */
export enum Action {
    /**
     * 0 is reserved for ACTION_UNSPECIFIED
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * 1 is reserved for MINT
     *
     * @generated from protobuf enum value: MINT = 1;
     */
    MINT = 1,
    /**
     * 2 is reserved for RECEIVE
     *
     * @generated from protobuf enum value: RECEIVE = 2;
     */
    RECEIVE = 2,
    /**
     * 4 is reserved for BURN
     *
     * @generated from protobuf enum value: BURN = 4;
     */
    BURN = 4,
    /**
     * 8 is reserved for SEND
     *
     * @generated from protobuf enum value: SEND = 8;
     */
    SEND = 8,
    /**
     * 16 is reserved for SUPER_BURN
     *
     * @generated from protobuf enum value: SUPER_BURN = 16;
     */
    SUPER_BURN = 16,
    /**
     * 2^27 is reserved for MODIFY_POLICY_MANAGERS
     *
     * 2^27 or 134217728
     *
     * @generated from protobuf enum value: MODIFY_POLICY_MANAGERS = 134217728;
     */
    MODIFY_POLICY_MANAGERS = 134217728,
    /**
     * 2^28 is reserved for MODIFY_CONTRACT_HOOK
     *
     * 2^28 or 268435456
     *
     * @generated from protobuf enum value: MODIFY_CONTRACT_HOOK = 268435456;
     */
    MODIFY_CONTRACT_HOOK = 268435456,
    /**
     * 2^29 is reserved for MODIFY_ROLE_PERMISSIONS
     *
     * 2^29 or 536870912
     *
     * @generated from protobuf enum value: MODIFY_ROLE_PERMISSIONS = 536870912;
     */
    MODIFY_ROLE_PERMISSIONS = 536870912,
    /**
     * 2^30 is reserved for MODIFY_ROLE_MANAGERS
     *
     * 2^30 or 1073741824
     *
     * @generated from protobuf enum value: MODIFY_ROLE_MANAGERS = 1073741824;
     */
    MODIFY_ROLE_MANAGERS = 1073741824
}
// @generated message type with reflection information, may provide speed optimized methods
class Namespace$Type extends MessageType<Namespace> {
    constructor() {
        super("injective.permissions.v1beta1.Namespace", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract_hook", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role_permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Role },
            { no: 4, name: "actor_roles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ActorRoles },
            { no: 5, name: "role_managers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleManager },
            { no: 6, name: "policy_statuses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PolicyStatus },
            { no: 7, name: "policy_manager_capabilities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PolicyManagerCapability }
        ]);
    }
    create(value?: PartialMessage<Namespace>): Namespace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.contractHook = "";
        message.rolePermissions = [];
        message.actorRoles = [];
        message.roleManagers = [];
        message.policyStatuses = [];
        message.policyManagerCapabilities = [];
        if (value !== undefined)
            reflectionMergePartial<Namespace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Namespace): Namespace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string contract_hook */ 2:
                    message.contractHook = reader.string();
                    break;
                case /* repeated injective.permissions.v1beta1.Role role_permissions */ 3:
                    message.rolePermissions.push(Role.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.ActorRoles actor_roles */ 4:
                    message.actorRoles.push(ActorRoles.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.RoleManager role_managers */ 5:
                    message.roleManagers.push(RoleManager.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.PolicyStatus policy_statuses */ 6:
                    message.policyStatuses.push(PolicyStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities */ 7:
                    message.policyManagerCapabilities.push(PolicyManagerCapability.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Namespace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string contract_hook = 2; */
        if (message.contractHook !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractHook);
        /* repeated injective.permissions.v1beta1.Role role_permissions = 3; */
        for (let i = 0; i < message.rolePermissions.length; i++)
            Role.internalBinaryWrite(message.rolePermissions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.ActorRoles actor_roles = 4; */
        for (let i = 0; i < message.actorRoles.length; i++)
            ActorRoles.internalBinaryWrite(message.actorRoles[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.RoleManager role_managers = 5; */
        for (let i = 0; i < message.roleManagers.length; i++)
            RoleManager.internalBinaryWrite(message.roleManagers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 6; */
        for (let i = 0; i < message.policyStatuses.length; i++)
            PolicyStatus.internalBinaryWrite(message.policyStatuses[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 7; */
        for (let i = 0; i < message.policyManagerCapabilities.length; i++)
            PolicyManagerCapability.internalBinaryWrite(message.policyManagerCapabilities[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.Namespace
 */
export const Namespace = new Namespace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActorRoles$Type extends MessageType<ActorRoles> {
    constructor() {
        super("injective.permissions.v1beta1.ActorRoles", [
            { no: 1, name: "actor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ActorRoles>): ActorRoles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actor = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<ActorRoles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActorRoles): ActorRoles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string actor */ 1:
                    message.actor = reader.string();
                    break;
                case /* repeated string roles */ 2:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActorRoles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string actor = 1; */
        if (message.actor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.actor);
        /* repeated string roles = 2; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.ActorRoles
 */
export const ActorRoles = new ActorRoles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleActors$Type extends MessageType<RoleActors> {
    constructor() {
        super("injective.permissions.v1beta1.RoleActors", [
            { no: 1, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "actors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RoleActors>): RoleActors {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.role = "";
        message.actors = [];
        if (value !== undefined)
            reflectionMergePartial<RoleActors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleActors): RoleActors {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string role */ 1:
                    message.role = reader.string();
                    break;
                case /* repeated string actors */ 2:
                    message.actors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleActors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string role = 1; */
        if (message.role !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.role);
        /* repeated string actors = 2; */
        for (let i = 0; i < message.actors.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.actors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.RoleActors
 */
export const RoleActors = new RoleActors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleManager$Type extends MessageType<RoleManager> {
    constructor() {
        super("injective.permissions.v1beta1.RoleManager", [
            { no: 1, name: "manager", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RoleManager>): RoleManager {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.manager = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<RoleManager>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleManager): RoleManager {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string manager */ 1:
                    message.manager = reader.string();
                    break;
                case /* repeated string roles */ 2:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleManager, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string manager = 1; */
        if (message.manager !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.manager);
        /* repeated string roles = 2; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.RoleManager
 */
export const RoleManager = new RoleManager$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PolicyStatus$Type extends MessageType<PolicyStatus> {
    constructor() {
        super("injective.permissions.v1beta1.PolicyStatus", [
            { no: 1, name: "action", kind: "enum", T: () => ["injective.permissions.v1beta1.Action", Action] },
            { no: 2, name: "is_disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_sealed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PolicyStatus>): PolicyStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.isDisabled = false;
        message.isSealed = false;
        if (value !== undefined)
            reflectionMergePartial<PolicyStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PolicyStatus): PolicyStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.permissions.v1beta1.Action action */ 1:
                    message.action = reader.int32();
                    break;
                case /* bool is_disabled */ 2:
                    message.isDisabled = reader.bool();
                    break;
                case /* bool is_sealed */ 3:
                    message.isSealed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PolicyStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.permissions.v1beta1.Action action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* bool is_disabled = 2; */
        if (message.isDisabled !== false)
            writer.tag(2, WireType.Varint).bool(message.isDisabled);
        /* bool is_sealed = 3; */
        if (message.isSealed !== false)
            writer.tag(3, WireType.Varint).bool(message.isSealed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.PolicyStatus
 */
export const PolicyStatus = new PolicyStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Role$Type extends MessageType<Role> {
    constructor() {
        super("injective.permissions.v1beta1.Role", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "role_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "permissions", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Role>): Role {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.roleId = 0;
        message.permissions = 0;
        if (value !== undefined)
            reflectionMergePartial<Role>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Role): Role {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 role_id */ 2:
                    message.roleId = reader.uint32();
                    break;
                case /* uint32 permissions */ 3:
                    message.permissions = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Role, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 role_id = 2; */
        if (message.roleId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.roleId);
        /* uint32 permissions = 3; */
        if (message.permissions !== 0)
            writer.tag(3, WireType.Varint).uint32(message.permissions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.Role
 */
export const Role = new Role$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PolicyManagerCapability$Type extends MessageType<PolicyManagerCapability> {
    constructor() {
        super("injective.permissions.v1beta1.PolicyManagerCapability", [
            { no: 1, name: "manager", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action", kind: "enum", T: () => ["injective.permissions.v1beta1.Action", Action] },
            { no: 3, name: "can_disable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "can_seal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PolicyManagerCapability>): PolicyManagerCapability {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.manager = "";
        message.action = 0;
        message.canDisable = false;
        message.canSeal = false;
        if (value !== undefined)
            reflectionMergePartial<PolicyManagerCapability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PolicyManagerCapability): PolicyManagerCapability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string manager */ 1:
                    message.manager = reader.string();
                    break;
                case /* injective.permissions.v1beta1.Action action */ 2:
                    message.action = reader.int32();
                    break;
                case /* bool can_disable */ 3:
                    message.canDisable = reader.bool();
                    break;
                case /* bool can_seal */ 4:
                    message.canSeal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PolicyManagerCapability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string manager = 1; */
        if (message.manager !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.manager);
        /* injective.permissions.v1beta1.Action action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        /* bool can_disable = 3; */
        if (message.canDisable !== false)
            writer.tag(3, WireType.Varint).bool(message.canDisable);
        /* bool can_seal = 4; */
        if (message.canSeal !== false)
            writer.tag(4, WireType.Varint).bool(message.canSeal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.PolicyManagerCapability
 */
export const PolicyManagerCapability = new PolicyManagerCapability$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleIDs$Type extends MessageType<RoleIDs> {
    constructor() {
        super("injective.permissions.v1beta1.RoleIDs", [
            { no: 1, name: "role_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RoleIDs>): RoleIDs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleIds = [];
        if (value !== undefined)
            reflectionMergePartial<RoleIDs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleIDs): RoleIDs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 role_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.roleIds.push(reader.uint32());
                    else
                        message.roleIds.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleIDs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 role_ids = 1; */
        if (message.roleIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.roleIds.length; i++)
                writer.uint32(message.roleIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.RoleIDs
 */
export const RoleIDs = new RoleIDs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddressVoucher$Type extends MessageType<AddressVoucher> {
    constructor() {
        super("injective.permissions.v1beta1.AddressVoucher", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "voucher", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Coin", "gogoproto.jsontag": "voucher,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AddressVoucher>): AddressVoucher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<AddressVoucher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddressVoucher): AddressVoucher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin voucher */ 2:
                    message.voucher = Coin.internalBinaryRead(reader, reader.uint32(), options, message.voucher);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddressVoucher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* cosmos.base.v1beta1.Coin voucher = 2; */
        if (message.voucher)
            Coin.internalBinaryWrite(message.voucher, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.AddressVoucher
 */
export const AddressVoucher = new AddressVoucher$Type();
