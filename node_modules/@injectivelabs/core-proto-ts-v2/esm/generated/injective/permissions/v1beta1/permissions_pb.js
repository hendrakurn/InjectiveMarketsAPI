import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
var Action = /* @__PURE__ */ ((Action2) => {
  Action2[Action2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  Action2[Action2["MINT"] = 1] = "MINT";
  Action2[Action2["RECEIVE"] = 2] = "RECEIVE";
  Action2[Action2["BURN"] = 4] = "BURN";
  Action2[Action2["SEND"] = 8] = "SEND";
  Action2[Action2["SUPER_BURN"] = 16] = "SUPER_BURN";
  Action2[Action2["MODIFY_POLICY_MANAGERS"] = 134217728] = "MODIFY_POLICY_MANAGERS";
  Action2[Action2["MODIFY_CONTRACT_HOOK"] = 268435456] = "MODIFY_CONTRACT_HOOK";
  Action2[Action2["MODIFY_ROLE_PERMISSIONS"] = 536870912] = "MODIFY_ROLE_PERMISSIONS";
  Action2[Action2["MODIFY_ROLE_MANAGERS"] = 1073741824] = "MODIFY_ROLE_MANAGERS";
  return Action2;
})(Action || {});
class Namespace$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.Namespace", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "contract_hook",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "role_permissions", kind: "message", repeat: 2, T: () => Role },
      { no: 4, name: "actor_roles", kind: "message", repeat: 2, T: () => ActorRoles },
      { no: 5, name: "role_managers", kind: "message", repeat: 2, T: () => RoleManager },
      { no: 6, name: "policy_statuses", kind: "message", repeat: 2, T: () => PolicyStatus },
      { no: 7, name: "policy_manager_capabilities", kind: "message", repeat: 2, T: () => PolicyManagerCapability }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.contractHook = "";
    message.rolePermissions = [];
    message.actorRoles = [];
    message.roleManagers = [];
    message.policyStatuses = [];
    message.policyManagerCapabilities = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string contract_hook */
        2:
          message.contractHook = reader.string();
          break;
        case /* repeated injective.permissions.v1beta1.Role role_permissions */
        3:
          message.rolePermissions.push(Role.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.permissions.v1beta1.ActorRoles actor_roles */
        4:
          message.actorRoles.push(ActorRoles.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.permissions.v1beta1.RoleManager role_managers */
        5:
          message.roleManagers.push(RoleManager.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.permissions.v1beta1.PolicyStatus policy_statuses */
        6:
          message.policyStatuses.push(PolicyStatus.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities */
        7:
          message.policyManagerCapabilities.push(PolicyManagerCapability.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.contractHook !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.contractHook);
    for (let i = 0; i < message.rolePermissions.length; i++)
      Role.internalBinaryWrite(message.rolePermissions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.actorRoles.length; i++)
      ActorRoles.internalBinaryWrite(message.actorRoles[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.roleManagers.length; i++)
      RoleManager.internalBinaryWrite(message.roleManagers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.policyStatuses.length; i++)
      PolicyStatus.internalBinaryWrite(message.policyStatuses[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.policyManagerCapabilities.length; i++)
      PolicyManagerCapability.internalBinaryWrite(message.policyManagerCapabilities[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Namespace = new Namespace$Type();
class ActorRoles$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.ActorRoles", [
      {
        no: 1,
        name: "actor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "roles",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.actor = "";
    message.roles = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string actor */
        1:
          message.actor = reader.string();
          break;
        case /* repeated string roles */
        2:
          message.roles.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.actor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.actor);
    for (let i = 0; i < message.roles.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ActorRoles = new ActorRoles$Type();
class RoleActors$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.RoleActors", [
      {
        no: 1,
        name: "role",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "actors",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.role = "";
    message.actors = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string role */
        1:
          message.role = reader.string();
          break;
        case /* repeated string actors */
        2:
          message.actors.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.role !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.role);
    for (let i = 0; i < message.actors.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.actors[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RoleActors = new RoleActors$Type();
class RoleManager$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.RoleManager", [
      {
        no: 1,
        name: "manager",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "roles",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.manager = "";
    message.roles = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string manager */
        1:
          message.manager = reader.string();
          break;
        case /* repeated string roles */
        2:
          message.roles.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.manager !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.manager);
    for (let i = 0; i < message.roles.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RoleManager = new RoleManager$Type();
class PolicyStatus$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.PolicyStatus", [
      { no: 1, name: "action", kind: "enum", T: () => ["injective.permissions.v1beta1.Action", Action] },
      {
        no: 2,
        name: "is_disabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "is_sealed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.action = 0;
    message.isDisabled = false;
    message.isSealed = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.permissions.v1beta1.Action action */
        1:
          message.action = reader.int32();
          break;
        case /* bool is_disabled */
        2:
          message.isDisabled = reader.bool();
          break;
        case /* bool is_sealed */
        3:
          message.isSealed = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.action !== 0)
      writer.tag(1, WireType.Varint).int32(message.action);
    if (message.isDisabled !== false)
      writer.tag(2, WireType.Varint).bool(message.isDisabled);
    if (message.isSealed !== false)
      writer.tag(3, WireType.Varint).bool(message.isSealed);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PolicyStatus = new PolicyStatus$Type();
class Role$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.Role", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "role_id",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "permissions",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.roleId = 0;
    message.permissions = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* uint32 role_id */
        2:
          message.roleId = reader.uint32();
          break;
        case /* uint32 permissions */
        3:
          message.permissions = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.roleId !== 0)
      writer.tag(2, WireType.Varint).uint32(message.roleId);
    if (message.permissions !== 0)
      writer.tag(3, WireType.Varint).uint32(message.permissions);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Role = new Role$Type();
class PolicyManagerCapability$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.PolicyManagerCapability", [
      {
        no: 1,
        name: "manager",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "action", kind: "enum", T: () => ["injective.permissions.v1beta1.Action", Action] },
      {
        no: 3,
        name: "can_disable",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "can_seal",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.manager = "";
    message.action = 0;
    message.canDisable = false;
    message.canSeal = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string manager */
        1:
          message.manager = reader.string();
          break;
        case /* injective.permissions.v1beta1.Action action */
        2:
          message.action = reader.int32();
          break;
        case /* bool can_disable */
        3:
          message.canDisable = reader.bool();
          break;
        case /* bool can_seal */
        4:
          message.canSeal = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.manager !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.manager);
    if (message.action !== 0)
      writer.tag(2, WireType.Varint).int32(message.action);
    if (message.canDisable !== false)
      writer.tag(3, WireType.Varint).bool(message.canDisable);
    if (message.canSeal !== false)
      writer.tag(4, WireType.Varint).bool(message.canSeal);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PolicyManagerCapability = new PolicyManagerCapability$Type();
class RoleIDs$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.RoleIDs", [
      {
        no: 1,
        name: "role_ids",
        kind: "scalar",
        repeat: 1,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.roleIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated uint32 role_ids */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.roleIds.push(reader.uint32());
          else
            message.roleIds.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.roleIds.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.roleIds.length; i++)
        writer.uint32(message.roleIds[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RoleIDs = new RoleIDs$Type();
class AddressVoucher$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.AddressVoucher", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "voucher", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Coin", "gogoproto.jsontag": "voucher,omitempty" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin voucher */
        2:
          message.voucher = Coin.internalBinaryRead(reader, reader.uint32(), options, message.voucher);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.voucher)
      Coin.internalBinaryWrite(message.voucher, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AddressVoucher = new AddressVoucher$Type();
export {
  Action,
  ActorRoles,
  AddressVoucher,
  Namespace,
  PolicyManagerCapability,
  PolicyStatus,
  Role,
  RoleActors,
  RoleIDs,
  RoleManager
};
