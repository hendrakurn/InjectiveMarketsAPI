import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GenesisState } from "./genesis_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { AddressVoucher } from "./permissions_pb.js";
import { PolicyManagerCapability } from "./permissions_pb.js";
import { PolicyStatus } from "./permissions_pb.js";
import { RoleManager } from "./permissions_pb.js";
import { Namespace } from "./permissions_pb.js";
import { Params } from "./params_pb.js";
class QueryParamsRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryParamsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsRequest = new QueryParamsRequest$Type();
class QueryParamsResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryParamsResponse", [
      { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.permissions.v1beta1.Params params */
        1:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsResponse = new QueryParamsResponse$Type();
class QueryNamespaceDenomsRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryNamespaceDenomsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryNamespaceDenomsRequest = new QueryNamespaceDenomsRequest$Type();
class QueryNamespaceDenomsResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryNamespaceDenomsResponse", [
      {
        no: 1,
        name: "denoms",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denoms = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string denoms */
        1:
          message.denoms.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.denoms.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.denoms[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryNamespaceDenomsResponse = new QueryNamespaceDenomsResponse$Type();
class QueryNamespacesRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryNamespacesRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryNamespacesRequest = new QueryNamespacesRequest$Type();
class QueryNamespacesResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryNamespacesResponse", [
      { no: 1, name: "namespaces", kind: "message", repeat: 2, T: () => Namespace }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.namespaces = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.permissions.v1beta1.Namespace namespaces */
        1:
          message.namespaces.push(Namespace.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.namespaces.length; i++)
      Namespace.internalBinaryWrite(message.namespaces[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryNamespacesResponse = new QueryNamespacesResponse$Type();
class QueryNamespaceRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryNamespaceRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryNamespaceRequest = new QueryNamespaceRequest$Type();
class QueryNamespaceResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryNamespaceResponse", [
      { no: 1, name: "namespace", kind: "message", T: () => Namespace }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.permissions.v1beta1.Namespace namespace */
        1:
          message.namespace = Namespace.internalBinaryRead(reader, reader.uint32(), options, message.namespace);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.namespace)
      Namespace.internalBinaryWrite(message.namespace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryNamespaceResponse = new QueryNamespaceResponse$Type();
class QueryActorsByRoleRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryActorsByRoleRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "role",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.role = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string role */
        2:
          message.role = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.role !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.role);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryActorsByRoleRequest = new QueryActorsByRoleRequest$Type();
class QueryActorsByRoleResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryActorsByRoleResponse", [
      {
        no: 1,
        name: "actors",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.actors = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string actors */
        1:
          message.actors.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.actors.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.actors[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryActorsByRoleResponse = new QueryActorsByRoleResponse$Type();
class QueryRolesByActorRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryRolesByActorRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "actor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.actor = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string actor */
        2:
          message.actor = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.actor !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.actor);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryRolesByActorRequest = new QueryRolesByActorRequest$Type();
class QueryRolesByActorResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryRolesByActorResponse", [
      {
        no: 1,
        name: "roles",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.roles = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string roles */
        1:
          message.roles.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.roles.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryRolesByActorResponse = new QueryRolesByActorResponse$Type();
class QueryRoleManagersRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryRoleManagersRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryRoleManagersRequest = new QueryRoleManagersRequest$Type();
class QueryRoleManagersResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryRoleManagersResponse", [
      { no: 1, name: "role_managers", kind: "message", repeat: 2, T: () => RoleManager }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.roleManagers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.permissions.v1beta1.RoleManager role_managers */
        1:
          message.roleManagers.push(RoleManager.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.roleManagers.length; i++)
      RoleManager.internalBinaryWrite(message.roleManagers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryRoleManagersResponse = new QueryRoleManagersResponse$Type();
class QueryRoleManagerRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryRoleManagerRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "manager",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.manager = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string manager */
        2:
          message.manager = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.manager !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.manager);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryRoleManagerRequest = new QueryRoleManagerRequest$Type();
class QueryRoleManagerResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryRoleManagerResponse", [
      { no: 1, name: "role_manager", kind: "message", T: () => RoleManager }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.permissions.v1beta1.RoleManager role_manager */
        1:
          message.roleManager = RoleManager.internalBinaryRead(reader, reader.uint32(), options, message.roleManager);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.roleManager)
      RoleManager.internalBinaryWrite(message.roleManager, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryRoleManagerResponse = new QueryRoleManagerResponse$Type();
class QueryPolicyStatusesRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryPolicyStatusesRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPolicyStatusesRequest = new QueryPolicyStatusesRequest$Type();
class QueryPolicyStatusesResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryPolicyStatusesResponse", [
      { no: 1, name: "policy_statuses", kind: "message", repeat: 2, T: () => PolicyStatus }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.policyStatuses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.permissions.v1beta1.PolicyStatus policy_statuses */
        1:
          message.policyStatuses.push(PolicyStatus.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.policyStatuses.length; i++)
      PolicyStatus.internalBinaryWrite(message.policyStatuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPolicyStatusesResponse = new QueryPolicyStatusesResponse$Type();
class QueryPolicyManagerCapabilitiesRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryPolicyManagerCapabilitiesRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPolicyManagerCapabilitiesRequest = new QueryPolicyManagerCapabilitiesRequest$Type();
class QueryPolicyManagerCapabilitiesResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryPolicyManagerCapabilitiesResponse", [
      { no: 1, name: "policy_manager_capabilities", kind: "message", repeat: 2, T: () => PolicyManagerCapability }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.policyManagerCapabilities = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities */
        1:
          message.policyManagerCapabilities.push(PolicyManagerCapability.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.policyManagerCapabilities.length; i++)
      PolicyManagerCapability.internalBinaryWrite(message.policyManagerCapabilities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryPolicyManagerCapabilitiesResponse = new QueryPolicyManagerCapabilitiesResponse$Type();
class QueryVouchersRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryVouchersRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryVouchersRequest = new QueryVouchersRequest$Type();
class QueryVouchersResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryVouchersResponse", [
      { no: 1, name: "vouchers", kind: "message", repeat: 2, T: () => AddressVoucher }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vouchers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.permissions.v1beta1.AddressVoucher vouchers */
        1:
          message.vouchers.push(AddressVoucher.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.vouchers.length; i++)
      AddressVoucher.internalBinaryWrite(message.vouchers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryVouchersResponse = new QueryVouchersResponse$Type();
class QueryVoucherRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryVoucherRequest", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryVoucherRequest = new QueryVoucherRequest$Type();
class QueryVoucherResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryVoucherResponse", [
      { no: 1, name: "voucher", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Coin", "gogoproto.jsontag": "voucher,omitempty" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cosmos.base.v1beta1.Coin voucher */
        1:
          message.voucher = Coin.internalBinaryRead(reader, reader.uint32(), options, message.voucher);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.voucher)
      Coin.internalBinaryWrite(message.voucher, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryVoucherResponse = new QueryVoucherResponse$Type();
class QueryModuleStateRequest$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryModuleStateRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryModuleStateRequest = new QueryModuleStateRequest$Type();
class QueryModuleStateResponse$Type extends MessageType {
  constructor() {
    super("injective.permissions.v1beta1.QueryModuleStateResponse", [
      { no: 1, name: "state", kind: "message", T: () => GenesisState }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.permissions.v1beta1.GenesisState state */
        1:
          message.state = GenesisState.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state)
      GenesisState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryModuleStateResponse = new QueryModuleStateResponse$Type();
const Query = new ServiceType("injective.permissions.v1beta1.Query", [
  { name: "Params", options: { "google.api.http": { get: "/injective/permissions/v1beta1/params" } }, I: QueryParamsRequest, O: QueryParamsResponse },
  { name: "NamespaceDenoms", options: { "google.api.http": { get: "/injective/permissions/v1beta1/namespace_denoms" } }, I: QueryNamespaceDenomsRequest, O: QueryNamespaceDenomsResponse },
  { name: "Namespaces", options: { "google.api.http": { get: "/injective/permissions/v1beta1/namespaces" } }, I: QueryNamespacesRequest, O: QueryNamespacesResponse },
  { name: "Namespace", options: { "google.api.http": { get: "/injective/permissions/v1beta1/namespace/{denom}" } }, I: QueryNamespaceRequest, O: QueryNamespaceResponse },
  { name: "RolesByActor", options: { "google.api.http": { get: "/injective/permissions/v1beta1/roles_by_actor/{denom}/{actor}" } }, I: QueryRolesByActorRequest, O: QueryRolesByActorResponse },
  { name: "ActorsByRole", options: { "google.api.http": { get: "/injective/permissions/v1beta1/actors_by_role/{denom}/{role}" } }, I: QueryActorsByRoleRequest, O: QueryActorsByRoleResponse },
  { name: "RoleManagers", options: { "google.api.http": { get: "/injective/permissions/v1beta1/role_managers/{denom}" } }, I: QueryRoleManagersRequest, O: QueryRoleManagersResponse },
  { name: "RoleManager", options: { "google.api.http": { get: "/injective/permissions/v1beta1/role_manager/{denom}/{manager}" } }, I: QueryRoleManagerRequest, O: QueryRoleManagerResponse },
  { name: "PolicyStatuses", options: { "google.api.http": { get: "/injective/permissions/v1beta1/policy_statuses/{denom}" } }, I: QueryPolicyStatusesRequest, O: QueryPolicyStatusesResponse },
  { name: "PolicyManagerCapabilities", options: { "google.api.http": { get: "/injective/permissions/v1beta1/policy_manager_capabilities/{denom}" } }, I: QueryPolicyManagerCapabilitiesRequest, O: QueryPolicyManagerCapabilitiesResponse },
  { name: "Vouchers", options: { "google.api.http": { get: "/injective/permissions/v1beta1/vouchers/{denom}" } }, I: QueryVouchersRequest, O: QueryVouchersResponse },
  { name: "Voucher", options: { "google.api.http": { get: "/injective/permissions/v1beta1/voucher/{denom}/{address}" } }, I: QueryVoucherRequest, O: QueryVoucherResponse },
  { name: "PermissionsModuleState", options: { "google.api.http": { get: "/injective/permissions/v1beta1/module_state" } }, I: QueryModuleStateRequest, O: QueryModuleStateResponse }
]);
export {
  Query,
  QueryActorsByRoleRequest,
  QueryActorsByRoleResponse,
  QueryModuleStateRequest,
  QueryModuleStateResponse,
  QueryNamespaceDenomsRequest,
  QueryNamespaceDenomsResponse,
  QueryNamespaceRequest,
  QueryNamespaceResponse,
  QueryNamespacesRequest,
  QueryNamespacesResponse,
  QueryParamsRequest,
  QueryParamsResponse,
  QueryPolicyManagerCapabilitiesRequest,
  QueryPolicyManagerCapabilitiesResponse,
  QueryPolicyStatusesRequest,
  QueryPolicyStatusesResponse,
  QueryRoleManagerRequest,
  QueryRoleManagerResponse,
  QueryRoleManagersRequest,
  QueryRoleManagersResponse,
  QueryRolesByActorRequest,
  QueryRolesByActorResponse,
  QueryVoucherRequest,
  QueryVoucherResponse,
  QueryVouchersRequest,
  QueryVouchersResponse
};
