// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/permissions/v1beta1/tx.proto" (package "injective.permissions.v1beta1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RoleActors } from "./permissions_pb";
import { PolicyManagerCapability } from "./permissions_pb";
import { PolicyStatus } from "./permissions_pb";
import { RoleManager } from "./permissions_pb";
import { Role } from "./permissions_pb";
import { Namespace } from "./permissions_pb";
import { Params } from "./params_pb";
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the permissions parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: injective.permissions.v1beta1.Params params = 2
     */
    params?: Params;
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgCreateNamespace
 */
export interface MsgCreateNamespace {
    /**
     * The sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * The namespace information
     *
     * @generated from protobuf field: injective.permissions.v1beta1.Namespace namespace = 2
     */
    namespace?: Namespace;
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgCreateNamespaceResponse
 */
export interface MsgCreateNamespaceResponse {
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateNamespace
 */
export interface MsgUpdateNamespace {
    /**
     * The sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * denom whose namespace updates are to be applied
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * address of smart contract to apply code-based restrictions
     *
     * @generated from protobuf field: injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook contract_hook = 3
     */
    contractHook?: MsgUpdateNamespace_SetContractHook;
    /**
     * role permissions to update
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.Role role_permissions = 4
     */
    rolePermissions: Role[];
    /**
     * role managers to update
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleManager role_managers = 5
     */
    roleManagers: RoleManager[];
    /**
     * policy statuses to update
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 6
     */
    policyStatuses: PolicyStatus[];
    /**
     * policy manager capabilities to update
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 7
     */
    policyManagerCapabilities: PolicyManagerCapability[];
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook
 */
export interface MsgUpdateNamespace_SetContractHook {
    /**
     * @generated from protobuf field: string new_value = 1
     */
    newValue: string;
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateNamespaceResponse
 */
export interface MsgUpdateNamespaceResponse {
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateActorRoles
 */
export interface MsgUpdateActorRoles {
    /**
     * The sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * The namespace denom to which this updates are applied
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * The roles to add for given actors
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleActors role_actors_to_add = 3
     */
    roleActorsToAdd: RoleActors[];
    /**
     * The roles to revoke from given actors
     *
     * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleActors role_actors_to_revoke = 5
     */
    roleActorsToRevoke: RoleActors[];
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateActorRolesResponse
 */
export interface MsgUpdateActorRolesResponse {
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgClaimVoucher
 */
export interface MsgClaimVoucher {
    /**
     * The sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * The token denom of the voucher to claim
     *
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgClaimVoucherResponse
 */
export interface MsgClaimVoucherResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("injective.permissions.v1beta1.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "permissions/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* injective.permissions.v1beta1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* injective.permissions.v1beta1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("injective.permissions.v1beta1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateNamespace$Type extends MessageType<MsgCreateNamespace> {
    constructor() {
        super("injective.permissions.v1beta1.MsgCreateNamespace", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "namespace", kind: "message", T: () => Namespace, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "permissions/MsgCreateNamespace", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCreateNamespace>): MsgCreateNamespace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCreateNamespace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateNamespace): MsgCreateNamespace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* injective.permissions.v1beta1.Namespace namespace */ 2:
                    message.namespace = Namespace.internalBinaryRead(reader, reader.uint32(), options, message.namespace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateNamespace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* injective.permissions.v1beta1.Namespace namespace = 2; */
        if (message.namespace)
            Namespace.internalBinaryWrite(message.namespace, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgCreateNamespace
 */
export const MsgCreateNamespace = new MsgCreateNamespace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateNamespaceResponse$Type extends MessageType<MsgCreateNamespaceResponse> {
    constructor() {
        super("injective.permissions.v1beta1.MsgCreateNamespaceResponse", []);
    }
    create(value?: PartialMessage<MsgCreateNamespaceResponse>): MsgCreateNamespaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCreateNamespaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateNamespaceResponse): MsgCreateNamespaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateNamespaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgCreateNamespaceResponse
 */
export const MsgCreateNamespaceResponse = new MsgCreateNamespaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateNamespace$Type extends MessageType<MsgUpdateNamespace> {
    constructor() {
        super("injective.permissions.v1beta1.MsgUpdateNamespace", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "contract_hook", kind: "message", T: () => MsgUpdateNamespace_SetContractHook },
            { no: 4, name: "role_permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Role },
            { no: 5, name: "role_managers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleManager },
            { no: 6, name: "policy_statuses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PolicyStatus },
            { no: 7, name: "policy_manager_capabilities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PolicyManagerCapability }
        ], { "amino.name": "permissions/MsgUpdateNamespace", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgUpdateNamespace>): MsgUpdateNamespace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.denom = "";
        message.rolePermissions = [];
        message.roleManagers = [];
        message.policyStatuses = [];
        message.policyManagerCapabilities = [];
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateNamespace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateNamespace): MsgUpdateNamespace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook contract_hook */ 3:
                    message.contractHook = MsgUpdateNamespace_SetContractHook.internalBinaryRead(reader, reader.uint32(), options, message.contractHook);
                    break;
                case /* repeated injective.permissions.v1beta1.Role role_permissions */ 4:
                    message.rolePermissions.push(Role.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.RoleManager role_managers */ 5:
                    message.roleManagers.push(RoleManager.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.PolicyStatus policy_statuses */ 6:
                    message.policyStatuses.push(PolicyStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities */ 7:
                    message.policyManagerCapabilities.push(PolicyManagerCapability.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateNamespace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook contract_hook = 3; */
        if (message.contractHook)
            MsgUpdateNamespace_SetContractHook.internalBinaryWrite(message.contractHook, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.Role role_permissions = 4; */
        for (let i = 0; i < message.rolePermissions.length; i++)
            Role.internalBinaryWrite(message.rolePermissions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.RoleManager role_managers = 5; */
        for (let i = 0; i < message.roleManagers.length; i++)
            RoleManager.internalBinaryWrite(message.roleManagers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 6; */
        for (let i = 0; i < message.policyStatuses.length; i++)
            PolicyStatus.internalBinaryWrite(message.policyStatuses[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 7; */
        for (let i = 0; i < message.policyManagerCapabilities.length; i++)
            PolicyManagerCapability.internalBinaryWrite(message.policyManagerCapabilities[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateNamespace
 */
export const MsgUpdateNamespace = new MsgUpdateNamespace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateNamespace_SetContractHook$Type extends MessageType<MsgUpdateNamespace_SetContractHook> {
    constructor() {
        super("injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook", [
            { no: 1, name: "new_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MsgUpdateNamespace_SetContractHook>): MsgUpdateNamespace_SetContractHook {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newValue = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateNamespace_SetContractHook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateNamespace_SetContractHook): MsgUpdateNamespace_SetContractHook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string new_value */ 1:
                    message.newValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateNamespace_SetContractHook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string new_value = 1; */
        if (message.newValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.newValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook
 */
export const MsgUpdateNamespace_SetContractHook = new MsgUpdateNamespace_SetContractHook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateNamespaceResponse$Type extends MessageType<MsgUpdateNamespaceResponse> {
    constructor() {
        super("injective.permissions.v1beta1.MsgUpdateNamespaceResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateNamespaceResponse>): MsgUpdateNamespaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateNamespaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateNamespaceResponse): MsgUpdateNamespaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateNamespaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateNamespaceResponse
 */
export const MsgUpdateNamespaceResponse = new MsgUpdateNamespaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateActorRoles$Type extends MessageType<MsgUpdateActorRoles> {
    constructor() {
        super("injective.permissions.v1beta1.MsgUpdateActorRoles", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role_actors_to_add", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleActors },
            { no: 5, name: "role_actors_to_revoke", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleActors }
        ], { "amino.name": "permissions/MsgUpdateActorRoles", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgUpdateActorRoles>): MsgUpdateActorRoles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.denom = "";
        message.roleActorsToAdd = [];
        message.roleActorsToRevoke = [];
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateActorRoles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateActorRoles): MsgUpdateActorRoles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* repeated injective.permissions.v1beta1.RoleActors role_actors_to_add */ 3:
                    message.roleActorsToAdd.push(RoleActors.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.permissions.v1beta1.RoleActors role_actors_to_revoke */ 5:
                    message.roleActorsToRevoke.push(RoleActors.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateActorRoles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* repeated injective.permissions.v1beta1.RoleActors role_actors_to_add = 3; */
        for (let i = 0; i < message.roleActorsToAdd.length; i++)
            RoleActors.internalBinaryWrite(message.roleActorsToAdd[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.permissions.v1beta1.RoleActors role_actors_to_revoke = 5; */
        for (let i = 0; i < message.roleActorsToRevoke.length; i++)
            RoleActors.internalBinaryWrite(message.roleActorsToRevoke[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateActorRoles
 */
export const MsgUpdateActorRoles = new MsgUpdateActorRoles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateActorRolesResponse$Type extends MessageType<MsgUpdateActorRolesResponse> {
    constructor() {
        super("injective.permissions.v1beta1.MsgUpdateActorRolesResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateActorRolesResponse>): MsgUpdateActorRolesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateActorRolesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateActorRolesResponse): MsgUpdateActorRolesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateActorRolesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateActorRolesResponse
 */
export const MsgUpdateActorRolesResponse = new MsgUpdateActorRolesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgClaimVoucher$Type extends MessageType<MsgClaimVoucher> {
    constructor() {
        super("injective.permissions.v1beta1.MsgClaimVoucher", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "permissions/MsgClaimVoucher", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgClaimVoucher>): MsgClaimVoucher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<MsgClaimVoucher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgClaimVoucher): MsgClaimVoucher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgClaimVoucher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgClaimVoucher
 */
export const MsgClaimVoucher = new MsgClaimVoucher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgClaimVoucherResponse$Type extends MessageType<MsgClaimVoucherResponse> {
    constructor() {
        super("injective.permissions.v1beta1.MsgClaimVoucherResponse", []);
    }
    create(value?: PartialMessage<MsgClaimVoucherResponse>): MsgClaimVoucherResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgClaimVoucherResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgClaimVoucherResponse): MsgClaimVoucherResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgClaimVoucherResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgClaimVoucherResponse
 */
export const MsgClaimVoucherResponse = new MsgClaimVoucherResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.permissions.v1beta1.Msg
 */
export const Msg = new ServiceType("injective.permissions.v1beta1.Msg", [
    { name: "UpdateParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse },
    { name: "CreateNamespace", options: {}, I: MsgCreateNamespace, O: MsgCreateNamespaceResponse },
    { name: "UpdateNamespace", options: {}, I: MsgUpdateNamespace, O: MsgUpdateNamespaceResponse },
    { name: "UpdateActorRoles", options: {}, I: MsgUpdateActorRoles, O: MsgUpdateActorRolesResponse },
    { name: "ClaimVoucher", options: {}, I: MsgClaimVoucher, O: MsgClaimVoucherResponse }
], { "cosmos.msg.v1.service": true });
