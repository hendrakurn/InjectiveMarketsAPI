import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { EpochAndRound } from "./ocr_pb.js";
import { Transmission } from "./ocr_pb.js";
import { FeedConfig } from "./ocr_pb.js";
import { Params } from "./ocr_pb.js";
class GenesisState$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.GenesisState", [
      { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } },
      { no: 2, name: "feed_configs", kind: "message", repeat: 2, T: () => FeedConfig },
      { no: 3, name: "latest_epoch_and_rounds", kind: "message", repeat: 2, T: () => FeedEpochAndRound },
      { no: 4, name: "feed_transmissions", kind: "message", repeat: 2, T: () => FeedTransmission },
      { no: 5, name: "latest_aggregator_round_ids", kind: "message", repeat: 2, T: () => FeedLatestAggregatorRoundIDs },
      { no: 6, name: "reward_pools", kind: "message", repeat: 2, T: () => RewardPool },
      { no: 7, name: "feed_observation_counts", kind: "message", repeat: 2, T: () => FeedCounts },
      { no: 8, name: "feed_transmission_counts", kind: "message", repeat: 2, T: () => FeedCounts },
      { no: 9, name: "pending_payeeships", kind: "message", repeat: 2, T: () => PendingPayeeship }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedConfigs = [];
    message.latestEpochAndRounds = [];
    message.feedTransmissions = [];
    message.latestAggregatorRoundIds = [];
    message.rewardPools = [];
    message.feedObservationCounts = [];
    message.feedTransmissionCounts = [];
    message.pendingPayeeships = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.ocr.v1beta1.Params params */
        1:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        case /* repeated injective.ocr.v1beta1.FeedConfig feed_configs */
        2:
          message.feedConfigs.push(FeedConfig.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.ocr.v1beta1.FeedEpochAndRound latest_epoch_and_rounds */
        3:
          message.latestEpochAndRounds.push(FeedEpochAndRound.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.ocr.v1beta1.FeedTransmission feed_transmissions */
        4:
          message.feedTransmissions.push(FeedTransmission.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs latest_aggregator_round_ids */
        5:
          message.latestAggregatorRoundIds.push(FeedLatestAggregatorRoundIDs.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.ocr.v1beta1.RewardPool reward_pools */
        6:
          message.rewardPools.push(RewardPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.ocr.v1beta1.FeedCounts feed_observation_counts */
        7:
          message.feedObservationCounts.push(FeedCounts.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.ocr.v1beta1.FeedCounts feed_transmission_counts */
        8:
          message.feedTransmissionCounts.push(FeedCounts.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.ocr.v1beta1.PendingPayeeship pending_payeeships */
        9:
          message.pendingPayeeships.push(PendingPayeeship.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.feedConfigs.length; i++)
      FeedConfig.internalBinaryWrite(message.feedConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.latestEpochAndRounds.length; i++)
      FeedEpochAndRound.internalBinaryWrite(message.latestEpochAndRounds[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.feedTransmissions.length; i++)
      FeedTransmission.internalBinaryWrite(message.feedTransmissions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.latestAggregatorRoundIds.length; i++)
      FeedLatestAggregatorRoundIDs.internalBinaryWrite(message.latestAggregatorRoundIds[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.rewardPools.length; i++)
      RewardPool.internalBinaryWrite(message.rewardPools[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.feedObservationCounts.length; i++)
      FeedCounts.internalBinaryWrite(message.feedObservationCounts[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.feedTransmissionCounts.length; i++)
      FeedCounts.internalBinaryWrite(message.feedTransmissionCounts[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.pendingPayeeships.length; i++)
      PendingPayeeship.internalBinaryWrite(message.pendingPayeeships[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GenesisState = new GenesisState$Type();
class FeedTransmission$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.FeedTransmission", [
      {
        no: 1,
        name: "feed_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "transmission", kind: "message", T: () => Transmission }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string feed_id */
        1:
          message.feedId = reader.string();
          break;
        case /* injective.ocr.v1beta1.Transmission transmission */
        2:
          message.transmission = Transmission.internalBinaryRead(reader, reader.uint32(), options, message.transmission);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feedId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.feedId);
    if (message.transmission)
      Transmission.internalBinaryWrite(message.transmission, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeedTransmission = new FeedTransmission$Type();
class FeedEpochAndRound$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.FeedEpochAndRound", [
      {
        no: 1,
        name: "feed_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "epoch_and_round", kind: "message", T: () => EpochAndRound }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string feed_id */
        1:
          message.feedId = reader.string();
          break;
        case /* injective.ocr.v1beta1.EpochAndRound epoch_and_round */
        2:
          message.epochAndRound = EpochAndRound.internalBinaryRead(reader, reader.uint32(), options, message.epochAndRound);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feedId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.feedId);
    if (message.epochAndRound)
      EpochAndRound.internalBinaryWrite(message.epochAndRound, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeedEpochAndRound = new FeedEpochAndRound$Type();
class FeedLatestAggregatorRoundIDs$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs", [
      {
        no: 1,
        name: "feed_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "aggregator_round_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedId = "";
    message.aggregatorRoundId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string feed_id */
        1:
          message.feedId = reader.string();
          break;
        case /* uint64 aggregator_round_id */
        2:
          message.aggregatorRoundId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feedId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.feedId);
    if (message.aggregatorRoundId !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.aggregatorRoundId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeedLatestAggregatorRoundIDs = new FeedLatestAggregatorRoundIDs$Type();
class RewardPool$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.RewardPool", [
      {
        no: 1,
        name: "feed_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string feed_id */
        1:
          message.feedId = reader.string();
          break;
        case /* cosmos.base.v1beta1.Coin amount */
        2:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feedId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.feedId);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RewardPool = new RewardPool$Type();
class FeedCounts$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.FeedCounts", [
      {
        no: 1,
        name: "feed_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "counts", kind: "message", repeat: 2, T: () => Count }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedId = "";
    message.counts = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string feed_id */
        1:
          message.feedId = reader.string();
          break;
        case /* repeated injective.ocr.v1beta1.Count counts */
        2:
          message.counts.push(Count.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feedId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.feedId);
    for (let i = 0; i < message.counts.length; i++)
      Count.internalBinaryWrite(message.counts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FeedCounts = new FeedCounts$Type();
class Count$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.Count", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.count = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* uint64 count */
        2:
          message.count = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.count !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.count);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Count = new Count$Type();
class PendingPayeeship$Type extends MessageType {
  constructor() {
    super("injective.ocr.v1beta1.PendingPayeeship", [
      {
        no: 1,
        name: "feed_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "transmitter",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "proposed_payee",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.feedId = "";
    message.transmitter = "";
    message.proposedPayee = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string feed_id */
        1:
          message.feedId = reader.string();
          break;
        case /* string transmitter */
        2:
          message.transmitter = reader.string();
          break;
        case /* string proposed_payee */
        3:
          message.proposedPayee = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.feedId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.feedId);
    if (message.transmitter !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.transmitter);
    if (message.proposedPayee !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.proposedPayee);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PendingPayeeship = new PendingPayeeship$Type();
export {
  Count,
  FeedCounts,
  FeedEpochAndRound,
  FeedLatestAggregatorRoundIDs,
  FeedTransmission,
  GenesisState,
  PendingPayeeship,
  RewardPool
};
