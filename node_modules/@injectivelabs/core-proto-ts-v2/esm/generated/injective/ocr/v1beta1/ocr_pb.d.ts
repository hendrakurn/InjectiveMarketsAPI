// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/ocr/v1beta1/ocr.proto" (package "injective.ocr.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
/**
 * @generated from protobuf message injective.ocr.v1beta1.Params
 */
export interface Params {
    /**
     * Native denom for LINK coin in the bank keeper
     *
     * @generated from protobuf field: string link_denom = 1
     */
    linkDenom: string;
    /**
     * The block number interval at which payouts are made
     *
     * @generated from protobuf field: uint64 payout_block_interval = 2
     */
    payoutBlockInterval: bigint;
    /**
     * The admin for the OCR module
     *
     * @generated from protobuf field: string module_admin = 3
     */
    moduleAdmin: string;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.FeedConfig
 */
export interface FeedConfig {
    /**
     * signers ith element is address ith oracle uses to sign a report
     *
     * @generated from protobuf field: repeated string signers = 1
     */
    signers: string[];
    /**
     * transmitters ith element is address ith oracle uses to transmit a report
     * via the transmit method
     *
     * @generated from protobuf field: repeated string transmitters = 2
     */
    transmitters: string[];
    /**
     * f maximum number of faulty/dishonest oracles the protocol can tolerate
     * while still working correctly
     *
     * @generated from protobuf field: uint32 f = 3
     */
    f: number;
    /**
     * onchain_config serialized data with reporting plugin params on chain.
     *
     * @generated from protobuf field: bytes onchain_config = 4
     */
    onchainConfig: Uint8Array;
    /**
     * offchain_config_version version of the serialization format used for
     * "offchain_config" parameter
     *
     * @generated from protobuf field: uint64 offchain_config_version = 5
     */
    offchainConfigVersion: bigint;
    /**
     * offchain_config serialized data used by oracles to configure their offchain
     * operation
     *
     * @generated from protobuf field: bytes offchain_config = 6
     */
    offchainConfig: Uint8Array;
    /**
     * feed-specific params for the Cosmos module.
     *
     * @generated from protobuf field: injective.ocr.v1beta1.ModuleParams module_params = 7
     */
    moduleParams?: ModuleParams;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.FeedConfigInfo
 */
export interface FeedConfigInfo {
    /**
     * @generated from protobuf field: bytes latest_config_digest = 1
     */
    latestConfigDigest: Uint8Array;
    /**
     * @generated from protobuf field: uint32 f = 2
     */
    f: number;
    /**
     * @generated from protobuf field: uint32 n = 3
     */
    n: number;
    /**
     * config_count ordinal number of this config setting among all config
     * settings
     *
     * @generated from protobuf field: uint64 config_count = 4
     */
    configCount: bigint;
    /**
     * @generated from protobuf field: int64 latest_config_block_number = 5
     */
    latestConfigBlockNumber: bigint;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.ModuleParams
 */
export interface ModuleParams {
    /**
     * feed_id is an unique ID for the target of this config
     *
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * lowest answer the median of a report is allowed to be
     *
     * @generated from protobuf field: string min_answer = 2
     */
    minAnswer: string;
    /**
     * highest answer the median of a report is allowed to be
     *
     * @generated from protobuf field: string max_answer = 3
     */
    maxAnswer: string;
    /**
     * Fixed LINK reward for each observer
     *
     * @generated from protobuf field: string link_per_observation = 4
     */
    linkPerObservation: string;
    /**
     * Fixed LINK reward for transmitter
     *
     * @generated from protobuf field: string link_per_transmission = 5
     */
    linkPerTransmission: string;
    /**
     * Native denom for LINK coin in the bank keeper
     *
     * @generated from protobuf field: string link_denom = 6
     */
    linkDenom: string;
    /**
     * Enables unique reports
     *
     * @generated from protobuf field: bool unique_reports = 7
     */
    uniqueReports: boolean;
    /**
     * short human-readable description of observable this feed's answers pertain
     * to
     *
     * @generated from protobuf field: string description = 8
     */
    description: string;
    /**
     * feed administrator
     *
     * @generated from protobuf field: string feed_admin = 9
     */
    feedAdmin: string;
    /**
     * feed billing administrator
     *
     * @generated from protobuf field: string billing_admin = 10
     */
    billingAdmin: string;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.ContractConfig
 */
export interface ContractConfig {
    /**
     * config_count ordinal number of this config setting among all config
     * settings
     *
     * @generated from protobuf field: uint64 config_count = 1
     */
    configCount: bigint;
    /**
     * signers ith element is address ith oracle uses to sign a report
     *
     * @generated from protobuf field: repeated string signers = 2
     */
    signers: string[];
    /**
     * transmitters ith element is address ith oracle uses to transmit a report
     * via the transmit method
     *
     * @generated from protobuf field: repeated string transmitters = 3
     */
    transmitters: string[];
    /**
     * f maximum number of faulty/dishonest oracles the protocol can tolerate
     * while still working correctly
     *
     * @generated from protobuf field: uint32 f = 4
     */
    f: number;
    /**
     * onchain_config serialized data with reporting plugin params on chain.
     *
     * @generated from protobuf field: bytes onchain_config = 5
     */
    onchainConfig: Uint8Array;
    /**
     * offchain_config_version version of the serialization format used for
     * "offchain_config" parameter
     *
     * @generated from protobuf field: uint64 offchain_config_version = 6
     */
    offchainConfigVersion: bigint;
    /**
     * offchain_config serialized data used by oracles to configure their offchain
     * operation
     *
     * @generated from protobuf field: bytes offchain_config = 7
     */
    offchainConfig: Uint8Array;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.SetConfigProposal
 */
export interface SetConfigProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: injective.ocr.v1beta1.FeedConfig config = 3
     */
    config?: FeedConfig;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.FeedProperties
 */
export interface FeedProperties {
    /**
     * feed_id is an unique ID for the target of this config
     *
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * f maximum number of faulty/dishonest oracles the protocol can tolerate
     * while still working correctly
     *
     * @generated from protobuf field: uint32 f = 2
     */
    f: number;
    /**
     * onchain_config serialized data with reporting plugin params on chain.
     *
     * @generated from protobuf field: bytes onchain_config = 3
     */
    onchainConfig: Uint8Array;
    /**
     * offchain_config_version version of the serialization format used for
     * "offchain_config" parameter
     *
     * @generated from protobuf field: uint64 offchain_config_version = 4
     */
    offchainConfigVersion: bigint;
    /**
     * offchain_config serialized data used by oracles to configure their offchain
     * operation
     *
     * @generated from protobuf field: bytes offchain_config = 5
     */
    offchainConfig: Uint8Array;
    /**
     * lowest answer the median of a report is allowed to be
     *
     * @generated from protobuf field: string min_answer = 6
     */
    minAnswer: string;
    /**
     * highest answer the median of a report is allowed to be
     *
     * @generated from protobuf field: string max_answer = 7
     */
    maxAnswer: string;
    /**
     * Fixed LINK reward for each observer
     *
     * @generated from protobuf field: string link_per_observation = 8
     */
    linkPerObservation: string;
    /**
     * Fixed LINK reward for transmitter
     *
     * @generated from protobuf field: string link_per_transmission = 9
     */
    linkPerTransmission: string;
    /**
     * Enables unique reports
     *
     * @generated from protobuf field: bool unique_reports = 10
     */
    uniqueReports: boolean;
    /**
     * short human-readable description of observable this feed's answers pertain
     * to
     *
     * @generated from protobuf field: string description = 11
     */
    description: string;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.SetBatchConfigProposal
 */
export interface SetBatchConfigProposal {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * signers ith element is address ith oracle uses to sign a report
     *
     * @generated from protobuf field: repeated string signers = 3
     */
    signers: string[];
    /**
     * transmitters ith element is address ith oracle uses to transmit a report
     * via the transmit method
     *
     * @generated from protobuf field: repeated string transmitters = 4
     */
    transmitters: string[];
    /**
     * Native denom for LINK coin in the bank keeper
     *
     * @generated from protobuf field: string link_denom = 5
     */
    linkDenom: string;
    /**
     * feed properties
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.FeedProperties feed_properties = 6
     */
    feedProperties: FeedProperties[];
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.OracleObservationsCounts
 */
export interface OracleObservationsCounts {
    /**
     * @generated from protobuf field: repeated uint32 counts = 1
     */
    counts: number[];
}
/**
 * LINK-INJ-denominated reimbursements for gas used by transmitters.
 *
 * @generated from protobuf message injective.ocr.v1beta1.GasReimbursements
 */
export interface GasReimbursements {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin reimbursements = 1
     */
    reimbursements: Coin[];
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.Payee
 */
export interface Payee {
    /**
     * @generated from protobuf field: string transmitter_addr = 1
     */
    transmitterAddr: string;
    /**
     * @generated from protobuf field: string payment_addr = 2
     */
    paymentAddr: string;
}
/**
 * Transmission records the median answer from the transmit transaction at
 * time timestamp
 *
 * @generated from protobuf message injective.ocr.v1beta1.Transmission
 */
export interface Transmission {
    /**
     * @generated from protobuf field: string answer = 1
     */
    answer: string;
    /**
     * @generated from protobuf field: int64 observations_timestamp = 2
     */
    observationsTimestamp: bigint; // when were observations made offchain
    /**
     * @generated from protobuf field: int64 transmission_timestamp = 3
     */
    transmissionTimestamp: bigint; // when was report received onchain
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.EpochAndRound
 */
export interface EpochAndRound {
    /**
     * @generated from protobuf field: uint64 epoch = 1
     */
    epoch: bigint;
    /**
     * @generated from protobuf field: uint64 round = 2
     */
    round: bigint;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.Report
 */
export interface Report {
    /**
     * @generated from protobuf field: int64 observations_timestamp = 1
     */
    observationsTimestamp: bigint;
    /**
     * @generated from protobuf field: bytes observers = 2
     */
    observers: Uint8Array; // ith element is the index of the ith observer
    /**
     * @generated from protobuf field: repeated string observations = 3
     */
    observations: string[]; // ith element is the ith observation
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.ReportToSign
 */
export interface ReportToSign {
    /**
     * @generated from protobuf field: bytes config_digest = 1
     */
    configDigest: Uint8Array;
    /**
     * @generated from protobuf field: uint64 epoch = 2
     */
    epoch: bigint;
    /**
     * @generated from protobuf field: uint64 round = 3
     */
    round: bigint;
    /**
     * @generated from protobuf field: bytes extra_hash = 4
     */
    extraHash: Uint8Array;
    /**
     * Opaque report
     *
     * @generated from protobuf field: bytes report = 5
     */
    report: Uint8Array;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.EventOraclePaid
 */
export interface EventOraclePaid {
    /**
     * @generated from protobuf field: string transmitter_addr = 1
     */
    transmitterAddr: string;
    /**
     * @generated from protobuf field: string payee_addr = 2
     */
    payeeAddr: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.EventAnswerUpdated
 */
export interface EventAnswerUpdated {
    /**
     * @generated from protobuf field: string current = 1
     */
    current: string;
    /**
     * @generated from protobuf field: string round_id = 2
     */
    roundId: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 3
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.EventNewRound
 */
export interface EventNewRound {
    /**
     * @generated from protobuf field: string round_id = 1
     */
    roundId: string;
    /**
     * address of starter
     *
     * @generated from protobuf field: string started_by = 2
     */
    startedBy: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp started_at = 3
     */
    startedAt?: Timestamp;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.EventTransmitted
 */
export interface EventTransmitted {
    /**
     * @generated from protobuf field: bytes config_digest = 1
     */
    configDigest: Uint8Array;
    /**
     * @generated from protobuf field: uint64 epoch = 2
     */
    epoch: bigint;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.EventNewTransmission
 */
export interface EventNewTransmission {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: uint32 aggregator_round_id = 2
     */
    aggregatorRoundId: number;
    /**
     * @generated from protobuf field: string answer = 3
     */
    answer: string;
    /**
     * @generated from protobuf field: string transmitter = 4
     */
    transmitter: string;
    /**
     * @generated from protobuf field: int64 observations_timestamp = 5
     */
    observationsTimestamp: bigint;
    /**
     * @generated from protobuf field: repeated string observations = 6
     */
    observations: string[];
    /**
     * @generated from protobuf field: bytes observers = 7
     */
    observers: Uint8Array;
    /**
     * @generated from protobuf field: bytes config_digest = 8
     */
    configDigest: Uint8Array;
    /**
     * @generated from protobuf field: injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9
     */
    epochAndRound?: EpochAndRound;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.EventConfigSet
 */
export interface EventConfigSet {
    /**
     * hash of the config
     *
     * @generated from protobuf field: bytes config_digest = 1
     */
    configDigest: Uint8Array;
    /**
     * previous_config_block_number block in which the previous config was set, to
     * simplify historic analysis
     *
     * @generated from protobuf field: int64 previous_config_block_number = 2
     */
    previousConfigBlockNumber: bigint;
    /**
     * @generated from protobuf field: injective.ocr.v1beta1.FeedConfig config = 3
     */
    config?: FeedConfig;
    /**
     * @generated from protobuf field: injective.ocr.v1beta1.FeedConfigInfo config_info = 4
     */
    configInfo?: FeedConfigInfo;
}
// @generated message type with reflection information, may provide speed optimized methods
class Params$Type extends MessageType<Params> {
    constructor() {
        super("injective.ocr.v1beta1.Params", [
            { no: 1, name: "link_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "payout_block_interval", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "module_admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true, "amino.name": "ocr/Params" });
    }
    create(value?: PartialMessage<Params>): Params {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.linkDenom = "";
        message.payoutBlockInterval = 0n;
        message.moduleAdmin = "";
        if (value !== undefined)
            reflectionMergePartial<Params>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string link_denom */ 1:
                    message.linkDenom = reader.string();
                    break;
                case /* uint64 payout_block_interval */ 2:
                    message.payoutBlockInterval = reader.uint64().toBigInt();
                    break;
                case /* string module_admin */ 3:
                    message.moduleAdmin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string link_denom = 1; */
        if (message.linkDenom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.linkDenom);
        /* uint64 payout_block_interval = 2; */
        if (message.payoutBlockInterval !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.payoutBlockInterval);
        /* string module_admin = 3; */
        if (message.moduleAdmin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.moduleAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.Params
 */
export const Params = new Params$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedConfig$Type extends MessageType<FeedConfig> {
    constructor() {
        super("injective.ocr.v1beta1.FeedConfig", [
            { no: 1, name: "signers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transmitters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "f", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "onchain_config", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "offchain_config_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "offchain_config", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "module_params", kind: "message", T: () => ModuleParams }
        ]);
    }
    create(value?: PartialMessage<FeedConfig>): FeedConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signers = [];
        message.transmitters = [];
        message.f = 0;
        message.onchainConfig = new Uint8Array(0);
        message.offchainConfigVersion = 0n;
        message.offchainConfig = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<FeedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedConfig): FeedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string signers */ 1:
                    message.signers.push(reader.string());
                    break;
                case /* repeated string transmitters */ 2:
                    message.transmitters.push(reader.string());
                    break;
                case /* uint32 f */ 3:
                    message.f = reader.uint32();
                    break;
                case /* bytes onchain_config */ 4:
                    message.onchainConfig = reader.bytes();
                    break;
                case /* uint64 offchain_config_version */ 5:
                    message.offchainConfigVersion = reader.uint64().toBigInt();
                    break;
                case /* bytes offchain_config */ 6:
                    message.offchainConfig = reader.bytes();
                    break;
                case /* injective.ocr.v1beta1.ModuleParams module_params */ 7:
                    message.moduleParams = ModuleParams.internalBinaryRead(reader, reader.uint32(), options, message.moduleParams);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string signers = 1; */
        for (let i = 0; i < message.signers.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.signers[i]);
        /* repeated string transmitters = 2; */
        for (let i = 0; i < message.transmitters.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.transmitters[i]);
        /* uint32 f = 3; */
        if (message.f !== 0)
            writer.tag(3, WireType.Varint).uint32(message.f);
        /* bytes onchain_config = 4; */
        if (message.onchainConfig.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.onchainConfig);
        /* uint64 offchain_config_version = 5; */
        if (message.offchainConfigVersion !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.offchainConfigVersion);
        /* bytes offchain_config = 6; */
        if (message.offchainConfig.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.offchainConfig);
        /* injective.ocr.v1beta1.ModuleParams module_params = 7; */
        if (message.moduleParams)
            ModuleParams.internalBinaryWrite(message.moduleParams, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.FeedConfig
 */
export const FeedConfig = new FeedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedConfigInfo$Type extends MessageType<FeedConfigInfo> {
    constructor() {
        super("injective.ocr.v1beta1.FeedConfigInfo", [
            { no: 1, name: "latest_config_digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "f", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "n", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "config_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "latest_config_block_number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FeedConfigInfo>): FeedConfigInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latestConfigDigest = new Uint8Array(0);
        message.f = 0;
        message.n = 0;
        message.configCount = 0n;
        message.latestConfigBlockNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<FeedConfigInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedConfigInfo): FeedConfigInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes latest_config_digest */ 1:
                    message.latestConfigDigest = reader.bytes();
                    break;
                case /* uint32 f */ 2:
                    message.f = reader.uint32();
                    break;
                case /* uint32 n */ 3:
                    message.n = reader.uint32();
                    break;
                case /* uint64 config_count */ 4:
                    message.configCount = reader.uint64().toBigInt();
                    break;
                case /* int64 latest_config_block_number */ 5:
                    message.latestConfigBlockNumber = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedConfigInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes latest_config_digest = 1; */
        if (message.latestConfigDigest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.latestConfigDigest);
        /* uint32 f = 2; */
        if (message.f !== 0)
            writer.tag(2, WireType.Varint).uint32(message.f);
        /* uint32 n = 3; */
        if (message.n !== 0)
            writer.tag(3, WireType.Varint).uint32(message.n);
        /* uint64 config_count = 4; */
        if (message.configCount !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.configCount);
        /* int64 latest_config_block_number = 5; */
        if (message.latestConfigBlockNumber !== 0n)
            writer.tag(5, WireType.Varint).int64(message.latestConfigBlockNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.FeedConfigInfo
 */
export const FeedConfigInfo = new FeedConfigInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleParams$Type extends MessageType<ModuleParams> {
    constructor() {
        super("injective.ocr.v1beta1.ModuleParams", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "min_answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "max_answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "link_per_observation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 5, name: "link_per_transmission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 6, name: "link_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "unique_reports", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "feed_admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "billing_admin", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ModuleParams>): ModuleParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.minAnswer = "";
        message.maxAnswer = "";
        message.linkPerObservation = "";
        message.linkPerTransmission = "";
        message.linkDenom = "";
        message.uniqueReports = false;
        message.description = "";
        message.feedAdmin = "";
        message.billingAdmin = "";
        if (value !== undefined)
            reflectionMergePartial<ModuleParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleParams): ModuleParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* string min_answer */ 2:
                    message.minAnswer = reader.string();
                    break;
                case /* string max_answer */ 3:
                    message.maxAnswer = reader.string();
                    break;
                case /* string link_per_observation */ 4:
                    message.linkPerObservation = reader.string();
                    break;
                case /* string link_per_transmission */ 5:
                    message.linkPerTransmission = reader.string();
                    break;
                case /* string link_denom */ 6:
                    message.linkDenom = reader.string();
                    break;
                case /* bool unique_reports */ 7:
                    message.uniqueReports = reader.bool();
                    break;
                case /* string description */ 8:
                    message.description = reader.string();
                    break;
                case /* string feed_admin */ 9:
                    message.feedAdmin = reader.string();
                    break;
                case /* string billing_admin */ 10:
                    message.billingAdmin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* string min_answer = 2; */
        if (message.minAnswer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.minAnswer);
        /* string max_answer = 3; */
        if (message.maxAnswer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.maxAnswer);
        /* string link_per_observation = 4; */
        if (message.linkPerObservation !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.linkPerObservation);
        /* string link_per_transmission = 5; */
        if (message.linkPerTransmission !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.linkPerTransmission);
        /* string link_denom = 6; */
        if (message.linkDenom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.linkDenom);
        /* bool unique_reports = 7; */
        if (message.uniqueReports !== false)
            writer.tag(7, WireType.Varint).bool(message.uniqueReports);
        /* string description = 8; */
        if (message.description !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.description);
        /* string feed_admin = 9; */
        if (message.feedAdmin !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feedAdmin);
        /* string billing_admin = 10; */
        if (message.billingAdmin !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.billingAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.ModuleParams
 */
export const ModuleParams = new ModuleParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContractConfig$Type extends MessageType<ContractConfig> {
    constructor() {
        super("injective.ocr.v1beta1.ContractConfig", [
            { no: 1, name: "config_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "signers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "transmitters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "f", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "onchain_config", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "offchain_config_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "offchain_config", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ContractConfig>): ContractConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configCount = 0n;
        message.signers = [];
        message.transmitters = [];
        message.f = 0;
        message.onchainConfig = new Uint8Array(0);
        message.offchainConfigVersion = 0n;
        message.offchainConfig = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ContractConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractConfig): ContractConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 config_count */ 1:
                    message.configCount = reader.uint64().toBigInt();
                    break;
                case /* repeated string signers */ 2:
                    message.signers.push(reader.string());
                    break;
                case /* repeated string transmitters */ 3:
                    message.transmitters.push(reader.string());
                    break;
                case /* uint32 f */ 4:
                    message.f = reader.uint32();
                    break;
                case /* bytes onchain_config */ 5:
                    message.onchainConfig = reader.bytes();
                    break;
                case /* uint64 offchain_config_version */ 6:
                    message.offchainConfigVersion = reader.uint64().toBigInt();
                    break;
                case /* bytes offchain_config */ 7:
                    message.offchainConfig = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContractConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 config_count = 1; */
        if (message.configCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.configCount);
        /* repeated string signers = 2; */
        for (let i = 0; i < message.signers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.signers[i]);
        /* repeated string transmitters = 3; */
        for (let i = 0; i < message.transmitters.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.transmitters[i]);
        /* uint32 f = 4; */
        if (message.f !== 0)
            writer.tag(4, WireType.Varint).uint32(message.f);
        /* bytes onchain_config = 5; */
        if (message.onchainConfig.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.onchainConfig);
        /* uint64 offchain_config_version = 6; */
        if (message.offchainConfigVersion !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.offchainConfigVersion);
        /* bytes offchain_config = 7; */
        if (message.offchainConfig.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.offchainConfig);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.ContractConfig
 */
export const ContractConfig = new ContractConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetConfigProposal$Type extends MessageType<SetConfigProposal> {
    constructor() {
        super("injective.ocr.v1beta1.SetConfigProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "config", kind: "message", T: () => FeedConfig }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "ocr/SetConfigProposal" });
    }
    create(value?: PartialMessage<SetConfigProposal>): SetConfigProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<SetConfigProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetConfigProposal): SetConfigProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* injective.ocr.v1beta1.FeedConfig config */ 3:
                    message.config = FeedConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetConfigProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* injective.ocr.v1beta1.FeedConfig config = 3; */
        if (message.config)
            FeedConfig.internalBinaryWrite(message.config, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.SetConfigProposal
 */
export const SetConfigProposal = new SetConfigProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedProperties$Type extends MessageType<FeedProperties> {
    constructor() {
        super("injective.ocr.v1beta1.FeedProperties", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "f", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "onchain_config", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "offchain_config_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "offchain_config", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "min_answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "max_answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "link_per_observation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 9, name: "link_per_transmission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 10, name: "unique_reports", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeedProperties>): FeedProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.f = 0;
        message.onchainConfig = new Uint8Array(0);
        message.offchainConfigVersion = 0n;
        message.offchainConfig = new Uint8Array(0);
        message.minAnswer = "";
        message.maxAnswer = "";
        message.linkPerObservation = "";
        message.linkPerTransmission = "";
        message.uniqueReports = false;
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<FeedProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedProperties): FeedProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* uint32 f */ 2:
                    message.f = reader.uint32();
                    break;
                case /* bytes onchain_config */ 3:
                    message.onchainConfig = reader.bytes();
                    break;
                case /* uint64 offchain_config_version */ 4:
                    message.offchainConfigVersion = reader.uint64().toBigInt();
                    break;
                case /* bytes offchain_config */ 5:
                    message.offchainConfig = reader.bytes();
                    break;
                case /* string min_answer */ 6:
                    message.minAnswer = reader.string();
                    break;
                case /* string max_answer */ 7:
                    message.maxAnswer = reader.string();
                    break;
                case /* string link_per_observation */ 8:
                    message.linkPerObservation = reader.string();
                    break;
                case /* string link_per_transmission */ 9:
                    message.linkPerTransmission = reader.string();
                    break;
                case /* bool unique_reports */ 10:
                    message.uniqueReports = reader.bool();
                    break;
                case /* string description */ 11:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* uint32 f = 2; */
        if (message.f !== 0)
            writer.tag(2, WireType.Varint).uint32(message.f);
        /* bytes onchain_config = 3; */
        if (message.onchainConfig.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.onchainConfig);
        /* uint64 offchain_config_version = 4; */
        if (message.offchainConfigVersion !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.offchainConfigVersion);
        /* bytes offchain_config = 5; */
        if (message.offchainConfig.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.offchainConfig);
        /* string min_answer = 6; */
        if (message.minAnswer !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.minAnswer);
        /* string max_answer = 7; */
        if (message.maxAnswer !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.maxAnswer);
        /* string link_per_observation = 8; */
        if (message.linkPerObservation !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.linkPerObservation);
        /* string link_per_transmission = 9; */
        if (message.linkPerTransmission !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.linkPerTransmission);
        /* bool unique_reports = 10; */
        if (message.uniqueReports !== false)
            writer.tag(10, WireType.Varint).bool(message.uniqueReports);
        /* string description = 11; */
        if (message.description !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.FeedProperties
 */
export const FeedProperties = new FeedProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetBatchConfigProposal$Type extends MessageType<SetBatchConfigProposal> {
    constructor() {
        super("injective.ocr.v1beta1.SetBatchConfigProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "signers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "transmitters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "link_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "feed_properties", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedProperties }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos_proto.implements_interface": ["cosmos.gov.v1beta1.Content"], "amino.name": "ocr/SetBatchConfigProposal" });
    }
    create(value?: PartialMessage<SetBatchConfigProposal>): SetBatchConfigProposal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.description = "";
        message.signers = [];
        message.transmitters = [];
        message.linkDenom = "";
        message.feedProperties = [];
        if (value !== undefined)
            reflectionMergePartial<SetBatchConfigProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetBatchConfigProposal): SetBatchConfigProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated string signers */ 3:
                    message.signers.push(reader.string());
                    break;
                case /* repeated string transmitters */ 4:
                    message.transmitters.push(reader.string());
                    break;
                case /* string link_denom */ 5:
                    message.linkDenom = reader.string();
                    break;
                case /* repeated injective.ocr.v1beta1.FeedProperties feed_properties */ 6:
                    message.feedProperties.push(FeedProperties.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetBatchConfigProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated string signers = 3; */
        for (let i = 0; i < message.signers.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.signers[i]);
        /* repeated string transmitters = 4; */
        for (let i = 0; i < message.transmitters.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.transmitters[i]);
        /* string link_denom = 5; */
        if (message.linkDenom !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.linkDenom);
        /* repeated injective.ocr.v1beta1.FeedProperties feed_properties = 6; */
        for (let i = 0; i < message.feedProperties.length; i++)
            FeedProperties.internalBinaryWrite(message.feedProperties[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.SetBatchConfigProposal
 */
export const SetBatchConfigProposal = new SetBatchConfigProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OracleObservationsCounts$Type extends MessageType<OracleObservationsCounts> {
    constructor() {
        super("injective.ocr.v1beta1.OracleObservationsCounts", [
            { no: 1, name: "counts", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OracleObservationsCounts>): OracleObservationsCounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.counts = [];
        if (value !== undefined)
            reflectionMergePartial<OracleObservationsCounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OracleObservationsCounts): OracleObservationsCounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 counts */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.counts.push(reader.uint32());
                    else
                        message.counts.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OracleObservationsCounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 counts = 1; */
        if (message.counts.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.counts.length; i++)
                writer.uint32(message.counts[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.OracleObservationsCounts
 */
export const OracleObservationsCounts = new OracleObservationsCounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GasReimbursements$Type extends MessageType<GasReimbursements> {
    constructor() {
        super("injective.ocr.v1beta1.GasReimbursements", [
            { no: 1, name: "reimbursements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin }
        ]);
    }
    create(value?: PartialMessage<GasReimbursements>): GasReimbursements {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reimbursements = [];
        if (value !== undefined)
            reflectionMergePartial<GasReimbursements>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GasReimbursements): GasReimbursements {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin reimbursements */ 1:
                    message.reimbursements.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GasReimbursements, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin reimbursements = 1; */
        for (let i = 0; i < message.reimbursements.length; i++)
            Coin.internalBinaryWrite(message.reimbursements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.GasReimbursements
 */
export const GasReimbursements = new GasReimbursements$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Payee$Type extends MessageType<Payee> {
    constructor() {
        super("injective.ocr.v1beta1.Payee", [
            { no: 1, name: "transmitter_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "payment_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Payee>): Payee {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transmitterAddr = "";
        message.paymentAddr = "";
        if (value !== undefined)
            reflectionMergePartial<Payee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payee): Payee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string transmitter_addr */ 1:
                    message.transmitterAddr = reader.string();
                    break;
                case /* string payment_addr */ 2:
                    message.paymentAddr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Payee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string transmitter_addr = 1; */
        if (message.transmitterAddr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.transmitterAddr);
        /* string payment_addr = 2; */
        if (message.paymentAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paymentAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.Payee
 */
export const Payee = new Payee$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transmission$Type extends MessageType<Transmission> {
    constructor() {
        super("injective.ocr.v1beta1.Transmission", [
            { no: 1, name: "answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 2, name: "observations_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "transmission_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Transmission>): Transmission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.answer = "";
        message.observationsTimestamp = 0n;
        message.transmissionTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Transmission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transmission): Transmission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string answer */ 1:
                    message.answer = reader.string();
                    break;
                case /* int64 observations_timestamp */ 2:
                    message.observationsTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 transmission_timestamp */ 3:
                    message.transmissionTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transmission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string answer = 1; */
        if (message.answer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.answer);
        /* int64 observations_timestamp = 2; */
        if (message.observationsTimestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.observationsTimestamp);
        /* int64 transmission_timestamp = 3; */
        if (message.transmissionTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.transmissionTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.Transmission
 */
export const Transmission = new Transmission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpochAndRound$Type extends MessageType<EpochAndRound> {
    constructor() {
        super("injective.ocr.v1beta1.EpochAndRound", [
            { no: 1, name: "epoch", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "round", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EpochAndRound>): EpochAndRound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epoch = 0n;
        message.round = 0n;
        if (value !== undefined)
            reflectionMergePartial<EpochAndRound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpochAndRound): EpochAndRound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 epoch */ 1:
                    message.epoch = reader.uint64().toBigInt();
                    break;
                case /* uint64 round */ 2:
                    message.round = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpochAndRound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 epoch = 1; */
        if (message.epoch !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.epoch);
        /* uint64 round = 2; */
        if (message.round !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.round);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.EpochAndRound
 */
export const EpochAndRound = new EpochAndRound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Report$Type extends MessageType<Report> {
    constructor() {
        super("injective.ocr.v1beta1.Report", [
            { no: 1, name: "observations_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "observers", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "observations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Report>): Report {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.observationsTimestamp = 0n;
        message.observers = new Uint8Array(0);
        message.observations = [];
        if (value !== undefined)
            reflectionMergePartial<Report>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Report): Report {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 observations_timestamp */ 1:
                    message.observationsTimestamp = reader.int64().toBigInt();
                    break;
                case /* bytes observers */ 2:
                    message.observers = reader.bytes();
                    break;
                case /* repeated string observations */ 3:
                    message.observations.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Report, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 observations_timestamp = 1; */
        if (message.observationsTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.observationsTimestamp);
        /* bytes observers = 2; */
        if (message.observers.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.observers);
        /* repeated string observations = 3; */
        for (let i = 0; i < message.observations.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.observations[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.Report
 */
export const Report = new Report$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportToSign$Type extends MessageType<ReportToSign> {
    constructor() {
        super("injective.ocr.v1beta1.ReportToSign", [
            { no: 1, name: "config_digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "epoch", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "round", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "extra_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "report", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ReportToSign>): ReportToSign {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configDigest = new Uint8Array(0);
        message.epoch = 0n;
        message.round = 0n;
        message.extraHash = new Uint8Array(0);
        message.report = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ReportToSign>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportToSign): ReportToSign {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes config_digest */ 1:
                    message.configDigest = reader.bytes();
                    break;
                case /* uint64 epoch */ 2:
                    message.epoch = reader.uint64().toBigInt();
                    break;
                case /* uint64 round */ 3:
                    message.round = reader.uint64().toBigInt();
                    break;
                case /* bytes extra_hash */ 4:
                    message.extraHash = reader.bytes();
                    break;
                case /* bytes report */ 5:
                    message.report = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportToSign, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes config_digest = 1; */
        if (message.configDigest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.configDigest);
        /* uint64 epoch = 2; */
        if (message.epoch !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.epoch);
        /* uint64 round = 3; */
        if (message.round !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.round);
        /* bytes extra_hash = 4; */
        if (message.extraHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.extraHash);
        /* bytes report = 5; */
        if (message.report.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.report);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.ReportToSign
 */
export const ReportToSign = new ReportToSign$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventOraclePaid$Type extends MessageType<EventOraclePaid> {
    constructor() {
        super("injective.ocr.v1beta1.EventOraclePaid", [
            { no: 1, name: "transmitter_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "payee_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EventOraclePaid>): EventOraclePaid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transmitterAddr = "";
        message.payeeAddr = "";
        if (value !== undefined)
            reflectionMergePartial<EventOraclePaid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventOraclePaid): EventOraclePaid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string transmitter_addr */ 1:
                    message.transmitterAddr = reader.string();
                    break;
                case /* string payee_addr */ 2:
                    message.payeeAddr = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventOraclePaid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string transmitter_addr = 1; */
        if (message.transmitterAddr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.transmitterAddr);
        /* string payee_addr = 2; */
        if (message.payeeAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.payeeAddr);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.EventOraclePaid
 */
export const EventOraclePaid = new EventOraclePaid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAnswerUpdated$Type extends MessageType<EventAnswerUpdated> {
    constructor() {
        super("injective.ocr.v1beta1.EventAnswerUpdated", [
            { no: 1, name: "current", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 2, name: "round_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 3, name: "updated_at", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<EventAnswerUpdated>): EventAnswerUpdated {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.current = "";
        message.roundId = "";
        if (value !== undefined)
            reflectionMergePartial<EventAnswerUpdated>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAnswerUpdated): EventAnswerUpdated {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string current */ 1:
                    message.current = reader.string();
                    break;
                case /* string round_id */ 2:
                    message.roundId = reader.string();
                    break;
                case /* google.protobuf.Timestamp updated_at */ 3:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAnswerUpdated, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string current = 1; */
        if (message.current !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.current);
        /* string round_id = 2; */
        if (message.roundId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roundId);
        /* google.protobuf.Timestamp updated_at = 3; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.EventAnswerUpdated
 */
export const EventAnswerUpdated = new EventAnswerUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventNewRound$Type extends MessageType<EventNewRound> {
    constructor() {
        super("injective.ocr.v1beta1.EventNewRound", [
            { no: 1, name: "round_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 2, name: "started_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "started_at", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<EventNewRound>): EventNewRound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roundId = "";
        message.startedBy = "";
        if (value !== undefined)
            reflectionMergePartial<EventNewRound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventNewRound): EventNewRound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string round_id */ 1:
                    message.roundId = reader.string();
                    break;
                case /* string started_by */ 2:
                    message.startedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp started_at */ 3:
                    message.startedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventNewRound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string round_id = 1; */
        if (message.roundId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.roundId);
        /* string started_by = 2; */
        if (message.startedBy !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.startedBy);
        /* google.protobuf.Timestamp started_at = 3; */
        if (message.startedAt)
            Timestamp.internalBinaryWrite(message.startedAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.EventNewRound
 */
export const EventNewRound = new EventNewRound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventTransmitted$Type extends MessageType<EventTransmitted> {
    constructor() {
        super("injective.ocr.v1beta1.EventTransmitted", [
            { no: 1, name: "config_digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "epoch", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventTransmitted>): EventTransmitted {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configDigest = new Uint8Array(0);
        message.epoch = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventTransmitted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventTransmitted): EventTransmitted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes config_digest */ 1:
                    message.configDigest = reader.bytes();
                    break;
                case /* uint64 epoch */ 2:
                    message.epoch = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventTransmitted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes config_digest = 1; */
        if (message.configDigest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.configDigest);
        /* uint64 epoch = 2; */
        if (message.epoch !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.epoch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.EventTransmitted
 */
export const EventTransmitted = new EventTransmitted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventNewTransmission$Type extends MessageType<EventNewTransmission> {
    constructor() {
        super("injective.ocr.v1beta1.EventNewTransmission", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregator_round_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "answer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 4, name: "transmitter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "observations_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "observations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "observers", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "config_digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "epoch_and_round", kind: "message", T: () => EpochAndRound }
        ]);
    }
    create(value?: PartialMessage<EventNewTransmission>): EventNewTransmission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.aggregatorRoundId = 0;
        message.answer = "";
        message.transmitter = "";
        message.observationsTimestamp = 0n;
        message.observations = [];
        message.observers = new Uint8Array(0);
        message.configDigest = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<EventNewTransmission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventNewTransmission): EventNewTransmission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* uint32 aggregator_round_id */ 2:
                    message.aggregatorRoundId = reader.uint32();
                    break;
                case /* string answer */ 3:
                    message.answer = reader.string();
                    break;
                case /* string transmitter */ 4:
                    message.transmitter = reader.string();
                    break;
                case /* int64 observations_timestamp */ 5:
                    message.observationsTimestamp = reader.int64().toBigInt();
                    break;
                case /* repeated string observations */ 6:
                    message.observations.push(reader.string());
                    break;
                case /* bytes observers */ 7:
                    message.observers = reader.bytes();
                    break;
                case /* bytes config_digest */ 8:
                    message.configDigest = reader.bytes();
                    break;
                case /* injective.ocr.v1beta1.EpochAndRound epoch_and_round */ 9:
                    message.epochAndRound = EpochAndRound.internalBinaryRead(reader, reader.uint32(), options, message.epochAndRound);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventNewTransmission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* uint32 aggregator_round_id = 2; */
        if (message.aggregatorRoundId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.aggregatorRoundId);
        /* string answer = 3; */
        if (message.answer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.answer);
        /* string transmitter = 4; */
        if (message.transmitter !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.transmitter);
        /* int64 observations_timestamp = 5; */
        if (message.observationsTimestamp !== 0n)
            writer.tag(5, WireType.Varint).int64(message.observationsTimestamp);
        /* repeated string observations = 6; */
        for (let i = 0; i < message.observations.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.observations[i]);
        /* bytes observers = 7; */
        if (message.observers.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.observers);
        /* bytes config_digest = 8; */
        if (message.configDigest.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.configDigest);
        /* injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9; */
        if (message.epochAndRound)
            EpochAndRound.internalBinaryWrite(message.epochAndRound, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.EventNewTransmission
 */
export const EventNewTransmission = new EventNewTransmission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventConfigSet$Type extends MessageType<EventConfigSet> {
    constructor() {
        super("injective.ocr.v1beta1.EventConfigSet", [
            { no: 1, name: "config_digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "previous_config_block_number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "config", kind: "message", T: () => FeedConfig },
            { no: 4, name: "config_info", kind: "message", T: () => FeedConfigInfo }
        ]);
    }
    create(value?: PartialMessage<EventConfigSet>): EventConfigSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configDigest = new Uint8Array(0);
        message.previousConfigBlockNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventConfigSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventConfigSet): EventConfigSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes config_digest */ 1:
                    message.configDigest = reader.bytes();
                    break;
                case /* int64 previous_config_block_number */ 2:
                    message.previousConfigBlockNumber = reader.int64().toBigInt();
                    break;
                case /* injective.ocr.v1beta1.FeedConfig config */ 3:
                    message.config = FeedConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* injective.ocr.v1beta1.FeedConfigInfo config_info */ 4:
                    message.configInfo = FeedConfigInfo.internalBinaryRead(reader, reader.uint32(), options, message.configInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventConfigSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes config_digest = 1; */
        if (message.configDigest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.configDigest);
        /* int64 previous_config_block_number = 2; */
        if (message.previousConfigBlockNumber !== 0n)
            writer.tag(2, WireType.Varint).int64(message.previousConfigBlockNumber);
        /* injective.ocr.v1beta1.FeedConfig config = 3; */
        if (message.config)
            FeedConfig.internalBinaryWrite(message.config, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective.ocr.v1beta1.FeedConfigInfo config_info = 4; */
        if (message.configInfo)
            FeedConfigInfo.internalBinaryWrite(message.configInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.EventConfigSet
 */
export const EventConfigSet = new EventConfigSet$Type();
