// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/ocr/v1beta1/genesis.proto" (package "injective.ocr.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
import { EpochAndRound } from "./ocr_pb";
import { Transmission } from "./ocr_pb";
import { FeedConfig } from "./ocr_pb";
import { Params } from "./ocr_pb";
/**
 * GenesisState defines the OCR module's genesis state.
 *
 * @generated from protobuf message injective.ocr.v1beta1.GenesisState
 */
export interface GenesisState {
    /**
     * params defines all the parameters of related to OCR.
     *
     * @generated from protobuf field: injective.ocr.v1beta1.Params params = 1
     */
    params?: Params;
    /**
     * feed_configs stores all of the supported OCR feeds
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.FeedConfig feed_configs = 2
     */
    feedConfigs: FeedConfig[];
    /**
     * latest_epoch_and_rounds stores the latest epoch and round for each feedId
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.FeedEpochAndRound latest_epoch_and_rounds = 3
     */
    latestEpochAndRounds: FeedEpochAndRound[];
    /**
     * feed_transmissions stores the last transmission for each feed
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.FeedTransmission feed_transmissions = 4
     */
    feedTransmissions: FeedTransmission[];
    /**
     * latest_aggregator_round_ids stores the latest aggregator round ID for each
     * feedId
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs latest_aggregator_round_ids = 5
     */
    latestAggregatorRoundIds: FeedLatestAggregatorRoundIDs[];
    /**
     * reward_pools stores the reward pools
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.RewardPool reward_pools = 6
     */
    rewardPools: RewardPool[];
    /**
     * feed_observation_counts stores the feed observation counts
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.FeedCounts feed_observation_counts = 7
     */
    feedObservationCounts: FeedCounts[];
    /**
     * feed_transmission_counts stores the feed transmission counts
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.FeedCounts feed_transmission_counts = 8
     */
    feedTransmissionCounts: FeedCounts[];
    /**
     * pending_payeeships stores the pending payeeships
     *
     * @generated from protobuf field: repeated injective.ocr.v1beta1.PendingPayeeship pending_payeeships = 9
     */
    pendingPayeeships: PendingPayeeship[];
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.FeedTransmission
 */
export interface FeedTransmission {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: injective.ocr.v1beta1.Transmission transmission = 2
     */
    transmission?: Transmission;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.FeedEpochAndRound
 */
export interface FeedEpochAndRound {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: injective.ocr.v1beta1.EpochAndRound epoch_and_round = 2
     */
    epochAndRound?: EpochAndRound;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs
 */
export interface FeedLatestAggregatorRoundIDs {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: uint64 aggregator_round_id = 2
     */
    aggregatorRoundId: bigint;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.RewardPool
 */
export interface RewardPool {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 2
     */
    amount?: Coin;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.FeedCounts
 */
export interface FeedCounts {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: repeated injective.ocr.v1beta1.Count counts = 2
     */
    counts: Count[];
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.Count
 */
export interface Count {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: uint64 count = 2
     */
    count: bigint;
}
/**
 * @generated from protobuf message injective.ocr.v1beta1.PendingPayeeship
 */
export interface PendingPayeeship {
    /**
     * @generated from protobuf field: string feed_id = 1
     */
    feedId: string;
    /**
     * @generated from protobuf field: string transmitter = 2
     */
    transmitter: string;
    /**
     * @generated from protobuf field: string proposed_payee = 3
     */
    proposedPayee: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GenesisState$Type extends MessageType<GenesisState> {
    constructor() {
        super("injective.ocr.v1beta1.GenesisState", [
            { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } },
            { no: 2, name: "feed_configs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedConfig },
            { no: 3, name: "latest_epoch_and_rounds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedEpochAndRound },
            { no: 4, name: "feed_transmissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedTransmission },
            { no: 5, name: "latest_aggregator_round_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedLatestAggregatorRoundIDs },
            { no: 6, name: "reward_pools", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RewardPool },
            { no: 7, name: "feed_observation_counts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedCounts },
            { no: 8, name: "feed_transmission_counts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedCounts },
            { no: 9, name: "pending_payeeships", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PendingPayeeship }
        ]);
    }
    create(value?: PartialMessage<GenesisState>): GenesisState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedConfigs = [];
        message.latestEpochAndRounds = [];
        message.feedTransmissions = [];
        message.latestAggregatorRoundIds = [];
        message.rewardPools = [];
        message.feedObservationCounts = [];
        message.feedTransmissionCounts = [];
        message.pendingPayeeships = [];
        if (value !== undefined)
            reflectionMergePartial<GenesisState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenesisState): GenesisState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.ocr.v1beta1.Params params */ 1:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* repeated injective.ocr.v1beta1.FeedConfig feed_configs */ 2:
                    message.feedConfigs.push(FeedConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.ocr.v1beta1.FeedEpochAndRound latest_epoch_and_rounds */ 3:
                    message.latestEpochAndRounds.push(FeedEpochAndRound.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.ocr.v1beta1.FeedTransmission feed_transmissions */ 4:
                    message.feedTransmissions.push(FeedTransmission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs latest_aggregator_round_ids */ 5:
                    message.latestAggregatorRoundIds.push(FeedLatestAggregatorRoundIDs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.ocr.v1beta1.RewardPool reward_pools */ 6:
                    message.rewardPools.push(RewardPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.ocr.v1beta1.FeedCounts feed_observation_counts */ 7:
                    message.feedObservationCounts.push(FeedCounts.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.ocr.v1beta1.FeedCounts feed_transmission_counts */ 8:
                    message.feedTransmissionCounts.push(FeedCounts.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.ocr.v1beta1.PendingPayeeship pending_payeeships */ 9:
                    message.pendingPayeeships.push(PendingPayeeship.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenesisState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.ocr.v1beta1.Params params = 1; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.FeedConfig feed_configs = 2; */
        for (let i = 0; i < message.feedConfigs.length; i++)
            FeedConfig.internalBinaryWrite(message.feedConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.FeedEpochAndRound latest_epoch_and_rounds = 3; */
        for (let i = 0; i < message.latestEpochAndRounds.length; i++)
            FeedEpochAndRound.internalBinaryWrite(message.latestEpochAndRounds[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.FeedTransmission feed_transmissions = 4; */
        for (let i = 0; i < message.feedTransmissions.length; i++)
            FeedTransmission.internalBinaryWrite(message.feedTransmissions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs latest_aggregator_round_ids = 5; */
        for (let i = 0; i < message.latestAggregatorRoundIds.length; i++)
            FeedLatestAggregatorRoundIDs.internalBinaryWrite(message.latestAggregatorRoundIds[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.RewardPool reward_pools = 6; */
        for (let i = 0; i < message.rewardPools.length; i++)
            RewardPool.internalBinaryWrite(message.rewardPools[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.FeedCounts feed_observation_counts = 7; */
        for (let i = 0; i < message.feedObservationCounts.length; i++)
            FeedCounts.internalBinaryWrite(message.feedObservationCounts[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.FeedCounts feed_transmission_counts = 8; */
        for (let i = 0; i < message.feedTransmissionCounts.length; i++)
            FeedCounts.internalBinaryWrite(message.feedTransmissionCounts[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.ocr.v1beta1.PendingPayeeship pending_payeeships = 9; */
        for (let i = 0; i < message.pendingPayeeships.length; i++)
            PendingPayeeship.internalBinaryWrite(message.pendingPayeeships[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.GenesisState
 */
export const GenesisState = new GenesisState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedTransmission$Type extends MessageType<FeedTransmission> {
    constructor() {
        super("injective.ocr.v1beta1.FeedTransmission", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transmission", kind: "message", T: () => Transmission }
        ]);
    }
    create(value?: PartialMessage<FeedTransmission>): FeedTransmission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        if (value !== undefined)
            reflectionMergePartial<FeedTransmission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedTransmission): FeedTransmission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* injective.ocr.v1beta1.Transmission transmission */ 2:
                    message.transmission = Transmission.internalBinaryRead(reader, reader.uint32(), options, message.transmission);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedTransmission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* injective.ocr.v1beta1.Transmission transmission = 2; */
        if (message.transmission)
            Transmission.internalBinaryWrite(message.transmission, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.FeedTransmission
 */
export const FeedTransmission = new FeedTransmission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedEpochAndRound$Type extends MessageType<FeedEpochAndRound> {
    constructor() {
        super("injective.ocr.v1beta1.FeedEpochAndRound", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "epoch_and_round", kind: "message", T: () => EpochAndRound }
        ]);
    }
    create(value?: PartialMessage<FeedEpochAndRound>): FeedEpochAndRound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        if (value !== undefined)
            reflectionMergePartial<FeedEpochAndRound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedEpochAndRound): FeedEpochAndRound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* injective.ocr.v1beta1.EpochAndRound epoch_and_round */ 2:
                    message.epochAndRound = EpochAndRound.internalBinaryRead(reader, reader.uint32(), options, message.epochAndRound);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedEpochAndRound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* injective.ocr.v1beta1.EpochAndRound epoch_and_round = 2; */
        if (message.epochAndRound)
            EpochAndRound.internalBinaryWrite(message.epochAndRound, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.FeedEpochAndRound
 */
export const FeedEpochAndRound = new FeedEpochAndRound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedLatestAggregatorRoundIDs$Type extends MessageType<FeedLatestAggregatorRoundIDs> {
    constructor() {
        super("injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregator_round_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FeedLatestAggregatorRoundIDs>): FeedLatestAggregatorRoundIDs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.aggregatorRoundId = 0n;
        if (value !== undefined)
            reflectionMergePartial<FeedLatestAggregatorRoundIDs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedLatestAggregatorRoundIDs): FeedLatestAggregatorRoundIDs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* uint64 aggregator_round_id */ 2:
                    message.aggregatorRoundId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedLatestAggregatorRoundIDs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* uint64 aggregator_round_id = 2; */
        if (message.aggregatorRoundId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.aggregatorRoundId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs
 */
export const FeedLatestAggregatorRoundIDs = new FeedLatestAggregatorRoundIDs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardPool$Type extends MessageType<RewardPool> {
    constructor() {
        super("injective.ocr.v1beta1.RewardPool", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<RewardPool>): RewardPool {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        if (value !== undefined)
            reflectionMergePartial<RewardPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardPool): RewardPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 2:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* cosmos.base.v1beta1.Coin amount = 2; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.RewardPool
 */
export const RewardPool = new RewardPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedCounts$Type extends MessageType<FeedCounts> {
    constructor() {
        super("injective.ocr.v1beta1.FeedCounts", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "counts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Count }
        ]);
    }
    create(value?: PartialMessage<FeedCounts>): FeedCounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.counts = [];
        if (value !== undefined)
            reflectionMergePartial<FeedCounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedCounts): FeedCounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* repeated injective.ocr.v1beta1.Count counts */ 2:
                    message.counts.push(Count.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedCounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* repeated injective.ocr.v1beta1.Count counts = 2; */
        for (let i = 0; i < message.counts.length; i++)
            Count.internalBinaryWrite(message.counts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.FeedCounts
 */
export const FeedCounts = new FeedCounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Count$Type extends MessageType<Count> {
    constructor() {
        super("injective.ocr.v1beta1.Count", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Count>): Count {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<Count>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Count): Count {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* uint64 count */ 2:
                    message.count = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Count, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* uint64 count = 2; */
        if (message.count !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.Count
 */
export const Count = new Count$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingPayeeship$Type extends MessageType<PendingPayeeship> {
    constructor() {
        super("injective.ocr.v1beta1.PendingPayeeship", [
            { no: 1, name: "feed_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transmitter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "proposed_payee", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PendingPayeeship>): PendingPayeeship {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feedId = "";
        message.transmitter = "";
        message.proposedPayee = "";
        if (value !== undefined)
            reflectionMergePartial<PendingPayeeship>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingPayeeship): PendingPayeeship {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feed_id */ 1:
                    message.feedId = reader.string();
                    break;
                case /* string transmitter */ 2:
                    message.transmitter = reader.string();
                    break;
                case /* string proposed_payee */ 3:
                    message.proposedPayee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingPayeeship, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feed_id = 1; */
        if (message.feedId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feedId);
        /* string transmitter = 2; */
        if (message.transmitter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.transmitter);
        /* string proposed_payee = 3; */
        if (message.proposedPayee !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.proposedPayee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.ocr.v1beta1.PendingPayeeship
 */
export const PendingPayeeship = new PendingPayeeship$Type();
