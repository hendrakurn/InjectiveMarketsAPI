// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/stream/v1beta1/query.proto" (package "injective.stream.v1beta1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PositionDelta } from "../../exchange/v1beta1/exchange_pb";
import { DerivativeLimitOrder } from "../../exchange/v1beta1/exchange_pb";
import { SpotLimitOrder } from "../../exchange/v1beta1/exchange_pb";
import { Deposit } from "../../exchange/v1beta1/exchange_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
import { Level } from "../../exchange/v1beta1/exchange_pb";
/**
 * @generated from protobuf message injective.stream.v1beta1.StreamRequest
 */
export interface StreamRequest {
    /**
     * filter for bank balances events
     *
     * @generated from protobuf field: injective.stream.v1beta1.BankBalancesFilter bank_balances_filter = 1
     */
    bankBalancesFilter?: BankBalancesFilter;
    /**
     * filter for subaccount deposits events
     *
     * @generated from protobuf field: injective.stream.v1beta1.SubaccountDepositsFilter subaccount_deposits_filter = 2
     */
    subaccountDepositsFilter?: SubaccountDepositsFilter;
    /**
     * filter for spot trades events
     *
     * @generated from protobuf field: injective.stream.v1beta1.TradesFilter spot_trades_filter = 3
     */
    spotTradesFilter?: TradesFilter;
    /**
     * filter for derivative trades events
     *
     * @generated from protobuf field: injective.stream.v1beta1.TradesFilter derivative_trades_filter = 4
     */
    derivativeTradesFilter?: TradesFilter;
    /**
     * filter for spot orders events
     *
     * @generated from protobuf field: injective.stream.v1beta1.OrdersFilter spot_orders_filter = 5
     */
    spotOrdersFilter?: OrdersFilter;
    /**
     * filter for derivative orders events
     *
     * @generated from protobuf field: injective.stream.v1beta1.OrdersFilter derivative_orders_filter = 6
     */
    derivativeOrdersFilter?: OrdersFilter;
    /**
     * filter for spot orderbooks events
     *
     * @generated from protobuf field: injective.stream.v1beta1.OrderbookFilter spot_orderbooks_filter = 7
     */
    spotOrderbooksFilter?: OrderbookFilter;
    /**
     * filter for derivative orderbooks events
     *
     * @generated from protobuf field: injective.stream.v1beta1.OrderbookFilter derivative_orderbooks_filter = 8
     */
    derivativeOrderbooksFilter?: OrderbookFilter;
    /**
     * filter for positions events
     *
     * @generated from protobuf field: injective.stream.v1beta1.PositionsFilter positions_filter = 9
     */
    positionsFilter?: PositionsFilter;
    /**
     * filter for oracle prices events
     *
     * @generated from protobuf field: injective.stream.v1beta1.OraclePriceFilter oracle_price_filter = 10
     */
    oraclePriceFilter?: OraclePriceFilter;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.StreamResponse
 */
export interface StreamResponse {
    /**
     * @generated from protobuf field: uint64 block_height = 1
     */
    blockHeight: bigint;
    /**
     * @generated from protobuf field: int64 block_time = 2
     */
    blockTime: bigint;
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.BankBalance bank_balances = 3
     */
    bankBalances: BankBalance[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.SubaccountDeposits subaccount_deposits = 4
     */
    subaccountDeposits: SubaccountDeposits[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.SpotTrade spot_trades = 5
     */
    spotTrades: SpotTrade[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.DerivativeTrade derivative_trades = 6
     */
    derivativeTrades: DerivativeTrade[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.SpotOrderUpdate spot_orders = 7
     */
    spotOrders: SpotOrderUpdate[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.DerivativeOrderUpdate derivative_orders = 8
     */
    derivativeOrders: DerivativeOrderUpdate[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.OrderbookUpdate spot_orderbook_updates = 9
     */
    spotOrderbookUpdates: OrderbookUpdate[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.OrderbookUpdate derivative_orderbook_updates = 10
     */
    derivativeOrderbookUpdates: OrderbookUpdate[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.Position positions = 11
     */
    positions: Position[];
    /**
     * @generated from protobuf field: repeated injective.stream.v1beta1.OraclePrice oracle_prices = 12
     */
    oraclePrices: OraclePrice[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.OrderbookUpdate
 */
export interface OrderbookUpdate {
    /**
     * @generated from protobuf field: uint64 seq = 1
     */
    seq: bigint;
    /**
     * @generated from protobuf field: injective.stream.v1beta1.Orderbook orderbook = 2
     */
    orderbook?: Orderbook;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.Orderbook
 */
export interface Orderbook {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.Level buy_levels = 2
     */
    buyLevels: Level[];
    /**
     * @generated from protobuf field: repeated injective.exchange.v1beta1.Level sell_levels = 3
     */
    sellLevels: Level[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.BankBalance
 */
export interface BankBalance {
    /**
     * @generated from protobuf field: string account = 1
     */
    account: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin balances = 2
     */
    balances: Coin[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.SubaccountDeposits
 */
export interface SubaccountDeposits {
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * the deposits details
     *
     * @generated from protobuf field: repeated injective.stream.v1beta1.SubaccountDeposit deposits = 2
     */
    deposits: SubaccountDeposit[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.SubaccountDeposit
 */
export interface SubaccountDeposit {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.Deposit deposit = 2
     */
    deposit?: Deposit;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.SpotOrderUpdate
 */
export interface SpotOrderUpdate {
    /**
     * @generated from protobuf field: injective.stream.v1beta1.OrderUpdateStatus status = 1
     */
    status: OrderUpdateStatus;
    /**
     * @generated from protobuf field: string order_hash = 2
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
    /**
     * @generated from protobuf field: injective.stream.v1beta1.SpotOrder order = 4
     */
    order?: SpotOrder;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.SpotOrder
 */
export interface SpotOrder {
    /**
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.SpotLimitOrder order = 2
     */
    order?: SpotLimitOrder;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.DerivativeOrderUpdate
 */
export interface DerivativeOrderUpdate {
    /**
     * @generated from protobuf field: injective.stream.v1beta1.OrderUpdateStatus status = 1
     */
    status: OrderUpdateStatus;
    /**
     * @generated from protobuf field: string order_hash = 2
     */
    orderHash: string;
    /**
     * @generated from protobuf field: string cid = 3
     */
    cid: string;
    /**
     * @generated from protobuf field: injective.stream.v1beta1.DerivativeOrder order = 4
     */
    order?: DerivativeOrder;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.DerivativeOrder
 */
export interface DerivativeOrder {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the derivative order details
     *
     * @generated from protobuf field: injective.exchange.v1beta1.DerivativeLimitOrder order = 2
     */
    order?: DerivativeLimitOrder;
    /**
     * whether the order is a market order
     *
     * @generated from protobuf field: bool is_market = 3
     */
    isMarket: boolean;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.Position
 */
export interface Position {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 2
     */
    subaccountId: string;
    /**
     * whether the position is long or short
     *
     * @generated from protobuf field: bool isLong = 3
     */
    isLong: boolean;
    /**
     * the quantity of the position
     *
     * @generated from protobuf field: string quantity = 4
     */
    quantity: string;
    /**
     * the entry price of the position
     *
     * @generated from protobuf field: string entry_price = 5
     */
    entryPrice: string;
    /**
     * the margin of the position
     *
     * @generated from protobuf field: string margin = 6
     */
    margin: string;
    /**
     * the cumulative funding entry of the position
     *
     * @generated from protobuf field: string cumulative_funding_entry = 7
     */
    cumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.OraclePrice
 */
export interface OraclePrice {
    /**
     * @generated from protobuf field: string symbol = 1
     */
    symbol: string;
    /**
     * @generated from protobuf field: string price = 2
     */
    price: string;
    /**
     * @generated from protobuf field: string type = 3
     */
    type: string;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.SpotTrade
 */
export interface SpotTrade {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * whether the trade is a buy or sell
     *
     * @generated from protobuf field: bool is_buy = 2
     */
    isBuy: boolean;
    /**
     * the execution type
     *
     * @generated from protobuf field: string executionType = 3
     */
    executionType: string;
    /**
     * the quantity of the trade
     *
     * @generated from protobuf field: string quantity = 4
     */
    quantity: string;
    /**
     * the price of the trade
     *
     * @generated from protobuf field: string price = 5
     */
    price: string;
    /**
     * the subaccount ID that executed the trade
     *
     * @generated from protobuf field: string subaccount_id = 6
     */
    subaccountId: string;
    /**
     * the fee of the trade
     *
     * @generated from protobuf field: string fee = 7
     */
    fee: string;
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 8
     */
    orderHash: string;
    /**
     * the fee recipient address
     *
     * @generated from protobuf field: string fee_recipient_address = 9
     */
    feeRecipientAddress: string;
    /**
     * the client order ID
     *
     * @generated from protobuf field: string cid = 10
     */
    cid: string;
    /**
     * the trade ID
     *
     * @generated from protobuf field: string trade_id = 11
     */
    tradeId: string;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.DerivativeTrade
 */
export interface DerivativeTrade {
    /**
     * the market ID
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * whether the trade is a buy or sell
     *
     * @generated from protobuf field: bool is_buy = 2
     */
    isBuy: boolean;
    /**
     * the execution type
     *
     * @generated from protobuf field: string executionType = 3
     */
    executionType: string;
    /**
     * the subaccount ID
     *
     * @generated from protobuf field: string subaccount_id = 4
     */
    subaccountId: string;
    /**
     * the position delta of the trade
     *
     * @generated from protobuf field: injective.exchange.v1beta1.PositionDelta position_delta = 5
     */
    positionDelta?: PositionDelta;
    /**
     * the payout of the trade
     *
     * @generated from protobuf field: string payout = 6
     */
    payout: string;
    /**
     * the fee of the trade
     *
     * @generated from protobuf field: string fee = 7
     */
    fee: string;
    /**
     * the order hash
     *
     * @generated from protobuf field: string order_hash = 8
     */
    orderHash: string;
    /**
     * the fee recipient address
     *
     * @generated from protobuf field: string fee_recipient_address = 9
     */
    feeRecipientAddress: string;
    /**
     * the client order ID
     *
     * @generated from protobuf field: string cid = 10
     */
    cid: string;
    /**
     * the trade ID
     *
     * @generated from protobuf field: string trade_id = 11
     */
    tradeId: string;
}
/**
 * @generated from protobuf message injective.stream.v1beta1.TradesFilter
 */
export interface TradesFilter {
    /**
     * @generated from protobuf field: repeated string subaccount_ids = 1
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string market_ids = 2
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.PositionsFilter
 */
export interface PositionsFilter {
    /**
     * @generated from protobuf field: repeated string subaccount_ids = 1
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string market_ids = 2
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.OrdersFilter
 */
export interface OrdersFilter {
    /**
     * @generated from protobuf field: repeated string subaccount_ids = 1
     */
    subaccountIds: string[];
    /**
     * @generated from protobuf field: repeated string market_ids = 2
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.OrderbookFilter
 */
export interface OrderbookFilter {
    /**
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.BankBalancesFilter
 */
export interface BankBalancesFilter {
    /**
     * @generated from protobuf field: repeated string accounts = 1
     */
    accounts: string[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.SubaccountDepositsFilter
 */
export interface SubaccountDepositsFilter {
    /**
     * @generated from protobuf field: repeated string subaccount_ids = 1
     */
    subaccountIds: string[];
}
/**
 * @generated from protobuf message injective.stream.v1beta1.OraclePriceFilter
 */
export interface OraclePriceFilter {
    /**
     * @generated from protobuf field: repeated string symbol = 1
     */
    symbol: string[];
}
/**
 * @generated from protobuf enum injective.stream.v1beta1.OrderUpdateStatus
 */
export enum OrderUpdateStatus {
    /**
     * @generated from protobuf enum value: Unspecified = 0;
     */
    Unspecified = 0,
    /**
     * @generated from protobuf enum value: Booked = 1;
     */
    Booked = 1,
    /**
     * @generated from protobuf enum value: Matched = 2;
     */
    Matched = 2,
    /**
     * @generated from protobuf enum value: Cancelled = 3;
     */
    Cancelled = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class StreamRequest$Type extends MessageType<StreamRequest> {
    constructor() {
        super("injective.stream.v1beta1.StreamRequest", [
            { no: 1, name: "bank_balances_filter", kind: "message", T: () => BankBalancesFilter, options: { "gogoproto.nullable": true } },
            { no: 2, name: "subaccount_deposits_filter", kind: "message", T: () => SubaccountDepositsFilter, options: { "gogoproto.nullable": true } },
            { no: 3, name: "spot_trades_filter", kind: "message", T: () => TradesFilter, options: { "gogoproto.nullable": true } },
            { no: 4, name: "derivative_trades_filter", kind: "message", T: () => TradesFilter, options: { "gogoproto.nullable": true } },
            { no: 5, name: "spot_orders_filter", kind: "message", T: () => OrdersFilter, options: { "gogoproto.nullable": true } },
            { no: 6, name: "derivative_orders_filter", kind: "message", T: () => OrdersFilter, options: { "gogoproto.nullable": true } },
            { no: 7, name: "spot_orderbooks_filter", kind: "message", T: () => OrderbookFilter, options: { "gogoproto.nullable": true } },
            { no: 8, name: "derivative_orderbooks_filter", kind: "message", T: () => OrderbookFilter, options: { "gogoproto.nullable": true } },
            { no: 9, name: "positions_filter", kind: "message", T: () => PositionsFilter, options: { "gogoproto.nullable": true } },
            { no: 10, name: "oracle_price_filter", kind: "message", T: () => OraclePriceFilter, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<StreamRequest>): StreamRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamRequest): StreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.stream.v1beta1.BankBalancesFilter bank_balances_filter */ 1:
                    message.bankBalancesFilter = BankBalancesFilter.internalBinaryRead(reader, reader.uint32(), options, message.bankBalancesFilter);
                    break;
                case /* injective.stream.v1beta1.SubaccountDepositsFilter subaccount_deposits_filter */ 2:
                    message.subaccountDepositsFilter = SubaccountDepositsFilter.internalBinaryRead(reader, reader.uint32(), options, message.subaccountDepositsFilter);
                    break;
                case /* injective.stream.v1beta1.TradesFilter spot_trades_filter */ 3:
                    message.spotTradesFilter = TradesFilter.internalBinaryRead(reader, reader.uint32(), options, message.spotTradesFilter);
                    break;
                case /* injective.stream.v1beta1.TradesFilter derivative_trades_filter */ 4:
                    message.derivativeTradesFilter = TradesFilter.internalBinaryRead(reader, reader.uint32(), options, message.derivativeTradesFilter);
                    break;
                case /* injective.stream.v1beta1.OrdersFilter spot_orders_filter */ 5:
                    message.spotOrdersFilter = OrdersFilter.internalBinaryRead(reader, reader.uint32(), options, message.spotOrdersFilter);
                    break;
                case /* injective.stream.v1beta1.OrdersFilter derivative_orders_filter */ 6:
                    message.derivativeOrdersFilter = OrdersFilter.internalBinaryRead(reader, reader.uint32(), options, message.derivativeOrdersFilter);
                    break;
                case /* injective.stream.v1beta1.OrderbookFilter spot_orderbooks_filter */ 7:
                    message.spotOrderbooksFilter = OrderbookFilter.internalBinaryRead(reader, reader.uint32(), options, message.spotOrderbooksFilter);
                    break;
                case /* injective.stream.v1beta1.OrderbookFilter derivative_orderbooks_filter */ 8:
                    message.derivativeOrderbooksFilter = OrderbookFilter.internalBinaryRead(reader, reader.uint32(), options, message.derivativeOrderbooksFilter);
                    break;
                case /* injective.stream.v1beta1.PositionsFilter positions_filter */ 9:
                    message.positionsFilter = PositionsFilter.internalBinaryRead(reader, reader.uint32(), options, message.positionsFilter);
                    break;
                case /* injective.stream.v1beta1.OraclePriceFilter oracle_price_filter */ 10:
                    message.oraclePriceFilter = OraclePriceFilter.internalBinaryRead(reader, reader.uint32(), options, message.oraclePriceFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.stream.v1beta1.BankBalancesFilter bank_balances_filter = 1; */
        if (message.bankBalancesFilter)
            BankBalancesFilter.internalBinaryWrite(message.bankBalancesFilter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.SubaccountDepositsFilter subaccount_deposits_filter = 2; */
        if (message.subaccountDepositsFilter)
            SubaccountDepositsFilter.internalBinaryWrite(message.subaccountDepositsFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.TradesFilter spot_trades_filter = 3; */
        if (message.spotTradesFilter)
            TradesFilter.internalBinaryWrite(message.spotTradesFilter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.TradesFilter derivative_trades_filter = 4; */
        if (message.derivativeTradesFilter)
            TradesFilter.internalBinaryWrite(message.derivativeTradesFilter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.OrdersFilter spot_orders_filter = 5; */
        if (message.spotOrdersFilter)
            OrdersFilter.internalBinaryWrite(message.spotOrdersFilter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.OrdersFilter derivative_orders_filter = 6; */
        if (message.derivativeOrdersFilter)
            OrdersFilter.internalBinaryWrite(message.derivativeOrdersFilter, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.OrderbookFilter spot_orderbooks_filter = 7; */
        if (message.spotOrderbooksFilter)
            OrderbookFilter.internalBinaryWrite(message.spotOrderbooksFilter, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.OrderbookFilter derivative_orderbooks_filter = 8; */
        if (message.derivativeOrderbooksFilter)
            OrderbookFilter.internalBinaryWrite(message.derivativeOrderbooksFilter, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.PositionsFilter positions_filter = 9; */
        if (message.positionsFilter)
            PositionsFilter.internalBinaryWrite(message.positionsFilter, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* injective.stream.v1beta1.OraclePriceFilter oracle_price_filter = 10; */
        if (message.oraclePriceFilter)
            OraclePriceFilter.internalBinaryWrite(message.oraclePriceFilter, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.StreamRequest
 */
export const StreamRequest = new StreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamResponse$Type extends MessageType<StreamResponse> {
    constructor() {
        super("injective.stream.v1beta1.StreamResponse", [
            { no: 1, name: "block_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "block_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "bank_balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BankBalance },
            { no: 4, name: "subaccount_deposits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountDeposits },
            { no: 5, name: "spot_trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotTrade },
            { no: 6, name: "derivative_trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeTrade },
            { no: 7, name: "spot_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpotOrderUpdate },
            { no: 8, name: "derivative_orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DerivativeOrderUpdate },
            { no: 9, name: "spot_orderbook_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderbookUpdate },
            { no: 10, name: "derivative_orderbook_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderbookUpdate },
            { no: 11, name: "positions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Position },
            { no: 12, name: "oracle_prices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OraclePrice }
        ]);
    }
    create(value?: PartialMessage<StreamResponse>): StreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blockHeight = 0n;
        message.blockTime = 0n;
        message.bankBalances = [];
        message.subaccountDeposits = [];
        message.spotTrades = [];
        message.derivativeTrades = [];
        message.spotOrders = [];
        message.derivativeOrders = [];
        message.spotOrderbookUpdates = [];
        message.derivativeOrderbookUpdates = [];
        message.positions = [];
        message.oraclePrices = [];
        if (value !== undefined)
            reflectionMergePartial<StreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamResponse): StreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 block_height */ 1:
                    message.blockHeight = reader.uint64().toBigInt();
                    break;
                case /* int64 block_time */ 2:
                    message.blockTime = reader.int64().toBigInt();
                    break;
                case /* repeated injective.stream.v1beta1.BankBalance bank_balances */ 3:
                    message.bankBalances.push(BankBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.SubaccountDeposits subaccount_deposits */ 4:
                    message.subaccountDeposits.push(SubaccountDeposits.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.SpotTrade spot_trades */ 5:
                    message.spotTrades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.DerivativeTrade derivative_trades */ 6:
                    message.derivativeTrades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.SpotOrderUpdate spot_orders */ 7:
                    message.spotOrders.push(SpotOrderUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.DerivativeOrderUpdate derivative_orders */ 8:
                    message.derivativeOrders.push(DerivativeOrderUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.OrderbookUpdate spot_orderbook_updates */ 9:
                    message.spotOrderbookUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.OrderbookUpdate derivative_orderbook_updates */ 10:
                    message.derivativeOrderbookUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.Position positions */ 11:
                    message.positions.push(Position.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.stream.v1beta1.OraclePrice oracle_prices */ 12:
                    message.oraclePrices.push(OraclePrice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 block_height = 1; */
        if (message.blockHeight !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.blockHeight);
        /* int64 block_time = 2; */
        if (message.blockTime !== 0n)
            writer.tag(2, WireType.Varint).int64(message.blockTime);
        /* repeated injective.stream.v1beta1.BankBalance bank_balances = 3; */
        for (let i = 0; i < message.bankBalances.length; i++)
            BankBalance.internalBinaryWrite(message.bankBalances[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.SubaccountDeposits subaccount_deposits = 4; */
        for (let i = 0; i < message.subaccountDeposits.length; i++)
            SubaccountDeposits.internalBinaryWrite(message.subaccountDeposits[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.SpotTrade spot_trades = 5; */
        for (let i = 0; i < message.spotTrades.length; i++)
            SpotTrade.internalBinaryWrite(message.spotTrades[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.DerivativeTrade derivative_trades = 6; */
        for (let i = 0; i < message.derivativeTrades.length; i++)
            DerivativeTrade.internalBinaryWrite(message.derivativeTrades[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.SpotOrderUpdate spot_orders = 7; */
        for (let i = 0; i < message.spotOrders.length; i++)
            SpotOrderUpdate.internalBinaryWrite(message.spotOrders[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.DerivativeOrderUpdate derivative_orders = 8; */
        for (let i = 0; i < message.derivativeOrders.length; i++)
            DerivativeOrderUpdate.internalBinaryWrite(message.derivativeOrders[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.OrderbookUpdate spot_orderbook_updates = 9; */
        for (let i = 0; i < message.spotOrderbookUpdates.length; i++)
            OrderbookUpdate.internalBinaryWrite(message.spotOrderbookUpdates[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.OrderbookUpdate derivative_orderbook_updates = 10; */
        for (let i = 0; i < message.derivativeOrderbookUpdates.length; i++)
            OrderbookUpdate.internalBinaryWrite(message.derivativeOrderbookUpdates[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.Position positions = 11; */
        for (let i = 0; i < message.positions.length; i++)
            Position.internalBinaryWrite(message.positions[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.stream.v1beta1.OraclePrice oracle_prices = 12; */
        for (let i = 0; i < message.oraclePrices.length; i++)
            OraclePrice.internalBinaryWrite(message.oraclePrices[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.StreamResponse
 */
export const StreamResponse = new StreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookUpdate$Type extends MessageType<OrderbookUpdate> {
    constructor() {
        super("injective.stream.v1beta1.OrderbookUpdate", [
            { no: 1, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "orderbook", kind: "message", T: () => Orderbook }
        ]);
    }
    create(value?: PartialMessage<OrderbookUpdate>): OrderbookUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seq = 0n;
        if (value !== undefined)
            reflectionMergePartial<OrderbookUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookUpdate): OrderbookUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 seq */ 1:
                    message.seq = reader.uint64().toBigInt();
                    break;
                case /* injective.stream.v1beta1.Orderbook orderbook */ 2:
                    message.orderbook = Orderbook.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 seq = 1; */
        if (message.seq !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.seq);
        /* injective.stream.v1beta1.Orderbook orderbook = 2; */
        if (message.orderbook)
            Orderbook.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.OrderbookUpdate
 */
export const OrderbookUpdate = new OrderbookUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Orderbook$Type extends MessageType<Orderbook> {
    constructor() {
        super("injective.stream.v1beta1.Orderbook", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "buy_levels", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level },
            { no: 3, name: "sell_levels", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Level }
        ]);
    }
    create(value?: PartialMessage<Orderbook>): Orderbook {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.buyLevels = [];
        message.sellLevels = [];
        if (value !== undefined)
            reflectionMergePartial<Orderbook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Orderbook): Orderbook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* repeated injective.exchange.v1beta1.Level buy_levels */ 2:
                    message.buyLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.exchange.v1beta1.Level sell_levels */ 3:
                    message.sellLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Orderbook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* repeated injective.exchange.v1beta1.Level buy_levels = 2; */
        for (let i = 0; i < message.buyLevels.length; i++)
            Level.internalBinaryWrite(message.buyLevels[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.exchange.v1beta1.Level sell_levels = 3; */
        for (let i = 0; i < message.sellLevels.length; i++)
            Level.internalBinaryWrite(message.sellLevels[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.Orderbook
 */
export const Orderbook = new Orderbook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BankBalance$Type extends MessageType<BankBalance> {
    constructor() {
        super("injective.stream.v1beta1.BankBalance", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<BankBalance>): BankBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account = "";
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<BankBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BankBalance): BankBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin balances */ 2:
                    message.balances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BankBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* repeated cosmos.base.v1beta1.Coin balances = 2; */
        for (let i = 0; i < message.balances.length; i++)
            Coin.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.BankBalance
 */
export const BankBalance = new BankBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountDeposits$Type extends MessageType<SubaccountDeposits> {
    constructor() {
        super("injective.stream.v1beta1.SubaccountDeposits", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deposits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubaccountDeposit, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<SubaccountDeposits>): SubaccountDeposits {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.deposits = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountDeposits>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountDeposits): SubaccountDeposits {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated injective.stream.v1beta1.SubaccountDeposit deposits */ 2:
                    message.deposits.push(SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountDeposits, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated injective.stream.v1beta1.SubaccountDeposit deposits = 2; */
        for (let i = 0; i < message.deposits.length; i++)
            SubaccountDeposit.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.SubaccountDeposits
 */
export const SubaccountDeposits = new SubaccountDeposits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountDeposit$Type extends MessageType<SubaccountDeposit> {
    constructor() {
        super("injective.stream.v1beta1.SubaccountDeposit", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deposit", kind: "message", T: () => Deposit, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<SubaccountDeposit>): SubaccountDeposit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<SubaccountDeposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountDeposit): SubaccountDeposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* injective.exchange.v1beta1.Deposit deposit */ 2:
                    message.deposit = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* injective.exchange.v1beta1.Deposit deposit = 2; */
        if (message.deposit)
            Deposit.internalBinaryWrite(message.deposit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.SubaccountDeposit
 */
export const SubaccountDeposit = new SubaccountDeposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotOrderUpdate$Type extends MessageType<SpotOrderUpdate> {
    constructor() {
        super("injective.stream.v1beta1.SpotOrderUpdate", [
            { no: 1, name: "status", kind: "enum", T: () => ["injective.stream.v1beta1.OrderUpdateStatus", OrderUpdateStatus] },
            { no: 2, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order", kind: "message", T: () => SpotOrder }
        ]);
    }
    create(value?: PartialMessage<SpotOrderUpdate>): SpotOrderUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<SpotOrderUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotOrderUpdate): SpotOrderUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.stream.v1beta1.OrderUpdateStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string order_hash */ 2:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                case /* injective.stream.v1beta1.SpotOrder order */ 4:
                    message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotOrderUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.stream.v1beta1.OrderUpdateStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string order_hash = 2; */
        if (message.orderHash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        /* injective.stream.v1beta1.SpotOrder order = 4; */
        if (message.order)
            SpotOrder.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.SpotOrderUpdate
 */
export const SpotOrderUpdate = new SpotOrderUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotOrder$Type extends MessageType<SpotOrder> {
    constructor() {
        super("injective.stream.v1beta1.SpotOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => SpotLimitOrder, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<SpotOrder>): SpotOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<SpotOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotOrder): SpotOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.SpotLimitOrder order */ 2:
                    message.order = SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.SpotLimitOrder order = 2; */
        if (message.order)
            SpotLimitOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.SpotOrder
 */
export const SpotOrder = new SpotOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeOrderUpdate$Type extends MessageType<DerivativeOrderUpdate> {
    constructor() {
        super("injective.stream.v1beta1.DerivativeOrderUpdate", [
            { no: 1, name: "status", kind: "enum", T: () => ["injective.stream.v1beta1.OrderUpdateStatus", OrderUpdateStatus] },
            { no: 2, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "order", kind: "message", T: () => DerivativeOrder }
        ]);
    }
    create(value?: PartialMessage<DerivativeOrderUpdate>): DerivativeOrderUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.orderHash = "";
        message.cid = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeOrderUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeOrderUpdate): DerivativeOrderUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.stream.v1beta1.OrderUpdateStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string order_hash */ 2:
                    message.orderHash = reader.string();
                    break;
                case /* string cid */ 3:
                    message.cid = reader.string();
                    break;
                case /* injective.stream.v1beta1.DerivativeOrder order */ 4:
                    message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeOrderUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.stream.v1beta1.OrderUpdateStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string order_hash = 2; */
        if (message.orderHash !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderHash);
        /* string cid = 3; */
        if (message.cid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cid);
        /* injective.stream.v1beta1.DerivativeOrder order = 4; */
        if (message.order)
            DerivativeOrder.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.DerivativeOrderUpdate
 */
export const DerivativeOrderUpdate = new DerivativeOrderUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeOrder$Type extends MessageType<DerivativeOrder> {
    constructor() {
        super("injective.stream.v1beta1.DerivativeOrder", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "message", T: () => DerivativeLimitOrder, options: { "gogoproto.nullable": false } },
            { no: 3, name: "is_market", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeOrder>): DerivativeOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isMarket = false;
        if (value !== undefined)
            reflectionMergePartial<DerivativeOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeOrder): DerivativeOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.DerivativeLimitOrder order */ 2:
                    message.order = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* bool is_market */ 3:
                    message.isMarket = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* injective.exchange.v1beta1.DerivativeLimitOrder order = 2; */
        if (message.order)
            DerivativeLimitOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool is_market = 3; */
        if (message.isMarket !== false)
            writer.tag(3, WireType.Varint).bool(message.isMarket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.DerivativeOrder
 */
export const DerivativeOrder = new DerivativeOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("injective.stream.v1beta1.Position", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "isLong", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "entry_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "cumulative_funding_entry", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.subaccountId = "";
        message.isLong = false;
        message.quantity = "";
        message.entryPrice = "";
        message.margin = "";
        message.cumulativeFundingEntry = "";
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string subaccount_id */ 2:
                    message.subaccountId = reader.string();
                    break;
                case /* bool isLong */ 3:
                    message.isLong = reader.bool();
                    break;
                case /* string quantity */ 4:
                    message.quantity = reader.string();
                    break;
                case /* string entry_price */ 5:
                    message.entryPrice = reader.string();
                    break;
                case /* string margin */ 6:
                    message.margin = reader.string();
                    break;
                case /* string cumulative_funding_entry */ 7:
                    message.cumulativeFundingEntry = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string subaccount_id = 2; */
        if (message.subaccountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
        /* bool isLong = 3; */
        if (message.isLong !== false)
            writer.tag(3, WireType.Varint).bool(message.isLong);
        /* string quantity = 4; */
        if (message.quantity !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quantity);
        /* string entry_price = 5; */
        if (message.entryPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.entryPrice);
        /* string margin = 6; */
        if (message.margin !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.margin);
        /* string cumulative_funding_entry = 7; */
        if (message.cumulativeFundingEntry !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OraclePrice$Type extends MessageType<OraclePrice> {
    constructor() {
        super("injective.stream.v1beta1.OraclePrice", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OraclePrice>): OraclePrice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = "";
        message.price = "";
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<OraclePrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OraclePrice): OraclePrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* string price */ 2:
                    message.price = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OraclePrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* string price = 2; */
        if (message.price !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.price);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.OraclePrice
 */
export const OraclePrice = new OraclePrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpotTrade$Type extends MessageType<SpotTrade> {
    constructor() {
        super("injective.stream.v1beta1.SpotTrade", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "executionType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "fee_recipient_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true } },
            { no: 10, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpotTrade>): SpotTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isBuy = false;
        message.executionType = "";
        message.quantity = "";
        message.price = "";
        message.subaccountId = "";
        message.fee = "";
        message.orderHash = "";
        message.feeRecipientAddress = "";
        message.cid = "";
        message.tradeId = "";
        if (value !== undefined)
            reflectionMergePartial<SpotTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpotTrade): SpotTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool is_buy */ 2:
                    message.isBuy = reader.bool();
                    break;
                case /* string executionType */ 3:
                    message.executionType = reader.string();
                    break;
                case /* string quantity */ 4:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 5:
                    message.price = reader.string();
                    break;
                case /* string subaccount_id */ 6:
                    message.subaccountId = reader.string();
                    break;
                case /* string fee */ 7:
                    message.fee = reader.string();
                    break;
                case /* string order_hash */ 8:
                    message.orderHash = reader.string();
                    break;
                case /* string fee_recipient_address */ 9:
                    message.feeRecipientAddress = reader.string();
                    break;
                case /* string cid */ 10:
                    message.cid = reader.string();
                    break;
                case /* string trade_id */ 11:
                    message.tradeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpotTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool is_buy = 2; */
        if (message.isBuy !== false)
            writer.tag(2, WireType.Varint).bool(message.isBuy);
        /* string executionType = 3; */
        if (message.executionType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionType);
        /* string quantity = 4; */
        if (message.quantity !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quantity);
        /* string price = 5; */
        if (message.price !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.price);
        /* string subaccount_id = 6; */
        if (message.subaccountId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.subaccountId);
        /* string fee = 7; */
        if (message.fee !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.fee);
        /* string order_hash = 8; */
        if (message.orderHash !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.orderHash);
        /* string fee_recipient_address = 9; */
        if (message.feeRecipientAddress !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feeRecipientAddress);
        /* string cid = 10; */
        if (message.cid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.cid);
        /* string trade_id = 11; */
        if (message.tradeId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.SpotTrade
 */
export const SpotTrade = new SpotTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivativeTrade$Type extends MessageType<DerivativeTrade> {
    constructor() {
        super("injective.stream.v1beta1.DerivativeTrade", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "executionType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "position_delta", kind: "message", T: () => PositionDelta },
            { no: 6, name: "payout", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 7, name: "fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 8, name: "order_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "fee_recipient_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": true } },
            { no: 10, name: "cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DerivativeTrade>): DerivativeTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.isBuy = false;
        message.executionType = "";
        message.subaccountId = "";
        message.payout = "";
        message.fee = "";
        message.orderHash = "";
        message.feeRecipientAddress = "";
        message.cid = "";
        message.tradeId = "";
        if (value !== undefined)
            reflectionMergePartial<DerivativeTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivativeTrade): DerivativeTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* bool is_buy */ 2:
                    message.isBuy = reader.bool();
                    break;
                case /* string executionType */ 3:
                    message.executionType = reader.string();
                    break;
                case /* string subaccount_id */ 4:
                    message.subaccountId = reader.string();
                    break;
                case /* injective.exchange.v1beta1.PositionDelta position_delta */ 5:
                    message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
                    break;
                case /* string payout */ 6:
                    message.payout = reader.string();
                    break;
                case /* string fee */ 7:
                    message.fee = reader.string();
                    break;
                case /* string order_hash */ 8:
                    message.orderHash = reader.string();
                    break;
                case /* string fee_recipient_address */ 9:
                    message.feeRecipientAddress = reader.string();
                    break;
                case /* string cid */ 10:
                    message.cid = reader.string();
                    break;
                case /* string trade_id */ 11:
                    message.tradeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivativeTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* bool is_buy = 2; */
        if (message.isBuy !== false)
            writer.tag(2, WireType.Varint).bool(message.isBuy);
        /* string executionType = 3; */
        if (message.executionType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.executionType);
        /* string subaccount_id = 4; */
        if (message.subaccountId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
        /* injective.exchange.v1beta1.PositionDelta position_delta = 5; */
        if (message.positionDelta)
            PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string payout = 6; */
        if (message.payout !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.payout);
        /* string fee = 7; */
        if (message.fee !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.fee);
        /* string order_hash = 8; */
        if (message.orderHash !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.orderHash);
        /* string fee_recipient_address = 9; */
        if (message.feeRecipientAddress !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.feeRecipientAddress);
        /* string cid = 10; */
        if (message.cid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.cid);
        /* string trade_id = 11; */
        if (message.tradeId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.DerivativeTrade
 */
export const DerivativeTrade = new DerivativeTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesFilter$Type extends MessageType<TradesFilter> {
    constructor() {
        super("injective.stream.v1beta1.TradesFilter", [
            { no: 1, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradesFilter>): TradesFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountIds = [];
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<TradesFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesFilter): TradesFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string subaccount_ids */ 1:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string market_ids */ 2:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string subaccount_ids = 1; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string market_ids = 2; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.TradesFilter
 */
export const TradesFilter = new TradesFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsFilter$Type extends MessageType<PositionsFilter> {
    constructor() {
        super("injective.stream.v1beta1.PositionsFilter", [
            { no: 1, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsFilter>): PositionsFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountIds = [];
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<PositionsFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsFilter): PositionsFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string subaccount_ids */ 1:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string market_ids */ 2:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string subaccount_ids = 1; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string market_ids = 2; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.PositionsFilter
 */
export const PositionsFilter = new PositionsFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrdersFilter$Type extends MessageType<OrdersFilter> {
    constructor() {
        super("injective.stream.v1beta1.OrdersFilter", [
            { no: 1, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrdersFilter>): OrdersFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountIds = [];
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<OrdersFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrdersFilter): OrdersFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string subaccount_ids */ 1:
                    message.subaccountIds.push(reader.string());
                    break;
                case /* repeated string market_ids */ 2:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrdersFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string subaccount_ids = 1; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
        /* repeated string market_ids = 2; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.OrdersFilter
 */
export const OrdersFilter = new OrdersFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderbookFilter$Type extends MessageType<OrderbookFilter> {
    constructor() {
        super("injective.stream.v1beta1.OrderbookFilter", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderbookFilter>): OrderbookFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<OrderbookFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderbookFilter): OrderbookFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderbookFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.OrderbookFilter
 */
export const OrderbookFilter = new OrderbookFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BankBalancesFilter$Type extends MessageType<BankBalancesFilter> {
    constructor() {
        super("injective.stream.v1beta1.BankBalancesFilter", [
            { no: 1, name: "accounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BankBalancesFilter>): BankBalancesFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accounts = [];
        if (value !== undefined)
            reflectionMergePartial<BankBalancesFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BankBalancesFilter): BankBalancesFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accounts */ 1:
                    message.accounts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BankBalancesFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.BankBalancesFilter
 */
export const BankBalancesFilter = new BankBalancesFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountDepositsFilter$Type extends MessageType<SubaccountDepositsFilter> {
    constructor() {
        super("injective.stream.v1beta1.SubaccountDepositsFilter", [
            { no: 1, name: "subaccount_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubaccountDepositsFilter>): SubaccountDepositsFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountIds = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountDepositsFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountDepositsFilter): SubaccountDepositsFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string subaccount_ids */ 1:
                    message.subaccountIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountDepositsFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string subaccount_ids = 1; */
        for (let i = 0; i < message.subaccountIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.SubaccountDepositsFilter
 */
export const SubaccountDepositsFilter = new SubaccountDepositsFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OraclePriceFilter$Type extends MessageType<OraclePriceFilter> {
    constructor() {
        super("injective.stream.v1beta1.OraclePriceFilter", [
            { no: 1, name: "symbol", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OraclePriceFilter>): OraclePriceFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbol = [];
        if (value !== undefined)
            reflectionMergePartial<OraclePriceFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OraclePriceFilter): OraclePriceFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string symbol */ 1:
                    message.symbol.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OraclePriceFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string symbol = 1; */
        for (let i = 0; i < message.symbol.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.symbol[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.stream.v1beta1.OraclePriceFilter
 */
export const OraclePriceFilter = new OraclePriceFilter$Type();
/**
 * @generated ServiceType for protobuf service injective.stream.v1beta1.Stream
 */
export const Stream = new ServiceType("injective.stream.v1beta1.Stream", [
    { name: "Stream", serverStreaming: true, options: {}, I: StreamRequest, O: StreamResponse }
]);
