import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PositionDelta } from "../../exchange/v1beta1/exchange_pb.js";
import { DerivativeLimitOrder } from "../../exchange/v1beta1/exchange_pb.js";
import { SpotLimitOrder } from "../../exchange/v1beta1/exchange_pb.js";
import { Deposit } from "../../exchange/v1beta1/exchange_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { Level } from "../../exchange/v1beta1/exchange_pb.js";
var OrderUpdateStatus = /* @__PURE__ */ ((OrderUpdateStatus2) => {
  OrderUpdateStatus2[OrderUpdateStatus2["Unspecified"] = 0] = "Unspecified";
  OrderUpdateStatus2[OrderUpdateStatus2["Booked"] = 1] = "Booked";
  OrderUpdateStatus2[OrderUpdateStatus2["Matched"] = 2] = "Matched";
  OrderUpdateStatus2[OrderUpdateStatus2["Cancelled"] = 3] = "Cancelled";
  return OrderUpdateStatus2;
})(OrderUpdateStatus || {});
class StreamRequest$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.StreamRequest", [
      { no: 1, name: "bank_balances_filter", kind: "message", T: () => BankBalancesFilter, options: { "gogoproto.nullable": true } },
      { no: 2, name: "subaccount_deposits_filter", kind: "message", T: () => SubaccountDepositsFilter, options: { "gogoproto.nullable": true } },
      { no: 3, name: "spot_trades_filter", kind: "message", T: () => TradesFilter, options: { "gogoproto.nullable": true } },
      { no: 4, name: "derivative_trades_filter", kind: "message", T: () => TradesFilter, options: { "gogoproto.nullable": true } },
      { no: 5, name: "spot_orders_filter", kind: "message", T: () => OrdersFilter, options: { "gogoproto.nullable": true } },
      { no: 6, name: "derivative_orders_filter", kind: "message", T: () => OrdersFilter, options: { "gogoproto.nullable": true } },
      { no: 7, name: "spot_orderbooks_filter", kind: "message", T: () => OrderbookFilter, options: { "gogoproto.nullable": true } },
      { no: 8, name: "derivative_orderbooks_filter", kind: "message", T: () => OrderbookFilter, options: { "gogoproto.nullable": true } },
      { no: 9, name: "positions_filter", kind: "message", T: () => PositionsFilter, options: { "gogoproto.nullable": true } },
      { no: 10, name: "oracle_price_filter", kind: "message", T: () => OraclePriceFilter, options: { "gogoproto.nullable": true } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.stream.v1beta1.BankBalancesFilter bank_balances_filter */
        1:
          message.bankBalancesFilter = BankBalancesFilter.internalBinaryRead(reader, reader.uint32(), options, message.bankBalancesFilter);
          break;
        case /* injective.stream.v1beta1.SubaccountDepositsFilter subaccount_deposits_filter */
        2:
          message.subaccountDepositsFilter = SubaccountDepositsFilter.internalBinaryRead(reader, reader.uint32(), options, message.subaccountDepositsFilter);
          break;
        case /* injective.stream.v1beta1.TradesFilter spot_trades_filter */
        3:
          message.spotTradesFilter = TradesFilter.internalBinaryRead(reader, reader.uint32(), options, message.spotTradesFilter);
          break;
        case /* injective.stream.v1beta1.TradesFilter derivative_trades_filter */
        4:
          message.derivativeTradesFilter = TradesFilter.internalBinaryRead(reader, reader.uint32(), options, message.derivativeTradesFilter);
          break;
        case /* injective.stream.v1beta1.OrdersFilter spot_orders_filter */
        5:
          message.spotOrdersFilter = OrdersFilter.internalBinaryRead(reader, reader.uint32(), options, message.spotOrdersFilter);
          break;
        case /* injective.stream.v1beta1.OrdersFilter derivative_orders_filter */
        6:
          message.derivativeOrdersFilter = OrdersFilter.internalBinaryRead(reader, reader.uint32(), options, message.derivativeOrdersFilter);
          break;
        case /* injective.stream.v1beta1.OrderbookFilter spot_orderbooks_filter */
        7:
          message.spotOrderbooksFilter = OrderbookFilter.internalBinaryRead(reader, reader.uint32(), options, message.spotOrderbooksFilter);
          break;
        case /* injective.stream.v1beta1.OrderbookFilter derivative_orderbooks_filter */
        8:
          message.derivativeOrderbooksFilter = OrderbookFilter.internalBinaryRead(reader, reader.uint32(), options, message.derivativeOrderbooksFilter);
          break;
        case /* injective.stream.v1beta1.PositionsFilter positions_filter */
        9:
          message.positionsFilter = PositionsFilter.internalBinaryRead(reader, reader.uint32(), options, message.positionsFilter);
          break;
        case /* injective.stream.v1beta1.OraclePriceFilter oracle_price_filter */
        10:
          message.oraclePriceFilter = OraclePriceFilter.internalBinaryRead(reader, reader.uint32(), options, message.oraclePriceFilter);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bankBalancesFilter)
      BankBalancesFilter.internalBinaryWrite(message.bankBalancesFilter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.subaccountDepositsFilter)
      SubaccountDepositsFilter.internalBinaryWrite(message.subaccountDepositsFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.spotTradesFilter)
      TradesFilter.internalBinaryWrite(message.spotTradesFilter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.derivativeTradesFilter)
      TradesFilter.internalBinaryWrite(message.derivativeTradesFilter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.spotOrdersFilter)
      OrdersFilter.internalBinaryWrite(message.spotOrdersFilter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.derivativeOrdersFilter)
      OrdersFilter.internalBinaryWrite(message.derivativeOrdersFilter, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.spotOrderbooksFilter)
      OrderbookFilter.internalBinaryWrite(message.spotOrderbooksFilter, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.derivativeOrderbooksFilter)
      OrderbookFilter.internalBinaryWrite(message.derivativeOrderbooksFilter, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.positionsFilter)
      PositionsFilter.internalBinaryWrite(message.positionsFilter, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.oraclePriceFilter)
      OraclePriceFilter.internalBinaryWrite(message.oraclePriceFilter, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamRequest = new StreamRequest$Type();
class StreamResponse$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.StreamResponse", [
      {
        no: 1,
        name: "block_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "block_time",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "bank_balances", kind: "message", repeat: 2, T: () => BankBalance },
      { no: 4, name: "subaccount_deposits", kind: "message", repeat: 2, T: () => SubaccountDeposits },
      { no: 5, name: "spot_trades", kind: "message", repeat: 2, T: () => SpotTrade },
      { no: 6, name: "derivative_trades", kind: "message", repeat: 2, T: () => DerivativeTrade },
      { no: 7, name: "spot_orders", kind: "message", repeat: 2, T: () => SpotOrderUpdate },
      { no: 8, name: "derivative_orders", kind: "message", repeat: 2, T: () => DerivativeOrderUpdate },
      { no: 9, name: "spot_orderbook_updates", kind: "message", repeat: 2, T: () => OrderbookUpdate },
      { no: 10, name: "derivative_orderbook_updates", kind: "message", repeat: 2, T: () => OrderbookUpdate },
      { no: 11, name: "positions", kind: "message", repeat: 2, T: () => Position },
      { no: 12, name: "oracle_prices", kind: "message", repeat: 2, T: () => OraclePrice }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.blockHeight = 0n;
    message.blockTime = 0n;
    message.bankBalances = [];
    message.subaccountDeposits = [];
    message.spotTrades = [];
    message.derivativeTrades = [];
    message.spotOrders = [];
    message.derivativeOrders = [];
    message.spotOrderbookUpdates = [];
    message.derivativeOrderbookUpdates = [];
    message.positions = [];
    message.oraclePrices = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 block_height */
        1:
          message.blockHeight = reader.uint64().toBigInt();
          break;
        case /* int64 block_time */
        2:
          message.blockTime = reader.int64().toBigInt();
          break;
        case /* repeated injective.stream.v1beta1.BankBalance bank_balances */
        3:
          message.bankBalances.push(BankBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.SubaccountDeposits subaccount_deposits */
        4:
          message.subaccountDeposits.push(SubaccountDeposits.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.SpotTrade spot_trades */
        5:
          message.spotTrades.push(SpotTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.DerivativeTrade derivative_trades */
        6:
          message.derivativeTrades.push(DerivativeTrade.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.SpotOrderUpdate spot_orders */
        7:
          message.spotOrders.push(SpotOrderUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.DerivativeOrderUpdate derivative_orders */
        8:
          message.derivativeOrders.push(DerivativeOrderUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.OrderbookUpdate spot_orderbook_updates */
        9:
          message.spotOrderbookUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.OrderbookUpdate derivative_orderbook_updates */
        10:
          message.derivativeOrderbookUpdates.push(OrderbookUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.Position positions */
        11:
          message.positions.push(Position.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.stream.v1beta1.OraclePrice oracle_prices */
        12:
          message.oraclePrices.push(OraclePrice.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.blockHeight !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.blockHeight);
    if (message.blockTime !== 0n)
      writer.tag(2, WireType.Varint).int64(message.blockTime);
    for (let i = 0; i < message.bankBalances.length; i++)
      BankBalance.internalBinaryWrite(message.bankBalances[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.subaccountDeposits.length; i++)
      SubaccountDeposits.internalBinaryWrite(message.subaccountDeposits[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.spotTrades.length; i++)
      SpotTrade.internalBinaryWrite(message.spotTrades[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeTrades.length; i++)
      DerivativeTrade.internalBinaryWrite(message.derivativeTrades[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.spotOrders.length; i++)
      SpotOrderUpdate.internalBinaryWrite(message.spotOrders[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeOrders.length; i++)
      DerivativeOrderUpdate.internalBinaryWrite(message.derivativeOrders[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.spotOrderbookUpdates.length; i++)
      OrderbookUpdate.internalBinaryWrite(message.spotOrderbookUpdates[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.derivativeOrderbookUpdates.length; i++)
      OrderbookUpdate.internalBinaryWrite(message.derivativeOrderbookUpdates[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.positions.length; i++)
      Position.internalBinaryWrite(message.positions[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.oraclePrices.length; i++)
      OraclePrice.internalBinaryWrite(message.oraclePrices[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamResponse = new StreamResponse$Type();
class OrderbookUpdate$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.OrderbookUpdate", [
      {
        no: 1,
        name: "seq",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "orderbook", kind: "message", T: () => Orderbook }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.seq = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 seq */
        1:
          message.seq = reader.uint64().toBigInt();
          break;
        case /* injective.stream.v1beta1.Orderbook orderbook */
        2:
          message.orderbook = Orderbook.internalBinaryRead(reader, reader.uint32(), options, message.orderbook);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.seq !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.seq);
    if (message.orderbook)
      Orderbook.internalBinaryWrite(message.orderbook, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookUpdate = new OrderbookUpdate$Type();
class Orderbook$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.Orderbook", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "buy_levels", kind: "message", repeat: 2, T: () => Level },
      { no: 3, name: "sell_levels", kind: "message", repeat: 2, T: () => Level }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.buyLevels = [];
    message.sellLevels = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* repeated injective.exchange.v1beta1.Level buy_levels */
        2:
          message.buyLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated injective.exchange.v1beta1.Level sell_levels */
        3:
          message.sellLevels.push(Level.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    for (let i = 0; i < message.buyLevels.length; i++)
      Level.internalBinaryWrite(message.buyLevels[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.sellLevels.length; i++)
      Level.internalBinaryWrite(message.sellLevels[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Orderbook = new Orderbook$Type();
class BankBalance$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.BankBalance", [
      {
        no: 1,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "balances", kind: "message", repeat: 2, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account = "";
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account */
        1:
          message.account = reader.string();
          break;
        case /* repeated cosmos.base.v1beta1.Coin balances */
        2:
          message.balances.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.account !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.account);
    for (let i = 0; i < message.balances.length; i++)
      Coin.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BankBalance = new BankBalance$Type();
class SubaccountDeposits$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.SubaccountDeposits", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "deposits", kind: "message", repeat: 2, T: () => SubaccountDeposit, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.deposits = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* repeated injective.stream.v1beta1.SubaccountDeposit deposits */
        2:
          message.deposits.push(SubaccountDeposit.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.deposits.length; i++)
      SubaccountDeposit.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountDeposits = new SubaccountDeposits$Type();
class SubaccountDeposit$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.SubaccountDeposit", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "deposit", kind: "message", T: () => Deposit, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* injective.exchange.v1beta1.Deposit deposit */
        2:
          message.deposit = Deposit.internalBinaryRead(reader, reader.uint32(), options, message.deposit);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.deposit)
      Deposit.internalBinaryWrite(message.deposit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountDeposit = new SubaccountDeposit$Type();
class SpotOrderUpdate$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.SpotOrderUpdate", [
      { no: 1, name: "status", kind: "enum", T: () => ["injective.stream.v1beta1.OrderUpdateStatus", OrderUpdateStatus] },
      {
        no: 2,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "order", kind: "message", T: () => SpotOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = 0;
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.stream.v1beta1.OrderUpdateStatus status */
        1:
          message.status = reader.int32();
          break;
        case /* string order_hash */
        2:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        3:
          message.cid = reader.string();
          break;
        case /* injective.stream.v1beta1.SpotOrder order */
        4:
          message.order = SpotOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== 0)
      writer.tag(1, WireType.Varint).int32(message.status);
    if (message.orderHash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.cid);
    if (message.order)
      SpotOrder.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotOrderUpdate = new SpotOrderUpdate$Type();
class SpotOrder$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.SpotOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => SpotLimitOrder, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v1beta1.SpotLimitOrder order */
        2:
          message.order = SpotLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.order)
      SpotLimitOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotOrder = new SpotOrder$Type();
class DerivativeOrderUpdate$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.DerivativeOrderUpdate", [
      { no: 1, name: "status", kind: "enum", T: () => ["injective.stream.v1beta1.OrderUpdateStatus", OrderUpdateStatus] },
      {
        no: 2,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "order", kind: "message", T: () => DerivativeOrder }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = 0;
    message.orderHash = "";
    message.cid = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.stream.v1beta1.OrderUpdateStatus status */
        1:
          message.status = reader.int32();
          break;
        case /* string order_hash */
        2:
          message.orderHash = reader.string();
          break;
        case /* string cid */
        3:
          message.cid = reader.string();
          break;
        case /* injective.stream.v1beta1.DerivativeOrder order */
        4:
          message.order = DerivativeOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== 0)
      writer.tag(1, WireType.Varint).int32(message.status);
    if (message.orderHash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.orderHash);
    if (message.cid !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.cid);
    if (message.order)
      DerivativeOrder.internalBinaryWrite(message.order, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeOrderUpdate = new DerivativeOrderUpdate$Type();
class DerivativeOrder$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.DerivativeOrder", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "order", kind: "message", T: () => DerivativeLimitOrder, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "is_market",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isMarket = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* injective.exchange.v1beta1.DerivativeLimitOrder order */
        2:
          message.order = DerivativeLimitOrder.internalBinaryRead(reader, reader.uint32(), options, message.order);
          break;
        case /* bool is_market */
        3:
          message.isMarket = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.order)
      DerivativeLimitOrder.internalBinaryWrite(message.order, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.isMarket !== false)
      writer.tag(3, WireType.Varint).bool(message.isMarket);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeOrder = new DerivativeOrder$Type();
class Position$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.Position", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "isLong",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "entry_price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 6, name: "margin", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "cumulative_funding_entry", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.subaccountId = "";
    message.isLong = false;
    message.quantity = "";
    message.entryPrice = "";
    message.margin = "";
    message.cumulativeFundingEntry = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* string subaccount_id */
        2:
          message.subaccountId = reader.string();
          break;
        case /* bool isLong */
        3:
          message.isLong = reader.bool();
          break;
        case /* string quantity */
        4:
          message.quantity = reader.string();
          break;
        case /* string entry_price */
        5:
          message.entryPrice = reader.string();
          break;
        case /* string margin */
        6:
          message.margin = reader.string();
          break;
        case /* string cumulative_funding_entry */
        7:
          message.cumulativeFundingEntry = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.subaccountId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.subaccountId);
    if (message.isLong !== false)
      writer.tag(3, WireType.Varint).bool(message.isLong);
    if (message.quantity !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quantity);
    if (message.entryPrice !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.entryPrice);
    if (message.margin !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.margin);
    if (message.cumulativeFundingEntry !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.cumulativeFundingEntry);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Position = new Position$Type();
class OraclePrice$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.OraclePrice", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 3,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = "";
    message.price = "";
    message.type = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string symbol */
        1:
          message.symbol = reader.string();
          break;
        case /* string price */
        2:
          message.price = reader.string();
          break;
        case /* string type */
        3:
          message.type = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.symbol !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.symbol);
    if (message.price !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.price);
    if (message.type !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.type);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OraclePrice = new OraclePrice$Type();
class SpotTrade$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.SpotTrade", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "is_buy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "executionType",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "quantity", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 5, name: "price", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 6,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 8,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 9, name: "fee_recipient_address", kind: "scalar", T: 9, options: { "gogoproto.nullable": true } },
      {
        no: 10,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isBuy = false;
    message.executionType = "";
    message.quantity = "";
    message.price = "";
    message.subaccountId = "";
    message.fee = "";
    message.orderHash = "";
    message.feeRecipientAddress = "";
    message.cid = "";
    message.tradeId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool is_buy */
        2:
          message.isBuy = reader.bool();
          break;
        case /* string executionType */
        3:
          message.executionType = reader.string();
          break;
        case /* string quantity */
        4:
          message.quantity = reader.string();
          break;
        case /* string price */
        5:
          message.price = reader.string();
          break;
        case /* string subaccount_id */
        6:
          message.subaccountId = reader.string();
          break;
        case /* string fee */
        7:
          message.fee = reader.string();
          break;
        case /* string order_hash */
        8:
          message.orderHash = reader.string();
          break;
        case /* string fee_recipient_address */
        9:
          message.feeRecipientAddress = reader.string();
          break;
        case /* string cid */
        10:
          message.cid = reader.string();
          break;
        case /* string trade_id */
        11:
          message.tradeId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isBuy !== false)
      writer.tag(2, WireType.Varint).bool(message.isBuy);
    if (message.executionType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionType);
    if (message.quantity !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quantity);
    if (message.price !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.price);
    if (message.subaccountId !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.subaccountId);
    if (message.fee !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.fee);
    if (message.orderHash !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.orderHash);
    if (message.feeRecipientAddress !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.feeRecipientAddress);
    if (message.cid !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.cid);
    if (message.tradeId !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SpotTrade = new SpotTrade$Type();
class DerivativeTrade$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.DerivativeTrade", [
      {
        no: 1,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "is_buy",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "executionType",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "position_delta", kind: "message", T: () => PositionDelta },
      { no: 6, name: "payout", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      { no: 7, name: "fee", kind: "scalar", T: 9, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
      {
        no: 8,
        name: "order_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 9, name: "fee_recipient_address", kind: "scalar", T: 9, options: { "gogoproto.nullable": true } },
      {
        no: 10,
        name: "cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "trade_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketId = "";
    message.isBuy = false;
    message.executionType = "";
    message.subaccountId = "";
    message.payout = "";
    message.fee = "";
    message.orderHash = "";
    message.feeRecipientAddress = "";
    message.cid = "";
    message.tradeId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string market_id */
        1:
          message.marketId = reader.string();
          break;
        case /* bool is_buy */
        2:
          message.isBuy = reader.bool();
          break;
        case /* string executionType */
        3:
          message.executionType = reader.string();
          break;
        case /* string subaccount_id */
        4:
          message.subaccountId = reader.string();
          break;
        case /* injective.exchange.v1beta1.PositionDelta position_delta */
        5:
          message.positionDelta = PositionDelta.internalBinaryRead(reader, reader.uint32(), options, message.positionDelta);
          break;
        case /* string payout */
        6:
          message.payout = reader.string();
          break;
        case /* string fee */
        7:
          message.fee = reader.string();
          break;
        case /* string order_hash */
        8:
          message.orderHash = reader.string();
          break;
        case /* string fee_recipient_address */
        9:
          message.feeRecipientAddress = reader.string();
          break;
        case /* string cid */
        10:
          message.cid = reader.string();
          break;
        case /* string trade_id */
        11:
          message.tradeId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.marketId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.marketId);
    if (message.isBuy !== false)
      writer.tag(2, WireType.Varint).bool(message.isBuy);
    if (message.executionType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.executionType);
    if (message.subaccountId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.subaccountId);
    if (message.positionDelta)
      PositionDelta.internalBinaryWrite(message.positionDelta, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.payout !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.payout);
    if (message.fee !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.fee);
    if (message.orderHash !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.orderHash);
    if (message.feeRecipientAddress !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.feeRecipientAddress);
    if (message.cid !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.cid);
    if (message.tradeId !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.tradeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DerivativeTrade = new DerivativeTrade$Type();
class TradesFilter$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.TradesFilter", [
      {
        no: 1,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountIds = [];
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string subaccount_ids */
        1:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string market_ids */
        2:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TradesFilter = new TradesFilter$Type();
class PositionsFilter$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.PositionsFilter", [
      {
        no: 1,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountIds = [];
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string subaccount_ids */
        1:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string market_ids */
        2:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PositionsFilter = new PositionsFilter$Type();
class OrdersFilter$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.OrdersFilter", [
      {
        no: 1,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountIds = [];
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string subaccount_ids */
        1:
          message.subaccountIds.push(reader.string());
          break;
        case /* repeated string market_ids */
        2:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrdersFilter = new OrdersFilter$Type();
class OrderbookFilter$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.OrderbookFilter", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OrderbookFilter = new OrderbookFilter$Type();
class BankBalancesFilter$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.BankBalancesFilter", [
      {
        no: 1,
        name: "accounts",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accounts = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string accounts */
        1:
          message.accounts.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.accounts.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BankBalancesFilter = new BankBalancesFilter$Type();
class SubaccountDepositsFilter$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.SubaccountDepositsFilter", [
      {
        no: 1,
        name: "subaccount_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string subaccount_ids */
        1:
          message.subaccountIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subaccountIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountDepositsFilter = new SubaccountDepositsFilter$Type();
class OraclePriceFilter$Type extends MessageType {
  constructor() {
    super("injective.stream.v1beta1.OraclePriceFilter", [
      {
        no: 1,
        name: "symbol",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.symbol = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string symbol */
        1:
          message.symbol.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.symbol.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.symbol[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OraclePriceFilter = new OraclePriceFilter$Type();
const Stream = new ServiceType("injective.stream.v1beta1.Stream", [
  { name: "Stream", serverStreaming: true, options: {}, I: StreamRequest, O: StreamResponse }
]);
export {
  BankBalance,
  BankBalancesFilter,
  DerivativeOrder,
  DerivativeOrderUpdate,
  DerivativeTrade,
  OraclePrice,
  OraclePriceFilter,
  OrderUpdateStatus,
  Orderbook,
  OrderbookFilter,
  OrderbookUpdate,
  OrdersFilter,
  Position,
  PositionsFilter,
  SpotOrder,
  SpotOrderUpdate,
  SpotTrade,
  Stream,
  StreamRequest,
  StreamResponse,
  SubaccountDeposit,
  SubaccountDeposits,
  SubaccountDepositsFilter,
  TradesFilter
};
