// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/peggy/v1/query.proto" (package "injective.peggy.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GenesisState } from "./genesis_pb";
import { OutgoingTransferTx } from "./batch_pb";
import { LastClaimEvent } from "./types_pb";
import { MsgConfirmBatch } from "./msgs_pb";
import { OutgoingTxBatch } from "./batch_pb";
import { BatchFees } from "./pool_pb";
import { MsgValsetConfirm } from "./msgs_pb";
import { Valset } from "./types_pb";
import { Params } from "./params_pb";
/**
 * @generated from protobuf message injective.peggy.v1.QueryParamsRequest
 */
export interface QueryParamsRequest {
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryParamsResponse
 */
export interface QueryParamsResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.Params params = 1
     */
    params?: Params;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryCurrentValsetRequest
 */
export interface QueryCurrentValsetRequest {
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryCurrentValsetResponse
 */
export interface QueryCurrentValsetResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.Valset valset = 1
     */
    valset?: Valset;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryValsetRequestRequest
 */
export interface QueryValsetRequestRequest {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryValsetRequestResponse
 */
export interface QueryValsetRequestResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.Valset valset = 1
     */
    valset?: Valset;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryValsetConfirmRequest
 */
export interface QueryValsetConfirmRequest {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
    /**
     * @generated from protobuf field: string address = 2
     */
    address: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryValsetConfirmResponse
 */
export interface QueryValsetConfirmResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.MsgValsetConfirm confirm = 1
     */
    confirm?: MsgValsetConfirm;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryValsetConfirmsByNonceRequest
 */
export interface QueryValsetConfirmsByNonceRequest {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryValsetConfirmsByNonceResponse
 */
export interface QueryValsetConfirmsByNonceResponse {
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.MsgValsetConfirm confirms = 1
     */
    confirms: MsgValsetConfirm[];
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastValsetRequestsRequest
 */
export interface QueryLastValsetRequestsRequest {
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastValsetRequestsResponse
 */
export interface QueryLastValsetRequestsResponse {
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.Valset valsets = 1
     */
    valsets: Valset[];
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest
 */
export interface QueryLastPendingValsetRequestByAddrRequest {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse
 */
export interface QueryLastPendingValsetRequestByAddrResponse {
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.Valset valsets = 1
     */
    valsets: Valset[];
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryBatchFeeRequest
 */
export interface QueryBatchFeeRequest {
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryBatchFeeResponse
 */
export interface QueryBatchFeeResponse {
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.BatchFees batchFees = 1
     */
    batchFees: BatchFees[];
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest
 */
export interface QueryLastPendingBatchRequestByAddrRequest {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse
 */
export interface QueryLastPendingBatchRequestByAddrResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.OutgoingTxBatch batch = 1
     */
    batch?: OutgoingTxBatch;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryOutgoingTxBatchesRequest
 */
export interface QueryOutgoingTxBatchesRequest {
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryOutgoingTxBatchesResponse
 */
export interface QueryOutgoingTxBatchesResponse {
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.OutgoingTxBatch batches = 1
     */
    batches: OutgoingTxBatch[];
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryBatchRequestByNonceRequest
 */
export interface QueryBatchRequestByNonceRequest {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
    /**
     * @generated from protobuf field: string contract_address = 2
     */
    contractAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryBatchRequestByNonceResponse
 */
export interface QueryBatchRequestByNonceResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.OutgoingTxBatch batch = 1
     */
    batch?: OutgoingTxBatch;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryBatchConfirmsRequest
 */
export interface QueryBatchConfirmsRequest {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
    /**
     * @generated from protobuf field: string contract_address = 2
     */
    contractAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryBatchConfirmsResponse
 */
export interface QueryBatchConfirmsResponse {
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.MsgConfirmBatch confirms = 1
     */
    confirms: MsgConfirmBatch[];
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastEventByAddrRequest
 */
export interface QueryLastEventByAddrRequest {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryLastEventByAddrResponse
 */
export interface QueryLastEventByAddrResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.LastClaimEvent last_claim_event = 1
     */
    lastClaimEvent?: LastClaimEvent;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryERC20ToDenomRequest
 */
export interface QueryERC20ToDenomRequest {
    /**
     * @generated from protobuf field: string erc20 = 1
     */
    erc20: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryERC20ToDenomResponse
 */
export interface QueryERC20ToDenomResponse {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: bool cosmos_originated = 2
     */
    cosmosOriginated: boolean;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDenomToERC20Request
 */
export interface QueryDenomToERC20Request {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDenomToERC20Response
 */
export interface QueryDenomToERC20Response {
    /**
     * @generated from protobuf field: string erc20 = 1
     */
    erc20: string;
    /**
     * @generated from protobuf field: bool cosmos_originated = 2
     */
    cosmosOriginated: boolean;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDelegateKeysByValidatorAddress
 */
export interface QueryDelegateKeysByValidatorAddress {
    /**
     * @generated from protobuf field: string validator_address = 1
     */
    validatorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse
 */
export interface QueryDelegateKeysByValidatorAddressResponse {
    /**
     * @generated from protobuf field: string eth_address = 1
     */
    ethAddress: string;
    /**
     * @generated from protobuf field: string orchestrator_address = 2
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDelegateKeysByEthAddress
 */
export interface QueryDelegateKeysByEthAddress {
    /**
     * @generated from protobuf field: string eth_address = 1
     */
    ethAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDelegateKeysByEthAddressResponse
 */
export interface QueryDelegateKeysByEthAddressResponse {
    /**
     * @generated from protobuf field: string validator_address = 1
     */
    validatorAddress: string;
    /**
     * @generated from protobuf field: string orchestrator_address = 2
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress
 */
export interface QueryDelegateKeysByOrchestratorAddress {
    /**
     * @generated from protobuf field: string orchestrator_address = 1
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse
 */
export interface QueryDelegateKeysByOrchestratorAddressResponse {
    /**
     * @generated from protobuf field: string validator_address = 1
     */
    validatorAddress: string;
    /**
     * @generated from protobuf field: string eth_address = 2
     */
    ethAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryPendingSendToEth
 */
export interface QueryPendingSendToEth {
    /**
     * @generated from protobuf field: string sender_address = 1
     */
    senderAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.QueryPendingSendToEthResponse
 */
export interface QueryPendingSendToEthResponse {
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.OutgoingTransferTx transfers_in_batches = 1
     */
    transfersInBatches: OutgoingTransferTx[];
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.OutgoingTransferTx unbatched_transfers = 2
     */
    unbatchedTransfers: OutgoingTransferTx[];
}
/**
 * QueryModuleStateRequest is the request type for the Query/PeggyModuleState
 * RPC method.
 *
 * @generated from protobuf message injective.peggy.v1.QueryModuleStateRequest
 */
export interface QueryModuleStateRequest {
}
/**
 * QueryModuleStateResponse is the response type for the Query/PeggyModuleState
 * RPC method.
 *
 * @generated from protobuf message injective.peggy.v1.QueryModuleStateResponse
 */
export interface QueryModuleStateResponse {
    /**
     * @generated from protobuf field: injective.peggy.v1.GenesisState state = 1
     */
    state?: GenesisState;
}
/**
 * @generated from protobuf message injective.peggy.v1.MissingNoncesRequest
 */
export interface MissingNoncesRequest {
}
/**
 * @generated from protobuf message injective.peggy.v1.MissingNoncesResponse
 */
export interface MissingNoncesResponse {
    /**
     * @generated from protobuf field: repeated string operator_addresses = 1
     */
    operatorAddresses: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class QueryParamsRequest$Type extends MessageType<QueryParamsRequest> {
    constructor() {
        super("injective.peggy.v1.QueryParamsRequest", []);
    }
    create(value?: PartialMessage<QueryParamsRequest>): QueryParamsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryParamsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParamsRequest): QueryParamsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParamsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryParamsRequest
 */
export const QueryParamsRequest = new QueryParamsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParamsResponse$Type extends MessageType<QueryParamsResponse> {
    constructor() {
        super("injective.peggy.v1.QueryParamsResponse", [
            { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryParamsResponse>): QueryParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParamsResponse): QueryParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.Params params */ 1:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.Params params = 1; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryParamsResponse
 */
export const QueryParamsResponse = new QueryParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCurrentValsetRequest$Type extends MessageType<QueryCurrentValsetRequest> {
    constructor() {
        super("injective.peggy.v1.QueryCurrentValsetRequest", []);
    }
    create(value?: PartialMessage<QueryCurrentValsetRequest>): QueryCurrentValsetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryCurrentValsetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCurrentValsetRequest): QueryCurrentValsetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCurrentValsetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryCurrentValsetRequest
 */
export const QueryCurrentValsetRequest = new QueryCurrentValsetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCurrentValsetResponse$Type extends MessageType<QueryCurrentValsetResponse> {
    constructor() {
        super("injective.peggy.v1.QueryCurrentValsetResponse", [
            { no: 1, name: "valset", kind: "message", T: () => Valset }
        ]);
    }
    create(value?: PartialMessage<QueryCurrentValsetResponse>): QueryCurrentValsetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryCurrentValsetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCurrentValsetResponse): QueryCurrentValsetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.Valset valset */ 1:
                    message.valset = Valset.internalBinaryRead(reader, reader.uint32(), options, message.valset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCurrentValsetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.Valset valset = 1; */
        if (message.valset)
            Valset.internalBinaryWrite(message.valset, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryCurrentValsetResponse
 */
export const QueryCurrentValsetResponse = new QueryCurrentValsetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryValsetRequestRequest$Type extends MessageType<QueryValsetRequestRequest> {
    constructor() {
        super("injective.peggy.v1.QueryValsetRequestRequest", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryValsetRequestRequest>): QueryValsetRequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryValsetRequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryValsetRequestRequest): QueryValsetRequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryValsetRequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryValsetRequestRequest
 */
export const QueryValsetRequestRequest = new QueryValsetRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryValsetRequestResponse$Type extends MessageType<QueryValsetRequestResponse> {
    constructor() {
        super("injective.peggy.v1.QueryValsetRequestResponse", [
            { no: 1, name: "valset", kind: "message", T: () => Valset }
        ]);
    }
    create(value?: PartialMessage<QueryValsetRequestResponse>): QueryValsetRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryValsetRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryValsetRequestResponse): QueryValsetRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.Valset valset */ 1:
                    message.valset = Valset.internalBinaryRead(reader, reader.uint32(), options, message.valset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryValsetRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.Valset valset = 1; */
        if (message.valset)
            Valset.internalBinaryWrite(message.valset, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryValsetRequestResponse
 */
export const QueryValsetRequestResponse = new QueryValsetRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryValsetConfirmRequest$Type extends MessageType<QueryValsetConfirmRequest> {
    constructor() {
        super("injective.peggy.v1.QueryValsetConfirmRequest", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryValsetConfirmRequest>): QueryValsetConfirmRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<QueryValsetConfirmRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryValsetConfirmRequest): QueryValsetConfirmRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryValsetConfirmRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryValsetConfirmRequest
 */
export const QueryValsetConfirmRequest = new QueryValsetConfirmRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryValsetConfirmResponse$Type extends MessageType<QueryValsetConfirmResponse> {
    constructor() {
        super("injective.peggy.v1.QueryValsetConfirmResponse", [
            { no: 1, name: "confirm", kind: "message", T: () => MsgValsetConfirm }
        ]);
    }
    create(value?: PartialMessage<QueryValsetConfirmResponse>): QueryValsetConfirmResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryValsetConfirmResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryValsetConfirmResponse): QueryValsetConfirmResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.MsgValsetConfirm confirm */ 1:
                    message.confirm = MsgValsetConfirm.internalBinaryRead(reader, reader.uint32(), options, message.confirm);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryValsetConfirmResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.MsgValsetConfirm confirm = 1; */
        if (message.confirm)
            MsgValsetConfirm.internalBinaryWrite(message.confirm, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryValsetConfirmResponse
 */
export const QueryValsetConfirmResponse = new QueryValsetConfirmResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryValsetConfirmsByNonceRequest$Type extends MessageType<QueryValsetConfirmsByNonceRequest> {
    constructor() {
        super("injective.peggy.v1.QueryValsetConfirmsByNonceRequest", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryValsetConfirmsByNonceRequest>): QueryValsetConfirmsByNonceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryValsetConfirmsByNonceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryValsetConfirmsByNonceRequest): QueryValsetConfirmsByNonceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryValsetConfirmsByNonceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryValsetConfirmsByNonceRequest
 */
export const QueryValsetConfirmsByNonceRequest = new QueryValsetConfirmsByNonceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryValsetConfirmsByNonceResponse$Type extends MessageType<QueryValsetConfirmsByNonceResponse> {
    constructor() {
        super("injective.peggy.v1.QueryValsetConfirmsByNonceResponse", [
            { no: 1, name: "confirms", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MsgValsetConfirm }
        ]);
    }
    create(value?: PartialMessage<QueryValsetConfirmsByNonceResponse>): QueryValsetConfirmsByNonceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.confirms = [];
        if (value !== undefined)
            reflectionMergePartial<QueryValsetConfirmsByNonceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryValsetConfirmsByNonceResponse): QueryValsetConfirmsByNonceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.peggy.v1.MsgValsetConfirm confirms */ 1:
                    message.confirms.push(MsgValsetConfirm.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryValsetConfirmsByNonceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.peggy.v1.MsgValsetConfirm confirms = 1; */
        for (let i = 0; i < message.confirms.length; i++)
            MsgValsetConfirm.internalBinaryWrite(message.confirms[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryValsetConfirmsByNonceResponse
 */
export const QueryValsetConfirmsByNonceResponse = new QueryValsetConfirmsByNonceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastValsetRequestsRequest$Type extends MessageType<QueryLastValsetRequestsRequest> {
    constructor() {
        super("injective.peggy.v1.QueryLastValsetRequestsRequest", []);
    }
    create(value?: PartialMessage<QueryLastValsetRequestsRequest>): QueryLastValsetRequestsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryLastValsetRequestsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastValsetRequestsRequest): QueryLastValsetRequestsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastValsetRequestsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastValsetRequestsRequest
 */
export const QueryLastValsetRequestsRequest = new QueryLastValsetRequestsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastValsetRequestsResponse$Type extends MessageType<QueryLastValsetRequestsResponse> {
    constructor() {
        super("injective.peggy.v1.QueryLastValsetRequestsResponse", [
            { no: 1, name: "valsets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Valset }
        ]);
    }
    create(value?: PartialMessage<QueryLastValsetRequestsResponse>): QueryLastValsetRequestsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valsets = [];
        if (value !== undefined)
            reflectionMergePartial<QueryLastValsetRequestsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastValsetRequestsResponse): QueryLastValsetRequestsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.peggy.v1.Valset valsets */ 1:
                    message.valsets.push(Valset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastValsetRequestsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.peggy.v1.Valset valsets = 1; */
        for (let i = 0; i < message.valsets.length; i++)
            Valset.internalBinaryWrite(message.valsets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastValsetRequestsResponse
 */
export const QueryLastValsetRequestsResponse = new QueryLastValsetRequestsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastPendingValsetRequestByAddrRequest$Type extends MessageType<QueryLastPendingValsetRequestByAddrRequest> {
    constructor() {
        super("injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryLastPendingValsetRequestByAddrRequest>): QueryLastPendingValsetRequestByAddrRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<QueryLastPendingValsetRequestByAddrRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastPendingValsetRequestByAddrRequest): QueryLastPendingValsetRequestByAddrRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastPendingValsetRequestByAddrRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest
 */
export const QueryLastPendingValsetRequestByAddrRequest = new QueryLastPendingValsetRequestByAddrRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastPendingValsetRequestByAddrResponse$Type extends MessageType<QueryLastPendingValsetRequestByAddrResponse> {
    constructor() {
        super("injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse", [
            { no: 1, name: "valsets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Valset }
        ]);
    }
    create(value?: PartialMessage<QueryLastPendingValsetRequestByAddrResponse>): QueryLastPendingValsetRequestByAddrResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valsets = [];
        if (value !== undefined)
            reflectionMergePartial<QueryLastPendingValsetRequestByAddrResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastPendingValsetRequestByAddrResponse): QueryLastPendingValsetRequestByAddrResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.peggy.v1.Valset valsets */ 1:
                    message.valsets.push(Valset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastPendingValsetRequestByAddrResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.peggy.v1.Valset valsets = 1; */
        for (let i = 0; i < message.valsets.length; i++)
            Valset.internalBinaryWrite(message.valsets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse
 */
export const QueryLastPendingValsetRequestByAddrResponse = new QueryLastPendingValsetRequestByAddrResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBatchFeeRequest$Type extends MessageType<QueryBatchFeeRequest> {
    constructor() {
        super("injective.peggy.v1.QueryBatchFeeRequest", []);
    }
    create(value?: PartialMessage<QueryBatchFeeRequest>): QueryBatchFeeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryBatchFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBatchFeeRequest): QueryBatchFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBatchFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryBatchFeeRequest
 */
export const QueryBatchFeeRequest = new QueryBatchFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBatchFeeResponse$Type extends MessageType<QueryBatchFeeResponse> {
    constructor() {
        super("injective.peggy.v1.QueryBatchFeeResponse", [
            { no: 1, name: "batchFees", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BatchFees }
        ]);
    }
    create(value?: PartialMessage<QueryBatchFeeResponse>): QueryBatchFeeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.batchFees = [];
        if (value !== undefined)
            reflectionMergePartial<QueryBatchFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBatchFeeResponse): QueryBatchFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.peggy.v1.BatchFees batchFees */ 1:
                    message.batchFees.push(BatchFees.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBatchFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.peggy.v1.BatchFees batchFees = 1; */
        for (let i = 0; i < message.batchFees.length; i++)
            BatchFees.internalBinaryWrite(message.batchFees[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryBatchFeeResponse
 */
export const QueryBatchFeeResponse = new QueryBatchFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastPendingBatchRequestByAddrRequest$Type extends MessageType<QueryLastPendingBatchRequestByAddrRequest> {
    constructor() {
        super("injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryLastPendingBatchRequestByAddrRequest>): QueryLastPendingBatchRequestByAddrRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<QueryLastPendingBatchRequestByAddrRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastPendingBatchRequestByAddrRequest): QueryLastPendingBatchRequestByAddrRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastPendingBatchRequestByAddrRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest
 */
export const QueryLastPendingBatchRequestByAddrRequest = new QueryLastPendingBatchRequestByAddrRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastPendingBatchRequestByAddrResponse$Type extends MessageType<QueryLastPendingBatchRequestByAddrResponse> {
    constructor() {
        super("injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse", [
            { no: 1, name: "batch", kind: "message", T: () => OutgoingTxBatch }
        ]);
    }
    create(value?: PartialMessage<QueryLastPendingBatchRequestByAddrResponse>): QueryLastPendingBatchRequestByAddrResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryLastPendingBatchRequestByAddrResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastPendingBatchRequestByAddrResponse): QueryLastPendingBatchRequestByAddrResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.OutgoingTxBatch batch */ 1:
                    message.batch = OutgoingTxBatch.internalBinaryRead(reader, reader.uint32(), options, message.batch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastPendingBatchRequestByAddrResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.OutgoingTxBatch batch = 1; */
        if (message.batch)
            OutgoingTxBatch.internalBinaryWrite(message.batch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse
 */
export const QueryLastPendingBatchRequestByAddrResponse = new QueryLastPendingBatchRequestByAddrResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryOutgoingTxBatchesRequest$Type extends MessageType<QueryOutgoingTxBatchesRequest> {
    constructor() {
        super("injective.peggy.v1.QueryOutgoingTxBatchesRequest", []);
    }
    create(value?: PartialMessage<QueryOutgoingTxBatchesRequest>): QueryOutgoingTxBatchesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryOutgoingTxBatchesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryOutgoingTxBatchesRequest): QueryOutgoingTxBatchesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryOutgoingTxBatchesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryOutgoingTxBatchesRequest
 */
export const QueryOutgoingTxBatchesRequest = new QueryOutgoingTxBatchesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryOutgoingTxBatchesResponse$Type extends MessageType<QueryOutgoingTxBatchesResponse> {
    constructor() {
        super("injective.peggy.v1.QueryOutgoingTxBatchesResponse", [
            { no: 1, name: "batches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OutgoingTxBatch }
        ]);
    }
    create(value?: PartialMessage<QueryOutgoingTxBatchesResponse>): QueryOutgoingTxBatchesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.batches = [];
        if (value !== undefined)
            reflectionMergePartial<QueryOutgoingTxBatchesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryOutgoingTxBatchesResponse): QueryOutgoingTxBatchesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.peggy.v1.OutgoingTxBatch batches */ 1:
                    message.batches.push(OutgoingTxBatch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryOutgoingTxBatchesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.peggy.v1.OutgoingTxBatch batches = 1; */
        for (let i = 0; i < message.batches.length; i++)
            OutgoingTxBatch.internalBinaryWrite(message.batches[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryOutgoingTxBatchesResponse
 */
export const QueryOutgoingTxBatchesResponse = new QueryOutgoingTxBatchesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBatchRequestByNonceRequest$Type extends MessageType<QueryBatchRequestByNonceRequest> {
    constructor() {
        super("injective.peggy.v1.QueryBatchRequestByNonceRequest", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryBatchRequestByNonceRequest>): QueryBatchRequestByNonceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        message.contractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryBatchRequestByNonceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBatchRequestByNonceRequest): QueryBatchRequestByNonceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string contract_address */ 2:
                    message.contractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBatchRequestByNonceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        /* string contract_address = 2; */
        if (message.contractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryBatchRequestByNonceRequest
 */
export const QueryBatchRequestByNonceRequest = new QueryBatchRequestByNonceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBatchRequestByNonceResponse$Type extends MessageType<QueryBatchRequestByNonceResponse> {
    constructor() {
        super("injective.peggy.v1.QueryBatchRequestByNonceResponse", [
            { no: 1, name: "batch", kind: "message", T: () => OutgoingTxBatch }
        ]);
    }
    create(value?: PartialMessage<QueryBatchRequestByNonceResponse>): QueryBatchRequestByNonceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryBatchRequestByNonceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBatchRequestByNonceResponse): QueryBatchRequestByNonceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.OutgoingTxBatch batch */ 1:
                    message.batch = OutgoingTxBatch.internalBinaryRead(reader, reader.uint32(), options, message.batch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBatchRequestByNonceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.OutgoingTxBatch batch = 1; */
        if (message.batch)
            OutgoingTxBatch.internalBinaryWrite(message.batch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryBatchRequestByNonceResponse
 */
export const QueryBatchRequestByNonceResponse = new QueryBatchRequestByNonceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBatchConfirmsRequest$Type extends MessageType<QueryBatchConfirmsRequest> {
    constructor() {
        super("injective.peggy.v1.QueryBatchConfirmsRequest", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryBatchConfirmsRequest>): QueryBatchConfirmsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        message.contractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryBatchConfirmsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBatchConfirmsRequest): QueryBatchConfirmsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string contract_address */ 2:
                    message.contractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBatchConfirmsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        /* string contract_address = 2; */
        if (message.contractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryBatchConfirmsRequest
 */
export const QueryBatchConfirmsRequest = new QueryBatchConfirmsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBatchConfirmsResponse$Type extends MessageType<QueryBatchConfirmsResponse> {
    constructor() {
        super("injective.peggy.v1.QueryBatchConfirmsResponse", [
            { no: 1, name: "confirms", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MsgConfirmBatch }
        ]);
    }
    create(value?: PartialMessage<QueryBatchConfirmsResponse>): QueryBatchConfirmsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.confirms = [];
        if (value !== undefined)
            reflectionMergePartial<QueryBatchConfirmsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBatchConfirmsResponse): QueryBatchConfirmsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.peggy.v1.MsgConfirmBatch confirms */ 1:
                    message.confirms.push(MsgConfirmBatch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBatchConfirmsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.peggy.v1.MsgConfirmBatch confirms = 1; */
        for (let i = 0; i < message.confirms.length; i++)
            MsgConfirmBatch.internalBinaryWrite(message.confirms[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryBatchConfirmsResponse
 */
export const QueryBatchConfirmsResponse = new QueryBatchConfirmsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastEventByAddrRequest$Type extends MessageType<QueryLastEventByAddrRequest> {
    constructor() {
        super("injective.peggy.v1.QueryLastEventByAddrRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryLastEventByAddrRequest>): QueryLastEventByAddrRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<QueryLastEventByAddrRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastEventByAddrRequest): QueryLastEventByAddrRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastEventByAddrRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastEventByAddrRequest
 */
export const QueryLastEventByAddrRequest = new QueryLastEventByAddrRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLastEventByAddrResponse$Type extends MessageType<QueryLastEventByAddrResponse> {
    constructor() {
        super("injective.peggy.v1.QueryLastEventByAddrResponse", [
            { no: 1, name: "last_claim_event", kind: "message", T: () => LastClaimEvent }
        ]);
    }
    create(value?: PartialMessage<QueryLastEventByAddrResponse>): QueryLastEventByAddrResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryLastEventByAddrResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLastEventByAddrResponse): QueryLastEventByAddrResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.LastClaimEvent last_claim_event */ 1:
                    message.lastClaimEvent = LastClaimEvent.internalBinaryRead(reader, reader.uint32(), options, message.lastClaimEvent);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLastEventByAddrResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.LastClaimEvent last_claim_event = 1; */
        if (message.lastClaimEvent)
            LastClaimEvent.internalBinaryWrite(message.lastClaimEvent, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryLastEventByAddrResponse
 */
export const QueryLastEventByAddrResponse = new QueryLastEventByAddrResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryERC20ToDenomRequest$Type extends MessageType<QueryERC20ToDenomRequest> {
    constructor() {
        super("injective.peggy.v1.QueryERC20ToDenomRequest", [
            { no: 1, name: "erc20", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryERC20ToDenomRequest>): QueryERC20ToDenomRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.erc20 = "";
        if (value !== undefined)
            reflectionMergePartial<QueryERC20ToDenomRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryERC20ToDenomRequest): QueryERC20ToDenomRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string erc20 */ 1:
                    message.erc20 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryERC20ToDenomRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string erc20 = 1; */
        if (message.erc20 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.erc20);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryERC20ToDenomRequest
 */
export const QueryERC20ToDenomRequest = new QueryERC20ToDenomRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryERC20ToDenomResponse$Type extends MessageType<QueryERC20ToDenomResponse> {
    constructor() {
        super("injective.peggy.v1.QueryERC20ToDenomResponse", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cosmos_originated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryERC20ToDenomResponse>): QueryERC20ToDenomResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.cosmosOriginated = false;
        if (value !== undefined)
            reflectionMergePartial<QueryERC20ToDenomResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryERC20ToDenomResponse): QueryERC20ToDenomResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* bool cosmos_originated */ 2:
                    message.cosmosOriginated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryERC20ToDenomResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* bool cosmos_originated = 2; */
        if (message.cosmosOriginated !== false)
            writer.tag(2, WireType.Varint).bool(message.cosmosOriginated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryERC20ToDenomResponse
 */
export const QueryERC20ToDenomResponse = new QueryERC20ToDenomResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDenomToERC20Request$Type extends MessageType<QueryDenomToERC20Request> {
    constructor() {
        super("injective.peggy.v1.QueryDenomToERC20Request", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDenomToERC20Request>): QueryDenomToERC20Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDenomToERC20Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDenomToERC20Request): QueryDenomToERC20Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDenomToERC20Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDenomToERC20Request
 */
export const QueryDenomToERC20Request = new QueryDenomToERC20Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDenomToERC20Response$Type extends MessageType<QueryDenomToERC20Response> {
    constructor() {
        super("injective.peggy.v1.QueryDenomToERC20Response", [
            { no: 1, name: "erc20", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cosmos_originated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDenomToERC20Response>): QueryDenomToERC20Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.erc20 = "";
        message.cosmosOriginated = false;
        if (value !== undefined)
            reflectionMergePartial<QueryDenomToERC20Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDenomToERC20Response): QueryDenomToERC20Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string erc20 */ 1:
                    message.erc20 = reader.string();
                    break;
                case /* bool cosmos_originated */ 2:
                    message.cosmosOriginated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDenomToERC20Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string erc20 = 1; */
        if (message.erc20 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.erc20);
        /* bool cosmos_originated = 2; */
        if (message.cosmosOriginated !== false)
            writer.tag(2, WireType.Varint).bool(message.cosmosOriginated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDenomToERC20Response
 */
export const QueryDenomToERC20Response = new QueryDenomToERC20Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDelegateKeysByValidatorAddress$Type extends MessageType<QueryDelegateKeysByValidatorAddress> {
    constructor() {
        super("injective.peggy.v1.QueryDelegateKeysByValidatorAddress", [
            { no: 1, name: "validator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDelegateKeysByValidatorAddress>): QueryDelegateKeysByValidatorAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validatorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDelegateKeysByValidatorAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDelegateKeysByValidatorAddress): QueryDelegateKeysByValidatorAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string validator_address */ 1:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDelegateKeysByValidatorAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string validator_address = 1; */
        if (message.validatorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDelegateKeysByValidatorAddress
 */
export const QueryDelegateKeysByValidatorAddress = new QueryDelegateKeysByValidatorAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDelegateKeysByValidatorAddressResponse$Type extends MessageType<QueryDelegateKeysByValidatorAddressResponse> {
    constructor() {
        super("injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse", [
            { no: 1, name: "eth_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDelegateKeysByValidatorAddressResponse>): QueryDelegateKeysByValidatorAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ethAddress = "";
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDelegateKeysByValidatorAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDelegateKeysByValidatorAddressResponse): QueryDelegateKeysByValidatorAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string eth_address */ 1:
                    message.ethAddress = reader.string();
                    break;
                case /* string orchestrator_address */ 2:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDelegateKeysByValidatorAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string eth_address = 1; */
        if (message.ethAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ethAddress);
        /* string orchestrator_address = 2; */
        if (message.orchestratorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse
 */
export const QueryDelegateKeysByValidatorAddressResponse = new QueryDelegateKeysByValidatorAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDelegateKeysByEthAddress$Type extends MessageType<QueryDelegateKeysByEthAddress> {
    constructor() {
        super("injective.peggy.v1.QueryDelegateKeysByEthAddress", [
            { no: 1, name: "eth_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDelegateKeysByEthAddress>): QueryDelegateKeysByEthAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ethAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDelegateKeysByEthAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDelegateKeysByEthAddress): QueryDelegateKeysByEthAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string eth_address */ 1:
                    message.ethAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDelegateKeysByEthAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string eth_address = 1; */
        if (message.ethAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ethAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDelegateKeysByEthAddress
 */
export const QueryDelegateKeysByEthAddress = new QueryDelegateKeysByEthAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDelegateKeysByEthAddressResponse$Type extends MessageType<QueryDelegateKeysByEthAddressResponse> {
    constructor() {
        super("injective.peggy.v1.QueryDelegateKeysByEthAddressResponse", [
            { no: 1, name: "validator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDelegateKeysByEthAddressResponse>): QueryDelegateKeysByEthAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validatorAddress = "";
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDelegateKeysByEthAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDelegateKeysByEthAddressResponse): QueryDelegateKeysByEthAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string validator_address */ 1:
                    message.validatorAddress = reader.string();
                    break;
                case /* string orchestrator_address */ 2:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDelegateKeysByEthAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string validator_address = 1; */
        if (message.validatorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
        /* string orchestrator_address = 2; */
        if (message.orchestratorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDelegateKeysByEthAddressResponse
 */
export const QueryDelegateKeysByEthAddressResponse = new QueryDelegateKeysByEthAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDelegateKeysByOrchestratorAddress$Type extends MessageType<QueryDelegateKeysByOrchestratorAddress> {
    constructor() {
        super("injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress", [
            { no: 1, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDelegateKeysByOrchestratorAddress>): QueryDelegateKeysByOrchestratorAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDelegateKeysByOrchestratorAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDelegateKeysByOrchestratorAddress): QueryDelegateKeysByOrchestratorAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string orchestrator_address */ 1:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDelegateKeysByOrchestratorAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string orchestrator_address = 1; */
        if (message.orchestratorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress
 */
export const QueryDelegateKeysByOrchestratorAddress = new QueryDelegateKeysByOrchestratorAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryDelegateKeysByOrchestratorAddressResponse$Type extends MessageType<QueryDelegateKeysByOrchestratorAddressResponse> {
    constructor() {
        super("injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse", [
            { no: 1, name: "validator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eth_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryDelegateKeysByOrchestratorAddressResponse>): QueryDelegateKeysByOrchestratorAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validatorAddress = "";
        message.ethAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryDelegateKeysByOrchestratorAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryDelegateKeysByOrchestratorAddressResponse): QueryDelegateKeysByOrchestratorAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string validator_address */ 1:
                    message.validatorAddress = reader.string();
                    break;
                case /* string eth_address */ 2:
                    message.ethAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryDelegateKeysByOrchestratorAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string validator_address = 1; */
        if (message.validatorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
        /* string eth_address = 2; */
        if (message.ethAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ethAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse
 */
export const QueryDelegateKeysByOrchestratorAddressResponse = new QueryDelegateKeysByOrchestratorAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPendingSendToEth$Type extends MessageType<QueryPendingSendToEth> {
    constructor() {
        super("injective.peggy.v1.QueryPendingSendToEth", [
            { no: 1, name: "sender_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPendingSendToEth>): QueryPendingSendToEth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senderAddress = "";
        if (value !== undefined)
            reflectionMergePartial<QueryPendingSendToEth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPendingSendToEth): QueryPendingSendToEth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender_address */ 1:
                    message.senderAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPendingSendToEth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender_address = 1; */
        if (message.senderAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.senderAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryPendingSendToEth
 */
export const QueryPendingSendToEth = new QueryPendingSendToEth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPendingSendToEthResponse$Type extends MessageType<QueryPendingSendToEthResponse> {
    constructor() {
        super("injective.peggy.v1.QueryPendingSendToEthResponse", [
            { no: 1, name: "transfers_in_batches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OutgoingTransferTx },
            { no: 2, name: "unbatched_transfers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OutgoingTransferTx }
        ]);
    }
    create(value?: PartialMessage<QueryPendingSendToEthResponse>): QueryPendingSendToEthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transfersInBatches = [];
        message.unbatchedTransfers = [];
        if (value !== undefined)
            reflectionMergePartial<QueryPendingSendToEthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPendingSendToEthResponse): QueryPendingSendToEthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective.peggy.v1.OutgoingTransferTx transfers_in_batches */ 1:
                    message.transfersInBatches.push(OutgoingTransferTx.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated injective.peggy.v1.OutgoingTransferTx unbatched_transfers */ 2:
                    message.unbatchedTransfers.push(OutgoingTransferTx.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPendingSendToEthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective.peggy.v1.OutgoingTransferTx transfers_in_batches = 1; */
        for (let i = 0; i < message.transfersInBatches.length; i++)
            OutgoingTransferTx.internalBinaryWrite(message.transfersInBatches[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated injective.peggy.v1.OutgoingTransferTx unbatched_transfers = 2; */
        for (let i = 0; i < message.unbatchedTransfers.length; i++)
            OutgoingTransferTx.internalBinaryWrite(message.unbatchedTransfers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryPendingSendToEthResponse
 */
export const QueryPendingSendToEthResponse = new QueryPendingSendToEthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryModuleStateRequest$Type extends MessageType<QueryModuleStateRequest> {
    constructor() {
        super("injective.peggy.v1.QueryModuleStateRequest", []);
    }
    create(value?: PartialMessage<QueryModuleStateRequest>): QueryModuleStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryModuleStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryModuleStateRequest): QueryModuleStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryModuleStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryModuleStateRequest
 */
export const QueryModuleStateRequest = new QueryModuleStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryModuleStateResponse$Type extends MessageType<QueryModuleStateResponse> {
    constructor() {
        super("injective.peggy.v1.QueryModuleStateResponse", [
            { no: 1, name: "state", kind: "message", T: () => GenesisState }
        ]);
    }
    create(value?: PartialMessage<QueryModuleStateResponse>): QueryModuleStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryModuleStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryModuleStateResponse): QueryModuleStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.GenesisState state */ 1:
                    message.state = GenesisState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryModuleStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.GenesisState state = 1; */
        if (message.state)
            GenesisState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryModuleStateResponse
 */
export const QueryModuleStateResponse = new QueryModuleStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissingNoncesRequest$Type extends MessageType<MissingNoncesRequest> {
    constructor() {
        super("injective.peggy.v1.MissingNoncesRequest", []);
    }
    create(value?: PartialMessage<MissingNoncesRequest>): MissingNoncesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MissingNoncesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissingNoncesRequest): MissingNoncesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissingNoncesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MissingNoncesRequest
 */
export const MissingNoncesRequest = new MissingNoncesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissingNoncesResponse$Type extends MessageType<MissingNoncesResponse> {
    constructor() {
        super("injective.peggy.v1.MissingNoncesResponse", [
            { no: 1, name: "operator_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MissingNoncesResponse>): MissingNoncesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operatorAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<MissingNoncesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissingNoncesResponse): MissingNoncesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string operator_addresses */ 1:
                    message.operatorAddresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissingNoncesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string operator_addresses = 1; */
        for (let i = 0; i < message.operatorAddresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.operatorAddresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MissingNoncesResponse
 */
export const MissingNoncesResponse = new MissingNoncesResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.peggy.v1.Query
 */
export const Query = new ServiceType("injective.peggy.v1.Query", [
    { name: "Params", options: { "google.api.http": { get: "/peggy/v1/params" } }, I: QueryParamsRequest, O: QueryParamsResponse },
    { name: "CurrentValset", options: { "google.api.http": { get: "/peggy/v1/valset/current" } }, I: QueryCurrentValsetRequest, O: QueryCurrentValsetResponse },
    { name: "ValsetRequest", options: { "google.api.http": { get: "/peggy/v1/valset" } }, I: QueryValsetRequestRequest, O: QueryValsetRequestResponse },
    { name: "ValsetConfirm", options: { "google.api.http": { get: "/peggy/v1/valset/confirm" } }, I: QueryValsetConfirmRequest, O: QueryValsetConfirmResponse },
    { name: "ValsetConfirmsByNonce", options: { "google.api.http": { get: "/peggy/v1/confirms/{nonce}" } }, I: QueryValsetConfirmsByNonceRequest, O: QueryValsetConfirmsByNonceResponse },
    { name: "LastValsetRequests", options: { "google.api.http": { get: "/peggy/v1/valset/requests" } }, I: QueryLastValsetRequestsRequest, O: QueryLastValsetRequestsResponse },
    { name: "LastPendingValsetRequestByAddr", options: { "google.api.http": { get: "/peggy/v1/valset/last" } }, I: QueryLastPendingValsetRequestByAddrRequest, O: QueryLastPendingValsetRequestByAddrResponse },
    { name: "LastEventByAddr", options: { "google.api.http": { get: "/peggy/v1/oracle/event/{address}" } }, I: QueryLastEventByAddrRequest, O: QueryLastEventByAddrResponse },
    { name: "GetPendingSendToEth", options: { "google.api.http": { get: "/peggy/v1/pending_send_to_eth" } }, I: QueryPendingSendToEth, O: QueryPendingSendToEthResponse },
    { name: "BatchFees", options: { "google.api.http": { get: "/peggy/v1/batchfees" } }, I: QueryBatchFeeRequest, O: QueryBatchFeeResponse },
    { name: "OutgoingTxBatches", options: { "google.api.http": { get: "/peggy/v1/batch/outgoingtx" } }, I: QueryOutgoingTxBatchesRequest, O: QueryOutgoingTxBatchesResponse },
    { name: "LastPendingBatchRequestByAddr", options: { "google.api.http": { get: "/peggy/v1/batch/last" } }, I: QueryLastPendingBatchRequestByAddrRequest, O: QueryLastPendingBatchRequestByAddrResponse },
    { name: "BatchRequestByNonce", options: { "google.api.http": { get: "/peggy/v1/batch" } }, I: QueryBatchRequestByNonceRequest, O: QueryBatchRequestByNonceResponse },
    { name: "BatchConfirms", options: { "google.api.http": { get: "/peggy/v1/batch/confirms" } }, I: QueryBatchConfirmsRequest, O: QueryBatchConfirmsResponse },
    { name: "ERC20ToDenom", options: { "google.api.http": { get: "/peggy/v1/cosmos_originated/erc20_to_denom" } }, I: QueryERC20ToDenomRequest, O: QueryERC20ToDenomResponse },
    { name: "DenomToERC20", options: { "google.api.http": { get: "/peggy/v1/cosmos_originated/denom_to_erc20" } }, I: QueryDenomToERC20Request, O: QueryDenomToERC20Response },
    { name: "GetDelegateKeyByValidator", options: { "google.api.http": { get: "/peggy/v1/query_delegate_keys_by_validator" } }, I: QueryDelegateKeysByValidatorAddress, O: QueryDelegateKeysByValidatorAddressResponse },
    { name: "GetDelegateKeyByEth", options: { "google.api.http": { get: "/peggy/v1/query_delegate_keys_by_eth" } }, I: QueryDelegateKeysByEthAddress, O: QueryDelegateKeysByEthAddressResponse },
    { name: "GetDelegateKeyByOrchestrator", options: { "google.api.http": { get: "/peggy/v1/query_delegate_keys_by_orchestrator" } }, I: QueryDelegateKeysByOrchestratorAddress, O: QueryDelegateKeysByOrchestratorAddressResponse },
    { name: "PeggyModuleState", options: { "google.api.http": { get: "/peggy/v1/module_state" } }, I: QueryModuleStateRequest, O: QueryModuleStateResponse },
    { name: "MissingPeggoNonces", options: { "google.api.http": { get: "/peggy/v1/missing_nonces" } }, I: MissingNoncesRequest, O: MissingNoncesResponse }
]);
