// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/peggy/v1/msgs.proto" (package "injective.peggy.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Params } from "./params_pb";
import { BridgeValidator } from "./types_pb";
import { Any } from "../../../google/protobuf/any_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
/**
 * MsgSetOrchestratorAddresses
 * this message allows validators to delegate their voting responsibilities
 * to a given key. This key is then used as an optional authentication method
 * for sigining oracle claims
 * VALIDATOR
 * The validator field is a cosmosvaloper1... string (i.e. sdk.ValAddress)
 * that references a validator in the active set
 * ORCHESTRATOR
 * The orchestrator field is a cosmos1... string  (i.e. sdk.AccAddress) that
 * references the key that is being delegated to
 * ETH_ADDRESS
 * This is a hex encoded 0x Ethereum public key that will be used by this
 * validator on Ethereum
 *
 * @generated from protobuf message injective.peggy.v1.MsgSetOrchestratorAddresses
 */
export interface MsgSetOrchestratorAddresses {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string orchestrator = 2
     */
    orchestrator: string;
    /**
     * @generated from protobuf field: string eth_address = 3
     */
    ethAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgSetOrchestratorAddressesResponse
 */
export interface MsgSetOrchestratorAddressesResponse {
}
/**
 * MsgValsetConfirm
 * this is the message sent by the validators when they wish to submit their
 * signatures over the validator set at a given block height. A validator must
 * first call MsgSetEthAddress to set their Ethereum address to be used for
 * signing. Then someone (anyone) must make a ValsetRequest the request is
 * essentially a messaging mechanism to determine which block all validators
 * should submit signatures over. Finally validators sign the validator set,
 * powers, and Ethereum addresses of the entire validator set at the height of a
 * ValsetRequest and submit that signature with this message.
 *
 * If a sufficient number of validators (66% of voting power) (A) have set
 * Ethereum addresses and (B) submit ValsetConfirm messages with their
 * signatures it is then possible for anyone to view these signatures in the
 * chain store and submit them to Ethereum to update the validator set
 * -------------
 *
 * @generated from protobuf message injective.peggy.v1.MsgValsetConfirm
 */
export interface MsgValsetConfirm {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
    /**
     * @generated from protobuf field: string orchestrator = 2
     */
    orchestrator: string;
    /**
     * @generated from protobuf field: string eth_address = 3
     */
    ethAddress: string;
    /**
     * @generated from protobuf field: string signature = 4
     */
    signature: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgValsetConfirmResponse
 */
export interface MsgValsetConfirmResponse {
}
/**
 * MsgSendToEth
 * This is the message that a user calls when they want to bridge an asset
 * it will later be removed when it is included in a batch and successfully
 * submitted tokens are removed from the users balance immediately
 * -------------
 * AMOUNT:
 * the coin to send across the bridge, note the restriction that this is a
 * single coin not a set of coins that is normal in other Cosmos messages
 * FEE:
 * the fee paid for the bridge, distinct from the fee paid to the chain to
 * actually send this message in the first place. So a successful send has
 * two layers of fees for the user
 *
 * @generated from protobuf message injective.peggy.v1.MsgSendToEth
 */
export interface MsgSendToEth {
    /**
     * The sender's Injective address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * The Ethereum address to send the tokens to
     *
     * @generated from protobuf field: string eth_dest = 2
     */
    ethDest: string;
    /**
     * The amount of tokens to send
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
     */
    amount?: Coin;
    /**
     * The fee paid for the bridge, distinct from the fee paid to the chain to
     * actually send this message in the first place. So a successful send has
     * two layers of fees for the user
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin bridge_fee = 4
     */
    bridgeFee?: Coin;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgSendToEthResponse
 */
export interface MsgSendToEthResponse {
}
/**
 * MsgRequestBatch
 * this is a message anyone can send that requests a batch of transactions to
 * send across the bridge be created for whatever block height this message is
 * included in. This acts as a coordination point, the handler for this message
 * looks at the AddToOutgoingPool tx's in the store and generates a batch, also
 * available in the store tied to this message. The validators then grab this
 * batch, sign it, submit the signatures with a MsgConfirmBatch before a relayer
 * can finally submit the batch
 * -------------
 *
 * @generated from protobuf message injective.peggy.v1.MsgRequestBatch
 */
export interface MsgRequestBatch {
    /**
     * @generated from protobuf field: string orchestrator = 1
     */
    orchestrator: string;
    /**
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgRequestBatchResponse
 */
export interface MsgRequestBatchResponse {
}
/**
 * MsgConfirmBatch
 * When validators observe a MsgRequestBatch they form a batch by ordering
 * transactions currently in the txqueue in order of highest to lowest fee,
 * cutting off when the batch either reaches a hardcoded maximum size (to be
 * decided, probably around 100) or when transactions stop being profitable
 * (TODO determine this without nondeterminism) This message includes the batch
 * as well as an Ethereum signature over this batch by the validator
 * -------------
 *
 * @generated from protobuf message injective.peggy.v1.MsgConfirmBatch
 */
export interface MsgConfirmBatch {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
    /**
     * @generated from protobuf field: string token_contract = 2
     */
    tokenContract: string;
    /**
     * @generated from protobuf field: string eth_signer = 3
     */
    ethSigner: string;
    /**
     * @generated from protobuf field: string orchestrator = 4
     */
    orchestrator: string;
    /**
     * @generated from protobuf field: string signature = 5
     */
    signature: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgConfirmBatchResponse
 */
export interface MsgConfirmBatchResponse {
}
/**
 * EthereumBridgeDepositClaim
 * When more than 66% of the active validator set has
 * claimed to have seen the deposit enter the ethereum blockchain coins are
 * issued to the Cosmos address in question
 * -------------
 *
 * @generated from protobuf message injective.peggy.v1.MsgDepositClaim
 */
export interface MsgDepositClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 block_height = 2
     */
    blockHeight: bigint;
    /**
     * @generated from protobuf field: string token_contract = 3
     */
    tokenContract: string;
    /**
     * @generated from protobuf field: string amount = 4
     */
    amount: string;
    /**
     * @generated from protobuf field: string ethereum_sender = 5
     */
    ethereumSender: string;
    /**
     * @generated from protobuf field: string cosmos_receiver = 6
     */
    cosmosReceiver: string;
    /**
     * @generated from protobuf field: string orchestrator = 7
     */
    orchestrator: string;
    /**
     * @generated from protobuf field: string data = 8
     */
    data: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgDepositClaimResponse
 */
export interface MsgDepositClaimResponse {
}
/**
 * WithdrawClaim claims that a batch of withdrawal
 * operations on the bridge contract was executed.
 *
 * @generated from protobuf message injective.peggy.v1.MsgWithdrawClaim
 */
export interface MsgWithdrawClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 block_height = 2
     */
    blockHeight: bigint;
    /**
     * @generated from protobuf field: uint64 batch_nonce = 3
     */
    batchNonce: bigint;
    /**
     * @generated from protobuf field: string token_contract = 4
     */
    tokenContract: string;
    /**
     * @generated from protobuf field: string orchestrator = 5
     */
    orchestrator: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgWithdrawClaimResponse
 */
export interface MsgWithdrawClaimResponse {
}
/**
 * ERC20DeployedClaim allows the Cosmos module
 * to learn about an ERC20 that someone deployed
 * to represent a Cosmos asset
 *
 * @generated from protobuf message injective.peggy.v1.MsgERC20DeployedClaim
 */
export interface MsgERC20DeployedClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 block_height = 2
     */
    blockHeight: bigint;
    /**
     * @generated from protobuf field: string cosmos_denom = 3
     */
    cosmosDenom: string;
    /**
     * @generated from protobuf field: string token_contract = 4
     */
    tokenContract: string;
    /**
     * @generated from protobuf field: string name = 5
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 6
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint64 decimals = 7
     */
    decimals: bigint;
    /**
     * @generated from protobuf field: string orchestrator = 8
     */
    orchestrator: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgERC20DeployedClaimResponse
 */
export interface MsgERC20DeployedClaimResponse {
}
/**
 * This call allows the sender (and only the sender)
 * to cancel a given MsgSendToEth and recieve a refund
 * of the tokens
 *
 * @generated from protobuf message injective.peggy.v1.MsgCancelSendToEth
 */
export interface MsgCancelSendToEth {
    /**
     * @generated from protobuf field: uint64 transaction_id = 1
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: string sender = 2
     */
    sender: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgCancelSendToEthResponse
 */
export interface MsgCancelSendToEthResponse {
}
/**
 * This call allows anyone to submit evidence that a
 * validator has signed a valset, batch, or logic call that never
 * existed. Subject contains the batch, valset, or logic call.
 *
 * @generated from protobuf message injective.peggy.v1.MsgSubmitBadSignatureEvidence
 */
export interface MsgSubmitBadSignatureEvidence {
    /**
     * @generated from protobuf field: google.protobuf.Any subject = 1
     */
    subject?: Any;
    /**
     * @generated from protobuf field: string signature = 2
     */
    signature: string;
    /**
     * @generated from protobuf field: string sender = 3
     */
    sender: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgSubmitBadSignatureEvidenceResponse
 */
export interface MsgSubmitBadSignatureEvidenceResponse {
}
/**
 * This informs the Cosmos module that a validator
 * set has been updated.
 *
 * @generated from protobuf message injective.peggy.v1.MsgValsetUpdatedClaim
 */
export interface MsgValsetUpdatedClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 valset_nonce = 2
     */
    valsetNonce: bigint;
    /**
     * @generated from protobuf field: uint64 block_height = 3
     */
    blockHeight: bigint;
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.BridgeValidator members = 4
     */
    members: BridgeValidator[];
    /**
     * @generated from protobuf field: string reward_amount = 5
     */
    rewardAmount: string;
    /**
     * @generated from protobuf field: string reward_token = 6
     */
    rewardToken: string;
    /**
     * @generated from protobuf field: string orchestrator = 7
     */
    orchestrator: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgValsetUpdatedClaimResponse
 */
export interface MsgValsetUpdatedClaimResponse {
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the peggy parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: injective.peggy.v1.Params params = 2
     */
    params?: Params;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgBlacklistEthereumAddresses defines the message used to add Ethereum
 * addresses to peggy blacklist.
 *
 * @generated from protobuf message injective.peggy.v1.MsgBlacklistEthereumAddresses
 */
export interface MsgBlacklistEthereumAddresses {
    /**
     * signer address
     *
     * @generated from protobuf field: string signer = 1
     */
    signer: string;
    /**
     * Ethereum addresses to include in the blacklist
     *
     * @generated from protobuf field: repeated string blacklist_addresses = 2
     */
    blacklistAddresses: string[];
}
/**
 * MsgBlacklistEthereumAddressesResponse defines the
 * MsgBlacklistEthereumAddresses response type.
 *
 * @generated from protobuf message injective.peggy.v1.MsgBlacklistEthereumAddressesResponse
 */
export interface MsgBlacklistEthereumAddressesResponse {
}
/**
 * MsgRevokeEthereumBlacklist defines the message used to remove Ethereum
 * addresses from peggy blacklist.
 *
 * @generated from protobuf message injective.peggy.v1.MsgRevokeEthereumBlacklist
 */
export interface MsgRevokeEthereumBlacklist {
    /**
     * signer address
     *
     * @generated from protobuf field: string signer = 1
     */
    signer: string;
    /**
     * Ethereum addresses to include in the blacklist
     *
     * @generated from protobuf field: repeated string blacklist_addresses = 2
     */
    blacklistAddresses: string[];
}
/**
 * MsgRevokeEthereumBlacklistResponse defines the MsgRevokeEthereumBlacklist
 * response type.
 *
 * @generated from protobuf message injective.peggy.v1.MsgRevokeEthereumBlacklistResponse
 */
export interface MsgRevokeEthereumBlacklistResponse {
}
/**
 * MsgCreateRateLimit is used to impose a (withdrawal) limit for specific ERC20
 * token within a sliding window
 *
 * @generated from protobuf message injective.peggy.v1.MsgCreateRateLimit
 */
export interface MsgCreateRateLimit {
    /**
     * address of peggy admin or governance account
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * address of the ERC20 token
     *
     * @generated from protobuf field: string token_address = 2
     */
    tokenAddress: string;
    /**
     * decimals of the ERC20 token
     *
     * @generated from protobuf field: uint32 token_decimals = 3
     */
    tokenDecimals: number;
    /**
     * a Pyth-specific ID used to obtain USD price of the ERC20 token
     *
     * @generated from protobuf field: string token_price_id = 4
     */
    tokenPriceId: string;
    /**
     * the notional USD limit imposed on all outgoing traffic (per token)
     *
     * @generated from protobuf field: string rate_limit_usd = 5
     */
    rateLimitUsd: string;
    /**
     * the absolute amount of tokens that can be minted on Injective
     *
     * @generated from protobuf field: string absolute_mint_limit = 6
     */
    absoluteMintLimit: string;
    /**
     * length of the sliding window in which inbound (outbound) traffic is
     * measured
     *
     * @generated from protobuf field: uint64 rate_limit_window = 7
     */
    rateLimitWindow: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgCreateRateLimitResponse
 */
export interface MsgCreateRateLimitResponse {
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgUpdateRateLimit
 */
export interface MsgUpdateRateLimit {
    /**
     * authority is the address of peggy admin or governance account
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * token_address is the address of rate limited token
     *
     * @generated from protobuf field: string token_address = 2
     */
    tokenAddress: string;
    /**
     * new_token_price_id is the new Pyth price ID of the rate limited token
     *
     * @generated from protobuf field: string new_token_price_id = 3
     */
    newTokenPriceId: string;
    /**
     * new_rate_limit_usd is the new notional limit (on withdrawals) in USD
     *
     * @generated from protobuf field: string new_rate_limit_usd = 4
     */
    newRateLimitUsd: string;
    /**
     * new_rate_limit_window is the new length of the sliding window
     *
     * @generated from protobuf field: uint64 new_rate_limit_window = 5
     */
    newRateLimitWindow: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgUpdateRateLimitResponse
 */
export interface MsgUpdateRateLimitResponse {
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgRemoveRateLimit
 */
export interface MsgRemoveRateLimit {
    /**
     * authority is the address of peggy admin or governance account
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * token_address is the address of rate limited token
     *
     * @generated from protobuf field: string token_address = 2
     */
    tokenAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.MsgRemoveRateLimitResponse
 */
export interface MsgRemoveRateLimitResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgSetOrchestratorAddresses$Type extends MessageType<MsgSetOrchestratorAddresses> {
    constructor() {
        super("injective.peggy.v1.MsgSetOrchestratorAddresses", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "eth_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgSetOrchestratorAddresses", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgSetOrchestratorAddresses>): MsgSetOrchestratorAddresses {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.orchestrator = "";
        message.ethAddress = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSetOrchestratorAddresses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSetOrchestratorAddresses): MsgSetOrchestratorAddresses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string orchestrator */ 2:
                    message.orchestrator = reader.string();
                    break;
                case /* string eth_address */ 3:
                    message.ethAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSetOrchestratorAddresses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string orchestrator = 2; */
        if (message.orchestrator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestrator);
        /* string eth_address = 3; */
        if (message.ethAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ethAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgSetOrchestratorAddresses
 */
export const MsgSetOrchestratorAddresses = new MsgSetOrchestratorAddresses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSetOrchestratorAddressesResponse$Type extends MessageType<MsgSetOrchestratorAddressesResponse> {
    constructor() {
        super("injective.peggy.v1.MsgSetOrchestratorAddressesResponse", []);
    }
    create(value?: PartialMessage<MsgSetOrchestratorAddressesResponse>): MsgSetOrchestratorAddressesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSetOrchestratorAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSetOrchestratorAddressesResponse): MsgSetOrchestratorAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSetOrchestratorAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgSetOrchestratorAddressesResponse
 */
export const MsgSetOrchestratorAddressesResponse = new MsgSetOrchestratorAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgValsetConfirm$Type extends MessageType<MsgValsetConfirm> {
    constructor() {
        super("injective.peggy.v1.MsgValsetConfirm", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "eth_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgValsetConfirm", "cosmos.msg.v1.signer": ["orchestrator"] });
    }
    create(value?: PartialMessage<MsgValsetConfirm>): MsgValsetConfirm {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        message.orchestrator = "";
        message.ethAddress = "";
        message.signature = "";
        if (value !== undefined)
            reflectionMergePartial<MsgValsetConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgValsetConfirm): MsgValsetConfirm {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string orchestrator */ 2:
                    message.orchestrator = reader.string();
                    break;
                case /* string eth_address */ 3:
                    message.ethAddress = reader.string();
                    break;
                case /* string signature */ 4:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgValsetConfirm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        /* string orchestrator = 2; */
        if (message.orchestrator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestrator);
        /* string eth_address = 3; */
        if (message.ethAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ethAddress);
        /* string signature = 4; */
        if (message.signature !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgValsetConfirm
 */
export const MsgValsetConfirm = new MsgValsetConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgValsetConfirmResponse$Type extends MessageType<MsgValsetConfirmResponse> {
    constructor() {
        super("injective.peggy.v1.MsgValsetConfirmResponse", []);
    }
    create(value?: PartialMessage<MsgValsetConfirmResponse>): MsgValsetConfirmResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgValsetConfirmResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgValsetConfirmResponse): MsgValsetConfirmResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgValsetConfirmResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgValsetConfirmResponse
 */
export const MsgValsetConfirmResponse = new MsgValsetConfirmResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSendToEth$Type extends MessageType<MsgSendToEth> {
    constructor() {
        super("injective.peggy.v1.MsgSendToEth", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eth_dest", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 4, name: "bridge_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "peggy/MsgSendToEth", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgSendToEth>): MsgSendToEth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.ethDest = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSendToEth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSendToEth): MsgSendToEth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string eth_dest */ 2:
                    message.ethDest = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin amount */ 3:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                case /* cosmos.base.v1beta1.Coin bridge_fee */ 4:
                    message.bridgeFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.bridgeFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSendToEth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string eth_dest = 2; */
        if (message.ethDest !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ethDest);
        /* cosmos.base.v1beta1.Coin amount = 3; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin bridge_fee = 4; */
        if (message.bridgeFee)
            Coin.internalBinaryWrite(message.bridgeFee, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgSendToEth
 */
export const MsgSendToEth = new MsgSendToEth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSendToEthResponse$Type extends MessageType<MsgSendToEthResponse> {
    constructor() {
        super("injective.peggy.v1.MsgSendToEthResponse", []);
    }
    create(value?: PartialMessage<MsgSendToEthResponse>): MsgSendToEthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSendToEthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSendToEthResponse): MsgSendToEthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSendToEthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgSendToEthResponse
 */
export const MsgSendToEthResponse = new MsgSendToEthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRequestBatch$Type extends MessageType<MsgRequestBatch> {
    constructor() {
        super("injective.peggy.v1.MsgRequestBatch", [
            { no: 1, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgRequestBatch", "cosmos.msg.v1.signer": ["orchestrator"] });
    }
    create(value?: PartialMessage<MsgRequestBatch>): MsgRequestBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orchestrator = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<MsgRequestBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRequestBatch): MsgRequestBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string orchestrator */ 1:
                    message.orchestrator = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRequestBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string orchestrator = 1; */
        if (message.orchestrator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orchestrator);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgRequestBatch
 */
export const MsgRequestBatch = new MsgRequestBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRequestBatchResponse$Type extends MessageType<MsgRequestBatchResponse> {
    constructor() {
        super("injective.peggy.v1.MsgRequestBatchResponse", []);
    }
    create(value?: PartialMessage<MsgRequestBatchResponse>): MsgRequestBatchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRequestBatchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRequestBatchResponse): MsgRequestBatchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRequestBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgRequestBatchResponse
 */
export const MsgRequestBatchResponse = new MsgRequestBatchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConfirmBatch$Type extends MessageType<MsgConfirmBatch> {
    constructor() {
        super("injective.peggy.v1.MsgConfirmBatch", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "token_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "eth_signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgConfirmBatch", "cosmos.msg.v1.signer": ["orchestrator"] });
    }
    create(value?: PartialMessage<MsgConfirmBatch>): MsgConfirmBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        message.tokenContract = "";
        message.ethSigner = "";
        message.orchestrator = "";
        message.signature = "";
        if (value !== undefined)
            reflectionMergePartial<MsgConfirmBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConfirmBatch): MsgConfirmBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string token_contract */ 2:
                    message.tokenContract = reader.string();
                    break;
                case /* string eth_signer */ 3:
                    message.ethSigner = reader.string();
                    break;
                case /* string orchestrator */ 4:
                    message.orchestrator = reader.string();
                    break;
                case /* string signature */ 5:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConfirmBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        /* string token_contract = 2; */
        if (message.tokenContract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenContract);
        /* string eth_signer = 3; */
        if (message.ethSigner !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ethSigner);
        /* string orchestrator = 4; */
        if (message.orchestrator !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orchestrator);
        /* string signature = 5; */
        if (message.signature !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgConfirmBatch
 */
export const MsgConfirmBatch = new MsgConfirmBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConfirmBatchResponse$Type extends MessageType<MsgConfirmBatchResponse> {
    constructor() {
        super("injective.peggy.v1.MsgConfirmBatchResponse", []);
    }
    create(value?: PartialMessage<MsgConfirmBatchResponse>): MsgConfirmBatchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgConfirmBatchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConfirmBatchResponse): MsgConfirmBatchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConfirmBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgConfirmBatchResponse
 */
export const MsgConfirmBatchResponse = new MsgConfirmBatchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositClaim$Type extends MessageType<MsgDepositClaim> {
    constructor() {
        super("injective.peggy.v1.MsgDepositClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "block_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "token_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 5, name: "ethereum_sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "cosmos_receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgDepositClaim", "cosmos.msg.v1.signer": ["orchestrator"] });
    }
    create(value?: PartialMessage<MsgDepositClaim>): MsgDepositClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.blockHeight = 0n;
        message.tokenContract = "";
        message.amount = "";
        message.ethereumSender = "";
        message.cosmosReceiver = "";
        message.orchestrator = "";
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<MsgDepositClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositClaim): MsgDepositClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 block_height */ 2:
                    message.blockHeight = reader.uint64().toBigInt();
                    break;
                case /* string token_contract */ 3:
                    message.tokenContract = reader.string();
                    break;
                case /* string amount */ 4:
                    message.amount = reader.string();
                    break;
                case /* string ethereum_sender */ 5:
                    message.ethereumSender = reader.string();
                    break;
                case /* string cosmos_receiver */ 6:
                    message.cosmosReceiver = reader.string();
                    break;
                case /* string orchestrator */ 7:
                    message.orchestrator = reader.string();
                    break;
                case /* string data */ 8:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDepositClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 block_height = 2; */
        if (message.blockHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockHeight);
        /* string token_contract = 3; */
        if (message.tokenContract !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tokenContract);
        /* string amount = 4; */
        if (message.amount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.amount);
        /* string ethereum_sender = 5; */
        if (message.ethereumSender !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ethereumSender);
        /* string cosmos_receiver = 6; */
        if (message.cosmosReceiver !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cosmosReceiver);
        /* string orchestrator = 7; */
        if (message.orchestrator !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.orchestrator);
        /* string data = 8; */
        if (message.data !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgDepositClaim
 */
export const MsgDepositClaim = new MsgDepositClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositClaimResponse$Type extends MessageType<MsgDepositClaimResponse> {
    constructor() {
        super("injective.peggy.v1.MsgDepositClaimResponse", []);
    }
    create(value?: PartialMessage<MsgDepositClaimResponse>): MsgDepositClaimResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgDepositClaimResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositClaimResponse): MsgDepositClaimResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDepositClaimResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgDepositClaimResponse
 */
export const MsgDepositClaimResponse = new MsgDepositClaimResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawClaim$Type extends MessageType<MsgWithdrawClaim> {
    constructor() {
        super("injective.peggy.v1.MsgWithdrawClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "block_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "batch_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "token_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgWithdrawClaim", "cosmos.msg.v1.signer": ["orchestrator"] });
    }
    create(value?: PartialMessage<MsgWithdrawClaim>): MsgWithdrawClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.blockHeight = 0n;
        message.batchNonce = 0n;
        message.tokenContract = "";
        message.orchestrator = "";
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawClaim): MsgWithdrawClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 block_height */ 2:
                    message.blockHeight = reader.uint64().toBigInt();
                    break;
                case /* uint64 batch_nonce */ 3:
                    message.batchNonce = reader.uint64().toBigInt();
                    break;
                case /* string token_contract */ 4:
                    message.tokenContract = reader.string();
                    break;
                case /* string orchestrator */ 5:
                    message.orchestrator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 block_height = 2; */
        if (message.blockHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockHeight);
        /* uint64 batch_nonce = 3; */
        if (message.batchNonce !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.batchNonce);
        /* string token_contract = 4; */
        if (message.tokenContract !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tokenContract);
        /* string orchestrator = 5; */
        if (message.orchestrator !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.orchestrator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgWithdrawClaim
 */
export const MsgWithdrawClaim = new MsgWithdrawClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawClaimResponse$Type extends MessageType<MsgWithdrawClaimResponse> {
    constructor() {
        super("injective.peggy.v1.MsgWithdrawClaimResponse", []);
    }
    create(value?: PartialMessage<MsgWithdrawClaimResponse>): MsgWithdrawClaimResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawClaimResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawClaimResponse): MsgWithdrawClaimResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawClaimResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgWithdrawClaimResponse
 */
export const MsgWithdrawClaimResponse = new MsgWithdrawClaimResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgERC20DeployedClaim$Type extends MessageType<MsgERC20DeployedClaim> {
    constructor() {
        super("injective.peggy.v1.MsgERC20DeployedClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "block_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "cosmos_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "token_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "decimals", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgERC20DeployedClaim", "cosmos.msg.v1.signer": ["orchestrator"] });
    }
    create(value?: PartialMessage<MsgERC20DeployedClaim>): MsgERC20DeployedClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.blockHeight = 0n;
        message.cosmosDenom = "";
        message.tokenContract = "";
        message.name = "";
        message.symbol = "";
        message.decimals = 0n;
        message.orchestrator = "";
        if (value !== undefined)
            reflectionMergePartial<MsgERC20DeployedClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgERC20DeployedClaim): MsgERC20DeployedClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 block_height */ 2:
                    message.blockHeight = reader.uint64().toBigInt();
                    break;
                case /* string cosmos_denom */ 3:
                    message.cosmosDenom = reader.string();
                    break;
                case /* string token_contract */ 4:
                    message.tokenContract = reader.string();
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 6:
                    message.symbol = reader.string();
                    break;
                case /* uint64 decimals */ 7:
                    message.decimals = reader.uint64().toBigInt();
                    break;
                case /* string orchestrator */ 8:
                    message.orchestrator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgERC20DeployedClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 block_height = 2; */
        if (message.blockHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockHeight);
        /* string cosmos_denom = 3; */
        if (message.cosmosDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cosmosDenom);
        /* string token_contract = 4; */
        if (message.tokenContract !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tokenContract);
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string symbol = 6; */
        if (message.symbol !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.symbol);
        /* uint64 decimals = 7; */
        if (message.decimals !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.decimals);
        /* string orchestrator = 8; */
        if (message.orchestrator !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.orchestrator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgERC20DeployedClaim
 */
export const MsgERC20DeployedClaim = new MsgERC20DeployedClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgERC20DeployedClaimResponse$Type extends MessageType<MsgERC20DeployedClaimResponse> {
    constructor() {
        super("injective.peggy.v1.MsgERC20DeployedClaimResponse", []);
    }
    create(value?: PartialMessage<MsgERC20DeployedClaimResponse>): MsgERC20DeployedClaimResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgERC20DeployedClaimResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgERC20DeployedClaimResponse): MsgERC20DeployedClaimResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgERC20DeployedClaimResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgERC20DeployedClaimResponse
 */
export const MsgERC20DeployedClaimResponse = new MsgERC20DeployedClaimResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelSendToEth$Type extends MessageType<MsgCancelSendToEth> {
    constructor() {
        super("injective.peggy.v1.MsgCancelSendToEth", [
            { no: 1, name: "transaction_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgCancelSendToEth", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgCancelSendToEth>): MsgCancelSendToEth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgCancelSendToEth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelSendToEth): MsgCancelSendToEth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 transaction_id */ 1:
                    message.transactionId = reader.uint64().toBigInt();
                    break;
                case /* string sender */ 2:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelSendToEth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 transaction_id = 1; */
        if (message.transactionId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.transactionId);
        /* string sender = 2; */
        if (message.sender !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgCancelSendToEth
 */
export const MsgCancelSendToEth = new MsgCancelSendToEth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCancelSendToEthResponse$Type extends MessageType<MsgCancelSendToEthResponse> {
    constructor() {
        super("injective.peggy.v1.MsgCancelSendToEthResponse", []);
    }
    create(value?: PartialMessage<MsgCancelSendToEthResponse>): MsgCancelSendToEthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCancelSendToEthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCancelSendToEthResponse): MsgCancelSendToEthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCancelSendToEthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgCancelSendToEthResponse
 */
export const MsgCancelSendToEthResponse = new MsgCancelSendToEthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubmitBadSignatureEvidence$Type extends MessageType<MsgSubmitBadSignatureEvidence> {
    constructor() {
        super("injective.peggy.v1.MsgSubmitBadSignatureEvidence", [
            { no: 1, name: "subject", kind: "message", T: () => Any },
            { no: 2, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgSubmitBadSignatureEvidence", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgSubmitBadSignatureEvidence>): MsgSubmitBadSignatureEvidence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signature = "";
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<MsgSubmitBadSignatureEvidence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubmitBadSignatureEvidence): MsgSubmitBadSignatureEvidence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any subject */ 1:
                    message.subject = Any.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* string signature */ 2:
                    message.signature = reader.string();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubmitBadSignatureEvidence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any subject = 1; */
        if (message.subject)
            Any.internalBinaryWrite(message.subject, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string signature = 2; */
        if (message.signature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signature);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgSubmitBadSignatureEvidence
 */
export const MsgSubmitBadSignatureEvidence = new MsgSubmitBadSignatureEvidence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubmitBadSignatureEvidenceResponse$Type extends MessageType<MsgSubmitBadSignatureEvidenceResponse> {
    constructor() {
        super("injective.peggy.v1.MsgSubmitBadSignatureEvidenceResponse", []);
    }
    create(value?: PartialMessage<MsgSubmitBadSignatureEvidenceResponse>): MsgSubmitBadSignatureEvidenceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgSubmitBadSignatureEvidenceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubmitBadSignatureEvidenceResponse): MsgSubmitBadSignatureEvidenceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubmitBadSignatureEvidenceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgSubmitBadSignatureEvidenceResponse
 */
export const MsgSubmitBadSignatureEvidenceResponse = new MsgSubmitBadSignatureEvidenceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgValsetUpdatedClaim$Type extends MessageType<MsgValsetUpdatedClaim> {
    constructor() {
        super("injective.peggy.v1.MsgValsetUpdatedClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "valset_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "block_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BridgeValidator },
            { no: 5, name: "reward_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 6, name: "reward_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "orchestrator", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgValsetUpdatedClaim", "cosmos.msg.v1.signer": ["orchestrator"] });
    }
    create(value?: PartialMessage<MsgValsetUpdatedClaim>): MsgValsetUpdatedClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.valsetNonce = 0n;
        message.blockHeight = 0n;
        message.members = [];
        message.rewardAmount = "";
        message.rewardToken = "";
        message.orchestrator = "";
        if (value !== undefined)
            reflectionMergePartial<MsgValsetUpdatedClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgValsetUpdatedClaim): MsgValsetUpdatedClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 valset_nonce */ 2:
                    message.valsetNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 block_height */ 3:
                    message.blockHeight = reader.uint64().toBigInt();
                    break;
                case /* repeated injective.peggy.v1.BridgeValidator members */ 4:
                    message.members.push(BridgeValidator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string reward_amount */ 5:
                    message.rewardAmount = reader.string();
                    break;
                case /* string reward_token */ 6:
                    message.rewardToken = reader.string();
                    break;
                case /* string orchestrator */ 7:
                    message.orchestrator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgValsetUpdatedClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 valset_nonce = 2; */
        if (message.valsetNonce !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.valsetNonce);
        /* uint64 block_height = 3; */
        if (message.blockHeight !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.blockHeight);
        /* repeated injective.peggy.v1.BridgeValidator members = 4; */
        for (let i = 0; i < message.members.length; i++)
            BridgeValidator.internalBinaryWrite(message.members[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string reward_amount = 5; */
        if (message.rewardAmount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.rewardAmount);
        /* string reward_token = 6; */
        if (message.rewardToken !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rewardToken);
        /* string orchestrator = 7; */
        if (message.orchestrator !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.orchestrator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgValsetUpdatedClaim
 */
export const MsgValsetUpdatedClaim = new MsgValsetUpdatedClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgValsetUpdatedClaimResponse$Type extends MessageType<MsgValsetUpdatedClaimResponse> {
    constructor() {
        super("injective.peggy.v1.MsgValsetUpdatedClaimResponse", []);
    }
    create(value?: PartialMessage<MsgValsetUpdatedClaimResponse>): MsgValsetUpdatedClaimResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgValsetUpdatedClaimResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgValsetUpdatedClaimResponse): MsgValsetUpdatedClaimResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgValsetUpdatedClaimResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgValsetUpdatedClaimResponse
 */
export const MsgValsetUpdatedClaimResponse = new MsgValsetUpdatedClaimResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("injective.peggy.v1.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "peggy/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* injective.peggy.v1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* injective.peggy.v1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("injective.peggy.v1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBlacklistEthereumAddresses$Type extends MessageType<MsgBlacklistEthereumAddresses> {
    constructor() {
        super("injective.peggy.v1.MsgBlacklistEthereumAddresses", [
            { no: 1, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blacklist_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgBlacklistEthereumAddresses", "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgBlacklistEthereumAddresses>): MsgBlacklistEthereumAddresses {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signer = "";
        message.blacklistAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<MsgBlacklistEthereumAddresses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBlacklistEthereumAddresses): MsgBlacklistEthereumAddresses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string signer */ 1:
                    message.signer = reader.string();
                    break;
                case /* repeated string blacklist_addresses */ 2:
                    message.blacklistAddresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBlacklistEthereumAddresses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string signer = 1; */
        if (message.signer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signer);
        /* repeated string blacklist_addresses = 2; */
        for (let i = 0; i < message.blacklistAddresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.blacklistAddresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgBlacklistEthereumAddresses
 */
export const MsgBlacklistEthereumAddresses = new MsgBlacklistEthereumAddresses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBlacklistEthereumAddressesResponse$Type extends MessageType<MsgBlacklistEthereumAddressesResponse> {
    constructor() {
        super("injective.peggy.v1.MsgBlacklistEthereumAddressesResponse", []);
    }
    create(value?: PartialMessage<MsgBlacklistEthereumAddressesResponse>): MsgBlacklistEthereumAddressesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgBlacklistEthereumAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBlacklistEthereumAddressesResponse): MsgBlacklistEthereumAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBlacklistEthereumAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgBlacklistEthereumAddressesResponse
 */
export const MsgBlacklistEthereumAddressesResponse = new MsgBlacklistEthereumAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRevokeEthereumBlacklist$Type extends MessageType<MsgRevokeEthereumBlacklist> {
    constructor() {
        super("injective.peggy.v1.MsgRevokeEthereumBlacklist", [
            { no: 1, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blacklist_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgRevokeEthereumBlacklist", "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgRevokeEthereumBlacklist>): MsgRevokeEthereumBlacklist {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signer = "";
        message.blacklistAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRevokeEthereumBlacklist>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRevokeEthereumBlacklist): MsgRevokeEthereumBlacklist {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string signer */ 1:
                    message.signer = reader.string();
                    break;
                case /* repeated string blacklist_addresses */ 2:
                    message.blacklistAddresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRevokeEthereumBlacklist, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string signer = 1; */
        if (message.signer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signer);
        /* repeated string blacklist_addresses = 2; */
        for (let i = 0; i < message.blacklistAddresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.blacklistAddresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgRevokeEthereumBlacklist
 */
export const MsgRevokeEthereumBlacklist = new MsgRevokeEthereumBlacklist$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRevokeEthereumBlacklistResponse$Type extends MessageType<MsgRevokeEthereumBlacklistResponse> {
    constructor() {
        super("injective.peggy.v1.MsgRevokeEthereumBlacklistResponse", []);
    }
    create(value?: PartialMessage<MsgRevokeEthereumBlacklistResponse>): MsgRevokeEthereumBlacklistResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRevokeEthereumBlacklistResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRevokeEthereumBlacklistResponse): MsgRevokeEthereumBlacklistResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRevokeEthereumBlacklistResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgRevokeEthereumBlacklistResponse
 */
export const MsgRevokeEthereumBlacklistResponse = new MsgRevokeEthereumBlacklistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateRateLimit$Type extends MessageType<MsgCreateRateLimit> {
    constructor() {
        super("injective.peggy.v1.MsgCreateRateLimit", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "token_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "token_price_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rate_limit_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 6, name: "absolute_mint_limit", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 7, name: "rate_limit_window", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "amino.name": "peggy/MsgCreateRateLimit", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgCreateRateLimit>): MsgCreateRateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.tokenAddress = "";
        message.tokenDecimals = 0;
        message.tokenPriceId = "";
        message.rateLimitUsd = "";
        message.absoluteMintLimit = "";
        message.rateLimitWindow = 0n;
        if (value !== undefined)
            reflectionMergePartial<MsgCreateRateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateRateLimit): MsgCreateRateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* string token_address */ 2:
                    message.tokenAddress = reader.string();
                    break;
                case /* uint32 token_decimals */ 3:
                    message.tokenDecimals = reader.uint32();
                    break;
                case /* string token_price_id */ 4:
                    message.tokenPriceId = reader.string();
                    break;
                case /* string rate_limit_usd */ 5:
                    message.rateLimitUsd = reader.string();
                    break;
                case /* string absolute_mint_limit */ 6:
                    message.absoluteMintLimit = reader.string();
                    break;
                case /* uint64 rate_limit_window */ 7:
                    message.rateLimitWindow = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateRateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* string token_address = 2; */
        if (message.tokenAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenAddress);
        /* uint32 token_decimals = 3; */
        if (message.tokenDecimals !== 0)
            writer.tag(3, WireType.Varint).uint32(message.tokenDecimals);
        /* string token_price_id = 4; */
        if (message.tokenPriceId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tokenPriceId);
        /* string rate_limit_usd = 5; */
        if (message.rateLimitUsd !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.rateLimitUsd);
        /* string absolute_mint_limit = 6; */
        if (message.absoluteMintLimit !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.absoluteMintLimit);
        /* uint64 rate_limit_window = 7; */
        if (message.rateLimitWindow !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.rateLimitWindow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgCreateRateLimit
 */
export const MsgCreateRateLimit = new MsgCreateRateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateRateLimitResponse$Type extends MessageType<MsgCreateRateLimitResponse> {
    constructor() {
        super("injective.peggy.v1.MsgCreateRateLimitResponse", []);
    }
    create(value?: PartialMessage<MsgCreateRateLimitResponse>): MsgCreateRateLimitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgCreateRateLimitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateRateLimitResponse): MsgCreateRateLimitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateRateLimitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgCreateRateLimitResponse
 */
export const MsgCreateRateLimitResponse = new MsgCreateRateLimitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateRateLimit$Type extends MessageType<MsgUpdateRateLimit> {
    constructor() {
        super("injective.peggy.v1.MsgUpdateRateLimit", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "token_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_token_price_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "new_rate_limit_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } },
            { no: 5, name: "new_rate_limit_window", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "amino.name": "peggy/MsgUpdateRateLimit", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateRateLimit>): MsgUpdateRateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.tokenAddress = "";
        message.newTokenPriceId = "";
        message.newRateLimitUsd = "";
        message.newRateLimitWindow = 0n;
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateRateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateRateLimit): MsgUpdateRateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* string token_address */ 2:
                    message.tokenAddress = reader.string();
                    break;
                case /* string new_token_price_id */ 3:
                    message.newTokenPriceId = reader.string();
                    break;
                case /* string new_rate_limit_usd */ 4:
                    message.newRateLimitUsd = reader.string();
                    break;
                case /* uint64 new_rate_limit_window */ 5:
                    message.newRateLimitWindow = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateRateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* string token_address = 2; */
        if (message.tokenAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenAddress);
        /* string new_token_price_id = 3; */
        if (message.newTokenPriceId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newTokenPriceId);
        /* string new_rate_limit_usd = 4; */
        if (message.newRateLimitUsd !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.newRateLimitUsd);
        /* uint64 new_rate_limit_window = 5; */
        if (message.newRateLimitWindow !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.newRateLimitWindow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgUpdateRateLimit
 */
export const MsgUpdateRateLimit = new MsgUpdateRateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateRateLimitResponse$Type extends MessageType<MsgUpdateRateLimitResponse> {
    constructor() {
        super("injective.peggy.v1.MsgUpdateRateLimitResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateRateLimitResponse>): MsgUpdateRateLimitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateRateLimitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateRateLimitResponse): MsgUpdateRateLimitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateRateLimitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgUpdateRateLimitResponse
 */
export const MsgUpdateRateLimitResponse = new MsgUpdateRateLimitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRemoveRateLimit$Type extends MessageType<MsgRemoveRateLimit> {
    constructor() {
        super("injective.peggy.v1.MsgRemoveRateLimit", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "token_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "amino.name": "peggy/MsgRemoveRateLimit", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgRemoveRateLimit>): MsgRemoveRateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.tokenAddress = "";
        if (value !== undefined)
            reflectionMergePartial<MsgRemoveRateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRemoveRateLimit): MsgRemoveRateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* string token_address */ 2:
                    message.tokenAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRemoveRateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* string token_address = 2; */
        if (message.tokenAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgRemoveRateLimit
 */
export const MsgRemoveRateLimit = new MsgRemoveRateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRemoveRateLimitResponse$Type extends MessageType<MsgRemoveRateLimitResponse> {
    constructor() {
        super("injective.peggy.v1.MsgRemoveRateLimitResponse", []);
    }
    create(value?: PartialMessage<MsgRemoveRateLimitResponse>): MsgRemoveRateLimitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRemoveRateLimitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRemoveRateLimitResponse): MsgRemoveRateLimitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRemoveRateLimitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgRemoveRateLimitResponse
 */
export const MsgRemoveRateLimitResponse = new MsgRemoveRateLimitResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.peggy.v1.Msg
 */
export const Msg = new ServiceType("injective.peggy.v1.Msg", [
    { name: "ValsetConfirm", options: { "google.api.http": { post: "/injective/peggy/v1/valset_confirm" } }, I: MsgValsetConfirm, O: MsgValsetConfirmResponse },
    { name: "SendToEth", options: { "google.api.http": { post: "/injective/peggy/v1/send_to_eth" } }, I: MsgSendToEth, O: MsgSendToEthResponse },
    { name: "RequestBatch", options: { "google.api.http": { post: "/injective/peggy/v1/request_batch" } }, I: MsgRequestBatch, O: MsgRequestBatchResponse },
    { name: "ConfirmBatch", options: { "google.api.http": { post: "/injective/peggy/v1/confirm_batch" } }, I: MsgConfirmBatch, O: MsgConfirmBatchResponse },
    { name: "DepositClaim", options: { "google.api.http": { post: "/injective/peggy/v1/deposit_claim" } }, I: MsgDepositClaim, O: MsgDepositClaimResponse },
    { name: "WithdrawClaim", options: { "google.api.http": { post: "/injective/peggy/v1/withdraw_claim" } }, I: MsgWithdrawClaim, O: MsgWithdrawClaimResponse },
    { name: "ValsetUpdateClaim", options: { "google.api.http": { post: "/injective/peggy/v1/valset_updated_claim" } }, I: MsgValsetUpdatedClaim, O: MsgValsetUpdatedClaimResponse },
    { name: "ERC20DeployedClaim", options: { "google.api.http": { post: "/injective/peggy/v1/erc20_deployed_claim" } }, I: MsgERC20DeployedClaim, O: MsgERC20DeployedClaimResponse },
    { name: "SetOrchestratorAddresses", options: { "google.api.http": { post: "/injective/peggy/v1/set_orchestrator_address" } }, I: MsgSetOrchestratorAddresses, O: MsgSetOrchestratorAddressesResponse },
    { name: "CancelSendToEth", options: { "google.api.http": { post: "/injective/peggy/v1/cancel_send_to_eth" } }, I: MsgCancelSendToEth, O: MsgCancelSendToEthResponse },
    { name: "SubmitBadSignatureEvidence", options: { "google.api.http": { post: "/injective/peggy/v1/submit_bad_signature_evidence" } }, I: MsgSubmitBadSignatureEvidence, O: MsgSubmitBadSignatureEvidenceResponse },
    { name: "UpdateParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse },
    { name: "BlacklistEthereumAddresses", options: {}, I: MsgBlacklistEthereumAddresses, O: MsgBlacklistEthereumAddressesResponse },
    { name: "RevokeEthereumBlacklist", options: {}, I: MsgRevokeEthereumBlacklist, O: MsgRevokeEthereumBlacklistResponse },
    { name: "CreateRateLimit", options: {}, I: MsgCreateRateLimit, O: MsgCreateRateLimitResponse },
    { name: "UpdateRateLimit", options: {}, I: MsgUpdateRateLimit, O: MsgUpdateRateLimitResponse },
    { name: "RemoveRateLimit", options: {}, I: MsgRemoveRateLimit, O: MsgRemoveRateLimitResponse }
], { "cosmos.msg.v1.service": true });
