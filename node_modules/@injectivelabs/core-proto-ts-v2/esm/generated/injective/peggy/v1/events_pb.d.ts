// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/peggy/v1/events.proto" (package "injective.peggy.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BridgeValidator } from "./types_pb";
import { ClaimType } from "./attestation_pb";
/**
 * @generated from protobuf message injective.peggy.v1.EventAttestationObserved
 */
export interface EventAttestationObserved {
    /**
     * @generated from protobuf field: injective.peggy.v1.ClaimType attestation_type = 1
     */
    attestationType: ClaimType;
    /**
     * @generated from protobuf field: string bridge_contract = 2
     */
    bridgeContract: string;
    /**
     * @generated from protobuf field: uint64 bridge_chain_id = 3
     */
    bridgeChainId: bigint;
    /**
     * @generated from protobuf field: bytes attestation_id = 4
     */
    attestationId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 nonce = 5
     */
    nonce: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventBridgeWithdrawCanceled
 */
export interface EventBridgeWithdrawCanceled {
    /**
     * @generated from protobuf field: string bridge_contract = 1
     */
    bridgeContract: string;
    /**
     * @generated from protobuf field: uint64 bridge_chain_id = 2
     */
    bridgeChainId: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventOutgoingBatch
 */
export interface EventOutgoingBatch {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string orchestrator_address = 2
     */
    orchestratorAddress: string;
    /**
     * @generated from protobuf field: uint64 batch_nonce = 3
     */
    batchNonce: bigint;
    /**
     * @generated from protobuf field: uint64 batch_timeout = 4
     */
    batchTimeout: bigint;
    /**
     * @generated from protobuf field: repeated uint64 batch_tx_ids = 5
     */
    batchTxIds: bigint[];
}
/**
 * @generated from protobuf message injective.peggy.v1.EventOutgoingBatchCanceled
 */
export interface EventOutgoingBatchCanceled {
    /**
     * @generated from protobuf field: string bridge_contract = 1
     */
    bridgeContract: string;
    /**
     * @generated from protobuf field: uint64 bridge_chain_id = 2
     */
    bridgeChainId: bigint;
    /**
     * @generated from protobuf field: uint64 batch_id = 3
     */
    batchId: bigint;
    /**
     * @generated from protobuf field: uint64 nonce = 4
     */
    nonce: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventValsetUpdateRequest
 */
export interface EventValsetUpdateRequest {
    /**
     * @generated from protobuf field: uint64 valset_nonce = 1
     */
    valsetNonce: bigint;
    /**
     * @generated from protobuf field: uint64 valset_height = 2
     */
    valsetHeight: bigint;
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.BridgeValidator valset_members = 3
     */
    valsetMembers: BridgeValidator[];
    /**
     * @generated from protobuf field: string reward_amount = 4
     */
    rewardAmount: string;
    /**
     * @generated from protobuf field: string reward_token = 5
     */
    rewardToken: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventSetOrchestratorAddresses
 */
export interface EventSetOrchestratorAddresses {
    /**
     * @generated from protobuf field: string validator_address = 1
     */
    validatorAddress: string;
    /**
     * @generated from protobuf field: string orchestrator_address = 2
     */
    orchestratorAddress: string;
    /**
     * @generated from protobuf field: string operator_eth_address = 3
     */
    operatorEthAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventValsetConfirm
 */
export interface EventValsetConfirm {
    /**
     * @generated from protobuf field: uint64 valset_nonce = 1
     */
    valsetNonce: bigint;
    /**
     * @generated from protobuf field: string orchestrator_address = 2
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventSendToEth
 */
export interface EventSendToEth {
    /**
     * @generated from protobuf field: uint64 outgoing_tx_id = 1
     */
    outgoingTxId: bigint;
    /**
     * @generated from protobuf field: string sender = 2
     */
    sender: string;
    /**
     * @generated from protobuf field: string receiver = 3
     */
    receiver: string;
    /**
     * @generated from protobuf field: string amount = 4
     */
    amount: string;
    /**
     * @generated from protobuf field: string bridge_fee = 5
     */
    bridgeFee: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventConfirmBatch
 */
export interface EventConfirmBatch {
    /**
     * @generated from protobuf field: uint64 batch_nonce = 1
     */
    batchNonce: bigint;
    /**
     * @generated from protobuf field: string orchestrator_address = 2
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventAttestationVote
 */
export interface EventAttestationVote {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: bytes attestation_id = 2
     */
    attestationId: Uint8Array;
    /**
     * @generated from protobuf field: string voter = 3
     */
    voter: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventDepositClaim
 */
export interface EventDepositClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 event_height = 2
     */
    eventHeight: bigint;
    /**
     * @generated from protobuf field: bytes attestation_id = 3
     */
    attestationId: Uint8Array;
    /**
     * @generated from protobuf field: string ethereum_sender = 4
     */
    ethereumSender: string;
    /**
     * @generated from protobuf field: string cosmos_receiver = 5
     */
    cosmosReceiver: string;
    /**
     * @generated from protobuf field: string token_contract = 6
     */
    tokenContract: string;
    /**
     * @generated from protobuf field: string amount = 7
     */
    amount: string;
    /**
     * @generated from protobuf field: string orchestrator_address = 8
     */
    orchestratorAddress: string;
    /**
     * @generated from protobuf field: string data = 9
     */
    data: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventWithdrawClaim
 */
export interface EventWithdrawClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 event_height = 2
     */
    eventHeight: bigint;
    /**
     * @generated from protobuf field: bytes attestation_id = 3
     */
    attestationId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 batch_nonce = 4
     */
    batchNonce: bigint;
    /**
     * @generated from protobuf field: string token_contract = 5
     */
    tokenContract: string;
    /**
     * @generated from protobuf field: string orchestrator_address = 6
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventERC20DeployedClaim
 */
export interface EventERC20DeployedClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 event_height = 2
     */
    eventHeight: bigint;
    /**
     * @generated from protobuf field: bytes attestation_id = 3
     */
    attestationId: Uint8Array;
    /**
     * @generated from protobuf field: string cosmos_denom = 4
     */
    cosmosDenom: string;
    /**
     * @generated from protobuf field: string token_contract = 5
     */
    tokenContract: string;
    /**
     * @generated from protobuf field: string name = 6
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 7
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint64 decimals = 8
     */
    decimals: bigint;
    /**
     * @generated from protobuf field: string orchestrator_address = 9
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventValsetUpdateClaim
 */
export interface EventValsetUpdateClaim {
    /**
     * @generated from protobuf field: uint64 event_nonce = 1
     */
    eventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 event_height = 2
     */
    eventHeight: bigint;
    /**
     * @generated from protobuf field: bytes attestation_id = 3
     */
    attestationId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 valset_nonce = 4
     */
    valsetNonce: bigint;
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.BridgeValidator valset_members = 5
     */
    valsetMembers: BridgeValidator[];
    /**
     * @generated from protobuf field: string reward_amount = 6
     */
    rewardAmount: string;
    /**
     * @generated from protobuf field: string reward_token = 7
     */
    rewardToken: string;
    /**
     * @generated from protobuf field: string orchestrator_address = 8
     */
    orchestratorAddress: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventCancelSendToEth
 */
export interface EventCancelSendToEth {
    /**
     * @generated from protobuf field: uint64 outgoing_tx_id = 1
     */
    outgoingTxId: bigint;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventSubmitBadSignatureEvidence
 */
export interface EventSubmitBadSignatureEvidence {
    /**
     * @generated from protobuf field: string bad_eth_signature = 1
     */
    badEthSignature: string;
    /**
     * @generated from protobuf field: string bad_eth_signature_subject = 2
     */
    badEthSignatureSubject: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventValidatorSlash
 */
export interface EventValidatorSlash {
    /**
     * @generated from protobuf field: int64 power = 1
     */
    power: bigint;
    /**
     * @generated from protobuf field: string reason = 2
     */
    reason: string;
    /**
     * @generated from protobuf field: string consensus_address = 3
     */
    consensusAddress: string;
    /**
     * @generated from protobuf field: string operator_address = 4
     */
    operatorAddress: string;
    /**
     * @generated from protobuf field: string moniker = 5
     */
    moniker: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventDepositReceived
 */
export interface EventDepositReceived {
    /**
     * Ethereum sender address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Injective receiver address
     *
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * Coin deposited to Injective
     *
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventWithdrawalsCompleted
 */
export interface EventWithdrawalsCompleted {
    /**
     * token denom of each withdrawal
     *
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * individual withdrawals
     *
     * @generated from protobuf field: repeated injective.peggy.v1.Withdrawal withdrawals = 2
     */
    withdrawals: Withdrawal[];
}
/**
 * @generated from protobuf message injective.peggy.v1.Withdrawal
 */
export interface Withdrawal {
    /**
     * Injective sender address
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Ethereum receiver address
     *
     * @generated from protobuf field: string receiver = 2
     */
    receiver: string;
    /**
     * Amount of tokens withdrawn to Ethereum
     *
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
}
/**
 * @generated from protobuf message injective.peggy.v1.EventValidatorJailed
 */
export interface EventValidatorJailed {
    /**
     * @generated from protobuf field: injective.peggy.v1.JailReason reason = 1
     */
    reason: JailReason;
    /**
     * @generated from protobuf field: int64 power = 2
     */
    power: bigint;
    /**
     * @generated from protobuf field: string consensus_address = 3
     */
    consensusAddress: string;
    /**
     * @generated from protobuf field: string operator_address = 4
     */
    operatorAddress: string;
    /**
     * @generated from protobuf field: string moniker = 5
     */
    moniker: string;
}
/**
 * @generated from protobuf enum injective.peggy.v1.JailReason
 */
export enum JailReason {
    /**
     * @generated from protobuf enum value: MissingValsetConfirm = 0;
     */
    MissingValsetConfirm = 0,
    /**
     * @generated from protobuf enum value: MissingBatchConfirm = 1;
     */
    MissingBatchConfirm = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class EventAttestationObserved$Type extends MessageType<EventAttestationObserved> {
    constructor() {
        super("injective.peggy.v1.EventAttestationObserved", [
            { no: 1, name: "attestation_type", kind: "enum", T: () => ["injective.peggy.v1.ClaimType", ClaimType, "CLAIM_TYPE_"] },
            { no: 2, name: "bridge_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bridge_chain_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "attestation_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventAttestationObserved>): EventAttestationObserved {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attestationType = 0;
        message.bridgeContract = "";
        message.bridgeChainId = 0n;
        message.attestationId = new Uint8Array(0);
        message.nonce = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventAttestationObserved>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAttestationObserved): EventAttestationObserved {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.ClaimType attestation_type */ 1:
                    message.attestationType = reader.int32();
                    break;
                case /* string bridge_contract */ 2:
                    message.bridgeContract = reader.string();
                    break;
                case /* uint64 bridge_chain_id */ 3:
                    message.bridgeChainId = reader.uint64().toBigInt();
                    break;
                case /* bytes attestation_id */ 4:
                    message.attestationId = reader.bytes();
                    break;
                case /* uint64 nonce */ 5:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAttestationObserved, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.ClaimType attestation_type = 1; */
        if (message.attestationType !== 0)
            writer.tag(1, WireType.Varint).int32(message.attestationType);
        /* string bridge_contract = 2; */
        if (message.bridgeContract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bridgeContract);
        /* uint64 bridge_chain_id = 3; */
        if (message.bridgeChainId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.bridgeChainId);
        /* bytes attestation_id = 4; */
        if (message.attestationId.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.attestationId);
        /* uint64 nonce = 5; */
        if (message.nonce !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventAttestationObserved
 */
export const EventAttestationObserved = new EventAttestationObserved$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventBridgeWithdrawCanceled$Type extends MessageType<EventBridgeWithdrawCanceled> {
    constructor() {
        super("injective.peggy.v1.EventBridgeWithdrawCanceled", [
            { no: 1, name: "bridge_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bridge_chain_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventBridgeWithdrawCanceled>): EventBridgeWithdrawCanceled {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bridgeContract = "";
        message.bridgeChainId = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventBridgeWithdrawCanceled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventBridgeWithdrawCanceled): EventBridgeWithdrawCanceled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bridge_contract */ 1:
                    message.bridgeContract = reader.string();
                    break;
                case /* uint64 bridge_chain_id */ 2:
                    message.bridgeChainId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventBridgeWithdrawCanceled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bridge_contract = 1; */
        if (message.bridgeContract !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bridgeContract);
        /* uint64 bridge_chain_id = 2; */
        if (message.bridgeChainId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.bridgeChainId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventBridgeWithdrawCanceled
 */
export const EventBridgeWithdrawCanceled = new EventBridgeWithdrawCanceled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventOutgoingBatch$Type extends MessageType<EventOutgoingBatch> {
    constructor() {
        super("injective.peggy.v1.EventOutgoingBatch", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "batch_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "batch_timeout", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "batch_tx_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventOutgoingBatch>): EventOutgoingBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.orchestratorAddress = "";
        message.batchNonce = 0n;
        message.batchTimeout = 0n;
        message.batchTxIds = [];
        if (value !== undefined)
            reflectionMergePartial<EventOutgoingBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventOutgoingBatch): EventOutgoingBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string orchestrator_address */ 2:
                    message.orchestratorAddress = reader.string();
                    break;
                case /* uint64 batch_nonce */ 3:
                    message.batchNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 batch_timeout */ 4:
                    message.batchTimeout = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 batch_tx_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.batchTxIds.push(reader.uint64().toBigInt());
                    else
                        message.batchTxIds.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventOutgoingBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string orchestrator_address = 2; */
        if (message.orchestratorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestratorAddress);
        /* uint64 batch_nonce = 3; */
        if (message.batchNonce !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.batchNonce);
        /* uint64 batch_timeout = 4; */
        if (message.batchTimeout !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.batchTimeout);
        /* repeated uint64 batch_tx_ids = 5; */
        if (message.batchTxIds.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.batchTxIds.length; i++)
                writer.uint64(message.batchTxIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventOutgoingBatch
 */
export const EventOutgoingBatch = new EventOutgoingBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventOutgoingBatchCanceled$Type extends MessageType<EventOutgoingBatchCanceled> {
    constructor() {
        super("injective.peggy.v1.EventOutgoingBatchCanceled", [
            { no: 1, name: "bridge_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bridge_chain_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "batch_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventOutgoingBatchCanceled>): EventOutgoingBatchCanceled {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bridgeContract = "";
        message.bridgeChainId = 0n;
        message.batchId = 0n;
        message.nonce = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventOutgoingBatchCanceled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventOutgoingBatchCanceled): EventOutgoingBatchCanceled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bridge_contract */ 1:
                    message.bridgeContract = reader.string();
                    break;
                case /* uint64 bridge_chain_id */ 2:
                    message.bridgeChainId = reader.uint64().toBigInt();
                    break;
                case /* uint64 batch_id */ 3:
                    message.batchId = reader.uint64().toBigInt();
                    break;
                case /* uint64 nonce */ 4:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventOutgoingBatchCanceled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bridge_contract = 1; */
        if (message.bridgeContract !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bridgeContract);
        /* uint64 bridge_chain_id = 2; */
        if (message.bridgeChainId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.bridgeChainId);
        /* uint64 batch_id = 3; */
        if (message.batchId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.batchId);
        /* uint64 nonce = 4; */
        if (message.nonce !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventOutgoingBatchCanceled
 */
export const EventOutgoingBatchCanceled = new EventOutgoingBatchCanceled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventValsetUpdateRequest$Type extends MessageType<EventValsetUpdateRequest> {
    constructor() {
        super("injective.peggy.v1.EventValsetUpdateRequest", [
            { no: 1, name: "valset_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "valset_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "valset_members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BridgeValidator },
            { no: 4, name: "reward_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 5, name: "reward_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventValsetUpdateRequest>): EventValsetUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valsetNonce = 0n;
        message.valsetHeight = 0n;
        message.valsetMembers = [];
        message.rewardAmount = "";
        message.rewardToken = "";
        if (value !== undefined)
            reflectionMergePartial<EventValsetUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventValsetUpdateRequest): EventValsetUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 valset_nonce */ 1:
                    message.valsetNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 valset_height */ 2:
                    message.valsetHeight = reader.uint64().toBigInt();
                    break;
                case /* repeated injective.peggy.v1.BridgeValidator valset_members */ 3:
                    message.valsetMembers.push(BridgeValidator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string reward_amount */ 4:
                    message.rewardAmount = reader.string();
                    break;
                case /* string reward_token */ 5:
                    message.rewardToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventValsetUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 valset_nonce = 1; */
        if (message.valsetNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.valsetNonce);
        /* uint64 valset_height = 2; */
        if (message.valsetHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.valsetHeight);
        /* repeated injective.peggy.v1.BridgeValidator valset_members = 3; */
        for (let i = 0; i < message.valsetMembers.length; i++)
            BridgeValidator.internalBinaryWrite(message.valsetMembers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string reward_amount = 4; */
        if (message.rewardAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.rewardAmount);
        /* string reward_token = 5; */
        if (message.rewardToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.rewardToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventValsetUpdateRequest
 */
export const EventValsetUpdateRequest = new EventValsetUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSetOrchestratorAddresses$Type extends MessageType<EventSetOrchestratorAddresses> {
    constructor() {
        super("injective.peggy.v1.EventSetOrchestratorAddresses", [
            { no: 1, name: "validator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "operator_eth_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventSetOrchestratorAddresses>): EventSetOrchestratorAddresses {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validatorAddress = "";
        message.orchestratorAddress = "";
        message.operatorEthAddress = "";
        if (value !== undefined)
            reflectionMergePartial<EventSetOrchestratorAddresses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSetOrchestratorAddresses): EventSetOrchestratorAddresses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string validator_address */ 1:
                    message.validatorAddress = reader.string();
                    break;
                case /* string orchestrator_address */ 2:
                    message.orchestratorAddress = reader.string();
                    break;
                case /* string operator_eth_address */ 3:
                    message.operatorEthAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSetOrchestratorAddresses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string validator_address = 1; */
        if (message.validatorAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.validatorAddress);
        /* string orchestrator_address = 2; */
        if (message.orchestratorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestratorAddress);
        /* string operator_eth_address = 3; */
        if (message.operatorEthAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.operatorEthAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventSetOrchestratorAddresses
 */
export const EventSetOrchestratorAddresses = new EventSetOrchestratorAddresses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventValsetConfirm$Type extends MessageType<EventValsetConfirm> {
    constructor() {
        super("injective.peggy.v1.EventValsetConfirm", [
            { no: 1, name: "valset_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventValsetConfirm>): EventValsetConfirm {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valsetNonce = 0n;
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<EventValsetConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventValsetConfirm): EventValsetConfirm {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 valset_nonce */ 1:
                    message.valsetNonce = reader.uint64().toBigInt();
                    break;
                case /* string orchestrator_address */ 2:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventValsetConfirm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 valset_nonce = 1; */
        if (message.valsetNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.valsetNonce);
        /* string orchestrator_address = 2; */
        if (message.orchestratorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventValsetConfirm
 */
export const EventValsetConfirm = new EventValsetConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSendToEth$Type extends MessageType<EventSendToEth> {
    constructor() {
        super("injective.peggy.v1.EventSendToEth", [
            { no: 1, name: "outgoing_tx_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Coin" } },
            { no: 5, name: "bridge_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Coin" } }
        ]);
    }
    create(value?: PartialMessage<EventSendToEth>): EventSendToEth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.outgoingTxId = 0n;
        message.sender = "";
        message.receiver = "";
        message.amount = "";
        message.bridgeFee = "";
        if (value !== undefined)
            reflectionMergePartial<EventSendToEth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSendToEth): EventSendToEth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 outgoing_tx_id */ 1:
                    message.outgoingTxId = reader.uint64().toBigInt();
                    break;
                case /* string sender */ 2:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 3:
                    message.receiver = reader.string();
                    break;
                case /* string amount */ 4:
                    message.amount = reader.string();
                    break;
                case /* string bridge_fee */ 5:
                    message.bridgeFee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSendToEth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 outgoing_tx_id = 1; */
        if (message.outgoingTxId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.outgoingTxId);
        /* string sender = 2; */
        if (message.sender !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 3; */
        if (message.receiver !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.receiver);
        /* string amount = 4; */
        if (message.amount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.amount);
        /* string bridge_fee = 5; */
        if (message.bridgeFee !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.bridgeFee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventSendToEth
 */
export const EventSendToEth = new EventSendToEth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventConfirmBatch$Type extends MessageType<EventConfirmBatch> {
    constructor() {
        super("injective.peggy.v1.EventConfirmBatch", [
            { no: 1, name: "batch_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventConfirmBatch>): EventConfirmBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.batchNonce = 0n;
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<EventConfirmBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventConfirmBatch): EventConfirmBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 batch_nonce */ 1:
                    message.batchNonce = reader.uint64().toBigInt();
                    break;
                case /* string orchestrator_address */ 2:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventConfirmBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 batch_nonce = 1; */
        if (message.batchNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.batchNonce);
        /* string orchestrator_address = 2; */
        if (message.orchestratorAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventConfirmBatch
 */
export const EventConfirmBatch = new EventConfirmBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAttestationVote$Type extends MessageType<EventAttestationVote> {
    constructor() {
        super("injective.peggy.v1.EventAttestationVote", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "attestation_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "voter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventAttestationVote>): EventAttestationVote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.attestationId = new Uint8Array(0);
        message.voter = "";
        if (value !== undefined)
            reflectionMergePartial<EventAttestationVote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAttestationVote): EventAttestationVote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* bytes attestation_id */ 2:
                    message.attestationId = reader.bytes();
                    break;
                case /* string voter */ 3:
                    message.voter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAttestationVote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* bytes attestation_id = 2; */
        if (message.attestationId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.attestationId);
        /* string voter = 3; */
        if (message.voter !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.voter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventAttestationVote
 */
export const EventAttestationVote = new EventAttestationVote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventDepositClaim$Type extends MessageType<EventDepositClaim> {
    constructor() {
        super("injective.peggy.v1.EventDepositClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "attestation_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "ethereum_sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cosmos_receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "token_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 8, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventDepositClaim>): EventDepositClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.eventHeight = 0n;
        message.attestationId = new Uint8Array(0);
        message.ethereumSender = "";
        message.cosmosReceiver = "";
        message.tokenContract = "";
        message.amount = "";
        message.orchestratorAddress = "";
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<EventDepositClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventDepositClaim): EventDepositClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 event_height */ 2:
                    message.eventHeight = reader.uint64().toBigInt();
                    break;
                case /* bytes attestation_id */ 3:
                    message.attestationId = reader.bytes();
                    break;
                case /* string ethereum_sender */ 4:
                    message.ethereumSender = reader.string();
                    break;
                case /* string cosmos_receiver */ 5:
                    message.cosmosReceiver = reader.string();
                    break;
                case /* string token_contract */ 6:
                    message.tokenContract = reader.string();
                    break;
                case /* string amount */ 7:
                    message.amount = reader.string();
                    break;
                case /* string orchestrator_address */ 8:
                    message.orchestratorAddress = reader.string();
                    break;
                case /* string data */ 9:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventDepositClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 event_height = 2; */
        if (message.eventHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.eventHeight);
        /* bytes attestation_id = 3; */
        if (message.attestationId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.attestationId);
        /* string ethereum_sender = 4; */
        if (message.ethereumSender !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ethereumSender);
        /* string cosmos_receiver = 5; */
        if (message.cosmosReceiver !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cosmosReceiver);
        /* string token_contract = 6; */
        if (message.tokenContract !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.tokenContract);
        /* string amount = 7; */
        if (message.amount !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.amount);
        /* string orchestrator_address = 8; */
        if (message.orchestratorAddress !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.orchestratorAddress);
        /* string data = 9; */
        if (message.data !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventDepositClaim
 */
export const EventDepositClaim = new EventDepositClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventWithdrawClaim$Type extends MessageType<EventWithdrawClaim> {
    constructor() {
        super("injective.peggy.v1.EventWithdrawClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "attestation_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "batch_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "token_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventWithdrawClaim>): EventWithdrawClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.eventHeight = 0n;
        message.attestationId = new Uint8Array(0);
        message.batchNonce = 0n;
        message.tokenContract = "";
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<EventWithdrawClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventWithdrawClaim): EventWithdrawClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 event_height */ 2:
                    message.eventHeight = reader.uint64().toBigInt();
                    break;
                case /* bytes attestation_id */ 3:
                    message.attestationId = reader.bytes();
                    break;
                case /* uint64 batch_nonce */ 4:
                    message.batchNonce = reader.uint64().toBigInt();
                    break;
                case /* string token_contract */ 5:
                    message.tokenContract = reader.string();
                    break;
                case /* string orchestrator_address */ 6:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventWithdrawClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 event_height = 2; */
        if (message.eventHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.eventHeight);
        /* bytes attestation_id = 3; */
        if (message.attestationId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.attestationId);
        /* uint64 batch_nonce = 4; */
        if (message.batchNonce !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.batchNonce);
        /* string token_contract = 5; */
        if (message.tokenContract !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tokenContract);
        /* string orchestrator_address = 6; */
        if (message.orchestratorAddress !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventWithdrawClaim
 */
export const EventWithdrawClaim = new EventWithdrawClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventERC20DeployedClaim$Type extends MessageType<EventERC20DeployedClaim> {
    constructor() {
        super("injective.peggy.v1.EventERC20DeployedClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "attestation_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "cosmos_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "token_contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "decimals", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventERC20DeployedClaim>): EventERC20DeployedClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.eventHeight = 0n;
        message.attestationId = new Uint8Array(0);
        message.cosmosDenom = "";
        message.tokenContract = "";
        message.name = "";
        message.symbol = "";
        message.decimals = 0n;
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<EventERC20DeployedClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventERC20DeployedClaim): EventERC20DeployedClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 event_height */ 2:
                    message.eventHeight = reader.uint64().toBigInt();
                    break;
                case /* bytes attestation_id */ 3:
                    message.attestationId = reader.bytes();
                    break;
                case /* string cosmos_denom */ 4:
                    message.cosmosDenom = reader.string();
                    break;
                case /* string token_contract */ 5:
                    message.tokenContract = reader.string();
                    break;
                case /* string name */ 6:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 7:
                    message.symbol = reader.string();
                    break;
                case /* uint64 decimals */ 8:
                    message.decimals = reader.uint64().toBigInt();
                    break;
                case /* string orchestrator_address */ 9:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventERC20DeployedClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 event_height = 2; */
        if (message.eventHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.eventHeight);
        /* bytes attestation_id = 3; */
        if (message.attestationId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.attestationId);
        /* string cosmos_denom = 4; */
        if (message.cosmosDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cosmosDenom);
        /* string token_contract = 5; */
        if (message.tokenContract !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tokenContract);
        /* string name = 6; */
        if (message.name !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        /* string symbol = 7; */
        if (message.symbol !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.symbol);
        /* uint64 decimals = 8; */
        if (message.decimals !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.decimals);
        /* string orchestrator_address = 9; */
        if (message.orchestratorAddress !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventERC20DeployedClaim
 */
export const EventERC20DeployedClaim = new EventERC20DeployedClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventValsetUpdateClaim$Type extends MessageType<EventValsetUpdateClaim> {
    constructor() {
        super("injective.peggy.v1.EventValsetUpdateClaim", [
            { no: 1, name: "event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "attestation_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "valset_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "valset_members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BridgeValidator },
            { no: 6, name: "reward_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 7, name: "reward_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "orchestrator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventValsetUpdateClaim>): EventValsetUpdateClaim {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventNonce = 0n;
        message.eventHeight = 0n;
        message.attestationId = new Uint8Array(0);
        message.valsetNonce = 0n;
        message.valsetMembers = [];
        message.rewardAmount = "";
        message.rewardToken = "";
        message.orchestratorAddress = "";
        if (value !== undefined)
            reflectionMergePartial<EventValsetUpdateClaim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventValsetUpdateClaim): EventValsetUpdateClaim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 event_nonce */ 1:
                    message.eventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 event_height */ 2:
                    message.eventHeight = reader.uint64().toBigInt();
                    break;
                case /* bytes attestation_id */ 3:
                    message.attestationId = reader.bytes();
                    break;
                case /* uint64 valset_nonce */ 4:
                    message.valsetNonce = reader.uint64().toBigInt();
                    break;
                case /* repeated injective.peggy.v1.BridgeValidator valset_members */ 5:
                    message.valsetMembers.push(BridgeValidator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string reward_amount */ 6:
                    message.rewardAmount = reader.string();
                    break;
                case /* string reward_token */ 7:
                    message.rewardToken = reader.string();
                    break;
                case /* string orchestrator_address */ 8:
                    message.orchestratorAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventValsetUpdateClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 event_nonce = 1; */
        if (message.eventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.eventNonce);
        /* uint64 event_height = 2; */
        if (message.eventHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.eventHeight);
        /* bytes attestation_id = 3; */
        if (message.attestationId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.attestationId);
        /* uint64 valset_nonce = 4; */
        if (message.valsetNonce !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.valsetNonce);
        /* repeated injective.peggy.v1.BridgeValidator valset_members = 5; */
        for (let i = 0; i < message.valsetMembers.length; i++)
            BridgeValidator.internalBinaryWrite(message.valsetMembers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string reward_amount = 6; */
        if (message.rewardAmount !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rewardAmount);
        /* string reward_token = 7; */
        if (message.rewardToken !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.rewardToken);
        /* string orchestrator_address = 8; */
        if (message.orchestratorAddress !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.orchestratorAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventValsetUpdateClaim
 */
export const EventValsetUpdateClaim = new EventValsetUpdateClaim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventCancelSendToEth$Type extends MessageType<EventCancelSendToEth> {
    constructor() {
        super("injective.peggy.v1.EventCancelSendToEth", [
            { no: 1, name: "outgoing_tx_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EventCancelSendToEth>): EventCancelSendToEth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.outgoingTxId = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventCancelSendToEth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventCancelSendToEth): EventCancelSendToEth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 outgoing_tx_id */ 1:
                    message.outgoingTxId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventCancelSendToEth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 outgoing_tx_id = 1; */
        if (message.outgoingTxId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.outgoingTxId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventCancelSendToEth
 */
export const EventCancelSendToEth = new EventCancelSendToEth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSubmitBadSignatureEvidence$Type extends MessageType<EventSubmitBadSignatureEvidence> {
    constructor() {
        super("injective.peggy.v1.EventSubmitBadSignatureEvidence", [
            { no: 1, name: "bad_eth_signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bad_eth_signature_subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventSubmitBadSignatureEvidence>): EventSubmitBadSignatureEvidence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.badEthSignature = "";
        message.badEthSignatureSubject = "";
        if (value !== undefined)
            reflectionMergePartial<EventSubmitBadSignatureEvidence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSubmitBadSignatureEvidence): EventSubmitBadSignatureEvidence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bad_eth_signature */ 1:
                    message.badEthSignature = reader.string();
                    break;
                case /* string bad_eth_signature_subject */ 2:
                    message.badEthSignatureSubject = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSubmitBadSignatureEvidence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bad_eth_signature = 1; */
        if (message.badEthSignature !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.badEthSignature);
        /* string bad_eth_signature_subject = 2; */
        if (message.badEthSignatureSubject !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.badEthSignatureSubject);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventSubmitBadSignatureEvidence
 */
export const EventSubmitBadSignatureEvidence = new EventSubmitBadSignatureEvidence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventValidatorSlash$Type extends MessageType<EventValidatorSlash> {
    constructor() {
        super("injective.peggy.v1.EventValidatorSlash", [
            { no: 1, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consensus_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "operator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "moniker", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventValidatorSlash>): EventValidatorSlash {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.power = 0n;
        message.reason = "";
        message.consensusAddress = "";
        message.operatorAddress = "";
        message.moniker = "";
        if (value !== undefined)
            reflectionMergePartial<EventValidatorSlash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventValidatorSlash): EventValidatorSlash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 power */ 1:
                    message.power = reader.int64().toBigInt();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                case /* string consensus_address */ 3:
                    message.consensusAddress = reader.string();
                    break;
                case /* string operator_address */ 4:
                    message.operatorAddress = reader.string();
                    break;
                case /* string moniker */ 5:
                    message.moniker = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventValidatorSlash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 power = 1; */
        if (message.power !== 0n)
            writer.tag(1, WireType.Varint).int64(message.power);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* string consensus_address = 3; */
        if (message.consensusAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.consensusAddress);
        /* string operator_address = 4; */
        if (message.operatorAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.operatorAddress);
        /* string moniker = 5; */
        if (message.moniker !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.moniker);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventValidatorSlash
 */
export const EventValidatorSlash = new EventValidatorSlash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventDepositReceived$Type extends MessageType<EventDepositReceived> {
    constructor() {
        super("injective.peggy.v1.EventDepositReceived", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Coin" } }
        ]);
    }
    create(value?: PartialMessage<EventDepositReceived>): EventDepositReceived {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<EventDepositReceived>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventDepositReceived): EventDepositReceived {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventDepositReceived, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventDepositReceived
 */
export const EventDepositReceived = new EventDepositReceived$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventWithdrawalsCompleted$Type extends MessageType<EventWithdrawalsCompleted> {
    constructor() {
        super("injective.peggy.v1.EventWithdrawalsCompleted", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "withdrawals", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Withdrawal }
        ]);
    }
    create(value?: PartialMessage<EventWithdrawalsCompleted>): EventWithdrawalsCompleted {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.withdrawals = [];
        if (value !== undefined)
            reflectionMergePartial<EventWithdrawalsCompleted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventWithdrawalsCompleted): EventWithdrawalsCompleted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* repeated injective.peggy.v1.Withdrawal withdrawals */ 2:
                    message.withdrawals.push(Withdrawal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventWithdrawalsCompleted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* repeated injective.peggy.v1.Withdrawal withdrawals = 2; */
        for (let i = 0; i < message.withdrawals.length; i++)
            Withdrawal.internalBinaryWrite(message.withdrawals[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventWithdrawalsCompleted
 */
export const EventWithdrawalsCompleted = new EventWithdrawalsCompleted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Withdrawal$Type extends MessageType<Withdrawal> {
    constructor() {
        super("injective.peggy.v1.Withdrawal", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "receiver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } }
        ]);
    }
    create(value?: PartialMessage<Withdrawal>): Withdrawal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.receiver = "";
        message.amount = "";
        if (value !== undefined)
            reflectionMergePartial<Withdrawal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Withdrawal): Withdrawal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string receiver */ 2:
                    message.receiver = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Withdrawal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string receiver = 2; */
        if (message.receiver !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.receiver);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.Withdrawal
 */
export const Withdrawal = new Withdrawal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventValidatorJailed$Type extends MessageType<EventValidatorJailed> {
    constructor() {
        super("injective.peggy.v1.EventValidatorJailed", [
            { no: 1, name: "reason", kind: "enum", T: () => ["injective.peggy.v1.JailReason", JailReason] },
            { no: 2, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "consensus_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "operator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "moniker", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventValidatorJailed>): EventValidatorJailed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = 0;
        message.power = 0n;
        message.consensusAddress = "";
        message.operatorAddress = "";
        message.moniker = "";
        if (value !== undefined)
            reflectionMergePartial<EventValidatorJailed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventValidatorJailed): EventValidatorJailed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective.peggy.v1.JailReason reason */ 1:
                    message.reason = reader.int32();
                    break;
                case /* int64 power */ 2:
                    message.power = reader.int64().toBigInt();
                    break;
                case /* string consensus_address */ 3:
                    message.consensusAddress = reader.string();
                    break;
                case /* string operator_address */ 4:
                    message.operatorAddress = reader.string();
                    break;
                case /* string moniker */ 5:
                    message.moniker = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventValidatorJailed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective.peggy.v1.JailReason reason = 1; */
        if (message.reason !== 0)
            writer.tag(1, WireType.Varint).int32(message.reason);
        /* int64 power = 2; */
        if (message.power !== 0n)
            writer.tag(2, WireType.Varint).int64(message.power);
        /* string consensus_address = 3; */
        if (message.consensusAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.consensusAddress);
        /* string operator_address = 4; */
        if (message.operatorAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.operatorAddress);
        /* string moniker = 5; */
        if (message.moniker !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.moniker);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.EventValidatorJailed
 */
export const EventValidatorJailed = new EventValidatorJailed$Type();
