// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/peggy/v1/types.proto" (package "injective.peggy.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * BridgeValidator represents a validator's ETH address and its power
 *
 * @generated from protobuf message injective.peggy.v1.BridgeValidator
 */
export interface BridgeValidator {
    /**
     * @generated from protobuf field: uint64 power = 1
     */
    power: bigint;
    /**
     * @generated from protobuf field: string ethereum_address = 2
     */
    ethereumAddress: string;
}
/**
 * Valset is the Ethereum Bridge Multsig Set, each peggy validator also
 * maintains an ETH key to sign messages, these are used to check signatures on
 * ETH because of the significant gas savings
 *
 * @generated from protobuf message injective.peggy.v1.Valset
 */
export interface Valset {
    /**
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
    /**
     * @generated from protobuf field: repeated injective.peggy.v1.BridgeValidator members = 2
     */
    members: BridgeValidator[];
    /**
     * @generated from protobuf field: uint64 height = 3
     */
    height: bigint;
    /**
     * @generated from protobuf field: string reward_amount = 4
     */
    rewardAmount: string;
    /**
     * the reward token in it's Ethereum hex address representation
     *
     * @generated from protobuf field: string reward_token = 5
     */
    rewardToken: string;
}
/**
 * LastObservedEthereumBlockHeight stores the last observed
 * Ethereum block height along with the Cosmos block height that
 * it was observed at. These two numbers can be used to project
 * outward and always produce batches with timeouts in the future
 * even if no Ethereum block height has been relayed for a long time
 *
 * @generated from protobuf message injective.peggy.v1.LastObservedEthereumBlockHeight
 */
export interface LastObservedEthereumBlockHeight {
    /**
     * @generated from protobuf field: uint64 cosmos_block_height = 1
     */
    cosmosBlockHeight: bigint;
    /**
     * @generated from protobuf field: uint64 ethereum_block_height = 2
     */
    ethereumBlockHeight: bigint;
}
/**
 * LastClaimEvent stores last claim event details of validator.
 *
 * @generated from protobuf message injective.peggy.v1.LastClaimEvent
 */
export interface LastClaimEvent {
    /**
     * @generated from protobuf field: uint64 ethereum_event_nonce = 1
     */
    ethereumEventNonce: bigint;
    /**
     * @generated from protobuf field: uint64 ethereum_event_height = 2
     */
    ethereumEventHeight: bigint;
}
/**
 * This records the relationship between an ERC20 token and the denom
 * of the corresponding Cosmos originated asset
 *
 * @generated from protobuf message injective.peggy.v1.ERC20ToDenom
 */
export interface ERC20ToDenom {
    /**
     * @generated from protobuf field: string erc20 = 1
     */
    erc20: string;
    /**
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class BridgeValidator$Type extends MessageType<BridgeValidator> {
    constructor() {
        super("injective.peggy.v1.BridgeValidator", [
            { no: 1, name: "power", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ethereum_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BridgeValidator>): BridgeValidator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.power = 0n;
        message.ethereumAddress = "";
        if (value !== undefined)
            reflectionMergePartial<BridgeValidator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeValidator): BridgeValidator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 power */ 1:
                    message.power = reader.uint64().toBigInt();
                    break;
                case /* string ethereum_address */ 2:
                    message.ethereumAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeValidator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 power = 1; */
        if (message.power !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.power);
        /* string ethereum_address = 2; */
        if (message.ethereumAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ethereumAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.BridgeValidator
 */
export const BridgeValidator = new BridgeValidator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Valset$Type extends MessageType<Valset> {
    constructor() {
        super("injective.peggy.v1.Valset", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BridgeValidator },
            { no: 3, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "reward_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 5, name: "reward_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Valset>): Valset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        message.members = [];
        message.height = 0n;
        message.rewardAmount = "";
        message.rewardToken = "";
        if (value !== undefined)
            reflectionMergePartial<Valset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Valset): Valset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* repeated injective.peggy.v1.BridgeValidator members */ 2:
                    message.members.push(BridgeValidator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 height */ 3:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* string reward_amount */ 4:
                    message.rewardAmount = reader.string();
                    break;
                case /* string reward_token */ 5:
                    message.rewardToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Valset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        /* repeated injective.peggy.v1.BridgeValidator members = 2; */
        for (let i = 0; i < message.members.length; i++)
            BridgeValidator.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.height);
        /* string reward_amount = 4; */
        if (message.rewardAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.rewardAmount);
        /* string reward_token = 5; */
        if (message.rewardToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.rewardToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.Valset
 */
export const Valset = new Valset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastObservedEthereumBlockHeight$Type extends MessageType<LastObservedEthereumBlockHeight> {
    constructor() {
        super("injective.peggy.v1.LastObservedEthereumBlockHeight", [
            { no: 1, name: "cosmos_block_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ethereum_block_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LastObservedEthereumBlockHeight>): LastObservedEthereumBlockHeight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cosmosBlockHeight = 0n;
        message.ethereumBlockHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<LastObservedEthereumBlockHeight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastObservedEthereumBlockHeight): LastObservedEthereumBlockHeight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 cosmos_block_height */ 1:
                    message.cosmosBlockHeight = reader.uint64().toBigInt();
                    break;
                case /* uint64 ethereum_block_height */ 2:
                    message.ethereumBlockHeight = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastObservedEthereumBlockHeight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 cosmos_block_height = 1; */
        if (message.cosmosBlockHeight !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.cosmosBlockHeight);
        /* uint64 ethereum_block_height = 2; */
        if (message.ethereumBlockHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.ethereumBlockHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.LastObservedEthereumBlockHeight
 */
export const LastObservedEthereumBlockHeight = new LastObservedEthereumBlockHeight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastClaimEvent$Type extends MessageType<LastClaimEvent> {
    constructor() {
        super("injective.peggy.v1.LastClaimEvent", [
            { no: 1, name: "ethereum_event_nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ethereum_event_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LastClaimEvent>): LastClaimEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ethereumEventNonce = 0n;
        message.ethereumEventHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<LastClaimEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastClaimEvent): LastClaimEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 ethereum_event_nonce */ 1:
                    message.ethereumEventNonce = reader.uint64().toBigInt();
                    break;
                case /* uint64 ethereum_event_height */ 2:
                    message.ethereumEventHeight = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastClaimEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 ethereum_event_nonce = 1; */
        if (message.ethereumEventNonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.ethereumEventNonce);
        /* uint64 ethereum_event_height = 2; */
        if (message.ethereumEventHeight !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.ethereumEventHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.LastClaimEvent
 */
export const LastClaimEvent = new LastClaimEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20ToDenom$Type extends MessageType<ERC20ToDenom> {
    constructor() {
        super("injective.peggy.v1.ERC20ToDenom", [
            { no: 1, name: "erc20", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20ToDenom>): ERC20ToDenom {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.erc20 = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<ERC20ToDenom>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20ToDenom): ERC20ToDenom {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string erc20 */ 1:
                    message.erc20 = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20ToDenom, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string erc20 = 1; */
        if (message.erc20 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.erc20);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.ERC20ToDenom
 */
export const ERC20ToDenom = new ERC20ToDenom$Type();
