// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/evm/v1/tx.proto" (package "injective.evm.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Params } from "./params_pb";
import { Log } from "./log_pb";
import { AccessTuple } from "./access_tuple_pb";
import { Any } from "../../../google/protobuf/any_pb";
/**
 * MsgEthereumTx encapsulates an Ethereum transaction as an SDK message.
 *
 * @generated from protobuf message injective.evm.v1.MsgEthereumTx
 */
export interface MsgEthereumTx {
    /**
     * data is inner transaction data of the Ethereum transaction
     *
     * @generated from protobuf field: google.protobuf.Any data = 1
     */
    data?: Any;
    /**
     * size is the encoded storage size of the transaction (DEPRECATED)
     *
     * @generated from protobuf field: double size = 2
     */
    size: number;
    /**
     * hash of the transaction in hex format
     *
     * @generated from protobuf field: string deprecated_hash = 3
     */
    deprecatedHash: string;
    /**
     * @deprecated
     * @generated from protobuf field: string deprecated_from = 4 [deprecated = true]
     */
    deprecatedFrom: string;
    /**
     * from is the bytes of ethereum signer address. This address value is checked
     * against the address derived from the signature (V, R, S) using the
     * secp256k1 elliptic curve
     *
     * @generated from protobuf field: bytes from = 5
     */
    from: Uint8Array;
    /**
     * raw is the raw bytes of the ethereum transaction
     *
     * @generated from protobuf field: bytes raw = 6
     */
    raw: Uint8Array;
}
/**
 * LegacyTx is the transaction data of regular Ethereum transactions.
 * NOTE: All non-protected transactions (i.e non EIP155 signed) will fail if the
 * AllowUnprotectedTxs parameter is disabled.
 *
 * @generated from protobuf message injective.evm.v1.LegacyTx
 */
export interface LegacyTx {
    /**
     * nonce corresponds to the account nonce (transaction sequence).
     *
     * @generated from protobuf field: uint64 nonce = 1
     */
    nonce: bigint;
    /**
     * gas_price defines the value for each gas unit
     *
     * @generated from protobuf field: string gas_price = 2
     */
    gasPrice: string;
    /**
     * gas defines the gas limit defined for the transaction.
     *
     * @generated from protobuf field: uint64 gas = 3
     */
    gas: bigint;
    /**
     * to is the hex formatted address of the recipient
     *
     * @generated from protobuf field: string to = 4
     */
    to: string;
    /**
     * value defines the unsigned integer value of the transaction amount.
     *
     * @generated from protobuf field: string value = 5
     */
    value: string;
    /**
     * data is the data payload bytes of the transaction.
     *
     * @generated from protobuf field: bytes data = 6
     */
    data: Uint8Array;
    /**
     * v defines the signature value
     *
     * @generated from protobuf field: bytes v = 7
     */
    v: Uint8Array;
    /**
     * r defines the signature value
     *
     * @generated from protobuf field: bytes r = 8
     */
    r: Uint8Array;
    /**
     * s define the signature value
     *
     * @generated from protobuf field: bytes s = 9
     */
    s: Uint8Array;
}
/**
 * AccessListTx is the data of EIP-2930 access list transactions.
 *
 * @generated from protobuf message injective.evm.v1.AccessListTx
 */
export interface AccessListTx {
    /**
     * chain_id of the destination EVM chain
     *
     * @generated from protobuf field: string chain_id = 1
     */
    chainId: string;
    /**
     * nonce corresponds to the account nonce (transaction sequence).
     *
     * @generated from protobuf field: uint64 nonce = 2
     */
    nonce: bigint;
    /**
     * gas_price defines the value for each gas unit
     *
     * @generated from protobuf field: string gas_price = 3
     */
    gasPrice: string;
    /**
     * gas defines the gas limit defined for the transaction.
     *
     * @generated from protobuf field: uint64 gas = 4
     */
    gas: bigint;
    /**
     * to is the recipient address in hex format
     *
     * @generated from protobuf field: string to = 5
     */
    to: string;
    /**
     * value defines the unsigned integer value of the transaction amount.
     *
     * @generated from protobuf field: string value = 6
     */
    value: string;
    /**
     * data is the data payload bytes of the transaction.
     *
     * @generated from protobuf field: bytes data = 7
     */
    data: Uint8Array;
    /**
     * accesses is an array of access tuples
     *
     * @generated from protobuf field: repeated injective.evm.v1.AccessTuple accesses = 8
     */
    accesses: AccessTuple[];
    /**
     * v defines the signature value
     *
     * @generated from protobuf field: bytes v = 9
     */
    v: Uint8Array;
    /**
     * r defines the signature value
     *
     * @generated from protobuf field: bytes r = 10
     */
    r: Uint8Array;
    /**
     * s define the signature value
     *
     * @generated from protobuf field: bytes s = 11
     */
    s: Uint8Array;
}
/**
 * DynamicFeeTx is the data of EIP-1559 dinamic fee transactions.
 *
 * @generated from protobuf message injective.evm.v1.DynamicFeeTx
 */
export interface DynamicFeeTx {
    /**
     * chain_id of the destination EVM chain
     *
     * @generated from protobuf field: string chain_id = 1
     */
    chainId: string;
    /**
     * nonce corresponds to the account nonce (transaction sequence).
     *
     * @generated from protobuf field: uint64 nonce = 2
     */
    nonce: bigint;
    /**
     * gas_tip_cap defines the max value for the gas tip
     *
     * @generated from protobuf field: string gas_tip_cap = 3
     */
    gasTipCap: string;
    /**
     * gas_fee_cap defines the max value for the gas fee
     *
     * @generated from protobuf field: string gas_fee_cap = 4
     */
    gasFeeCap: string;
    /**
     * gas defines the gas limit defined for the transaction.
     *
     * @generated from protobuf field: uint64 gas = 5
     */
    gas: bigint;
    /**
     * to is the hex formatted address of the recipient
     *
     * @generated from protobuf field: string to = 6
     */
    to: string;
    /**
     * value defines the the transaction amount.
     *
     * @generated from protobuf field: string value = 7
     */
    value: string;
    /**
     * data is the data payload bytes of the transaction.
     *
     * @generated from protobuf field: bytes data = 8
     */
    data: Uint8Array;
    /**
     * accesses is an array of access tuples
     *
     * @generated from protobuf field: repeated injective.evm.v1.AccessTuple accesses = 9
     */
    accesses: AccessTuple[];
    /**
     * v defines the signature value
     *
     * @generated from protobuf field: bytes v = 10
     */
    v: Uint8Array;
    /**
     * r defines the signature value
     *
     * @generated from protobuf field: bytes r = 11
     */
    r: Uint8Array;
    /**
     * s define the signature value
     *
     * @generated from protobuf field: bytes s = 12
     */
    s: Uint8Array;
}
/**
 * ExtensionOptionsEthereumTx is an extension option for ethereum transactions
 *
 * @generated from protobuf message injective.evm.v1.ExtensionOptionsEthereumTx
 */
export interface ExtensionOptionsEthereumTx {
}
/**
 * MsgEthereumTxResponse defines the Msg/EthereumTx response type.
 *
 * @generated from protobuf message injective.evm.v1.MsgEthereumTxResponse
 */
export interface MsgEthereumTxResponse {
    /**
     * hash of the ethereum transaction in hex format. This hash differs from the
     * Tendermint sha256 hash of the transaction bytes. See
     * https://github.com/tendermint/tendermint/issues/6539 for reference
     *
     * @generated from protobuf field: string hash = 1
     */
    hash: string;
    /**
     * logs contains the transaction hash and the proto-compatible ethereum
     * logs.
     *
     * @generated from protobuf field: repeated injective.evm.v1.Log logs = 2
     */
    logs: Log[];
    /**
     * ret is the returned data from evm function (result or data supplied with
     * revert opcode)
     *
     * @generated from protobuf field: bytes ret = 3
     */
    ret: Uint8Array;
    /**
     * vm_error is the error returned by vm execution
     *
     * @generated from protobuf field: string vm_error = 4
     */
    vmError: string;
    /**
     * gas_used specifies how much gas was consumed by the transaction
     *
     * @generated from protobuf field: uint64 gas_used = 5
     */
    gasUsed: bigint;
    /**
     * include the block hash for json-rpc to use
     *
     * @generated from protobuf field: bytes block_hash = 6
     */
    blockHash: Uint8Array;
}
/**
 * MsgUpdateParams defines a Msg for updating the x/evm module parameters.
 *
 * @generated from protobuf message injective.evm.v1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the x/evm parameters to update.
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: injective.evm.v1.Params params = 2
     */
    params?: Params;
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * @generated from protobuf message injective.evm.v1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgEthereumTx$Type extends MessageType<MsgEthereumTx> {
    constructor() {
        super("injective.evm.v1.MsgEthereumTx", [
            { no: 1, name: "data", kind: "message", T: () => Any },
            { no: 2, name: "size", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "gogoproto.jsontag": "-" } },
            { no: 3, name: "deprecated_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "rlp:\"-\"" } },
            { no: 4, name: "deprecated_from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "from", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "raw", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "EthereumTx" } }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["from"] });
    }
    create(value?: PartialMessage<MsgEthereumTx>): MsgEthereumTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.size = 0;
        message.deprecatedHash = "";
        message.deprecatedFrom = "";
        message.from = new Uint8Array(0);
        message.raw = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgEthereumTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgEthereumTx): MsgEthereumTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any data */ 1:
                    message.data = Any.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* double size */ 2:
                    message.size = reader.double();
                    break;
                case /* string deprecated_hash */ 3:
                    message.deprecatedHash = reader.string();
                    break;
                case /* string deprecated_from = 4 [deprecated = true] */ 4:
                    message.deprecatedFrom = reader.string();
                    break;
                case /* bytes from */ 5:
                    message.from = reader.bytes();
                    break;
                case /* bytes raw */ 6:
                    message.raw = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgEthereumTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any data = 1; */
        if (message.data)
            Any.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* double size = 2; */
        if (message.size !== 0)
            writer.tag(2, WireType.Bit64).double(message.size);
        /* string deprecated_hash = 3; */
        if (message.deprecatedHash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.deprecatedHash);
        /* string deprecated_from = 4 [deprecated = true]; */
        if (message.deprecatedFrom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.deprecatedFrom);
        /* bytes from = 5; */
        if (message.from.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.from);
        /* bytes raw = 6; */
        if (message.raw.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.raw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.MsgEthereumTx
 */
export const MsgEthereumTx = new MsgEthereumTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LegacyTx$Type extends MessageType<LegacyTx> {
    constructor() {
        super("injective.evm.v1.LegacyTx", [
            { no: 1, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "gas_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 3, name: "gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "GasLimit" } },
            { no: 4, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int", "gogoproto.customname": "Amount" } },
            { no: 6, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "v", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "r", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "s", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.goproto_getters": false, "cosmos_proto.implements_interface": ["TxData"] });
    }
    create(value?: PartialMessage<LegacyTx>): LegacyTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        message.gasPrice = "";
        message.gas = 0n;
        message.to = "";
        message.value = "";
        message.data = new Uint8Array(0);
        message.v = new Uint8Array(0);
        message.r = new Uint8Array(0);
        message.s = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<LegacyTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LegacyTx): LegacyTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 nonce */ 1:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string gas_price */ 2:
                    message.gasPrice = reader.string();
                    break;
                case /* uint64 gas */ 3:
                    message.gas = reader.uint64().toBigInt();
                    break;
                case /* string to */ 4:
                    message.to = reader.string();
                    break;
                case /* string value */ 5:
                    message.value = reader.string();
                    break;
                case /* bytes data */ 6:
                    message.data = reader.bytes();
                    break;
                case /* bytes v */ 7:
                    message.v = reader.bytes();
                    break;
                case /* bytes r */ 8:
                    message.r = reader.bytes();
                    break;
                case /* bytes s */ 9:
                    message.s = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LegacyTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 nonce = 1; */
        if (message.nonce !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.nonce);
        /* string gas_price = 2; */
        if (message.gasPrice !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gasPrice);
        /* uint64 gas = 3; */
        if (message.gas !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.gas);
        /* string to = 4; */
        if (message.to !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.to);
        /* string value = 5; */
        if (message.value !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.value);
        /* bytes data = 6; */
        if (message.data.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.data);
        /* bytes v = 7; */
        if (message.v.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.v);
        /* bytes r = 8; */
        if (message.r.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.r);
        /* bytes s = 9; */
        if (message.s.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.s);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.LegacyTx
 */
export const LegacyTx = new LegacyTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListTx$Type extends MessageType<AccessListTx> {
    constructor() {
        super("injective.evm.v1.AccessListTx", [
            { no: 1, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int", "gogoproto.customname": "ChainID", "gogoproto.jsontag": "chainID" } },
            { no: 2, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "gas_price", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 4, name: "gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "GasLimit" } },
            { no: 5, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int", "gogoproto.customname": "Amount" } },
            { no: 7, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "accesses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AccessTuple, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "accessList", "gogoproto.castrepeated": "AccessList" } },
            { no: 9, name: "v", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "r", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "s", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.goproto_getters": false, "cosmos_proto.implements_interface": ["TxData"] });
    }
    create(value?: PartialMessage<AccessListTx>): AccessListTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = "";
        message.nonce = 0n;
        message.gasPrice = "";
        message.gas = 0n;
        message.to = "";
        message.value = "";
        message.data = new Uint8Array(0);
        message.accesses = [];
        message.v = new Uint8Array(0);
        message.r = new Uint8Array(0);
        message.s = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<AccessListTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListTx): AccessListTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string chain_id */ 1:
                    message.chainId = reader.string();
                    break;
                case /* uint64 nonce */ 2:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string gas_price */ 3:
                    message.gasPrice = reader.string();
                    break;
                case /* uint64 gas */ 4:
                    message.gas = reader.uint64().toBigInt();
                    break;
                case /* string to */ 5:
                    message.to = reader.string();
                    break;
                case /* string value */ 6:
                    message.value = reader.string();
                    break;
                case /* bytes data */ 7:
                    message.data = reader.bytes();
                    break;
                case /* repeated injective.evm.v1.AccessTuple accesses */ 8:
                    message.accesses.push(AccessTuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes v */ 9:
                    message.v = reader.bytes();
                    break;
                case /* bytes r */ 10:
                    message.r = reader.bytes();
                    break;
                case /* bytes s */ 11:
                    message.s = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string chain_id = 1; */
        if (message.chainId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.chainId);
        /* uint64 nonce = 2; */
        if (message.nonce !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.nonce);
        /* string gas_price = 3; */
        if (message.gasPrice !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gasPrice);
        /* uint64 gas = 4; */
        if (message.gas !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.gas);
        /* string to = 5; */
        if (message.to !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.to);
        /* string value = 6; */
        if (message.value !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.value);
        /* bytes data = 7; */
        if (message.data.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.data);
        /* repeated injective.evm.v1.AccessTuple accesses = 8; */
        for (let i = 0; i < message.accesses.length; i++)
            AccessTuple.internalBinaryWrite(message.accesses[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bytes v = 9; */
        if (message.v.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.v);
        /* bytes r = 10; */
        if (message.r.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.r);
        /* bytes s = 11; */
        if (message.s.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.s);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.AccessListTx
 */
export const AccessListTx = new AccessListTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicFeeTx$Type extends MessageType<DynamicFeeTx> {
    constructor() {
        super("injective.evm.v1.DynamicFeeTx", [
            { no: 1, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int", "gogoproto.customname": "ChainID", "gogoproto.jsontag": "chainID" } },
            { no: 2, name: "nonce", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "gas_tip_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 4, name: "gas_fee_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int" } },
            { no: 5, name: "gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "GasLimit" } },
            { no: 6, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "cosmossdk.io/math.Int", "gogoproto.customname": "Amount" } },
            { no: 8, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "accesses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AccessTuple, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "accessList", "gogoproto.castrepeated": "AccessList" } },
            { no: 10, name: "v", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "r", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "s", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.goproto_getters": false, "cosmos_proto.implements_interface": ["TxData"] });
    }
    create(value?: PartialMessage<DynamicFeeTx>): DynamicFeeTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = "";
        message.nonce = 0n;
        message.gasTipCap = "";
        message.gasFeeCap = "";
        message.gas = 0n;
        message.to = "";
        message.value = "";
        message.data = new Uint8Array(0);
        message.accesses = [];
        message.v = new Uint8Array(0);
        message.r = new Uint8Array(0);
        message.s = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<DynamicFeeTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicFeeTx): DynamicFeeTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string chain_id */ 1:
                    message.chainId = reader.string();
                    break;
                case /* uint64 nonce */ 2:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* string gas_tip_cap */ 3:
                    message.gasTipCap = reader.string();
                    break;
                case /* string gas_fee_cap */ 4:
                    message.gasFeeCap = reader.string();
                    break;
                case /* uint64 gas */ 5:
                    message.gas = reader.uint64().toBigInt();
                    break;
                case /* string to */ 6:
                    message.to = reader.string();
                    break;
                case /* string value */ 7:
                    message.value = reader.string();
                    break;
                case /* bytes data */ 8:
                    message.data = reader.bytes();
                    break;
                case /* repeated injective.evm.v1.AccessTuple accesses */ 9:
                    message.accesses.push(AccessTuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes v */ 10:
                    message.v = reader.bytes();
                    break;
                case /* bytes r */ 11:
                    message.r = reader.bytes();
                    break;
                case /* bytes s */ 12:
                    message.s = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicFeeTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string chain_id = 1; */
        if (message.chainId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.chainId);
        /* uint64 nonce = 2; */
        if (message.nonce !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.nonce);
        /* string gas_tip_cap = 3; */
        if (message.gasTipCap !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gasTipCap);
        /* string gas_fee_cap = 4; */
        if (message.gasFeeCap !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.gasFeeCap);
        /* uint64 gas = 5; */
        if (message.gas !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.gas);
        /* string to = 6; */
        if (message.to !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.to);
        /* string value = 7; */
        if (message.value !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.value);
        /* bytes data = 8; */
        if (message.data.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.data);
        /* repeated injective.evm.v1.AccessTuple accesses = 9; */
        for (let i = 0; i < message.accesses.length; i++)
            AccessTuple.internalBinaryWrite(message.accesses[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bytes v = 10; */
        if (message.v.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.v);
        /* bytes r = 11; */
        if (message.r.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.r);
        /* bytes s = 12; */
        if (message.s.length)
            writer.tag(12, WireType.LengthDelimited).bytes(message.s);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.DynamicFeeTx
 */
export const DynamicFeeTx = new DynamicFeeTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionOptionsEthereumTx$Type extends MessageType<ExtensionOptionsEthereumTx> {
    constructor() {
        super("injective.evm.v1.ExtensionOptionsEthereumTx", [], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<ExtensionOptionsEthereumTx>): ExtensionOptionsEthereumTx {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExtensionOptionsEthereumTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionOptionsEthereumTx): ExtensionOptionsEthereumTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionOptionsEthereumTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.ExtensionOptionsEthereumTx
 */
export const ExtensionOptionsEthereumTx = new ExtensionOptionsEthereumTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgEthereumTxResponse$Type extends MessageType<MsgEthereumTxResponse> {
    constructor() {
        super("injective.evm.v1.MsgEthereumTxResponse", [
            { no: 1, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "logs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Log },
            { no: 3, name: "ret", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "vm_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_used", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "block_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<MsgEthereumTxResponse>): MsgEthereumTxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = "";
        message.logs = [];
        message.ret = new Uint8Array(0);
        message.vmError = "";
        message.gasUsed = 0n;
        message.blockHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgEthereumTxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgEthereumTxResponse): MsgEthereumTxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash */ 1:
                    message.hash = reader.string();
                    break;
                case /* repeated injective.evm.v1.Log logs */ 2:
                    message.logs.push(Log.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes ret */ 3:
                    message.ret = reader.bytes();
                    break;
                case /* string vm_error */ 4:
                    message.vmError = reader.string();
                    break;
                case /* uint64 gas_used */ 5:
                    message.gasUsed = reader.uint64().toBigInt();
                    break;
                case /* bytes block_hash */ 6:
                    message.blockHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgEthereumTxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash = 1; */
        if (message.hash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hash);
        /* repeated injective.evm.v1.Log logs = 2; */
        for (let i = 0; i < message.logs.length; i++)
            Log.internalBinaryWrite(message.logs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes ret = 3; */
        if (message.ret.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.ret);
        /* string vm_error = 4; */
        if (message.vmError !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.vmError);
        /* uint64 gas_used = 5; */
        if (message.gasUsed !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.gasUsed);
        /* bytes block_hash = 6; */
        if (message.blockHash.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.blockHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.MsgEthereumTxResponse
 */
export const MsgEthereumTxResponse = new MsgEthereumTxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("injective.evm.v1.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ], { "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* injective.evm.v1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* injective.evm.v1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("injective.evm.v1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.evm.v1.Msg
 */
export const Msg = new ServiceType("injective.evm.v1.Msg", [
    { name: "EthereumTx", options: { "google.api.http": { post: "/injective/evm/v1/ethereum_tx" } }, I: MsgEthereumTx, O: MsgEthereumTxResponse },
    { name: "UpdateParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse }
], { "cosmos.msg.v1.service": true });
