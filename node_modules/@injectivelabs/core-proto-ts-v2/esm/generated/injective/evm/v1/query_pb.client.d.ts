// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/evm/v1/query.proto" (package "injective.evm.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Query } from "./query_pb";
import type { QueryBaseFeeResponse } from "./query_pb";
import type { QueryBaseFeeRequest } from "./query_pb";
import type { QueryTraceCallResponse } from "./query_pb";
import type { QueryTraceCallRequest } from "./query_pb";
import type { QueryTraceBlockResponse } from "./query_pb";
import type { QueryTraceBlockRequest } from "./query_pb";
import type { QueryTraceTxResponse } from "./query_pb";
import type { QueryTraceTxRequest } from "./query_pb";
import type { EstimateGasResponse } from "./query_pb";
import type { MsgEthereumTxResponse } from "./tx_pb";
import type { EthCallRequest } from "./query_pb";
import type { QueryParamsResponse } from "./query_pb";
import type { QueryParamsRequest } from "./query_pb";
import type { QueryCodeResponse } from "./query_pb";
import type { QueryCodeRequest } from "./query_pb";
import type { QueryStorageResponse } from "./query_pb";
import type { QueryStorageRequest } from "./query_pb";
import type { QueryBalanceResponse } from "./query_pb";
import type { QueryBalanceRequest } from "./query_pb";
import type { QueryValidatorAccountResponse } from "./query_pb";
import type { QueryValidatorAccountRequest } from "./query_pb";
import type { QueryCosmosAccountResponse } from "./query_pb";
import type { QueryCosmosAccountRequest } from "./query_pb";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { QueryAccountResponse } from "./query_pb";
import type { QueryAccountRequest } from "./query_pb";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Query defines the gRPC querier service.
 *
 * @generated from protobuf service injective.evm.v1.Query
 */
export interface IQueryClient {
    /**
     * Account queries an Ethereum account.
     *
     * @generated from protobuf rpc: Account
     */
    account(input: QueryAccountRequest, options?: RpcOptions): UnaryCall<QueryAccountRequest, QueryAccountResponse>;
    /**
     * CosmosAccount queries an Ethereum account's Cosmos Address.
     *
     * @generated from protobuf rpc: CosmosAccount
     */
    cosmosAccount(input: QueryCosmosAccountRequest, options?: RpcOptions): UnaryCall<QueryCosmosAccountRequest, QueryCosmosAccountResponse>;
    /**
     * ValidatorAccount queries an Ethereum account's from a validator consensus
     * Address.
     *
     * @generated from protobuf rpc: ValidatorAccount
     */
    validatorAccount(input: QueryValidatorAccountRequest, options?: RpcOptions): UnaryCall<QueryValidatorAccountRequest, QueryValidatorAccountResponse>;
    /**
     * Balance queries the balance of a the EVM denomination for a single
     * EthAccount.
     *
     * @generated from protobuf rpc: Balance
     */
    balance(input: QueryBalanceRequest, options?: RpcOptions): UnaryCall<QueryBalanceRequest, QueryBalanceResponse>;
    /**
     * Storage queries the balance of all coins for a single account.
     *
     * @generated from protobuf rpc: Storage
     */
    storage(input: QueryStorageRequest, options?: RpcOptions): UnaryCall<QueryStorageRequest, QueryStorageResponse>;
    /**
     * Code queries the code of a single account.
     *
     * @generated from protobuf rpc: Code
     */
    code(input: QueryCodeRequest, options?: RpcOptions): UnaryCall<QueryCodeRequest, QueryCodeResponse>;
    /**
     * Params queries the parameters of x/evm module.
     *
     * @generated from protobuf rpc: Params
     */
    params(input: QueryParamsRequest, options?: RpcOptions): UnaryCall<QueryParamsRequest, QueryParamsResponse>;
    /**
     * EthCall implements the `eth_call` rpc api
     *
     * @generated from protobuf rpc: EthCall
     */
    ethCall(input: EthCallRequest, options?: RpcOptions): UnaryCall<EthCallRequest, MsgEthereumTxResponse>;
    /**
     * EstimateGas implements the `eth_estimateGas` rpc api
     *
     * @generated from protobuf rpc: EstimateGas
     */
    estimateGas(input: EthCallRequest, options?: RpcOptions): UnaryCall<EthCallRequest, EstimateGasResponse>;
    /**
     * TraceTx implements the `debug_traceTransaction` rpc api
     *
     * @generated from protobuf rpc: TraceTx
     */
    traceTx(input: QueryTraceTxRequest, options?: RpcOptions): UnaryCall<QueryTraceTxRequest, QueryTraceTxResponse>;
    /**
     * TraceBlock implements the `debug_traceBlockByNumber` and
     * `debug_traceBlockByHash` rpc api
     *
     * @generated from protobuf rpc: TraceBlock
     */
    traceBlock(input: QueryTraceBlockRequest, options?: RpcOptions): UnaryCall<QueryTraceBlockRequest, QueryTraceBlockResponse>;
    /**
     * TraceCall implements the `debug_traceCall` rpc api
     *
     * @generated from protobuf rpc: TraceCall
     */
    traceCall(input: QueryTraceCallRequest, options?: RpcOptions): UnaryCall<QueryTraceCallRequest, QueryTraceCallResponse>;
    /**
     * BaseFee queries the base fee of the parent block of the current block,
     * it's similar to feemarket module's method, but also checks london hardfork
     * status.
     *
     * @generated from protobuf rpc: BaseFee
     */
    baseFee(input: QueryBaseFeeRequest, options?: RpcOptions): UnaryCall<QueryBaseFeeRequest, QueryBaseFeeResponse>;
}
/**
 * Query defines the gRPC querier service.
 *
 * @generated from protobuf service injective.evm.v1.Query
 */
export class QueryClient implements IQueryClient, ServiceInfo {
    typeName = Query.typeName;
    methods = Query.methods;
    options = Query.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Account queries an Ethereum account.
     *
     * @generated from protobuf rpc: Account
     */
    account(input: QueryAccountRequest, options?: RpcOptions): UnaryCall<QueryAccountRequest, QueryAccountResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryAccountRequest, QueryAccountResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CosmosAccount queries an Ethereum account's Cosmos Address.
     *
     * @generated from protobuf rpc: CosmosAccount
     */
    cosmosAccount(input: QueryCosmosAccountRequest, options?: RpcOptions): UnaryCall<QueryCosmosAccountRequest, QueryCosmosAccountResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryCosmosAccountRequest, QueryCosmosAccountResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidatorAccount queries an Ethereum account's from a validator consensus
     * Address.
     *
     * @generated from protobuf rpc: ValidatorAccount
     */
    validatorAccount(input: QueryValidatorAccountRequest, options?: RpcOptions): UnaryCall<QueryValidatorAccountRequest, QueryValidatorAccountResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryValidatorAccountRequest, QueryValidatorAccountResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Balance queries the balance of a the EVM denomination for a single
     * EthAccount.
     *
     * @generated from protobuf rpc: Balance
     */
    balance(input: QueryBalanceRequest, options?: RpcOptions): UnaryCall<QueryBalanceRequest, QueryBalanceResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryBalanceRequest, QueryBalanceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Storage queries the balance of all coins for a single account.
     *
     * @generated from protobuf rpc: Storage
     */
    storage(input: QueryStorageRequest, options?: RpcOptions): UnaryCall<QueryStorageRequest, QueryStorageResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryStorageRequest, QueryStorageResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Code queries the code of a single account.
     *
     * @generated from protobuf rpc: Code
     */
    code(input: QueryCodeRequest, options?: RpcOptions): UnaryCall<QueryCodeRequest, QueryCodeResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryCodeRequest, QueryCodeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Params queries the parameters of x/evm module.
     *
     * @generated from protobuf rpc: Params
     */
    params(input: QueryParamsRequest, options?: RpcOptions): UnaryCall<QueryParamsRequest, QueryParamsResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryParamsRequest, QueryParamsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * EthCall implements the `eth_call` rpc api
     *
     * @generated from protobuf rpc: EthCall
     */
    ethCall(input: EthCallRequest, options?: RpcOptions): UnaryCall<EthCallRequest, MsgEthereumTxResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<EthCallRequest, MsgEthereumTxResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * EstimateGas implements the `eth_estimateGas` rpc api
     *
     * @generated from protobuf rpc: EstimateGas
     */
    estimateGas(input: EthCallRequest, options?: RpcOptions): UnaryCall<EthCallRequest, EstimateGasResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<EthCallRequest, EstimateGasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * TraceTx implements the `debug_traceTransaction` rpc api
     *
     * @generated from protobuf rpc: TraceTx
     */
    traceTx(input: QueryTraceTxRequest, options?: RpcOptions): UnaryCall<QueryTraceTxRequest, QueryTraceTxResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryTraceTxRequest, QueryTraceTxResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * TraceBlock implements the `debug_traceBlockByNumber` and
     * `debug_traceBlockByHash` rpc api
     *
     * @generated from protobuf rpc: TraceBlock
     */
    traceBlock(input: QueryTraceBlockRequest, options?: RpcOptions): UnaryCall<QueryTraceBlockRequest, QueryTraceBlockResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryTraceBlockRequest, QueryTraceBlockResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * TraceCall implements the `debug_traceCall` rpc api
     *
     * @generated from protobuf rpc: TraceCall
     */
    traceCall(input: QueryTraceCallRequest, options?: RpcOptions): UnaryCall<QueryTraceCallRequest, QueryTraceCallResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryTraceCallRequest, QueryTraceCallResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * BaseFee queries the base fee of the parent block of the current block,
     * it's similar to feemarket module's method, but also checks london hardfork
     * status.
     *
     * @generated from protobuf rpc: BaseFee
     */
    baseFee(input: QueryBaseFeeRequest, options?: RpcOptions): UnaryCall<QueryBaseFeeRequest, QueryBaseFeeResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryBaseFeeRequest, QueryBaseFeeResponse>("unary", this._transport, method, opt, input);
    }
}
