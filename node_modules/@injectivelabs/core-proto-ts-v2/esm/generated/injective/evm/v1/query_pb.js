import { MsgEthereumTxResponse } from "./tx_pb.js";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp_pb.js";
import { TraceConfig } from "./trace_config_pb.js";
import { MsgEthereumTx } from "./tx_pb.js";
import { Params } from "./params_pb.js";
import { PageResponse } from "../../../cosmos/base/query/v1beta1/pagination_pb.js";
import { Log } from "./log_pb.js";
import { PageRequest } from "../../../cosmos/base/query/v1beta1/pagination_pb.js";
class QueryAccountRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryAccountRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAccountRequest = new QueryAccountRequest$Type();
class QueryAccountResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryAccountResponse", [
      {
        no: 1,
        name: "balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "code_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "nonce",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balance = "";
    message.codeHash = "";
    message.nonce = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string balance */
        1:
          message.balance = reader.string();
          break;
        case /* string code_hash */
        2:
          message.codeHash = reader.string();
          break;
        case /* uint64 nonce */
        3:
          message.nonce = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.balance);
    if (message.codeHash !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.codeHash);
    if (message.nonce !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.nonce);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryAccountResponse = new QueryAccountResponse$Type();
class QueryCosmosAccountRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryCosmosAccountRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryCosmosAccountRequest = new QueryCosmosAccountRequest$Type();
class QueryCosmosAccountResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryCosmosAccountResponse", [
      {
        no: 1,
        name: "cosmos_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "account_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cosmosAddress = "";
    message.sequence = 0n;
    message.accountNumber = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cosmos_address */
        1:
          message.cosmosAddress = reader.string();
          break;
        case /* uint64 sequence */
        2:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* uint64 account_number */
        3:
          message.accountNumber = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cosmosAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cosmosAddress);
    if (message.sequence !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.sequence);
    if (message.accountNumber !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.accountNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryCosmosAccountResponse = new QueryCosmosAccountResponse$Type();
class QueryValidatorAccountRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryValidatorAccountRequest", [
      {
        no: 1,
        name: "cons_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.consAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cons_address */
        1:
          message.consAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.consAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.consAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorAccountRequest = new QueryValidatorAccountRequest$Type();
class QueryValidatorAccountResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryValidatorAccountResponse", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "sequence",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "account_number",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.sequence = 0n;
    message.accountNumber = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* uint64 sequence */
        2:
          message.sequence = reader.uint64().toBigInt();
          break;
        case /* uint64 account_number */
        3:
          message.accountNumber = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.sequence !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.sequence);
    if (message.accountNumber !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.accountNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryValidatorAccountResponse = new QueryValidatorAccountResponse$Type();
class QueryBalanceRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryBalanceRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceRequest = new QueryBalanceRequest$Type();
class QueryBalanceResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryBalanceResponse", [
      {
        no: 1,
        name: "balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string balance */
        1:
          message.balance = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.balance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBalanceResponse = new QueryBalanceResponse$Type();
class QueryStorageRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryStorageRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.key = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* string key */
        2:
          message.key = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.key !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.key);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryStorageRequest = new QueryStorageRequest$Type();
class QueryStorageResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryStorageResponse", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryStorageResponse = new QueryStorageResponse$Type();
class QueryCodeRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryCodeRequest", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryCodeRequest = new QueryCodeRequest$Type();
class QueryCodeResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryCodeResponse", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes code */
        1:
          message.code = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.code);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryCodeResponse = new QueryCodeResponse$Type();
class QueryTxLogsRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTxLogsRequest", [
      {
        no: 1,
        name: "hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "pagination", kind: "message", T: () => PageRequest }
    ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string hash */
        1:
          message.hash = reader.string();
          break;
        case /* cosmos.base.query.v1beta1.PageRequest pagination */
        2:
          message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.hash);
    if (message.pagination)
      PageRequest.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTxLogsRequest = new QueryTxLogsRequest$Type();
class QueryTxLogsResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTxLogsResponse", [
      { no: 1, name: "logs", kind: "message", repeat: 2, T: () => Log },
      { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.logs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.evm.v1.Log logs */
        1:
          message.logs.push(Log.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cosmos.base.query.v1beta1.PageResponse pagination */
        2:
          message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.logs.length; i++)
      Log.internalBinaryWrite(message.logs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTxLogsResponse = new QueryTxLogsResponse$Type();
class QueryParamsRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryParamsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsRequest = new QueryParamsRequest$Type();
class QueryParamsResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryParamsResponse", [
      { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.evm.v1.Params params */
        1:
          message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.params)
      Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryParamsResponse = new QueryParamsResponse$Type();
class EthCallRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.EthCallRequest", [
      {
        no: 1,
        name: "args",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "gas_cap",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "proposer_address", kind: "scalar", T: 12, options: { "gogoproto.casttype": "github.com/cosmos/cosmos-sdk/types.ConsAddress" } },
      {
        no: 4,
        name: "chain_id",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "overrides",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.args = new Uint8Array(0);
    message.gasCap = 0n;
    message.proposerAddress = new Uint8Array(0);
    message.chainId = 0n;
    message.overrides = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes args */
        1:
          message.args = reader.bytes();
          break;
        case /* uint64 gas_cap */
        2:
          message.gasCap = reader.uint64().toBigInt();
          break;
        case /* bytes proposer_address */
        3:
          message.proposerAddress = reader.bytes();
          break;
        case /* int64 chain_id */
        4:
          message.chainId = reader.int64().toBigInt();
          break;
        case /* bytes overrides */
        5:
          message.overrides = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.args.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.args);
    if (message.gasCap !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.gasCap);
    if (message.proposerAddress.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.proposerAddress);
    if (message.chainId !== 0n)
      writer.tag(4, WireType.Varint).int64(message.chainId);
    if (message.overrides.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.overrides);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EthCallRequest = new EthCallRequest$Type();
class EstimateGasResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.EstimateGasResponse", [
      {
        no: 1,
        name: "gas",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "ret",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "vm_error",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.gas = 0n;
    message.ret = new Uint8Array(0);
    message.vmError = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 gas */
        1:
          message.gas = reader.uint64().toBigInt();
          break;
        case /* bytes ret */
        2:
          message.ret = reader.bytes();
          break;
        case /* string vm_error */
        3:
          message.vmError = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.gas !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.gas);
    if (message.ret.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.ret);
    if (message.vmError !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.vmError);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EstimateGasResponse = new EstimateGasResponse$Type();
class QueryTraceTxRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTraceTxRequest", [
      { no: 1, name: "msg", kind: "message", T: () => MsgEthereumTx },
      { no: 3, name: "trace_config", kind: "message", T: () => TraceConfig },
      { no: 4, name: "predecessors", kind: "message", repeat: 2, T: () => MsgEthereumTx },
      {
        no: 5,
        name: "block_number",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "block_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "block_time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      { no: 8, name: "proposer_address", kind: "scalar", T: 12, options: { "gogoproto.casttype": "github.com/cosmos/cosmos-sdk/types.ConsAddress" } },
      {
        no: 9,
        name: "chain_id",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.predecessors = [];
    message.blockNumber = 0n;
    message.blockHash = "";
    message.proposerAddress = new Uint8Array(0);
    message.chainId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective.evm.v1.MsgEthereumTx msg */
        1:
          message.msg = MsgEthereumTx.internalBinaryRead(reader, reader.uint32(), options, message.msg);
          break;
        case /* injective.evm.v1.TraceConfig trace_config */
        3:
          message.traceConfig = TraceConfig.internalBinaryRead(reader, reader.uint32(), options, message.traceConfig);
          break;
        case /* repeated injective.evm.v1.MsgEthereumTx predecessors */
        4:
          message.predecessors.push(MsgEthereumTx.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* int64 block_number */
        5:
          message.blockNumber = reader.int64().toBigInt();
          break;
        case /* string block_hash */
        6:
          message.blockHash = reader.string();
          break;
        case /* google.protobuf.Timestamp block_time */
        7:
          message.blockTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.blockTime);
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        case /* int64 chain_id */
        9:
          message.chainId = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.msg)
      MsgEthereumTx.internalBinaryWrite(message.msg, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.traceConfig)
      TraceConfig.internalBinaryWrite(message.traceConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.predecessors.length; i++)
      MsgEthereumTx.internalBinaryWrite(message.predecessors[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.blockNumber !== 0n)
      writer.tag(5, WireType.Varint).int64(message.blockNumber);
    if (message.blockHash !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.blockHash);
    if (message.blockTime)
      Timestamp.internalBinaryWrite(message.blockTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    if (message.chainId !== 0n)
      writer.tag(9, WireType.Varint).int64(message.chainId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraceTxRequest = new QueryTraceTxRequest$Type();
class QueryTraceTxResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTraceTxResponse", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */
        1:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraceTxResponse = new QueryTraceTxResponse$Type();
class QueryTraceCallRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTraceCallRequest", [
      {
        no: 1,
        name: "args",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "gas_cap",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "proposer_address", kind: "scalar", T: 12, options: { "gogoproto.casttype": "github.com/cosmos/cosmos-sdk/types.ConsAddress" } },
      { no: 4, name: "trace_config", kind: "message", T: () => TraceConfig },
      {
        no: 5,
        name: "block_number",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "block_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "block_time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 8,
        name: "chain_id",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.args = new Uint8Array(0);
    message.gasCap = 0n;
    message.proposerAddress = new Uint8Array(0);
    message.blockNumber = 0n;
    message.blockHash = "";
    message.chainId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes args */
        1:
          message.args = reader.bytes();
          break;
        case /* uint64 gas_cap */
        2:
          message.gasCap = reader.uint64().toBigInt();
          break;
        case /* bytes proposer_address */
        3:
          message.proposerAddress = reader.bytes();
          break;
        case /* injective.evm.v1.TraceConfig trace_config */
        4:
          message.traceConfig = TraceConfig.internalBinaryRead(reader, reader.uint32(), options, message.traceConfig);
          break;
        case /* int64 block_number */
        5:
          message.blockNumber = reader.int64().toBigInt();
          break;
        case /* string block_hash */
        6:
          message.blockHash = reader.string();
          break;
        case /* google.protobuf.Timestamp block_time */
        7:
          message.blockTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.blockTime);
          break;
        case /* int64 chain_id */
        8:
          message.chainId = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.args.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.args);
    if (message.gasCap !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.gasCap);
    if (message.proposerAddress.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.proposerAddress);
    if (message.traceConfig)
      TraceConfig.internalBinaryWrite(message.traceConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.blockNumber !== 0n)
      writer.tag(5, WireType.Varint).int64(message.blockNumber);
    if (message.blockHash !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.blockHash);
    if (message.blockTime)
      Timestamp.internalBinaryWrite(message.blockTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.chainId !== 0n)
      writer.tag(8, WireType.Varint).int64(message.chainId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraceCallRequest = new QueryTraceCallRequest$Type();
class QueryTraceCallResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTraceCallResponse", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */
        1:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraceCallResponse = new QueryTraceCallResponse$Type();
class QueryTraceBlockRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTraceBlockRequest", [
      { no: 1, name: "txs", kind: "message", repeat: 2, T: () => MsgEthereumTx },
      { no: 3, name: "trace_config", kind: "message", T: () => TraceConfig },
      {
        no: 5,
        name: "block_number",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "block_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 7, name: "block_time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      { no: 8, name: "proposer_address", kind: "scalar", T: 12, options: { "gogoproto.casttype": "github.com/cosmos/cosmos-sdk/types.ConsAddress" } },
      {
        no: 9,
        name: "chain_id",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.txs = [];
    message.blockNumber = 0n;
    message.blockHash = "";
    message.proposerAddress = new Uint8Array(0);
    message.chainId = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective.evm.v1.MsgEthereumTx txs */
        1:
          message.txs.push(MsgEthereumTx.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* injective.evm.v1.TraceConfig trace_config */
        3:
          message.traceConfig = TraceConfig.internalBinaryRead(reader, reader.uint32(), options, message.traceConfig);
          break;
        case /* int64 block_number */
        5:
          message.blockNumber = reader.int64().toBigInt();
          break;
        case /* string block_hash */
        6:
          message.blockHash = reader.string();
          break;
        case /* google.protobuf.Timestamp block_time */
        7:
          message.blockTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.blockTime);
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        case /* int64 chain_id */
        9:
          message.chainId = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.txs.length; i++)
      MsgEthereumTx.internalBinaryWrite(message.txs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.traceConfig)
      TraceConfig.internalBinaryWrite(message.traceConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.blockNumber !== 0n)
      writer.tag(5, WireType.Varint).int64(message.blockNumber);
    if (message.blockHash !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.blockHash);
    if (message.blockTime)
      Timestamp.internalBinaryWrite(message.blockTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    if (message.chainId !== 0n)
      writer.tag(9, WireType.Varint).int64(message.chainId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraceBlockRequest = new QueryTraceBlockRequest$Type();
class QueryTraceBlockResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryTraceBlockResponse", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */
        1:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryTraceBlockResponse = new QueryTraceBlockResponse$Type();
class QueryBaseFeeRequest$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryBaseFeeRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBaseFeeRequest = new QueryBaseFeeRequest$Type();
class QueryBaseFeeResponse$Type extends MessageType {
  constructor() {
    super("injective.evm.v1.QueryBaseFeeResponse", [
      { no: 1, name: "base_fee", kind: "scalar", T: 9, options: { "gogoproto.customtype": "cosmossdk.io/math.Int" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.baseFee = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string base_fee */
        1:
          message.baseFee = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.baseFee !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.baseFee);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryBaseFeeResponse = new QueryBaseFeeResponse$Type();
const Query = new ServiceType("injective.evm.v1.Query", [
  { name: "Account", options: { "google.api.http": { get: "/injective/evm/v1/account/{address}" } }, I: QueryAccountRequest, O: QueryAccountResponse },
  { name: "CosmosAccount", options: { "google.api.http": { get: "/injective/evm/v1/cosmos_account/{address}" } }, I: QueryCosmosAccountRequest, O: QueryCosmosAccountResponse },
  { name: "ValidatorAccount", options: { "google.api.http": { get: "/injective/evm/v1/validator_account/{cons_address}" } }, I: QueryValidatorAccountRequest, O: QueryValidatorAccountResponse },
  { name: "Balance", options: { "google.api.http": { get: "/injective/evm/v1/balances/{address}" } }, I: QueryBalanceRequest, O: QueryBalanceResponse },
  { name: "Storage", options: { "google.api.http": { get: "/injective/evm/v1/storage/{address}/{key}" } }, I: QueryStorageRequest, O: QueryStorageResponse },
  { name: "Code", options: { "google.api.http": { get: "/injective/evm/v1/codes/{address}" } }, I: QueryCodeRequest, O: QueryCodeResponse },
  { name: "Params", options: { "google.api.http": { get: "/injective/evm/v1/params" } }, I: QueryParamsRequest, O: QueryParamsResponse },
  { name: "EthCall", options: { "google.api.http": { get: "/injective/evm/v1/eth_call" } }, I: EthCallRequest, O: MsgEthereumTxResponse },
  { name: "EstimateGas", options: { "google.api.http": { get: "/injective/evm/v1/estimate_gas" } }, I: EthCallRequest, O: EstimateGasResponse },
  { name: "TraceTx", options: { "google.api.http": { get: "/injective/evm/v1/trace_tx" } }, I: QueryTraceTxRequest, O: QueryTraceTxResponse },
  { name: "TraceBlock", options: { "google.api.http": { get: "/injective/evm/v1/trace_block" } }, I: QueryTraceBlockRequest, O: QueryTraceBlockResponse },
  { name: "TraceCall", options: { "google.api.http": { get: "/injective/evm/v1/trace_call" } }, I: QueryTraceCallRequest, O: QueryTraceCallResponse },
  { name: "BaseFee", options: { "google.api.http": { get: "/injective/evm/v1/base_fee" } }, I: QueryBaseFeeRequest, O: QueryBaseFeeResponse }
]);
export {
  EstimateGasResponse,
  EthCallRequest,
  Query,
  QueryAccountRequest,
  QueryAccountResponse,
  QueryBalanceRequest,
  QueryBalanceResponse,
  QueryBaseFeeRequest,
  QueryBaseFeeResponse,
  QueryCodeRequest,
  QueryCodeResponse,
  QueryCosmosAccountRequest,
  QueryCosmosAccountResponse,
  QueryParamsRequest,
  QueryParamsResponse,
  QueryStorageRequest,
  QueryStorageResponse,
  QueryTraceBlockRequest,
  QueryTraceBlockResponse,
  QueryTraceCallRequest,
  QueryTraceCallResponse,
  QueryTraceTxRequest,
  QueryTraceTxResponse,
  QueryTxLogsRequest,
  QueryTxLogsResponse,
  QueryValidatorAccountRequest,
  QueryValidatorAccountResponse
};
