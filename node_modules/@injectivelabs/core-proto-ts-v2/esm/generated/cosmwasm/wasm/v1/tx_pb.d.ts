// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "cosmwasm/wasm/v1/tx.proto" (package "cosmwasm.wasm.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Params } from "./types_pb";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb";
import { AccessConfig } from "./types_pb";
/**
 * MsgStoreCode submit Wasm code to the system
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgStoreCode
 */
export interface MsgStoreCode {
    /**
     * Sender is the actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * WASMByteCode can be raw or gzip compressed
     *
     * @generated from protobuf field: bytes wasm_byte_code = 2
     */
    wasmByteCode: Uint8Array;
    /**
     * InstantiatePermission access control to apply on contract creation,
     * optional
     *
     * @generated from protobuf field: cosmwasm.wasm.v1.AccessConfig instantiate_permission = 5
     */
    instantiatePermission?: AccessConfig;
}
/**
 * MsgStoreCodeResponse returns store result data.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgStoreCodeResponse
 */
export interface MsgStoreCodeResponse {
    /**
     * CodeID is the reference to the stored WASM code
     *
     * @generated from protobuf field: uint64 code_id = 1
     */
    codeId: bigint;
    /**
     * Checksum is the sha256 hash of the stored code
     *
     * @generated from protobuf field: bytes checksum = 2
     */
    checksum: Uint8Array;
}
/**
 * MsgInstantiateContract create a new smart contract instance for the given
 * code id.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgInstantiateContract
 */
export interface MsgInstantiateContract {
    /**
     * Sender is the that actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Admin is an optional address that can execute migrations
     *
     * @generated from protobuf field: string admin = 2
     */
    admin: string;
    /**
     * CodeID is the reference to the stored WASM code
     *
     * @generated from protobuf field: uint64 code_id = 3
     */
    codeId: bigint;
    /**
     * Label is optional metadata to be stored with a contract instance.
     *
     * @generated from protobuf field: string label = 4
     */
    label: string;
    /**
     * Msg json encoded message to be passed to the contract on instantiation
     *
     * @generated from protobuf field: bytes msg = 5
     */
    msg: Uint8Array;
    /**
     * Funds coins that are transferred to the contract on instantiation
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds = 6
     */
    funds: Coin[];
}
/**
 * MsgInstantiateContractResponse return instantiation result data
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgInstantiateContractResponse
 */
export interface MsgInstantiateContractResponse {
    /**
     * Address is the bech32 address of the new contract instance.
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Data contains bytes to returned from the contract
     *
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
}
/**
 * MsgInstantiateContract2 create a new smart contract instance for the given
 * code id with a predictable address.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgInstantiateContract2
 */
export interface MsgInstantiateContract2 {
    /**
     * Sender is the that actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Admin is an optional address that can execute migrations
     *
     * @generated from protobuf field: string admin = 2
     */
    admin: string;
    /**
     * CodeID is the reference to the stored WASM code
     *
     * @generated from protobuf field: uint64 code_id = 3
     */
    codeId: bigint;
    /**
     * Label is optional metadata to be stored with a contract instance.
     *
     * @generated from protobuf field: string label = 4
     */
    label: string;
    /**
     * Msg json encoded message to be passed to the contract on instantiation
     *
     * @generated from protobuf field: bytes msg = 5
     */
    msg: Uint8Array;
    /**
     * Funds coins that are transferred to the contract on instantiation
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds = 6
     */
    funds: Coin[];
    /**
     * Salt is an arbitrary value provided by the sender. Size can be 1 to 64.
     *
     * @generated from protobuf field: bytes salt = 7
     */
    salt: Uint8Array;
    /**
     * FixMsg include the msg value into the hash for the predictable address.
     * Default is false
     *
     * @generated from protobuf field: bool fix_msg = 8
     */
    fixMsg: boolean;
}
/**
 * MsgInstantiateContract2Response return instantiation result data
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgInstantiateContract2Response
 */
export interface MsgInstantiateContract2Response {
    /**
     * Address is the bech32 address of the new contract instance.
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Data contains bytes to returned from the contract
     *
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
}
/**
 * MsgExecuteContract submits the given message data to a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgExecuteContract
 */
export interface MsgExecuteContract {
    /**
     * Sender is the that actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Contract is the address of the smart contract
     *
     * @generated from protobuf field: string contract = 2
     */
    contract: string;
    /**
     * Msg json encoded message to be passed to the contract
     *
     * @generated from protobuf field: bytes msg = 3
     */
    msg: Uint8Array;
    /**
     * Funds coins that are transferred to the contract on execution
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds = 5
     */
    funds: Coin[];
}
/**
 * MsgExecuteContractResponse returns execution result data.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgExecuteContractResponse
 */
export interface MsgExecuteContractResponse {
    /**
     * Data contains bytes to returned from the contract
     *
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array;
}
/**
 * MsgMigrateContract runs a code upgrade/ downgrade for a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgMigrateContract
 */
export interface MsgMigrateContract {
    /**
     * Sender is the that actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Contract is the address of the smart contract
     *
     * @generated from protobuf field: string contract = 2
     */
    contract: string;
    /**
     * CodeID references the new WASM code
     *
     * @generated from protobuf field: uint64 code_id = 3
     */
    codeId: bigint;
    /**
     * Msg json encoded message to be passed to the contract on migration
     *
     * @generated from protobuf field: bytes msg = 4
     */
    msg: Uint8Array;
}
/**
 * MsgMigrateContractResponse returns contract migration result data.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgMigrateContractResponse
 */
export interface MsgMigrateContractResponse {
    /**
     * Data contains same raw bytes returned as data from the wasm contract.
     * (May be empty)
     *
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array;
}
/**
 * MsgUpdateAdmin sets a new admin for a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateAdmin
 */
export interface MsgUpdateAdmin {
    /**
     * Sender is the that actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * NewAdmin address to be set
     *
     * @generated from protobuf field: string new_admin = 2
     */
    newAdmin: string;
    /**
     * Contract is the address of the smart contract
     *
     * @generated from protobuf field: string contract = 3
     */
    contract: string;
}
/**
 * MsgUpdateAdminResponse returns empty data
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateAdminResponse
 */
export interface MsgUpdateAdminResponse {
}
/**
 * MsgClearAdmin removes any admin stored for a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgClearAdmin
 */
export interface MsgClearAdmin {
    /**
     * Sender is the actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * Contract is the address of the smart contract
     *
     * @generated from protobuf field: string contract = 3
     */
    contract: string;
}
/**
 * MsgClearAdminResponse returns empty data
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgClearAdminResponse
 */
export interface MsgClearAdminResponse {
}
/**
 * MsgUpdateInstantiateConfig updates instantiate config for a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateInstantiateConfig
 */
export interface MsgUpdateInstantiateConfig {
    /**
     * Sender is the that actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * CodeID references the stored WASM code
     *
     * @generated from protobuf field: uint64 code_id = 2
     */
    codeId: bigint;
    /**
     * NewInstantiatePermission is the new access control
     *
     * @generated from protobuf field: cosmwasm.wasm.v1.AccessConfig new_instantiate_permission = 3
     */
    newInstantiatePermission?: AccessConfig;
}
/**
 * MsgUpdateInstantiateConfigResponse returns empty data
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateInstantiateConfigResponse
 */
export interface MsgUpdateInstantiateConfigResponse {
}
/**
 * MsgUpdateParams is the MsgUpdateParams request type.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the x/wasm parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: cosmwasm.wasm.v1.Params params = 2
     */
    params?: Params;
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgSudoContract is the MsgSudoContract request type.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgSudoContract
 */
export interface MsgSudoContract {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * Contract is the address of the smart contract
     *
     * @generated from protobuf field: string contract = 2
     */
    contract: string;
    /**
     * Msg json encoded message to be passed to the contract as sudo
     *
     * @generated from protobuf field: bytes msg = 3
     */
    msg: Uint8Array;
}
/**
 * MsgSudoContractResponse defines the response structure for executing a
 * MsgSudoContract message.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgSudoContractResponse
 */
export interface MsgSudoContractResponse {
    /**
     * Data contains bytes to returned from the contract
     *
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array;
}
/**
 * MsgPinCodes is the MsgPinCodes request type.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgPinCodes
 */
export interface MsgPinCodes {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * CodeIDs references the new WASM codes
     *
     * @generated from protobuf field: repeated uint64 code_ids = 2
     */
    codeIds: bigint[];
}
/**
 * MsgPinCodesResponse defines the response structure for executing a
 * MsgPinCodes message.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgPinCodesResponse
 */
export interface MsgPinCodesResponse {
}
/**
 * MsgUnpinCodes is the MsgUnpinCodes request type.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUnpinCodes
 */
export interface MsgUnpinCodes {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * CodeIDs references the WASM codes
     *
     * @generated from protobuf field: repeated uint64 code_ids = 2
     */
    codeIds: bigint[];
}
/**
 * MsgUnpinCodesResponse defines the response structure for executing a
 * MsgUnpinCodes message.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUnpinCodesResponse
 */
export interface MsgUnpinCodesResponse {
}
/**
 * MsgStoreAndInstantiateContract is the MsgStoreAndInstantiateContract
 * request type.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgStoreAndInstantiateContract
 */
export interface MsgStoreAndInstantiateContract {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * WASMByteCode can be raw or gzip compressed
     *
     * @generated from protobuf field: bytes wasm_byte_code = 3
     */
    wasmByteCode: Uint8Array;
    /**
     * InstantiatePermission to apply on contract creation, optional
     *
     * @generated from protobuf field: cosmwasm.wasm.v1.AccessConfig instantiate_permission = 4
     */
    instantiatePermission?: AccessConfig;
    /**
     * UnpinCode code on upload, optional. As default the uploaded contract is
     * pinned to cache.
     *
     * @generated from protobuf field: bool unpin_code = 5
     */
    unpinCode: boolean;
    /**
     * Admin is an optional address that can execute migrations
     *
     * @generated from protobuf field: string admin = 6
     */
    admin: string;
    /**
     * Label is optional metadata to be stored with a constract instance.
     *
     * @generated from protobuf field: string label = 7
     */
    label: string;
    /**
     * Msg json encoded message to be passed to the contract on instantiation
     *
     * @generated from protobuf field: bytes msg = 8
     */
    msg: Uint8Array;
    /**
     * Funds coins that are transferred from the authority account to the contract
     * on instantiation
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds = 9
     */
    funds: Coin[];
    /**
     * Source is the URL where the code is hosted
     *
     * @generated from protobuf field: string source = 10
     */
    source: string;
    /**
     * Builder is the docker image used to build the code deterministically, used
     * for smart contract verification
     *
     * @generated from protobuf field: string builder = 11
     */
    builder: string;
    /**
     * CodeHash is the SHA256 sum of the code outputted by builder, used for smart
     * contract verification
     *
     * @generated from protobuf field: bytes code_hash = 12
     */
    codeHash: Uint8Array;
}
/**
 * MsgStoreAndInstantiateContractResponse defines the response structure
 * for executing a MsgStoreAndInstantiateContract message.
 *
 * Since: 0.40
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgStoreAndInstantiateContractResponse
 */
export interface MsgStoreAndInstantiateContractResponse {
    /**
     * Address is the bech32 address of the new contract instance.
     *
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * Data contains bytes to returned from the contract
     *
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
}
/**
 * MsgAddCodeUploadParamsAddresses is the
 * MsgAddCodeUploadParamsAddresses request type.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddresses
 */
export interface MsgAddCodeUploadParamsAddresses {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * @generated from protobuf field: repeated string addresses = 2
     */
    addresses: string[];
}
/**
 * MsgAddCodeUploadParamsAddressesResponse defines the response
 * structure for executing a MsgAddCodeUploadParamsAddresses message.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddressesResponse
 */
export interface MsgAddCodeUploadParamsAddressesResponse {
}
/**
 * MsgRemoveCodeUploadParamsAddresses is the
 * MsgRemoveCodeUploadParamsAddresses request type.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddresses
 */
export interface MsgRemoveCodeUploadParamsAddresses {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * @generated from protobuf field: repeated string addresses = 2
     */
    addresses: string[];
}
/**
 * MsgRemoveCodeUploadParamsAddressesResponse defines the response
 * structure for executing a MsgRemoveCodeUploadParamsAddresses message.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddressesResponse
 */
export interface MsgRemoveCodeUploadParamsAddressesResponse {
}
/**
 * MsgStoreAndMigrateContract is the MsgStoreAndMigrateContract
 * request type.
 *
 * Since: 0.42
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgStoreAndMigrateContract
 */
export interface MsgStoreAndMigrateContract {
    /**
     * Authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * WASMByteCode can be raw or gzip compressed
     *
     * @generated from protobuf field: bytes wasm_byte_code = 2
     */
    wasmByteCode: Uint8Array;
    /**
     * InstantiatePermission to apply on contract creation, optional
     *
     * @generated from protobuf field: cosmwasm.wasm.v1.AccessConfig instantiate_permission = 3
     */
    instantiatePermission?: AccessConfig;
    /**
     * Contract is the address of the smart contract
     *
     * @generated from protobuf field: string contract = 4
     */
    contract: string;
    /**
     * Msg json encoded message to be passed to the contract on migration
     *
     * @generated from protobuf field: bytes msg = 5
     */
    msg: Uint8Array;
}
/**
 * MsgStoreAndMigrateContractResponse defines the response structure
 * for executing a MsgStoreAndMigrateContract message.
 *
 * Since: 0.42
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgStoreAndMigrateContractResponse
 */
export interface MsgStoreAndMigrateContractResponse {
    /**
     * CodeID is the reference to the stored WASM code
     *
     * @generated from protobuf field: uint64 code_id = 1
     */
    codeId: bigint;
    /**
     * Checksum is the sha256 hash of the stored code
     *
     * @generated from protobuf field: bytes checksum = 2
     */
    checksum: Uint8Array;
    /**
     * Data contains bytes to returned from the contract
     *
     * @generated from protobuf field: bytes data = 3
     */
    data: Uint8Array;
}
/**
 * MsgUpdateContractLabel sets a new label for a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateContractLabel
 */
export interface MsgUpdateContractLabel {
    /**
     * Sender is the that actor that signed the messages
     *
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * NewLabel string to be set
     *
     * @generated from protobuf field: string new_label = 2
     */
    newLabel: string;
    /**
     * Contract is the address of the smart contract
     *
     * @generated from protobuf field: string contract = 3
     */
    contract: string;
}
/**
 * MsgUpdateContractLabelResponse returns empty data
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateContractLabelResponse
 */
export interface MsgUpdateContractLabelResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgStoreCode$Type extends MessageType<MsgStoreCode> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgStoreCode", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "wasm_byte_code", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.customname": "WASMByteCode" } },
            { no: 5, name: "instantiate_permission", kind: "message", T: () => AccessConfig }
        ], { "amino.name": "wasm/MsgStoreCode", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgStoreCode>): MsgStoreCode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.wasmByteCode = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgStoreCode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgStoreCode): MsgStoreCode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* bytes wasm_byte_code */ 2:
                    message.wasmByteCode = reader.bytes();
                    break;
                case /* cosmwasm.wasm.v1.AccessConfig instantiate_permission */ 5:
                    message.instantiatePermission = AccessConfig.internalBinaryRead(reader, reader.uint32(), options, message.instantiatePermission);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgStoreCode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* bytes wasm_byte_code = 2; */
        if (message.wasmByteCode.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.wasmByteCode);
        /* cosmwasm.wasm.v1.AccessConfig instantiate_permission = 5; */
        if (message.instantiatePermission)
            AccessConfig.internalBinaryWrite(message.instantiatePermission, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgStoreCode
 */
export const MsgStoreCode = new MsgStoreCode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgStoreCodeResponse$Type extends MessageType<MsgStoreCodeResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgStoreCodeResponse", [
            { no: 1, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeID" } },
            { no: 2, name: "checksum", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgStoreCodeResponse>): MsgStoreCodeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.codeId = 0n;
        message.checksum = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgStoreCodeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgStoreCodeResponse): MsgStoreCodeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 code_id */ 1:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* bytes checksum */ 2:
                    message.checksum = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgStoreCodeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 code_id = 1; */
        if (message.codeId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.codeId);
        /* bytes checksum = 2; */
        if (message.checksum.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.checksum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgStoreCodeResponse
 */
export const MsgStoreCodeResponse = new MsgStoreCodeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantiateContract$Type extends MessageType<MsgInstantiateContract> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgInstantiateContract", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeID" } },
            { no: 4, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.casttype": "RawContractMessage", "amino.encoding": "inline_json" } },
            { no: 6, name: "funds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } }
        ], { "amino.name": "wasm/MsgInstantiateContract", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantiateContract>): MsgInstantiateContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.admin = "";
        message.codeId = 0n;
        message.label = "";
        message.msg = new Uint8Array(0);
        message.funds = [];
        if (value !== undefined)
            reflectionMergePartial<MsgInstantiateContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantiateContract): MsgInstantiateContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string admin */ 2:
                    message.admin = reader.string();
                    break;
                case /* uint64 code_id */ 3:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* string label */ 4:
                    message.label = reader.string();
                    break;
                case /* bytes msg */ 5:
                    message.msg = reader.bytes();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin funds */ 6:
                    message.funds.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantiateContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string admin = 2; */
        if (message.admin !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.admin);
        /* uint64 code_id = 3; */
        if (message.codeId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.codeId);
        /* string label = 4; */
        if (message.label !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.label);
        /* bytes msg = 5; */
        if (message.msg.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.msg);
        /* repeated cosmos.base.v1beta1.Coin funds = 6; */
        for (let i = 0; i < message.funds.length; i++)
            Coin.internalBinaryWrite(message.funds[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgInstantiateContract
 */
export const MsgInstantiateContract = new MsgInstantiateContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantiateContractResponse$Type extends MessageType<MsgInstantiateContractResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgInstantiateContractResponse", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgInstantiateContractResponse>): MsgInstantiateContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgInstantiateContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantiateContractResponse): MsgInstantiateContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantiateContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgInstantiateContractResponse
 */
export const MsgInstantiateContractResponse = new MsgInstantiateContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantiateContract2$Type extends MessageType<MsgInstantiateContract2> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgInstantiateContract2", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeID" } },
            { no: 4, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.casttype": "RawContractMessage", "amino.encoding": "inline_json" } },
            { no: 6, name: "funds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
            { no: 7, name: "salt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "fix_msg", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "amino.name": "wasm/MsgInstantiateContract2", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgInstantiateContract2>): MsgInstantiateContract2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.admin = "";
        message.codeId = 0n;
        message.label = "";
        message.msg = new Uint8Array(0);
        message.funds = [];
        message.salt = new Uint8Array(0);
        message.fixMsg = false;
        if (value !== undefined)
            reflectionMergePartial<MsgInstantiateContract2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantiateContract2): MsgInstantiateContract2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string admin */ 2:
                    message.admin = reader.string();
                    break;
                case /* uint64 code_id */ 3:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* string label */ 4:
                    message.label = reader.string();
                    break;
                case /* bytes msg */ 5:
                    message.msg = reader.bytes();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin funds */ 6:
                    message.funds.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes salt */ 7:
                    message.salt = reader.bytes();
                    break;
                case /* bool fix_msg */ 8:
                    message.fixMsg = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantiateContract2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string admin = 2; */
        if (message.admin !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.admin);
        /* uint64 code_id = 3; */
        if (message.codeId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.codeId);
        /* string label = 4; */
        if (message.label !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.label);
        /* bytes msg = 5; */
        if (message.msg.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.msg);
        /* repeated cosmos.base.v1beta1.Coin funds = 6; */
        for (let i = 0; i < message.funds.length; i++)
            Coin.internalBinaryWrite(message.funds[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes salt = 7; */
        if (message.salt.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.salt);
        /* bool fix_msg = 8; */
        if (message.fixMsg !== false)
            writer.tag(8, WireType.Varint).bool(message.fixMsg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgInstantiateContract2
 */
export const MsgInstantiateContract2 = new MsgInstantiateContract2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgInstantiateContract2Response$Type extends MessageType<MsgInstantiateContract2Response> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgInstantiateContract2Response", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgInstantiateContract2Response>): MsgInstantiateContract2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgInstantiateContract2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgInstantiateContract2Response): MsgInstantiateContract2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgInstantiateContract2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgInstantiateContract2Response
 */
export const MsgInstantiateContract2Response = new MsgInstantiateContract2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExecuteContract$Type extends MessageType<MsgExecuteContract> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgExecuteContract", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.casttype": "RawContractMessage", "amino.encoding": "inline_json" } },
            { no: 5, name: "funds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } }
        ], { "amino.name": "wasm/MsgExecuteContract", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgExecuteContract>): MsgExecuteContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.contract = "";
        message.msg = new Uint8Array(0);
        message.funds = [];
        if (value !== undefined)
            reflectionMergePartial<MsgExecuteContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExecuteContract): MsgExecuteContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string contract */ 2:
                    message.contract = reader.string();
                    break;
                case /* bytes msg */ 3:
                    message.msg = reader.bytes();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin funds */ 5:
                    message.funds.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExecuteContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string contract = 2; */
        if (message.contract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contract);
        /* bytes msg = 3; */
        if (message.msg.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.msg);
        /* repeated cosmos.base.v1beta1.Coin funds = 5; */
        for (let i = 0; i < message.funds.length; i++)
            Coin.internalBinaryWrite(message.funds[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgExecuteContract
 */
export const MsgExecuteContract = new MsgExecuteContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExecuteContractResponse$Type extends MessageType<MsgExecuteContractResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgExecuteContractResponse", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgExecuteContractResponse>): MsgExecuteContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgExecuteContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExecuteContractResponse): MsgExecuteContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExecuteContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgExecuteContractResponse
 */
export const MsgExecuteContractResponse = new MsgExecuteContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgMigrateContract$Type extends MessageType<MsgMigrateContract> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgMigrateContract", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeID" } },
            { no: 4, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.casttype": "RawContractMessage", "amino.encoding": "inline_json" } }
        ], { "amino.name": "wasm/MsgMigrateContract", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgMigrateContract>): MsgMigrateContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.contract = "";
        message.codeId = 0n;
        message.msg = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgMigrateContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMigrateContract): MsgMigrateContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string contract */ 2:
                    message.contract = reader.string();
                    break;
                case /* uint64 code_id */ 3:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* bytes msg */ 4:
                    message.msg = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMigrateContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string contract = 2; */
        if (message.contract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contract);
        /* uint64 code_id = 3; */
        if (message.codeId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.codeId);
        /* bytes msg = 4; */
        if (message.msg.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgMigrateContract
 */
export const MsgMigrateContract = new MsgMigrateContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgMigrateContractResponse$Type extends MessageType<MsgMigrateContractResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgMigrateContractResponse", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgMigrateContractResponse>): MsgMigrateContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgMigrateContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMigrateContractResponse): MsgMigrateContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMigrateContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgMigrateContractResponse
 */
export const MsgMigrateContractResponse = new MsgMigrateContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateAdmin$Type extends MessageType<MsgUpdateAdmin> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateAdmin", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "new_admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "amino.name": "wasm/MsgUpdateAdmin", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgUpdateAdmin>): MsgUpdateAdmin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.newAdmin = "";
        message.contract = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateAdmin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateAdmin): MsgUpdateAdmin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string new_admin */ 2:
                    message.newAdmin = reader.string();
                    break;
                case /* string contract */ 3:
                    message.contract = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateAdmin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string new_admin = 2; */
        if (message.newAdmin !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newAdmin);
        /* string contract = 3; */
        if (message.contract !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contract);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateAdmin
 */
export const MsgUpdateAdmin = new MsgUpdateAdmin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateAdminResponse$Type extends MessageType<MsgUpdateAdminResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateAdminResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateAdminResponse>): MsgUpdateAdminResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateAdminResponse): MsgUpdateAdminResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateAdminResponse
 */
export const MsgUpdateAdminResponse = new MsgUpdateAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgClearAdmin$Type extends MessageType<MsgClearAdmin> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgClearAdmin", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "amino.name": "wasm/MsgClearAdmin", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgClearAdmin>): MsgClearAdmin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.contract = "";
        if (value !== undefined)
            reflectionMergePartial<MsgClearAdmin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgClearAdmin): MsgClearAdmin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string contract */ 3:
                    message.contract = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgClearAdmin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string contract = 3; */
        if (message.contract !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contract);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgClearAdmin
 */
export const MsgClearAdmin = new MsgClearAdmin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgClearAdminResponse$Type extends MessageType<MsgClearAdminResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgClearAdminResponse", []);
    }
    create(value?: PartialMessage<MsgClearAdminResponse>): MsgClearAdminResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgClearAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgClearAdminResponse): MsgClearAdminResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgClearAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgClearAdminResponse
 */
export const MsgClearAdminResponse = new MsgClearAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateInstantiateConfig$Type extends MessageType<MsgUpdateInstantiateConfig> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateInstantiateConfig", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeID" } },
            { no: 3, name: "new_instantiate_permission", kind: "message", T: () => AccessConfig }
        ], { "amino.name": "wasm/MsgUpdateInstantiateConfig", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgUpdateInstantiateConfig>): MsgUpdateInstantiateConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.codeId = 0n;
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateInstantiateConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateInstantiateConfig): MsgUpdateInstantiateConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* uint64 code_id */ 2:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* cosmwasm.wasm.v1.AccessConfig new_instantiate_permission */ 3:
                    message.newInstantiatePermission = AccessConfig.internalBinaryRead(reader, reader.uint32(), options, message.newInstantiatePermission);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateInstantiateConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* uint64 code_id = 2; */
        if (message.codeId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.codeId);
        /* cosmwasm.wasm.v1.AccessConfig new_instantiate_permission = 3; */
        if (message.newInstantiatePermission)
            AccessConfig.internalBinaryWrite(message.newInstantiatePermission, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateInstantiateConfig
 */
export const MsgUpdateInstantiateConfig = new MsgUpdateInstantiateConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateInstantiateConfigResponse$Type extends MessageType<MsgUpdateInstantiateConfigResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateInstantiateConfigResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateInstantiateConfigResponse>): MsgUpdateInstantiateConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateInstantiateConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateInstantiateConfigResponse): MsgUpdateInstantiateConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateInstantiateConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateInstantiateConfigResponse
 */
export const MsgUpdateInstantiateConfigResponse = new MsgUpdateInstantiateConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false, "amino.dont_omitempty": true } }
        ], { "amino.name": "wasm/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* cosmwasm.wasm.v1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* cosmwasm.wasm.v1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSudoContract$Type extends MessageType<MsgSudoContract> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgSudoContract", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.casttype": "RawContractMessage", "amino.encoding": "inline_json" } }
        ], { "amino.name": "wasm/MsgSudoContract", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgSudoContract>): MsgSudoContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.contract = "";
        message.msg = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgSudoContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSudoContract): MsgSudoContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* string contract */ 2:
                    message.contract = reader.string();
                    break;
                case /* bytes msg */ 3:
                    message.msg = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSudoContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* string contract = 2; */
        if (message.contract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contract);
        /* bytes msg = 3; */
        if (message.msg.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgSudoContract
 */
export const MsgSudoContract = new MsgSudoContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSudoContractResponse$Type extends MessageType<MsgSudoContractResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgSudoContractResponse", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgSudoContractResponse>): MsgSudoContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgSudoContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSudoContractResponse): MsgSudoContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSudoContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgSudoContractResponse
 */
export const MsgSudoContractResponse = new MsgSudoContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPinCodes$Type extends MessageType<MsgPinCodes> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgPinCodes", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "code_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeIDs", "gogoproto.moretags": "yaml:\"code_ids\"" } }
        ], { "amino.name": "wasm/MsgPinCodes", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgPinCodes>): MsgPinCodes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.codeIds = [];
        if (value !== undefined)
            reflectionMergePartial<MsgPinCodes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPinCodes): MsgPinCodes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* repeated uint64 code_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.codeIds.push(reader.uint64().toBigInt());
                    else
                        message.codeIds.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPinCodes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* repeated uint64 code_ids = 2; */
        if (message.codeIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.codeIds.length; i++)
                writer.uint64(message.codeIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgPinCodes
 */
export const MsgPinCodes = new MsgPinCodes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgPinCodesResponse$Type extends MessageType<MsgPinCodesResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgPinCodesResponse", []);
    }
    create(value?: PartialMessage<MsgPinCodesResponse>): MsgPinCodesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgPinCodesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgPinCodesResponse): MsgPinCodesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgPinCodesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgPinCodesResponse
 */
export const MsgPinCodesResponse = new MsgPinCodesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUnpinCodes$Type extends MessageType<MsgUnpinCodes> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUnpinCodes", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "code_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeIDs", "gogoproto.moretags": "yaml:\"code_ids\"" } }
        ], { "amino.name": "wasm/MsgUnpinCodes", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUnpinCodes>): MsgUnpinCodes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.codeIds = [];
        if (value !== undefined)
            reflectionMergePartial<MsgUnpinCodes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUnpinCodes): MsgUnpinCodes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* repeated uint64 code_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.codeIds.push(reader.uint64().toBigInt());
                    else
                        message.codeIds.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUnpinCodes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* repeated uint64 code_ids = 2; */
        if (message.codeIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.codeIds.length; i++)
                writer.uint64(message.codeIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUnpinCodes
 */
export const MsgUnpinCodes = new MsgUnpinCodes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUnpinCodesResponse$Type extends MessageType<MsgUnpinCodesResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUnpinCodesResponse", []);
    }
    create(value?: PartialMessage<MsgUnpinCodesResponse>): MsgUnpinCodesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUnpinCodesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUnpinCodesResponse): MsgUnpinCodesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUnpinCodesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUnpinCodesResponse
 */
export const MsgUnpinCodesResponse = new MsgUnpinCodesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgStoreAndInstantiateContract$Type extends MessageType<MsgStoreAndInstantiateContract> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgStoreAndInstantiateContract", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "wasm_byte_code", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.customname": "WASMByteCode" } },
            { no: 4, name: "instantiate_permission", kind: "message", T: () => AccessConfig },
            { no: 5, name: "unpin_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 7, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.casttype": "RawContractMessage", "amino.encoding": "inline_json" } },
            { no: 9, name: "funds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins", "amino.encoding": "legacy_coins", "amino.dont_omitempty": true } },
            { no: 10, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "builder", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "code_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "amino.name": "wasm/MsgStoreAndInstantiateContract", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgStoreAndInstantiateContract>): MsgStoreAndInstantiateContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.wasmByteCode = new Uint8Array(0);
        message.unpinCode = false;
        message.admin = "";
        message.label = "";
        message.msg = new Uint8Array(0);
        message.funds = [];
        message.source = "";
        message.builder = "";
        message.codeHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgStoreAndInstantiateContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgStoreAndInstantiateContract): MsgStoreAndInstantiateContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* bytes wasm_byte_code */ 3:
                    message.wasmByteCode = reader.bytes();
                    break;
                case /* cosmwasm.wasm.v1.AccessConfig instantiate_permission */ 4:
                    message.instantiatePermission = AccessConfig.internalBinaryRead(reader, reader.uint32(), options, message.instantiatePermission);
                    break;
                case /* bool unpin_code */ 5:
                    message.unpinCode = reader.bool();
                    break;
                case /* string admin */ 6:
                    message.admin = reader.string();
                    break;
                case /* string label */ 7:
                    message.label = reader.string();
                    break;
                case /* bytes msg */ 8:
                    message.msg = reader.bytes();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin funds */ 9:
                    message.funds.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string source */ 10:
                    message.source = reader.string();
                    break;
                case /* string builder */ 11:
                    message.builder = reader.string();
                    break;
                case /* bytes code_hash */ 12:
                    message.codeHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgStoreAndInstantiateContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* bytes wasm_byte_code = 3; */
        if (message.wasmByteCode.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.wasmByteCode);
        /* cosmwasm.wasm.v1.AccessConfig instantiate_permission = 4; */
        if (message.instantiatePermission)
            AccessConfig.internalBinaryWrite(message.instantiatePermission, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool unpin_code = 5; */
        if (message.unpinCode !== false)
            writer.tag(5, WireType.Varint).bool(message.unpinCode);
        /* string admin = 6; */
        if (message.admin !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.admin);
        /* string label = 7; */
        if (message.label !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.label);
        /* bytes msg = 8; */
        if (message.msg.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.msg);
        /* repeated cosmos.base.v1beta1.Coin funds = 9; */
        for (let i = 0; i < message.funds.length; i++)
            Coin.internalBinaryWrite(message.funds[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string source = 10; */
        if (message.source !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.source);
        /* string builder = 11; */
        if (message.builder !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.builder);
        /* bytes code_hash = 12; */
        if (message.codeHash.length)
            writer.tag(12, WireType.LengthDelimited).bytes(message.codeHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgStoreAndInstantiateContract
 */
export const MsgStoreAndInstantiateContract = new MsgStoreAndInstantiateContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgStoreAndInstantiateContractResponse$Type extends MessageType<MsgStoreAndInstantiateContractResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgStoreAndInstantiateContractResponse", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgStoreAndInstantiateContractResponse>): MsgStoreAndInstantiateContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgStoreAndInstantiateContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgStoreAndInstantiateContractResponse): MsgStoreAndInstantiateContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgStoreAndInstantiateContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgStoreAndInstantiateContractResponse
 */
export const MsgStoreAndInstantiateContractResponse = new MsgStoreAndInstantiateContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAddCodeUploadParamsAddresses$Type extends MessageType<MsgAddCodeUploadParamsAddresses> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddresses", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"addresses\"" } }
        ], { "amino.name": "wasm/MsgAddCodeUploadParamsAddresses", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgAddCodeUploadParamsAddresses>): MsgAddCodeUploadParamsAddresses {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.addresses = [];
        if (value !== undefined)
            reflectionMergePartial<MsgAddCodeUploadParamsAddresses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAddCodeUploadParamsAddresses): MsgAddCodeUploadParamsAddresses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* repeated string addresses */ 2:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAddCodeUploadParamsAddresses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* repeated string addresses = 2; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddresses
 */
export const MsgAddCodeUploadParamsAddresses = new MsgAddCodeUploadParamsAddresses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgAddCodeUploadParamsAddressesResponse$Type extends MessageType<MsgAddCodeUploadParamsAddressesResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddressesResponse", []);
    }
    create(value?: PartialMessage<MsgAddCodeUploadParamsAddressesResponse>): MsgAddCodeUploadParamsAddressesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgAddCodeUploadParamsAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgAddCodeUploadParamsAddressesResponse): MsgAddCodeUploadParamsAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgAddCodeUploadParamsAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddressesResponse
 */
export const MsgAddCodeUploadParamsAddressesResponse = new MsgAddCodeUploadParamsAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRemoveCodeUploadParamsAddresses$Type extends MessageType<MsgRemoveCodeUploadParamsAddresses> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddresses", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"addresses\"" } }
        ], { "amino.name": "wasm/MsgRemoveCodeUploadParamsAddresses", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgRemoveCodeUploadParamsAddresses>): MsgRemoveCodeUploadParamsAddresses {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.addresses = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRemoveCodeUploadParamsAddresses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRemoveCodeUploadParamsAddresses): MsgRemoveCodeUploadParamsAddresses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* repeated string addresses */ 2:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRemoveCodeUploadParamsAddresses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* repeated string addresses = 2; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddresses
 */
export const MsgRemoveCodeUploadParamsAddresses = new MsgRemoveCodeUploadParamsAddresses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRemoveCodeUploadParamsAddressesResponse$Type extends MessageType<MsgRemoveCodeUploadParamsAddressesResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddressesResponse", []);
    }
    create(value?: PartialMessage<MsgRemoveCodeUploadParamsAddressesResponse>): MsgRemoveCodeUploadParamsAddressesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRemoveCodeUploadParamsAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRemoveCodeUploadParamsAddressesResponse): MsgRemoveCodeUploadParamsAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRemoveCodeUploadParamsAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddressesResponse
 */
export const MsgRemoveCodeUploadParamsAddressesResponse = new MsgRemoveCodeUploadParamsAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgStoreAndMigrateContract$Type extends MessageType<MsgStoreAndMigrateContract> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgStoreAndMigrateContract", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "wasm_byte_code", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.customname": "WASMByteCode" } },
            { no: 3, name: "instantiate_permission", kind: "message", T: () => AccessConfig },
            { no: 4, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "msg", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.casttype": "RawContractMessage", "amino.encoding": "inline_json" } }
        ], { "amino.name": "wasm/MsgStoreAndMigrateContract", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgStoreAndMigrateContract>): MsgStoreAndMigrateContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        message.wasmByteCode = new Uint8Array(0);
        message.contract = "";
        message.msg = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgStoreAndMigrateContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgStoreAndMigrateContract): MsgStoreAndMigrateContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* bytes wasm_byte_code */ 2:
                    message.wasmByteCode = reader.bytes();
                    break;
                case /* cosmwasm.wasm.v1.AccessConfig instantiate_permission */ 3:
                    message.instantiatePermission = AccessConfig.internalBinaryRead(reader, reader.uint32(), options, message.instantiatePermission);
                    break;
                case /* string contract */ 4:
                    message.contract = reader.string();
                    break;
                case /* bytes msg */ 5:
                    message.msg = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgStoreAndMigrateContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* bytes wasm_byte_code = 2; */
        if (message.wasmByteCode.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.wasmByteCode);
        /* cosmwasm.wasm.v1.AccessConfig instantiate_permission = 3; */
        if (message.instantiatePermission)
            AccessConfig.internalBinaryWrite(message.instantiatePermission, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string contract = 4; */
        if (message.contract !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.contract);
        /* bytes msg = 5; */
        if (message.msg.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgStoreAndMigrateContract
 */
export const MsgStoreAndMigrateContract = new MsgStoreAndMigrateContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgStoreAndMigrateContractResponse$Type extends MessageType<MsgStoreAndMigrateContractResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgStoreAndMigrateContractResponse", [
            { no: 1, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.customname": "CodeID" } },
            { no: 2, name: "checksum", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MsgStoreAndMigrateContractResponse>): MsgStoreAndMigrateContractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.codeId = 0n;
        message.checksum = new Uint8Array(0);
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MsgStoreAndMigrateContractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgStoreAndMigrateContractResponse): MsgStoreAndMigrateContractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 code_id */ 1:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* bytes checksum */ 2:
                    message.checksum = reader.bytes();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgStoreAndMigrateContractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 code_id = 1; */
        if (message.codeId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.codeId);
        /* bytes checksum = 2; */
        if (message.checksum.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.checksum);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgStoreAndMigrateContractResponse
 */
export const MsgStoreAndMigrateContractResponse = new MsgStoreAndMigrateContractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateContractLabel$Type extends MessageType<MsgUpdateContractLabel> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateContractLabel", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "new_label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "amino.name": "wasm/MsgUpdateContractLabel", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgUpdateContractLabel>): MsgUpdateContractLabel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.newLabel = "";
        message.contract = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateContractLabel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateContractLabel): MsgUpdateContractLabel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string new_label */ 2:
                    message.newLabel = reader.string();
                    break;
                case /* string contract */ 3:
                    message.contract = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateContractLabel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string new_label = 2; */
        if (message.newLabel !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newLabel);
        /* string contract = 3; */
        if (message.contract !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contract);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateContractLabel
 */
export const MsgUpdateContractLabel = new MsgUpdateContractLabel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateContractLabelResponse$Type extends MessageType<MsgUpdateContractLabelResponse> {
    constructor() {
        super("cosmwasm.wasm.v1.MsgUpdateContractLabelResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateContractLabelResponse>): MsgUpdateContractLabelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateContractLabelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateContractLabelResponse): MsgUpdateContractLabelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateContractLabelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateContractLabelResponse
 */
export const MsgUpdateContractLabelResponse = new MsgUpdateContractLabelResponse$Type();
/**
 * @generated ServiceType for protobuf service cosmwasm.wasm.v1.Msg
 */
export const Msg = new ServiceType("cosmwasm.wasm.v1.Msg", [
    { name: "StoreCode", options: {}, I: MsgStoreCode, O: MsgStoreCodeResponse },
    { name: "InstantiateContract", options: {}, I: MsgInstantiateContract, O: MsgInstantiateContractResponse },
    { name: "InstantiateContract2", options: {}, I: MsgInstantiateContract2, O: MsgInstantiateContract2Response },
    { name: "ExecuteContract", options: {}, I: MsgExecuteContract, O: MsgExecuteContractResponse },
    { name: "MigrateContract", options: {}, I: MsgMigrateContract, O: MsgMigrateContractResponse },
    { name: "UpdateAdmin", options: {}, I: MsgUpdateAdmin, O: MsgUpdateAdminResponse },
    { name: "ClearAdmin", options: {}, I: MsgClearAdmin, O: MsgClearAdminResponse },
    { name: "UpdateInstantiateConfig", options: {}, I: MsgUpdateInstantiateConfig, O: MsgUpdateInstantiateConfigResponse },
    { name: "UpdateParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse },
    { name: "SudoContract", options: {}, I: MsgSudoContract, O: MsgSudoContractResponse },
    { name: "PinCodes", options: {}, I: MsgPinCodes, O: MsgPinCodesResponse },
    { name: "UnpinCodes", options: {}, I: MsgUnpinCodes, O: MsgUnpinCodesResponse },
    { name: "StoreAndInstantiateContract", options: {}, I: MsgStoreAndInstantiateContract, O: MsgStoreAndInstantiateContractResponse },
    { name: "RemoveCodeUploadParamsAddresses", options: {}, I: MsgRemoveCodeUploadParamsAddresses, O: MsgRemoveCodeUploadParamsAddressesResponse },
    { name: "AddCodeUploadParamsAddresses", options: {}, I: MsgAddCodeUploadParamsAddresses, O: MsgAddCodeUploadParamsAddressesResponse },
    { name: "StoreAndMigrateContract", options: {}, I: MsgStoreAndMigrateContract, O: MsgStoreAndMigrateContractResponse },
    { name: "UpdateContractLabel", options: {}, I: MsgUpdateContractLabel, O: MsgUpdateContractLabelResponse }
], { "cosmos.msg.v1.service": true });
