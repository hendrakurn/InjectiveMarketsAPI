import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BlockIDFlag } from "../../types/v1/validator_pb.js";
import { ProofOps } from "../../crypto/v1/proof_pb.js";
import { ConsensusParams } from "../../types/v1/params_pb.js";
import { Timestamp } from "../../../google/protobuf/timestamp_pb.js";
var CheckTxType = /* @__PURE__ */ ((CheckTxType2) => {
  CheckTxType2[CheckTxType2["UNKNOWN"] = 0] = "UNKNOWN";
  CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
  CheckTxType2[CheckTxType2["CHECK"] = 2] = "CHECK";
  return CheckTxType2;
})(CheckTxType || {});
var OfferSnapshotResult = /* @__PURE__ */ ((OfferSnapshotResult2) => {
  OfferSnapshotResult2[OfferSnapshotResult2["UNKNOWN"] = 0] = "UNKNOWN";
  OfferSnapshotResult2[OfferSnapshotResult2["ACCEPT"] = 1] = "ACCEPT";
  OfferSnapshotResult2[OfferSnapshotResult2["ABORT"] = 2] = "ABORT";
  OfferSnapshotResult2[OfferSnapshotResult2["REJECT"] = 3] = "REJECT";
  OfferSnapshotResult2[OfferSnapshotResult2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
  OfferSnapshotResult2[OfferSnapshotResult2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
  return OfferSnapshotResult2;
})(OfferSnapshotResult || {});
var ApplySnapshotChunkResult = /* @__PURE__ */ ((ApplySnapshotChunkResult2) => {
  ApplySnapshotChunkResult2[ApplySnapshotChunkResult2["UNKNOWN"] = 0] = "UNKNOWN";
  ApplySnapshotChunkResult2[ApplySnapshotChunkResult2["ACCEPT"] = 1] = "ACCEPT";
  ApplySnapshotChunkResult2[ApplySnapshotChunkResult2["ABORT"] = 2] = "ABORT";
  ApplySnapshotChunkResult2[ApplySnapshotChunkResult2["RETRY"] = 3] = "RETRY";
  ApplySnapshotChunkResult2[ApplySnapshotChunkResult2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
  ApplySnapshotChunkResult2[ApplySnapshotChunkResult2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
  return ApplySnapshotChunkResult2;
})(ApplySnapshotChunkResult || {});
var ProcessProposalStatus = /* @__PURE__ */ ((ProcessProposalStatus2) => {
  ProcessProposalStatus2[ProcessProposalStatus2["UNKNOWN"] = 0] = "UNKNOWN";
  ProcessProposalStatus2[ProcessProposalStatus2["ACCEPT"] = 1] = "ACCEPT";
  ProcessProposalStatus2[ProcessProposalStatus2["REJECT"] = 2] = "REJECT";
  return ProcessProposalStatus2;
})(ProcessProposalStatus || {});
var VerifyVoteExtensionStatus = /* @__PURE__ */ ((VerifyVoteExtensionStatus2) => {
  VerifyVoteExtensionStatus2[VerifyVoteExtensionStatus2["UNKNOWN"] = 0] = "UNKNOWN";
  VerifyVoteExtensionStatus2[VerifyVoteExtensionStatus2["ACCEPT"] = 1] = "ACCEPT";
  VerifyVoteExtensionStatus2[VerifyVoteExtensionStatus2["REJECT"] = 2] = "REJECT";
  return VerifyVoteExtensionStatus2;
})(VerifyVoteExtensionStatus || {});
var MisbehaviorType = /* @__PURE__ */ ((MisbehaviorType2) => {
  MisbehaviorType2[MisbehaviorType2["UNKNOWN"] = 0] = "UNKNOWN";
  MisbehaviorType2[MisbehaviorType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
  MisbehaviorType2[MisbehaviorType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
  return MisbehaviorType2;
})(MisbehaviorType || {});
class Request$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.Request", [
      { no: 1, name: "echo", kind: "message", oneof: "value", T: () => EchoRequest },
      { no: 2, name: "flush", kind: "message", oneof: "value", T: () => FlushRequest },
      { no: 3, name: "info", kind: "message", oneof: "value", T: () => InfoRequest },
      { no: 5, name: "init_chain", kind: "message", oneof: "value", T: () => InitChainRequest },
      { no: 6, name: "query", kind: "message", oneof: "value", T: () => QueryRequest },
      { no: 8, name: "check_tx", kind: "message", oneof: "value", T: () => CheckTxRequest },
      { no: 11, name: "commit", kind: "message", oneof: "value", T: () => CommitRequest },
      { no: 12, name: "list_snapshots", kind: "message", oneof: "value", T: () => ListSnapshotsRequest },
      { no: 13, name: "offer_snapshot", kind: "message", oneof: "value", T: () => OfferSnapshotRequest },
      { no: 14, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => LoadSnapshotChunkRequest },
      { no: 15, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ApplySnapshotChunkRequest },
      { no: 16, name: "prepare_proposal", kind: "message", oneof: "value", T: () => PrepareProposalRequest },
      { no: 17, name: "process_proposal", kind: "message", oneof: "value", T: () => ProcessProposalRequest },
      { no: 18, name: "extend_vote", kind: "message", oneof: "value", T: () => ExtendVoteRequest },
      { no: 19, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => VerifyVoteExtensionRequest },
      { no: 20, name: "finalize_block", kind: "message", oneof: "value", T: () => FinalizeBlockRequest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.EchoRequest echo */
        1:
          message.value = {
            oneofKind: "echo",
            echo: EchoRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.echo)
          };
          break;
        case /* cometbft.abci.v1.FlushRequest flush */
        2:
          message.value = {
            oneofKind: "flush",
            flush: FlushRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.flush)
          };
          break;
        case /* cometbft.abci.v1.InfoRequest info */
        3:
          message.value = {
            oneofKind: "info",
            info: InfoRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.info)
          };
          break;
        case /* cometbft.abci.v1.InitChainRequest init_chain */
        5:
          message.value = {
            oneofKind: "initChain",
            initChain: InitChainRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.initChain)
          };
          break;
        case /* cometbft.abci.v1.QueryRequest query */
        6:
          message.value = {
            oneofKind: "query",
            query: QueryRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.query)
          };
          break;
        case /* cometbft.abci.v1.CheckTxRequest check_tx */
        8:
          message.value = {
            oneofKind: "checkTx",
            checkTx: CheckTxRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.checkTx)
          };
          break;
        case /* cometbft.abci.v1.CommitRequest commit */
        11:
          message.value = {
            oneofKind: "commit",
            commit: CommitRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.commit)
          };
          break;
        case /* cometbft.abci.v1.ListSnapshotsRequest list_snapshots */
        12:
          message.value = {
            oneofKind: "listSnapshots",
            listSnapshots: ListSnapshotsRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.listSnapshots)
          };
          break;
        case /* cometbft.abci.v1.OfferSnapshotRequest offer_snapshot */
        13:
          message.value = {
            oneofKind: "offerSnapshot",
            offerSnapshot: OfferSnapshotRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.offerSnapshot)
          };
          break;
        case /* cometbft.abci.v1.LoadSnapshotChunkRequest load_snapshot_chunk */
        14:
          message.value = {
            oneofKind: "loadSnapshotChunk",
            loadSnapshotChunk: LoadSnapshotChunkRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.loadSnapshotChunk)
          };
          break;
        case /* cometbft.abci.v1.ApplySnapshotChunkRequest apply_snapshot_chunk */
        15:
          message.value = {
            oneofKind: "applySnapshotChunk",
            applySnapshotChunk: ApplySnapshotChunkRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.applySnapshotChunk)
          };
          break;
        case /* cometbft.abci.v1.PrepareProposalRequest prepare_proposal */
        16:
          message.value = {
            oneofKind: "prepareProposal",
            prepareProposal: PrepareProposalRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.prepareProposal)
          };
          break;
        case /* cometbft.abci.v1.ProcessProposalRequest process_proposal */
        17:
          message.value = {
            oneofKind: "processProposal",
            processProposal: ProcessProposalRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.processProposal)
          };
          break;
        case /* cometbft.abci.v1.ExtendVoteRequest extend_vote */
        18:
          message.value = {
            oneofKind: "extendVote",
            extendVote: ExtendVoteRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.extendVote)
          };
          break;
        case /* cometbft.abci.v1.VerifyVoteExtensionRequest verify_vote_extension */
        19:
          message.value = {
            oneofKind: "verifyVoteExtension",
            verifyVoteExtension: VerifyVoteExtensionRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.verifyVoteExtension)
          };
          break;
        case /* cometbft.abci.v1.FinalizeBlockRequest finalize_block */
        20:
          message.value = {
            oneofKind: "finalizeBlock",
            finalizeBlock: FinalizeBlockRequest.internalBinaryRead(reader, reader.uint32(), options, message.value.finalizeBlock)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value.oneofKind === "echo")
      EchoRequest.internalBinaryWrite(message.value.echo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "flush")
      FlushRequest.internalBinaryWrite(message.value.flush, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "info")
      InfoRequest.internalBinaryWrite(message.value.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "initChain")
      InitChainRequest.internalBinaryWrite(message.value.initChain, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "query")
      QueryRequest.internalBinaryWrite(message.value.query, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "checkTx")
      CheckTxRequest.internalBinaryWrite(message.value.checkTx, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "commit")
      CommitRequest.internalBinaryWrite(message.value.commit, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "listSnapshots")
      ListSnapshotsRequest.internalBinaryWrite(message.value.listSnapshots, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "offerSnapshot")
      OfferSnapshotRequest.internalBinaryWrite(message.value.offerSnapshot, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "loadSnapshotChunk")
      LoadSnapshotChunkRequest.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "applySnapshotChunk")
      ApplySnapshotChunkRequest.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "prepareProposal")
      PrepareProposalRequest.internalBinaryWrite(message.value.prepareProposal, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "processProposal")
      ProcessProposalRequest.internalBinaryWrite(message.value.processProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "extendVote")
      ExtendVoteRequest.internalBinaryWrite(message.value.extendVote, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "verifyVoteExtension")
      VerifyVoteExtensionRequest.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "finalizeBlock")
      FinalizeBlockRequest.internalBinaryWrite(message.value.finalizeBlock, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Request = new Request$Type();
class EchoRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.EchoRequest", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.message = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EchoRequest = new EchoRequest$Type();
class FlushRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.FlushRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FlushRequest = new FlushRequest$Type();
class InfoRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.InfoRequest", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "block_version",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "p2p_version",
        kind: "scalar",
        jsonName: "p2pVersion",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "abci_version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.version = "";
    message.blockVersion = 0n;
    message.p2PVersion = 0n;
    message.abciVersion = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string version */
        1:
          message.version = reader.string();
          break;
        case /* uint64 block_version */
        2:
          message.blockVersion = reader.uint64().toBigInt();
          break;
        case /* uint64 p2p_version */
        3:
          message.p2PVersion = reader.uint64().toBigInt();
          break;
        case /* string abci_version */
        4:
          message.abciVersion = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.version !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.version);
    if (message.blockVersion !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.blockVersion);
    if (message.p2PVersion !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.p2PVersion);
    if (message.abciVersion !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.abciVersion);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InfoRequest = new InfoRequest$Type();
class InitChainRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.InitChainRequest", [
      { no: 1, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 2,
        name: "chain_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "consensus_params", kind: "message", T: () => ConsensusParams },
      { no: 4, name: "validators", kind: "message", repeat: 2, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
      {
        no: 5,
        name: "app_state_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "initial_height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.chainId = "";
    message.validators = [];
    message.appStateBytes = new Uint8Array(0);
    message.initialHeight = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Timestamp time */
        1:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* string chain_id */
        2:
          message.chainId = reader.string();
          break;
        case /* cometbft.types.v1.ConsensusParams consensus_params */
        3:
          message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
          break;
        case /* repeated cometbft.abci.v1.ValidatorUpdate validators */
        4:
          message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes app_state_bytes */
        5:
          message.appStateBytes = reader.bytes();
          break;
        case /* int64 initial_height */
        6:
          message.initialHeight = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.chainId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.chainId);
    if (message.consensusParams)
      ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.validators.length; i++)
      ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.appStateBytes.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.appStateBytes);
    if (message.initialHeight !== 0n)
      writer.tag(6, WireType.Varint).int64(message.initialHeight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InitChainRequest = new InitChainRequest$Type();
class QueryRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.QueryRequest", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "path",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "prove",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    message.path = "";
    message.height = 0n;
    message.prove = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */
        1:
          message.data = reader.bytes();
          break;
        case /* string path */
        2:
          message.path = reader.string();
          break;
        case /* int64 height */
        3:
          message.height = reader.int64().toBigInt();
          break;
        case /* bool prove */
        4:
          message.prove = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    if (message.path !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.path);
    if (message.height !== 0n)
      writer.tag(3, WireType.Varint).int64(message.height);
    if (message.prove !== false)
      writer.tag(4, WireType.Varint).bool(message.prove);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryRequest = new QueryRequest$Type();
class CheckTxRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.CheckTxRequest", [
      {
        no: 1,
        name: "tx",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "type", kind: "enum", T: () => ["cometbft.abci.v1.CheckTxType", CheckTxType, "CHECK_TX_TYPE_"] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.tx = new Uint8Array(0);
    message.type = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes tx */
        1:
          message.tx = reader.bytes();
          break;
        case /* cometbft.abci.v1.CheckTxType type */
        3:
          message.type = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tx.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
    if (message.type !== 0)
      writer.tag(3, WireType.Varint).int32(message.type);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CheckTxRequest = new CheckTxRequest$Type();
class CommitRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.CommitRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommitRequest = new CommitRequest$Type();
class ListSnapshotsRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ListSnapshotsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListSnapshotsRequest = new ListSnapshotsRequest$Type();
class OfferSnapshotRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.OfferSnapshotRequest", [
      { no: 1, name: "snapshot", kind: "message", T: () => Snapshot },
      {
        no: 2,
        name: "app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.appHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.Snapshot snapshot */
        1:
          message.snapshot = Snapshot.internalBinaryRead(reader, reader.uint32(), options, message.snapshot);
          break;
        case /* bytes app_hash */
        2:
          message.appHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.snapshot)
      Snapshot.internalBinaryWrite(message.snapshot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.appHash.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.appHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OfferSnapshotRequest = new OfferSnapshotRequest$Type();
class LoadSnapshotChunkRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.LoadSnapshotChunkRequest", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "format",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "chunk",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.format = 0;
    message.chunk = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 height */
        1:
          message.height = reader.uint64().toBigInt();
          break;
        case /* uint32 format */
        2:
          message.format = reader.uint32();
          break;
        case /* uint32 chunk */
        3:
          message.chunk = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.height);
    if (message.format !== 0)
      writer.tag(2, WireType.Varint).uint32(message.format);
    if (message.chunk !== 0)
      writer.tag(3, WireType.Varint).uint32(message.chunk);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LoadSnapshotChunkRequest = new LoadSnapshotChunkRequest$Type();
class ApplySnapshotChunkRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ApplySnapshotChunkRequest", [
      {
        no: 1,
        name: "index",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "chunk",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "sender",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.index = 0;
    message.chunk = new Uint8Array(0);
    message.sender = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 index */
        1:
          message.index = reader.uint32();
          break;
        case /* bytes chunk */
        2:
          message.chunk = reader.bytes();
          break;
        case /* string sender */
        3:
          message.sender = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.index !== 0)
      writer.tag(1, WireType.Varint).uint32(message.index);
    if (message.chunk.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.chunk);
    if (message.sender !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.sender);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ApplySnapshotChunkRequest = new ApplySnapshotChunkRequest$Type();
class PrepareProposalRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.PrepareProposalRequest", [
      {
        no: 1,
        name: "max_tx_bytes",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "local_last_commit", kind: "message", T: () => ExtendedCommitInfo, options: { "gogoproto.nullable": false } },
      { no: 4, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.maxTxBytes = 0n;
    message.txs = [];
    message.misbehavior = [];
    message.height = 0n;
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 max_tx_bytes */
        1:
          message.maxTxBytes = reader.int64().toBigInt();
          break;
        case /* repeated bytes txs */
        2:
          message.txs.push(reader.bytes());
          break;
        case /* cometbft.abci.v1.ExtendedCommitInfo local_last_commit */
        3:
          message.localLastCommit = ExtendedCommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.localLastCommit);
          break;
        case /* repeated cometbft.abci.v1.Misbehavior misbehavior */
        4:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* int64 height */
        5:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        6:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.maxTxBytes !== 0n)
      writer.tag(1, WireType.Varint).int64(message.maxTxBytes);
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.localLastCommit)
      ExtendedCommitInfo.internalBinaryWrite(message.localLastCommit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PrepareProposalRequest = new PrepareProposalRequest$Type();
class ProcessProposalRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ProcessProposalRequest", [
      {
        no: 1,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.txs = [];
    message.misbehavior = [];
    message.hash = new Uint8Array(0);
    message.height = 0n;
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes txs */
        1:
          message.txs.push(reader.bytes());
          break;
        case /* cometbft.abci.v1.CommitInfo proposed_last_commit */
        2:
          message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
          break;
        case /* repeated cometbft.abci.v1.Misbehavior misbehavior */
        3:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes hash */
        4:
          message.hash = reader.bytes();
          break;
        case /* int64 height */
        5:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        6:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.proposedLastCommit)
      CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.hash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProcessProposalRequest = new ProcessProposalRequest$Type();
class ExtendVoteRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ExtendVoteRequest", [
      {
        no: 1,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 3, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 4,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 5, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
      { no: 6, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = new Uint8Array(0);
    message.height = 0n;
    message.txs = [];
    message.misbehavior = [];
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hash */
        1:
          message.hash = reader.bytes();
          break;
        case /* int64 height */
        2:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        3:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* repeated bytes txs */
        4:
          message.txs.push(reader.bytes());
          break;
        case /* cometbft.abci.v1.CommitInfo proposed_last_commit */
        5:
          message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
          break;
        case /* repeated cometbft.abci.v1.Misbehavior misbehavior */
        6:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
    if (message.height !== 0n)
      writer.tag(2, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(4, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.proposedLastCommit)
      CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExtendVoteRequest = new ExtendVoteRequest$Type();
class VerifyVoteExtensionRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.VerifyVoteExtensionRequest", [
      {
        no: 1,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "validator_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "vote_extension",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hash = new Uint8Array(0);
    message.validatorAddress = new Uint8Array(0);
    message.height = 0n;
    message.voteExtension = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hash */
        1:
          message.hash = reader.bytes();
          break;
        case /* bytes validator_address */
        2:
          message.validatorAddress = reader.bytes();
          break;
        case /* int64 height */
        3:
          message.height = reader.int64().toBigInt();
          break;
        case /* bytes vote_extension */
        4:
          message.voteExtension = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hash.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
    if (message.validatorAddress.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.validatorAddress);
    if (message.height !== 0n)
      writer.tag(3, WireType.Varint).int64(message.height);
    if (message.voteExtension.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.voteExtension);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VerifyVoteExtensionRequest = new VerifyVoteExtensionRequest$Type();
class FinalizeBlockRequest$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.FinalizeBlockRequest", [
      {
        no: 1,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "decided_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
      { no: 3, name: "misbehavior", kind: "message", repeat: 2, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 7,
        name: "next_validators_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proposer_address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 9,
        name: "syncing_to_height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.txs = [];
    message.misbehavior = [];
    message.hash = new Uint8Array(0);
    message.height = 0n;
    message.nextValidatorsHash = new Uint8Array(0);
    message.proposerAddress = new Uint8Array(0);
    message.syncingToHeight = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes txs */
        1:
          message.txs.push(reader.bytes());
          break;
        case /* cometbft.abci.v1.CommitInfo decided_last_commit */
        2:
          message.decidedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.decidedLastCommit);
          break;
        case /* repeated cometbft.abci.v1.Misbehavior misbehavior */
        3:
          message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes hash */
        4:
          message.hash = reader.bytes();
          break;
        case /* int64 height */
        5:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        6:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* bytes next_validators_hash */
        7:
          message.nextValidatorsHash = reader.bytes();
          break;
        case /* bytes proposer_address */
        8:
          message.proposerAddress = reader.bytes();
          break;
        case /* int64 syncing_to_height */
        9:
          message.syncingToHeight = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
    if (message.decidedLastCommit)
      CommitInfo.internalBinaryWrite(message.decidedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.misbehavior.length; i++)
      Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.hash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
    if (message.height !== 0n)
      writer.tag(5, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.nextValidatorsHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
    if (message.proposerAddress.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
    if (message.syncingToHeight !== 0n)
      writer.tag(9, WireType.Varint).int64(message.syncingToHeight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FinalizeBlockRequest = new FinalizeBlockRequest$Type();
class Response$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.Response", [
      { no: 1, name: "exception", kind: "message", oneof: "value", T: () => ExceptionResponse },
      { no: 2, name: "echo", kind: "message", oneof: "value", T: () => EchoResponse },
      { no: 3, name: "flush", kind: "message", oneof: "value", T: () => FlushResponse },
      { no: 4, name: "info", kind: "message", oneof: "value", T: () => InfoResponse },
      { no: 6, name: "init_chain", kind: "message", oneof: "value", T: () => InitChainResponse },
      { no: 7, name: "query", kind: "message", oneof: "value", T: () => QueryResponse },
      { no: 9, name: "check_tx", kind: "message", oneof: "value", T: () => CheckTxResponse },
      { no: 12, name: "commit", kind: "message", oneof: "value", T: () => CommitResponse },
      { no: 13, name: "list_snapshots", kind: "message", oneof: "value", T: () => ListSnapshotsResponse },
      { no: 14, name: "offer_snapshot", kind: "message", oneof: "value", T: () => OfferSnapshotResponse },
      { no: 15, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => LoadSnapshotChunkResponse },
      { no: 16, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ApplySnapshotChunkResponse },
      { no: 17, name: "prepare_proposal", kind: "message", oneof: "value", T: () => PrepareProposalResponse },
      { no: 18, name: "process_proposal", kind: "message", oneof: "value", T: () => ProcessProposalResponse },
      { no: 19, name: "extend_vote", kind: "message", oneof: "value", T: () => ExtendVoteResponse },
      { no: 20, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => VerifyVoteExtensionResponse },
      { no: 21, name: "finalize_block", kind: "message", oneof: "value", T: () => FinalizeBlockResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.ExceptionResponse exception */
        1:
          message.value = {
            oneofKind: "exception",
            exception: ExceptionResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.exception)
          };
          break;
        case /* cometbft.abci.v1.EchoResponse echo */
        2:
          message.value = {
            oneofKind: "echo",
            echo: EchoResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.echo)
          };
          break;
        case /* cometbft.abci.v1.FlushResponse flush */
        3:
          message.value = {
            oneofKind: "flush",
            flush: FlushResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.flush)
          };
          break;
        case /* cometbft.abci.v1.InfoResponse info */
        4:
          message.value = {
            oneofKind: "info",
            info: InfoResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.info)
          };
          break;
        case /* cometbft.abci.v1.InitChainResponse init_chain */
        6:
          message.value = {
            oneofKind: "initChain",
            initChain: InitChainResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.initChain)
          };
          break;
        case /* cometbft.abci.v1.QueryResponse query */
        7:
          message.value = {
            oneofKind: "query",
            query: QueryResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.query)
          };
          break;
        case /* cometbft.abci.v1.CheckTxResponse check_tx */
        9:
          message.value = {
            oneofKind: "checkTx",
            checkTx: CheckTxResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.checkTx)
          };
          break;
        case /* cometbft.abci.v1.CommitResponse commit */
        12:
          message.value = {
            oneofKind: "commit",
            commit: CommitResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.commit)
          };
          break;
        case /* cometbft.abci.v1.ListSnapshotsResponse list_snapshots */
        13:
          message.value = {
            oneofKind: "listSnapshots",
            listSnapshots: ListSnapshotsResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.listSnapshots)
          };
          break;
        case /* cometbft.abci.v1.OfferSnapshotResponse offer_snapshot */
        14:
          message.value = {
            oneofKind: "offerSnapshot",
            offerSnapshot: OfferSnapshotResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.offerSnapshot)
          };
          break;
        case /* cometbft.abci.v1.LoadSnapshotChunkResponse load_snapshot_chunk */
        15:
          message.value = {
            oneofKind: "loadSnapshotChunk",
            loadSnapshotChunk: LoadSnapshotChunkResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.loadSnapshotChunk)
          };
          break;
        case /* cometbft.abci.v1.ApplySnapshotChunkResponse apply_snapshot_chunk */
        16:
          message.value = {
            oneofKind: "applySnapshotChunk",
            applySnapshotChunk: ApplySnapshotChunkResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.applySnapshotChunk)
          };
          break;
        case /* cometbft.abci.v1.PrepareProposalResponse prepare_proposal */
        17:
          message.value = {
            oneofKind: "prepareProposal",
            prepareProposal: PrepareProposalResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.prepareProposal)
          };
          break;
        case /* cometbft.abci.v1.ProcessProposalResponse process_proposal */
        18:
          message.value = {
            oneofKind: "processProposal",
            processProposal: ProcessProposalResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.processProposal)
          };
          break;
        case /* cometbft.abci.v1.ExtendVoteResponse extend_vote */
        19:
          message.value = {
            oneofKind: "extendVote",
            extendVote: ExtendVoteResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.extendVote)
          };
          break;
        case /* cometbft.abci.v1.VerifyVoteExtensionResponse verify_vote_extension */
        20:
          message.value = {
            oneofKind: "verifyVoteExtension",
            verifyVoteExtension: VerifyVoteExtensionResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.verifyVoteExtension)
          };
          break;
        case /* cometbft.abci.v1.FinalizeBlockResponse finalize_block */
        21:
          message.value = {
            oneofKind: "finalizeBlock",
            finalizeBlock: FinalizeBlockResponse.internalBinaryRead(reader, reader.uint32(), options, message.value.finalizeBlock)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value.oneofKind === "exception")
      ExceptionResponse.internalBinaryWrite(message.value.exception, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "echo")
      EchoResponse.internalBinaryWrite(message.value.echo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "flush")
      FlushResponse.internalBinaryWrite(message.value.flush, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "info")
      InfoResponse.internalBinaryWrite(message.value.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "initChain")
      InitChainResponse.internalBinaryWrite(message.value.initChain, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "query")
      QueryResponse.internalBinaryWrite(message.value.query, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "checkTx")
      CheckTxResponse.internalBinaryWrite(message.value.checkTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "commit")
      CommitResponse.internalBinaryWrite(message.value.commit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "listSnapshots")
      ListSnapshotsResponse.internalBinaryWrite(message.value.listSnapshots, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "offerSnapshot")
      OfferSnapshotResponse.internalBinaryWrite(message.value.offerSnapshot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "loadSnapshotChunk")
      LoadSnapshotChunkResponse.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "applySnapshotChunk")
      ApplySnapshotChunkResponse.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "prepareProposal")
      PrepareProposalResponse.internalBinaryWrite(message.value.prepareProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "processProposal")
      ProcessProposalResponse.internalBinaryWrite(message.value.processProposal, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "extendVote")
      ExtendVoteResponse.internalBinaryWrite(message.value.extendVote, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "verifyVoteExtension")
      VerifyVoteExtensionResponse.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    if (message.value.oneofKind === "finalizeBlock")
      FinalizeBlockResponse.internalBinaryWrite(message.value.finalizeBlock, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Response = new Response$Type();
class ExceptionResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ExceptionResponse", [
      {
        no: 1,
        name: "error",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.error = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string error */
        1:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.error !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExceptionResponse = new ExceptionResponse$Type();
class EchoResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.EchoResponse", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.message = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EchoResponse = new EchoResponse$Type();
class FlushResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.FlushResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FlushResponse = new FlushResponse$Type();
class InfoResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.InfoResponse", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "app_version",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "last_block_height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "last_block_app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = "";
    message.version = "";
    message.appVersion = 0n;
    message.lastBlockHeight = 0n;
    message.lastBlockAppHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string data */
        1:
          message.data = reader.string();
          break;
        case /* string version */
        2:
          message.version = reader.string();
          break;
        case /* uint64 app_version */
        3:
          message.appVersion = reader.uint64().toBigInt();
          break;
        case /* int64 last_block_height */
        4:
          message.lastBlockHeight = reader.int64().toBigInt();
          break;
        case /* bytes last_block_app_hash */
        5:
          message.lastBlockAppHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.data);
    if (message.version !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.version);
    if (message.appVersion !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.appVersion);
    if (message.lastBlockHeight !== 0n)
      writer.tag(4, WireType.Varint).int64(message.lastBlockHeight);
    if (message.lastBlockAppHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.lastBlockAppHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InfoResponse = new InfoResponse$Type();
class InitChainResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.InitChainResponse", [
      { no: 1, name: "consensus_params", kind: "message", T: () => ConsensusParams },
      { no: 2, name: "validators", kind: "message", repeat: 2, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validators = [];
    message.appHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.types.v1.ConsensusParams consensus_params */
        1:
          message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
          break;
        case /* repeated cometbft.abci.v1.ValidatorUpdate validators */
        2:
          message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes app_hash */
        3:
          message.appHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.consensusParams)
      ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.validators.length; i++)
      ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.appHash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.appHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InitChainResponse = new InitChainResponse$Type();
class QueryResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.QueryResponse", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "index",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "key",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "value",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 8, name: "proof_ops", kind: "message", T: () => ProofOps },
      {
        no: 9,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = 0;
    message.log = "";
    message.info = "";
    message.index = 0n;
    message.key = new Uint8Array(0);
    message.value = new Uint8Array(0);
    message.height = 0n;
    message.codespace = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 code */
        1:
          message.code = reader.uint32();
          break;
        case /* string log */
        3:
          message.log = reader.string();
          break;
        case /* string info */
        4:
          message.info = reader.string();
          break;
        case /* int64 index */
        5:
          message.index = reader.int64().toBigInt();
          break;
        case /* bytes key */
        6:
          message.key = reader.bytes();
          break;
        case /* bytes value */
        7:
          message.value = reader.bytes();
          break;
        case /* cometbft.crypto.v1.ProofOps proof_ops */
        8:
          message.proofOps = ProofOps.internalBinaryRead(reader, reader.uint32(), options, message.proofOps);
          break;
        case /* int64 height */
        9:
          message.height = reader.int64().toBigInt();
          break;
        case /* string codespace */
        10:
          message.codespace = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code !== 0)
      writer.tag(1, WireType.Varint).uint32(message.code);
    if (message.log !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.log);
    if (message.info !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.info);
    if (message.index !== 0n)
      writer.tag(5, WireType.Varint).int64(message.index);
    if (message.key.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.key);
    if (message.value.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.value);
    if (message.proofOps)
      ProofOps.internalBinaryWrite(message.proofOps, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.height !== 0n)
      writer.tag(9, WireType.Varint).int64(message.height);
    if (message.codespace !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.codespace);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QueryResponse = new QueryResponse$Type();
class CheckTxResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.CheckTxResponse", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "gas_wanted",
        kind: "scalar",
        jsonName: "gas_wanted",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "gas_used",
        kind: "scalar",
        jsonName: "gas_used",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 7, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
      {
        no: 8,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = 0;
    message.data = new Uint8Array(0);
    message.log = "";
    message.info = "";
    message.gasWanted = 0n;
    message.gasUsed = 0n;
    message.events = [];
    message.codespace = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 code */
        1:
          message.code = reader.uint32();
          break;
        case /* bytes data */
        2:
          message.data = reader.bytes();
          break;
        case /* string log */
        3:
          message.log = reader.string();
          break;
        case /* string info */
        4:
          message.info = reader.string();
          break;
        case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */
        5:
          message.gasWanted = reader.int64().toBigInt();
          break;
        case /* int64 gas_used = 6 [json_name = "gas_used"] */
        6:
          message.gasUsed = reader.int64().toBigInt();
          break;
        case /* repeated cometbft.abci.v1.Event events */
        7:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string codespace */
        8:
          message.codespace = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code !== 0)
      writer.tag(1, WireType.Varint).uint32(message.code);
    if (message.data.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    if (message.log !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.log);
    if (message.info !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.info);
    if (message.gasWanted !== 0n)
      writer.tag(5, WireType.Varint).int64(message.gasWanted);
    if (message.gasUsed !== 0n)
      writer.tag(6, WireType.Varint).int64(message.gasUsed);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.codespace !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.codespace);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CheckTxResponse = new CheckTxResponse$Type();
class CommitResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.CommitResponse", [
      {
        no: 3,
        name: "retain_height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.retainHeight = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 retain_height */
        3:
          message.retainHeight = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.retainHeight !== 0n)
      writer.tag(3, WireType.Varint).int64(message.retainHeight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommitResponse = new CommitResponse$Type();
class ListSnapshotsResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ListSnapshotsResponse", [
      { no: 1, name: "snapshots", kind: "message", repeat: 2, T: () => Snapshot }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.snapshots = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cometbft.abci.v1.Snapshot snapshots */
        1:
          message.snapshots.push(Snapshot.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.snapshots.length; i++)
      Snapshot.internalBinaryWrite(message.snapshots[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListSnapshotsResponse = new ListSnapshotsResponse$Type();
class OfferSnapshotResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.OfferSnapshotResponse", [
      { no: 1, name: "result", kind: "enum", T: () => ["cometbft.abci.v1.OfferSnapshotResult", OfferSnapshotResult, "OFFER_SNAPSHOT_RESULT_"] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.OfferSnapshotResult result */
        1:
          message.result = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result !== 0)
      writer.tag(1, WireType.Varint).int32(message.result);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OfferSnapshotResponse = new OfferSnapshotResponse$Type();
class LoadSnapshotChunkResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.LoadSnapshotChunkResponse", [
      {
        no: 1,
        name: "chunk",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.chunk = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes chunk */
        1:
          message.chunk = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.chunk.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.chunk);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LoadSnapshotChunkResponse = new LoadSnapshotChunkResponse$Type();
class ApplySnapshotChunkResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ApplySnapshotChunkResponse", [
      { no: 1, name: "result", kind: "enum", T: () => ["cometbft.abci.v1.ApplySnapshotChunkResult", ApplySnapshotChunkResult, "APPLY_SNAPSHOT_CHUNK_RESULT_"] },
      {
        no: 2,
        name: "refetch_chunks",
        kind: "scalar",
        repeat: 1,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "reject_senders",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = 0;
    message.refetchChunks = [];
    message.rejectSenders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.ApplySnapshotChunkResult result */
        1:
          message.result = reader.int32();
          break;
        case /* repeated uint32 refetch_chunks */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.refetchChunks.push(reader.uint32());
          else
            message.refetchChunks.push(reader.uint32());
          break;
        case /* repeated string reject_senders */
        3:
          message.rejectSenders.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result !== 0)
      writer.tag(1, WireType.Varint).int32(message.result);
    if (message.refetchChunks.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.refetchChunks.length; i++)
        writer.uint32(message.refetchChunks[i]);
      writer.join();
    }
    for (let i = 0; i < message.rejectSenders.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.rejectSenders[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ApplySnapshotChunkResponse = new ApplySnapshotChunkResponse$Type();
class PrepareProposalResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.PrepareProposalResponse", [
      {
        no: 1,
        name: "txs",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.txs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes txs */
        1:
          message.txs.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.txs.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PrepareProposalResponse = new PrepareProposalResponse$Type();
class ProcessProposalResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ProcessProposalResponse", [
      { no: 1, name: "status", kind: "enum", T: () => ["cometbft.abci.v1.ProcessProposalStatus", ProcessProposalStatus, "PROCESS_PROPOSAL_STATUS_"] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.ProcessProposalStatus status */
        1:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== 0)
      writer.tag(1, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProcessProposalResponse = new ProcessProposalResponse$Type();
class ExtendVoteResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ExtendVoteResponse", [
      {
        no: 1,
        name: "vote_extension",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.voteExtension = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes vote_extension */
        1:
          message.voteExtension = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.voteExtension.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.voteExtension);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExtendVoteResponse = new ExtendVoteResponse$Type();
class VerifyVoteExtensionResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.VerifyVoteExtensionResponse", [
      { no: 1, name: "status", kind: "enum", T: () => ["cometbft.abci.v1.VerifyVoteExtensionStatus", VerifyVoteExtensionStatus, "VERIFY_VOTE_EXTENSION_STATUS_"] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.VerifyVoteExtensionStatus status */
        1:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== 0)
      writer.tag(1, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VerifyVoteExtensionResponse = new VerifyVoteExtensionResponse$Type();
class FinalizeBlockResponse$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.FinalizeBlockResponse", [
      { no: 1, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
      { no: 2, name: "tx_results", kind: "message", repeat: 2, T: () => ExecTxResult },
      { no: 3, name: "validator_updates", kind: "message", repeat: 2, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
      { no: 4, name: "consensus_param_updates", kind: "message", T: () => ConsensusParams },
      {
        no: 5,
        name: "app_hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.events = [];
    message.txResults = [];
    message.validatorUpdates = [];
    message.appHash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated cometbft.abci.v1.Event events */
        1:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated cometbft.abci.v1.ExecTxResult tx_results */
        2:
          message.txResults.push(ExecTxResult.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated cometbft.abci.v1.ValidatorUpdate validator_updates */
        3:
          message.validatorUpdates.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* cometbft.types.v1.ConsensusParams consensus_param_updates */
        4:
          message.consensusParamUpdates = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParamUpdates);
          break;
        case /* bytes app_hash */
        5:
          message.appHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.txResults.length; i++)
      ExecTxResult.internalBinaryWrite(message.txResults[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.validatorUpdates.length; i++)
      ValidatorUpdate.internalBinaryWrite(message.validatorUpdates[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.consensusParamUpdates)
      ConsensusParams.internalBinaryWrite(message.consensusParamUpdates, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.appHash.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.appHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FinalizeBlockResponse = new FinalizeBlockResponse$Type();
class CommitInfo$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.CommitInfo", [
      {
        no: 1,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 2, name: "votes", kind: "message", repeat: 2, T: () => VoteInfo, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.round = 0;
    message.votes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 round */
        1:
          message.round = reader.int32();
          break;
        case /* repeated cometbft.abci.v1.VoteInfo votes */
        2:
          message.votes.push(VoteInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.round !== 0)
      writer.tag(1, WireType.Varint).int32(message.round);
    for (let i = 0; i < message.votes.length; i++)
      VoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommitInfo = new CommitInfo$Type();
class ExtendedCommitInfo$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ExtendedCommitInfo", [
      {
        no: 1,
        name: "round",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 2, name: "votes", kind: "message", repeat: 2, T: () => ExtendedVoteInfo, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.round = 0;
    message.votes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 round */
        1:
          message.round = reader.int32();
          break;
        case /* repeated cometbft.abci.v1.ExtendedVoteInfo votes */
        2:
          message.votes.push(ExtendedVoteInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.round !== 0)
      writer.tag(1, WireType.Varint).int32(message.round);
    for (let i = 0; i < message.votes.length; i++)
      ExtendedVoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExtendedCommitInfo = new ExtendedCommitInfo$Type();
class Event$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.Event", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "attributes", kind: "message", repeat: 2, T: () => EventAttribute, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "attributes,omitempty" } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = "";
    message.attributes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */
        1:
          message.type = reader.string();
          break;
        case /* repeated cometbft.abci.v1.EventAttribute attributes */
        2:
          message.attributes.push(EventAttribute.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    for (let i = 0; i < message.attributes.length; i++)
      EventAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Event = new Event$Type();
class EventAttribute$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.EventAttribute", [
      {
        no: 1,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "index",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = "";
    message.value = "";
    message.index = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */
        1:
          message.key = reader.string();
          break;
        case /* string value */
        2:
          message.value = reader.string();
          break;
        case /* bool index */
        3:
          message.index = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    if (message.value !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.value);
    if (message.index !== false)
      writer.tag(3, WireType.Varint).bool(message.index);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EventAttribute = new EventAttribute$Type();
class ExecTxResult$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ExecTxResult", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "log",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "info",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "gas_wanted",
        kind: "scalar",
        jsonName: "gas_wanted",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "gas_used",
        kind: "scalar",
        jsonName: "gas_used",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 7, name: "events", kind: "message", repeat: 2, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
      {
        no: 8,
        name: "codespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = 0;
    message.data = new Uint8Array(0);
    message.log = "";
    message.info = "";
    message.gasWanted = 0n;
    message.gasUsed = 0n;
    message.events = [];
    message.codespace = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 code */
        1:
          message.code = reader.uint32();
          break;
        case /* bytes data */
        2:
          message.data = reader.bytes();
          break;
        case /* string log */
        3:
          message.log = reader.string();
          break;
        case /* string info */
        4:
          message.info = reader.string();
          break;
        case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */
        5:
          message.gasWanted = reader.int64().toBigInt();
          break;
        case /* int64 gas_used = 6 [json_name = "gas_used"] */
        6:
          message.gasUsed = reader.int64().toBigInt();
          break;
        case /* repeated cometbft.abci.v1.Event events */
        7:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string codespace */
        8:
          message.codespace = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code !== 0)
      writer.tag(1, WireType.Varint).uint32(message.code);
    if (message.data.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    if (message.log !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.log);
    if (message.info !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.info);
    if (message.gasWanted !== 0n)
      writer.tag(5, WireType.Varint).int64(message.gasWanted);
    if (message.gasUsed !== 0n)
      writer.tag(6, WireType.Varint).int64(message.gasUsed);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.codespace !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.codespace);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecTxResult = new ExecTxResult$Type();
class TxResult$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.TxResult", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "index",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "tx",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "result", kind: "message", T: () => ExecTxResult, options: { "gogoproto.nullable": false } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.index = 0;
    message.tx = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 height */
        1:
          message.height = reader.int64().toBigInt();
          break;
        case /* uint32 index */
        2:
          message.index = reader.uint32();
          break;
        case /* bytes tx */
        3:
          message.tx = reader.bytes();
          break;
        case /* cometbft.abci.v1.ExecTxResult result */
        4:
          message.result = ExecTxResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).int64(message.height);
    if (message.index !== 0)
      writer.tag(2, WireType.Varint).uint32(message.index);
    if (message.tx.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.tx);
    if (message.result)
      ExecTxResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TxResult = new TxResult$Type();
class Validator$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.Validator", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "power",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = new Uint8Array(0);
    message.power = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes address */
        1:
          message.address = reader.bytes();
          break;
        case /* int64 power */
        3:
          message.power = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.address);
    if (message.power !== 0n)
      writer.tag(3, WireType.Varint).int64(message.power);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Validator = new Validator$Type();
class ValidatorUpdate$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ValidatorUpdate", [
      {
        no: 2,
        name: "power",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "pub_key_bytes",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "pub_key_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.power = 0n;
    message.pubKeyBytes = new Uint8Array(0);
    message.pubKeyType = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 power */
        2:
          message.power = reader.int64().toBigInt();
          break;
        case /* bytes pub_key_bytes */
        3:
          message.pubKeyBytes = reader.bytes();
          break;
        case /* string pub_key_type */
        4:
          message.pubKeyType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.power !== 0n)
      writer.tag(2, WireType.Varint).int64(message.power);
    if (message.pubKeyBytes.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.pubKeyBytes);
    if (message.pubKeyType !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.pubKeyType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorUpdate = new ValidatorUpdate$Type();
class VoteInfo$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.VoteInfo", [
      { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
      { no: 3, name: "block_id_flag", kind: "enum", T: () => ["cometbft.types.v1.BlockIDFlag", BlockIDFlag] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.blockIdFlag = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.Validator validator */
        1:
          message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
          break;
        case /* cometbft.types.v1.BlockIDFlag block_id_flag */
        3:
          message.blockIdFlag = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validator)
      Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.blockIdFlag !== 0)
      writer.tag(3, WireType.Varint).int32(message.blockIdFlag);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VoteInfo = new VoteInfo$Type();
class ExtendedVoteInfo$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.ExtendedVoteInfo", [
      { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "vote_extension",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "extension_signature",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 5, name: "block_id_flag", kind: "enum", T: () => ["cometbft.types.v1.BlockIDFlag", BlockIDFlag] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.voteExtension = new Uint8Array(0);
    message.extensionSignature = new Uint8Array(0);
    message.blockIdFlag = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.Validator validator */
        1:
          message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
          break;
        case /* bytes vote_extension */
        3:
          message.voteExtension = reader.bytes();
          break;
        case /* bytes extension_signature */
        4:
          message.extensionSignature = reader.bytes();
          break;
        case /* cometbft.types.v1.BlockIDFlag block_id_flag */
        5:
          message.blockIdFlag = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validator)
      Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.voteExtension.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.voteExtension);
    if (message.extensionSignature.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.extensionSignature);
    if (message.blockIdFlag !== 0)
      writer.tag(5, WireType.Varint).int32(message.blockIdFlag);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExtendedVoteInfo = new ExtendedVoteInfo$Type();
class Misbehavior$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.Misbehavior", [
      { no: 1, name: "type", kind: "enum", T: () => ["cometbft.abci.v1.MisbehaviorType", MisbehaviorType, "MISBEHAVIOR_TYPE_"] },
      { no: 2, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
      {
        no: 3,
        name: "height",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
      {
        no: 5,
        name: "total_voting_power",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.type = 0;
    message.height = 0n;
    message.totalVotingPower = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cometbft.abci.v1.MisbehaviorType type */
        1:
          message.type = reader.int32();
          break;
        case /* cometbft.abci.v1.Validator validator */
        2:
          message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
          break;
        case /* int64 height */
        3:
          message.height = reader.int64().toBigInt();
          break;
        case /* google.protobuf.Timestamp time */
        4:
          message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
          break;
        case /* int64 total_voting_power */
        5:
          message.totalVotingPower = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== 0)
      writer.tag(1, WireType.Varint).int32(message.type);
    if (message.validator)
      Validator.internalBinaryWrite(message.validator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.height !== 0n)
      writer.tag(3, WireType.Varint).int64(message.height);
    if (message.time)
      Timestamp.internalBinaryWrite(message.time, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.totalVotingPower !== 0n)
      writer.tag(5, WireType.Varint).int64(message.totalVotingPower);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Misbehavior = new Misbehavior$Type();
class Snapshot$Type extends MessageType {
  constructor() {
    super("cometbft.abci.v1.Snapshot", [
      {
        no: 1,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "format",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "chunks",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "hash",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.height = 0n;
    message.format = 0;
    message.chunks = 0;
    message.hash = new Uint8Array(0);
    message.metadata = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 height */
        1:
          message.height = reader.uint64().toBigInt();
          break;
        case /* uint32 format */
        2:
          message.format = reader.uint32();
          break;
        case /* uint32 chunks */
        3:
          message.chunks = reader.uint32();
          break;
        case /* bytes hash */
        4:
          message.hash = reader.bytes();
          break;
        case /* bytes metadata */
        5:
          message.metadata = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.height !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.height);
    if (message.format !== 0)
      writer.tag(2, WireType.Varint).uint32(message.format);
    if (message.chunks !== 0)
      writer.tag(3, WireType.Varint).uint32(message.chunks);
    if (message.hash.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
    if (message.metadata.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.metadata);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Snapshot = new Snapshot$Type();
export {
  ApplySnapshotChunkRequest,
  ApplySnapshotChunkResponse,
  ApplySnapshotChunkResult,
  CheckTxRequest,
  CheckTxResponse,
  CheckTxType,
  CommitInfo,
  CommitRequest,
  CommitResponse,
  EchoRequest,
  EchoResponse,
  Event,
  EventAttribute,
  ExceptionResponse,
  ExecTxResult,
  ExtendVoteRequest,
  ExtendVoteResponse,
  ExtendedCommitInfo,
  ExtendedVoteInfo,
  FinalizeBlockRequest,
  FinalizeBlockResponse,
  FlushRequest,
  FlushResponse,
  InfoRequest,
  InfoResponse,
  InitChainRequest,
  InitChainResponse,
  ListSnapshotsRequest,
  ListSnapshotsResponse,
  LoadSnapshotChunkRequest,
  LoadSnapshotChunkResponse,
  Misbehavior,
  MisbehaviorType,
  OfferSnapshotRequest,
  OfferSnapshotResponse,
  OfferSnapshotResult,
  PrepareProposalRequest,
  PrepareProposalResponse,
  ProcessProposalRequest,
  ProcessProposalResponse,
  ProcessProposalStatus,
  QueryRequest,
  QueryResponse,
  Request,
  Response,
  Snapshot,
  TxResult,
  Validator,
  ValidatorUpdate,
  VerifyVoteExtensionRequest,
  VerifyVoteExtensionResponse,
  VerifyVoteExtensionStatus,
  VoteInfo
};
