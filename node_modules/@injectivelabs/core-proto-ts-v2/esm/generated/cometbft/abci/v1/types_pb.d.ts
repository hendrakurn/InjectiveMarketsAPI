// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "cometbft/abci/v1/types.proto" (package "cometbft.abci.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BlockIDFlag } from "../../types/v1/validator_pb";
import { ProofOps } from "../../crypto/v1/proof_pb";
import { ConsensusParams } from "../../types/v1/params_pb";
import { Timestamp } from "../../../google/protobuf/timestamp_pb";
// ----------------------------------------
// Request types

/**
 * Request represents a request to the ABCI application.
 *
 * @generated from protobuf message cometbft.abci.v1.Request
 */
export interface Request {
    /**
     * Sum of all possible messages.
     *
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "echo";
        /**
         * @generated from protobuf field: cometbft.abci.v1.EchoRequest echo = 1
         */
        echo: EchoRequest;
    } | {
        oneofKind: "flush";
        /**
         * @generated from protobuf field: cometbft.abci.v1.FlushRequest flush = 2
         */
        flush: FlushRequest;
    } | {
        oneofKind: "info";
        /**
         * @generated from protobuf field: cometbft.abci.v1.InfoRequest info = 3
         */
        info: InfoRequest;
    } | {
        oneofKind: "initChain";
        /**
         * @generated from protobuf field: cometbft.abci.v1.InitChainRequest init_chain = 5
         */
        initChain: InitChainRequest;
    } | {
        oneofKind: "query";
        /**
         * @generated from protobuf field: cometbft.abci.v1.QueryRequest query = 6
         */
        query: QueryRequest;
    } | {
        oneofKind: "checkTx";
        /**
         * @generated from protobuf field: cometbft.abci.v1.CheckTxRequest check_tx = 8
         */
        checkTx: CheckTxRequest;
    } | {
        oneofKind: "commit";
        /**
         * @generated from protobuf field: cometbft.abci.v1.CommitRequest commit = 11
         */
        commit: CommitRequest;
    } | {
        oneofKind: "listSnapshots";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ListSnapshotsRequest list_snapshots = 12
         */
        listSnapshots: ListSnapshotsRequest;
    } | {
        oneofKind: "offerSnapshot";
        /**
         * @generated from protobuf field: cometbft.abci.v1.OfferSnapshotRequest offer_snapshot = 13
         */
        offerSnapshot: OfferSnapshotRequest;
    } | {
        oneofKind: "loadSnapshotChunk";
        /**
         * @generated from protobuf field: cometbft.abci.v1.LoadSnapshotChunkRequest load_snapshot_chunk = 14
         */
        loadSnapshotChunk: LoadSnapshotChunkRequest;
    } | {
        oneofKind: "applySnapshotChunk";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ApplySnapshotChunkRequest apply_snapshot_chunk = 15
         */
        applySnapshotChunk: ApplySnapshotChunkRequest;
    } | {
        oneofKind: "prepareProposal";
        /**
         * @generated from protobuf field: cometbft.abci.v1.PrepareProposalRequest prepare_proposal = 16
         */
        prepareProposal: PrepareProposalRequest;
    } | {
        oneofKind: "processProposal";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ProcessProposalRequest process_proposal = 17
         */
        processProposal: ProcessProposalRequest;
    } | {
        oneofKind: "extendVote";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ExtendVoteRequest extend_vote = 18
         */
        extendVote: ExtendVoteRequest;
    } | {
        oneofKind: "verifyVoteExtension";
        /**
         * @generated from protobuf field: cometbft.abci.v1.VerifyVoteExtensionRequest verify_vote_extension = 19
         */
        verifyVoteExtension: VerifyVoteExtensionRequest;
    } | {
        oneofKind: "finalizeBlock";
        /**
         * @generated from protobuf field: cometbft.abci.v1.FinalizeBlockRequest finalize_block = 20
         */
        finalizeBlock: FinalizeBlockRequest;
    } | {
        oneofKind: undefined;
    };
}
/**
 * EchoRequest is a request to "echo" the given string.
 *
 * @generated from protobuf message cometbft.abci.v1.EchoRequest
 */
export interface EchoRequest {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * FlushRequest is a request to flush the write buffer.
 *
 * @generated from protobuf message cometbft.abci.v1.FlushRequest
 */
export interface FlushRequest {
}
/**
 * InfoRequest is a request for the ABCI application version.
 *
 * @generated from protobuf message cometbft.abci.v1.InfoRequest
 */
export interface InfoRequest {
    /**
     * @generated from protobuf field: string version = 1
     */
    version: string;
    /**
     * @generated from protobuf field: uint64 block_version = 2
     */
    blockVersion: bigint;
    /**
     * @generated from protobuf field: uint64 p2p_version = 3
     */
    p2PVersion: bigint;
    /**
     * @generated from protobuf field: string abci_version = 4
     */
    abciVersion: string;
}
/**
 * InitChainRequest is a request to initialize the blockchain.
 *
 * @generated from protobuf message cometbft.abci.v1.InitChainRequest
 */
export interface InitChainRequest {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 1
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: string chain_id = 2
     */
    chainId: string;
    /**
     * @generated from protobuf field: cometbft.types.v1.ConsensusParams consensus_params = 3
     */
    consensusParams?: ConsensusParams;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.ValidatorUpdate validators = 4
     */
    validators: ValidatorUpdate[];
    /**
     * @generated from protobuf field: bytes app_state_bytes = 5
     */
    appStateBytes: Uint8Array;
    /**
     * @generated from protobuf field: int64 initial_height = 6
     */
    initialHeight: bigint;
}
/**
 * QueryRequest is a request to query the application state.
 *
 * @generated from protobuf message cometbft.abci.v1.QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: int64 height = 3
     */
    height: bigint;
    /**
     * @generated from protobuf field: bool prove = 4
     */
    prove: boolean;
}
/**
 * CheckTxRequest is a request to check that the transaction is valid.
 *
 * @generated from protobuf message cometbft.abci.v1.CheckTxRequest
 */
export interface CheckTxRequest {
    /**
     * @generated from protobuf field: bytes tx = 1
     */
    tx: Uint8Array;
    /**
     * @generated from protobuf field: cometbft.abci.v1.CheckTxType type = 3
     */
    type: CheckTxType;
}
/**
 * CommitRequest is a request to commit the pending application state.
 *
 * @generated from protobuf message cometbft.abci.v1.CommitRequest
 */
export interface CommitRequest {
}
/**
 * Request to list available snapshots.
 *
 * @generated from protobuf message cometbft.abci.v1.ListSnapshotsRequest
 */
export interface ListSnapshotsRequest {
}
/**
 * Request offering a snapshot to the application.
 *
 * @generated from protobuf message cometbft.abci.v1.OfferSnapshotRequest
 */
export interface OfferSnapshotRequest {
    /**
     * @generated from protobuf field: cometbft.abci.v1.Snapshot snapshot = 1
     */
    snapshot?: Snapshot; // snapshot offered by peers
    /**
     * @generated from protobuf field: bytes app_hash = 2
     */
    appHash: Uint8Array; // light client-verified app hash for snapshot height
}
/**
 * Request to load a snapshot chunk.
 *
 * @generated from protobuf message cometbft.abci.v1.LoadSnapshotChunkRequest
 */
export interface LoadSnapshotChunkRequest {
    /**
     * @generated from protobuf field: uint64 height = 1
     */
    height: bigint;
    /**
     * @generated from protobuf field: uint32 format = 2
     */
    format: number;
    /**
     * @generated from protobuf field: uint32 chunk = 3
     */
    chunk: number;
}
/**
 * Request to apply a snapshot chunk.
 *
 * @generated from protobuf message cometbft.abci.v1.ApplySnapshotChunkRequest
 */
export interface ApplySnapshotChunkRequest {
    /**
     * @generated from protobuf field: uint32 index = 1
     */
    index: number;
    /**
     * @generated from protobuf field: bytes chunk = 2
     */
    chunk: Uint8Array;
    /**
     * @generated from protobuf field: string sender = 3
     */
    sender: string;
}
/**
 * PrepareProposalRequest is a request for the ABCI application to prepare a new
 * block proposal.
 *
 * @generated from protobuf message cometbft.abci.v1.PrepareProposalRequest
 */
export interface PrepareProposalRequest {
    /**
     * the modified transactions cannot exceed this size.
     *
     * @generated from protobuf field: int64 max_tx_bytes = 1
     */
    maxTxBytes: bigint;
    /**
     * txs is an array of transactions that will be included in a block,
     * sent to the app for possible modifications.
     *
     * @generated from protobuf field: repeated bytes txs = 2
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: cometbft.abci.v1.ExtendedCommitInfo local_last_commit = 3
     */
    localLastCommit?: ExtendedCommitInfo;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.Misbehavior misbehavior = 4
     */
    misbehavior: Misbehavior[];
    /**
     * @generated from protobuf field: int64 height = 5
     */
    height: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * address of the public key of the validator proposing the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
}
/**
 * ProcessProposalRequest is a request for the ABCI application to process a proposal
 * received from another validator.
 *
 * @generated from protobuf message cometbft.abci.v1.ProcessProposalRequest
 */
export interface ProcessProposalRequest {
    /**
     * @generated from protobuf field: repeated bytes txs = 1
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: cometbft.abci.v1.CommitInfo proposed_last_commit = 2
     */
    proposedLastCommit?: CommitInfo;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.Misbehavior misbehavior = 3
     */
    misbehavior: Misbehavior[];
    /**
     * Merkle root hash of the fields of the proposed block.
     *
     * @generated from protobuf field: bytes hash = 4
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: int64 height = 5
     */
    height: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * address of the public key of the original proposer of the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
}
/**
 * ExtendVoteRequest extends a precommit vote with application-injected data.
 *
 * @generated from protobuf message cometbft.abci.v1.ExtendVoteRequest
 */
export interface ExtendVoteRequest {
    /**
     * the hash of the block that this vote may be referring to
     *
     * @generated from protobuf field: bytes hash = 1
     */
    hash: Uint8Array;
    /**
     * the height of the extended vote
     *
     * @generated from protobuf field: int64 height = 2
     */
    height: bigint;
    /**
     * info of the block that this vote may be referring to
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 3
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: repeated bytes txs = 4
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: cometbft.abci.v1.CommitInfo proposed_last_commit = 5
     */
    proposedLastCommit?: CommitInfo;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.Misbehavior misbehavior = 6
     */
    misbehavior: Misbehavior[];
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * address of the public key of the original proposer of the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
}
/**
 * VerifyVoteExtensionRequest is a request for the application to verify a vote extension
 * produced by a different validator.
 *
 * @generated from protobuf message cometbft.abci.v1.VerifyVoteExtensionRequest
 */
export interface VerifyVoteExtensionRequest {
    /**
     * the hash of the block that this received vote corresponds to
     *
     * @generated from protobuf field: bytes hash = 1
     */
    hash: Uint8Array;
    /**
     * the validator that signed the vote extension
     *
     * @generated from protobuf field: bytes validator_address = 2
     */
    validatorAddress: Uint8Array;
    /**
     * @generated from protobuf field: int64 height = 3
     */
    height: bigint;
    /**
     * @generated from protobuf field: bytes vote_extension = 4
     */
    voteExtension: Uint8Array;
}
/**
 * FinalizeBlockRequest is a request to finalize the block.
 *
 * @generated from protobuf message cometbft.abci.v1.FinalizeBlockRequest
 */
export interface FinalizeBlockRequest {
    /**
     * @generated from protobuf field: repeated bytes txs = 1
     */
    txs: Uint8Array[];
    /**
     * @generated from protobuf field: cometbft.abci.v1.CommitInfo decided_last_commit = 2
     */
    decidedLastCommit?: CommitInfo;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.Misbehavior misbehavior = 3
     */
    misbehavior: Misbehavior[];
    /**
     * Merkle root hash of the fields of the decided block.
     *
     * @generated from protobuf field: bytes hash = 4
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: int64 height = 5
     */
    height: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: bytes next_validators_hash = 7
     */
    nextValidatorsHash: Uint8Array;
    /**
     * address of the public key of the original proposer of the block.
     *
     * @generated from protobuf field: bytes proposer_address = 8
     */
    proposerAddress: Uint8Array;
    /**
     * If the node is syncing/replaying blocks - target height. If not, syncing_to == height.
     *
     * @generated from protobuf field: int64 syncing_to_height = 9
     */
    syncingToHeight: bigint;
}
// ----------------------------------------
// Response types

/**
 * Response represents a response from the ABCI application.
 *
 * @generated from protobuf message cometbft.abci.v1.Response
 */
export interface Response {
    /**
     * Sum of all possible messages.
     *
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "exception";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ExceptionResponse exception = 1
         */
        exception: ExceptionResponse;
    } | {
        oneofKind: "echo";
        /**
         * @generated from protobuf field: cometbft.abci.v1.EchoResponse echo = 2
         */
        echo: EchoResponse;
    } | {
        oneofKind: "flush";
        /**
         * @generated from protobuf field: cometbft.abci.v1.FlushResponse flush = 3
         */
        flush: FlushResponse;
    } | {
        oneofKind: "info";
        /**
         * @generated from protobuf field: cometbft.abci.v1.InfoResponse info = 4
         */
        info: InfoResponse;
    } | {
        oneofKind: "initChain";
        /**
         * @generated from protobuf field: cometbft.abci.v1.InitChainResponse init_chain = 6
         */
        initChain: InitChainResponse;
    } | {
        oneofKind: "query";
        /**
         * @generated from protobuf field: cometbft.abci.v1.QueryResponse query = 7
         */
        query: QueryResponse;
    } | {
        oneofKind: "checkTx";
        /**
         * @generated from protobuf field: cometbft.abci.v1.CheckTxResponse check_tx = 9
         */
        checkTx: CheckTxResponse;
    } | {
        oneofKind: "commit";
        /**
         * @generated from protobuf field: cometbft.abci.v1.CommitResponse commit = 12
         */
        commit: CommitResponse;
    } | {
        oneofKind: "listSnapshots";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ListSnapshotsResponse list_snapshots = 13
         */
        listSnapshots: ListSnapshotsResponse;
    } | {
        oneofKind: "offerSnapshot";
        /**
         * @generated from protobuf field: cometbft.abci.v1.OfferSnapshotResponse offer_snapshot = 14
         */
        offerSnapshot: OfferSnapshotResponse;
    } | {
        oneofKind: "loadSnapshotChunk";
        /**
         * @generated from protobuf field: cometbft.abci.v1.LoadSnapshotChunkResponse load_snapshot_chunk = 15
         */
        loadSnapshotChunk: LoadSnapshotChunkResponse;
    } | {
        oneofKind: "applySnapshotChunk";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ApplySnapshotChunkResponse apply_snapshot_chunk = 16
         */
        applySnapshotChunk: ApplySnapshotChunkResponse;
    } | {
        oneofKind: "prepareProposal";
        /**
         * @generated from protobuf field: cometbft.abci.v1.PrepareProposalResponse prepare_proposal = 17
         */
        prepareProposal: PrepareProposalResponse;
    } | {
        oneofKind: "processProposal";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ProcessProposalResponse process_proposal = 18
         */
        processProposal: ProcessProposalResponse;
    } | {
        oneofKind: "extendVote";
        /**
         * @generated from protobuf field: cometbft.abci.v1.ExtendVoteResponse extend_vote = 19
         */
        extendVote: ExtendVoteResponse;
    } | {
        oneofKind: "verifyVoteExtension";
        /**
         * @generated from protobuf field: cometbft.abci.v1.VerifyVoteExtensionResponse verify_vote_extension = 20
         */
        verifyVoteExtension: VerifyVoteExtensionResponse;
    } | {
        oneofKind: "finalizeBlock";
        /**
         * @generated from protobuf field: cometbft.abci.v1.FinalizeBlockResponse finalize_block = 21
         */
        finalizeBlock: FinalizeBlockResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * nondeterministic
 *
 * @generated from protobuf message cometbft.abci.v1.ExceptionResponse
 */
export interface ExceptionResponse {
    /**
     * @generated from protobuf field: string error = 1
     */
    error: string;
}
/**
 * EchoResponse indicates that the connection is still alive.
 *
 * @generated from protobuf message cometbft.abci.v1.EchoResponse
 */
export interface EchoResponse {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * FlushResponse indicates that the write buffer was flushed.
 *
 * @generated from protobuf message cometbft.abci.v1.FlushResponse
 */
export interface FlushResponse {
}
/**
 * InfoResponse contains the ABCI application version information.
 *
 * @generated from protobuf message cometbft.abci.v1.InfoResponse
 */
export interface InfoResponse {
    /**
     * @generated from protobuf field: string data = 1
     */
    data: string;
    /**
     * @generated from protobuf field: string version = 2
     */
    version: string;
    /**
     * @generated from protobuf field: uint64 app_version = 3
     */
    appVersion: bigint;
    /**
     * @generated from protobuf field: int64 last_block_height = 4
     */
    lastBlockHeight: bigint;
    /**
     * @generated from protobuf field: bytes last_block_app_hash = 5
     */
    lastBlockAppHash: Uint8Array;
}
/**
 * InitChainResponse contains the ABCI application's hash and updates to the
 * validator set and/or the consensus params, if any.
 *
 * @generated from protobuf message cometbft.abci.v1.InitChainResponse
 */
export interface InitChainResponse {
    /**
     * @generated from protobuf field: cometbft.types.v1.ConsensusParams consensus_params = 1
     */
    consensusParams?: ConsensusParams;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.ValidatorUpdate validators = 2
     */
    validators: ValidatorUpdate[];
    /**
     * @generated from protobuf field: bytes app_hash = 3
     */
    appHash: Uint8Array;
}
/**
 * QueryResponse contains the ABCI application data along with a proof.
 *
 * @generated from protobuf message cometbft.abci.v1.QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: uint32 code = 1
     */
    code: number;
    /**
     * bytes data = 2; // use "value" instead.
     *
     * @generated from protobuf field: string log = 3
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 index = 5
     */
    index: bigint;
    /**
     * @generated from protobuf field: bytes key = 6
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 7
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: cometbft.crypto.v1.ProofOps proof_ops = 8
     */
    proofOps?: ProofOps;
    /**
     * @generated from protobuf field: int64 height = 9
     */
    height: bigint;
    /**
     * @generated from protobuf field: string codespace = 10
     */
    codespace: string;
}
/**
 * CheckTxResponse shows if the transaction was deemed valid by the ABCI
 * application.
 *
 * @generated from protobuf message cometbft.abci.v1.CheckTxResponse
 */
export interface CheckTxResponse {
    /**
     * @generated from protobuf field: uint32 code = 1
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string log = 3
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 gas_wanted = 5 [json_name = "gas_wanted"]
     */
    gasWanted: bigint;
    /**
     * @generated from protobuf field: int64 gas_used = 6 [json_name = "gas_used"]
     */
    gasUsed: bigint;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.Event events = 7
     */
    events: Event[]; // nondeterministic
    /**
     * @generated from protobuf field: string codespace = 8
     */
    codespace: string;
}
/**
 * CommitResponse indicates how much blocks should CometBFT retain.
 *
 * @generated from protobuf message cometbft.abci.v1.CommitResponse
 */
export interface CommitResponse {
    /**
     * @generated from protobuf field: int64 retain_height = 3
     */
    retainHeight: bigint;
}
/**
 * ListSnapshotsResponse contains the list of snapshots.
 *
 * @generated from protobuf message cometbft.abci.v1.ListSnapshotsResponse
 */
export interface ListSnapshotsResponse {
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.Snapshot snapshots = 1
     */
    snapshots: Snapshot[];
}
/**
 * OfferSnapshotResponse indicates the ABCI application decision whenever to
 * provide a snapshot to the requester or not.
 *
 * @generated from protobuf message cometbft.abci.v1.OfferSnapshotResponse
 */
export interface OfferSnapshotResponse {
    /**
     * @generated from protobuf field: cometbft.abci.v1.OfferSnapshotResult result = 1
     */
    result: OfferSnapshotResult;
}
/**
 * LoadSnapshotChunkResponse returns a snapshot's chunk.
 *
 * @generated from protobuf message cometbft.abci.v1.LoadSnapshotChunkResponse
 */
export interface LoadSnapshotChunkResponse {
    /**
     * @generated from protobuf field: bytes chunk = 1
     */
    chunk: Uint8Array;
}
/**
 * ApplySnapshotChunkResponse returns a result of applying the specified chunk.
 *
 * @generated from protobuf message cometbft.abci.v1.ApplySnapshotChunkResponse
 */
export interface ApplySnapshotChunkResponse {
    /**
     * @generated from protobuf field: cometbft.abci.v1.ApplySnapshotChunkResult result = 1
     */
    result: ApplySnapshotChunkResult;
    /**
     * @generated from protobuf field: repeated uint32 refetch_chunks = 2
     */
    refetchChunks: number[]; // Chunks to refetch and reapply
    /**
     * @generated from protobuf field: repeated string reject_senders = 3
     */
    rejectSenders: string[]; // Chunk senders to reject and ban
}
/**
 * PrepareProposalResponse contains a list of transactions, which will form a block.
 *
 * @generated from protobuf message cometbft.abci.v1.PrepareProposalResponse
 */
export interface PrepareProposalResponse {
    /**
     * @generated from protobuf field: repeated bytes txs = 1
     */
    txs: Uint8Array[];
}
/**
 * ProcessProposalResponse indicates the ABCI application's decision whenever
 * the given proposal should be accepted or not.
 *
 * @generated from protobuf message cometbft.abci.v1.ProcessProposalResponse
 */
export interface ProcessProposalResponse {
    /**
     * @generated from protobuf field: cometbft.abci.v1.ProcessProposalStatus status = 1
     */
    status: ProcessProposalStatus;
}
/**
 * ExtendVoteResponse contains the vote extension that the application would like to
 * attach to its next precommit vote.
 *
 * @generated from protobuf message cometbft.abci.v1.ExtendVoteResponse
 */
export interface ExtendVoteResponse {
    /**
     * @generated from protobuf field: bytes vote_extension = 1
     */
    voteExtension: Uint8Array;
}
/**
 * VerifyVoteExtensionResponse indicates the ABCI application's decision
 * whenever the vote extension should be accepted or not.
 *
 * @generated from protobuf message cometbft.abci.v1.VerifyVoteExtensionResponse
 */
export interface VerifyVoteExtensionResponse {
    /**
     * @generated from protobuf field: cometbft.abci.v1.VerifyVoteExtensionStatus status = 1
     */
    status: VerifyVoteExtensionStatus;
}
/**
 * FinalizeBlockResponse contains the result of executing the block.
 *
 * @generated from protobuf message cometbft.abci.v1.FinalizeBlockResponse
 */
export interface FinalizeBlockResponse {
    /**
     * set of block events emitted as part of executing the block
     *
     * @generated from protobuf field: repeated cometbft.abci.v1.Event events = 1
     */
    events: Event[]; // nondeterministic
    /**
     * the result of executing each transaction including the events
     * the particular transaction emitted. This should match the order
     * of the transactions delivered in the block itself
     *
     * @generated from protobuf field: repeated cometbft.abci.v1.ExecTxResult tx_results = 2
     */
    txResults: ExecTxResult[];
    /**
     * a list of updates to the validator set. These will reflect the validator set at current height + 2.
     *
     * @generated from protobuf field: repeated cometbft.abci.v1.ValidatorUpdate validator_updates = 3
     */
    validatorUpdates: ValidatorUpdate[];
    /**
     * updates to the consensus params, if any.
     *
     * @generated from protobuf field: cometbft.types.v1.ConsensusParams consensus_param_updates = 4
     */
    consensusParamUpdates?: ConsensusParams;
    /**
     * app_hash is the hash of the applications' state which is used to confirm
     * that execution of the transactions was deterministic.
     * It is up to the application to decide which algorithm to use.
     *
     * @generated from protobuf field: bytes app_hash = 5
     */
    appHash: Uint8Array;
}
// ----------------------------------------
// Misc.

/**
 * CommitInfo contains votes for the particular round.
 *
 * @generated from protobuf message cometbft.abci.v1.CommitInfo
 */
export interface CommitInfo {
    /**
     * @generated from protobuf field: int32 round = 1
     */
    round: number;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.VoteInfo votes = 2
     */
    votes: VoteInfo[];
}
/**
 * ExtendedCommitInfo is similar to CommitInfo except that it is only used in
 * the PrepareProposal request such that Tendermint can provide vote extensions
 * to the application.
 *
 * @generated from protobuf message cometbft.abci.v1.ExtendedCommitInfo
 */
export interface ExtendedCommitInfo {
    /**
     * The round at which the block proposer decided in the previous height.
     *
     * @generated from protobuf field: int32 round = 1
     */
    round: number;
    /**
     * List of validators' addresses in the last validator set with their voting
     * information, including vote extensions.
     *
     * @generated from protobuf field: repeated cometbft.abci.v1.ExtendedVoteInfo votes = 2
     */
    votes: ExtendedVoteInfo[];
}
/**
 * Event allows application developers to attach additional information to
 * ResponseFinalizeBlock and ResponseCheckTx.
 * Up to 0.37, this could also be used in ResponseBeginBlock, ResponseEndBlock,
 * and ResponseDeliverTx.
 * Later, transactions may be queried using these events.
 *
 * @generated from protobuf message cometbft.abci.v1.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: string type = 1
     */
    type: string;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.EventAttribute attributes = 2
     */
    attributes: EventAttribute[];
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 *
 * @generated from protobuf message cometbft.abci.v1.EventAttribute
 */
export interface EventAttribute {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2
     */
    value: string;
    /**
     * @generated from protobuf field: bool index = 3
     */
    index: boolean; // nondeterministic
}
/**
 * ExecTxResult contains results of executing one individual transaction.
 *
 * * Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted
 *
 * @generated from protobuf message cometbft.abci.v1.ExecTxResult
 */
export interface ExecTxResult {
    /**
     * @generated from protobuf field: uint32 code = 1
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string log = 3
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 gas_wanted = 5 [json_name = "gas_wanted"]
     */
    gasWanted: bigint;
    /**
     * @generated from protobuf field: int64 gas_used = 6 [json_name = "gas_used"]
     */
    gasUsed: bigint;
    /**
     * @generated from protobuf field: repeated cometbft.abci.v1.Event events = 7
     */
    events: Event[]; // nondeterministic
    /**
     * @generated from protobuf field: string codespace = 8
     */
    codespace: string;
}
/**
 * TxResult contains results of executing the transaction.
 *
 * One usage is indexing transaction results.
 *
 * @generated from protobuf message cometbft.abci.v1.TxResult
 */
export interface TxResult {
    /**
     * @generated from protobuf field: int64 height = 1
     */
    height: bigint;
    /**
     * @generated from protobuf field: uint32 index = 2
     */
    index: number;
    /**
     * @generated from protobuf field: bytes tx = 3
     */
    tx: Uint8Array;
    /**
     * @generated from protobuf field: cometbft.abci.v1.ExecTxResult result = 4
     */
    result?: ExecTxResult;
}
// ----------------------------------------
// Blockchain Types

/**
 * Validator in the validator set.
 *
 * @generated from protobuf message cometbft.abci.v1.Validator
 */
export interface Validator {
    /**
     * @generated from protobuf field: bytes address = 1
     */
    address: Uint8Array; // The first 20 bytes of SHA256(public key)
    /**
     * PubKey pub_key = 2 [(gogoproto.nullable)=false];
     *
     * @generated from protobuf field: int64 power = 3
     */
    power: bigint; // The voting power
}
/**
 * ValidatorUpdate is a singular update to a validator set.
 *
 * @generated from protobuf message cometbft.abci.v1.ValidatorUpdate
 */
export interface ValidatorUpdate {
    /**
     * @generated from protobuf field: int64 power = 2
     */
    power: bigint;
    /**
     * @generated from protobuf field: bytes pub_key_bytes = 3
     */
    pubKeyBytes: Uint8Array;
    /**
     * @generated from protobuf field: string pub_key_type = 4
     */
    pubKeyType: string;
}
/**
 * VoteInfo contains the information about the vote.
 *
 * @generated from protobuf message cometbft.abci.v1.VoteInfo
 */
export interface VoteInfo {
    /**
     * @generated from protobuf field: cometbft.abci.v1.Validator validator = 1
     */
    validator?: Validator;
    /**
     * @generated from protobuf field: cometbft.types.v1.BlockIDFlag block_id_flag = 3
     */
    blockIdFlag: BlockIDFlag;
}
/**
 * ExtendedVoteInfo extends VoteInfo with the vote extensions (non-deterministic).
 *
 * @generated from protobuf message cometbft.abci.v1.ExtendedVoteInfo
 */
export interface ExtendedVoteInfo {
    /**
     * The validator that sent the vote.
     *
     * @generated from protobuf field: cometbft.abci.v1.Validator validator = 1
     */
    validator?: Validator;
    /**
     * Non-deterministic extension provided by the sending validator's application.
     *
     * @generated from protobuf field: bytes vote_extension = 3
     */
    voteExtension: Uint8Array;
    /**
     * Vote extension signature created by CometBFT
     *
     * @generated from protobuf field: bytes extension_signature = 4
     */
    extensionSignature: Uint8Array;
    /**
     * block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all
     *
     * @generated from protobuf field: cometbft.types.v1.BlockIDFlag block_id_flag = 5
     */
    blockIdFlag: BlockIDFlag;
}
/**
 * Misbehavior is a type of misbehavior committed by a validator.
 *
 * @generated from protobuf message cometbft.abci.v1.Misbehavior
 */
export interface Misbehavior {
    /**
     * @generated from protobuf field: cometbft.abci.v1.MisbehaviorType type = 1
     */
    type: MisbehaviorType;
    /**
     * The offending validator
     *
     * @generated from protobuf field: cometbft.abci.v1.Validator validator = 2
     */
    validator?: Validator;
    /**
     * The height when the offense occurred
     *
     * @generated from protobuf field: int64 height = 3
     */
    height: bigint;
    /**
     * The corresponding time where the offense occurred
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 4
     */
    time?: Timestamp;
    /**
     * Total voting power of the validator set in case the ABCI application does
     * not store historical validators.
     * https://github.com/tendermint/tendermint/issues/4581
     *
     * @generated from protobuf field: int64 total_voting_power = 5
     */
    totalVotingPower: bigint;
}
// ----------------------------------------
// State Sync Types

/**
 * Snapshot of the ABCI application state.
 *
 * @generated from protobuf message cometbft.abci.v1.Snapshot
 */
export interface Snapshot {
    /**
     * @generated from protobuf field: uint64 height = 1
     */
    height: bigint; // The height at which the snapshot was taken
    /**
     * @generated from protobuf field: uint32 format = 2
     */
    format: number; // The application-specific snapshot format
    /**
     * @generated from protobuf field: uint32 chunks = 3
     */
    chunks: number; // Number of chunks in the snapshot
    /**
     * @generated from protobuf field: bytes hash = 4
     */
    hash: Uint8Array; // Arbitrary snapshot hash, equal only if identical
    /**
     * @generated from protobuf field: bytes metadata = 5
     */
    metadata: Uint8Array; // Arbitrary application metadata
}
/**
 * Type of the transaction check request.
 *
 * This enumeration is incompatible with the CheckTxType definition in
 * cometbft.abci.v1beta1 and therefore shall not be used in encoding with the same
 * field number.
 *
 * @generated from protobuf enum cometbft.abci.v1.CheckTxType
 */
export enum CheckTxType {
    /**
     * Unknown
     *
     * @generated from protobuf enum value: CHECK_TX_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Recheck (2nd, 3rd, etc.)
     *
     * @generated from protobuf enum value: CHECK_TX_TYPE_RECHECK = 1;
     */
    RECHECK = 1,
    /**
     * Check (1st time)
     *
     * @generated from protobuf enum value: CHECK_TX_TYPE_CHECK = 2;
     */
    CHECK = 2
}
/**
 * The result of offering a snapshot.
 *
 * @generated from protobuf enum cometbft.abci.v1.OfferSnapshotResult
 */
export enum OfferSnapshotResult {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: OFFER_SNAPSHOT_RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Snapshot accepted, apply chunks
     *
     * @generated from protobuf enum value: OFFER_SNAPSHOT_RESULT_ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: OFFER_SNAPSHOT_RESULT_ABORT = 2;
     */
    ABORT = 2,
    /**
     * Reject this specific snapshot, try others
     *
     * @generated from protobuf enum value: OFFER_SNAPSHOT_RESULT_REJECT = 3;
     */
    REJECT = 3,
    /**
     * Reject all snapshots of this format, try others
     *
     * @generated from protobuf enum value: OFFER_SNAPSHOT_RESULT_REJECT_FORMAT = 4;
     */
    REJECT_FORMAT = 4,
    /**
     * Reject all snapshots from the sender(s), try others
     *
     * @generated from protobuf enum value: OFFER_SNAPSHOT_RESULT_REJECT_SENDER = 5;
     */
    REJECT_SENDER = 5
}
/**
 * The result of applying a snapshot chunk.
 *
 * @generated from protobuf enum cometbft.abci.v1.ApplySnapshotChunkResult
 */
export enum ApplySnapshotChunkResult {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: APPLY_SNAPSHOT_CHUNK_RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Chunk successfully accepted
     *
     * @generated from protobuf enum value: APPLY_SNAPSHOT_CHUNK_RESULT_ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: APPLY_SNAPSHOT_CHUNK_RESULT_ABORT = 2;
     */
    ABORT = 2,
    /**
     * Retry chunk (combine with refetch and reject)
     *
     * @generated from protobuf enum value: APPLY_SNAPSHOT_CHUNK_RESULT_RETRY = 3;
     */
    RETRY = 3,
    /**
     * Retry snapshot (combine with refetch and reject)
     *
     * @generated from protobuf enum value: APPLY_SNAPSHOT_CHUNK_RESULT_RETRY_SNAPSHOT = 4;
     */
    RETRY_SNAPSHOT = 4,
    /**
     * Reject this snapshot, try others
     *
     * @generated from protobuf enum value: APPLY_SNAPSHOT_CHUNK_RESULT_REJECT_SNAPSHOT = 5;
     */
    REJECT_SNAPSHOT = 5
}
/**
 * ProcessProposalStatus is the status of the proposal processing.
 *
 * @generated from protobuf enum cometbft.abci.v1.ProcessProposalStatus
 */
export enum ProcessProposalStatus {
    /**
     * Unknown
     *
     * @generated from protobuf enum value: PROCESS_PROPOSAL_STATUS_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Accepted
     *
     * @generated from protobuf enum value: PROCESS_PROPOSAL_STATUS_ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Rejected
     *
     * @generated from protobuf enum value: PROCESS_PROPOSAL_STATUS_REJECT = 2;
     */
    REJECT = 2
}
/**
 * VerifyVoteExtensionStatus is the status of the vote extension verification.
 *
 * @generated from protobuf enum cometbft.abci.v1.VerifyVoteExtensionStatus
 */
export enum VerifyVoteExtensionStatus {
    /**
     * Unknown
     *
     * @generated from protobuf enum value: VERIFY_VOTE_EXTENSION_STATUS_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Accepted
     *
     * @generated from protobuf enum value: VERIFY_VOTE_EXTENSION_STATUS_ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Rejecting the vote extension will reject the entire precommit by the sender.
     * Incorrectly implementing this thus has liveness implications as it may affect
     * CometBFT's ability to receive 2/3+ valid votes to finalize the block.
     * Honest nodes should never be rejected.
     *
     * @generated from protobuf enum value: VERIFY_VOTE_EXTENSION_STATUS_REJECT = 2;
     */
    REJECT = 2
}
/**
 * The type of misbehavior committed by a validator.
 *
 * @generated from protobuf enum cometbft.abci.v1.MisbehaviorType
 */
export enum MisbehaviorType {
    /**
     * Unknown
     *
     * @generated from protobuf enum value: MISBEHAVIOR_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Duplicate vote
     *
     * @generated from protobuf enum value: MISBEHAVIOR_TYPE_DUPLICATE_VOTE = 1;
     */
    DUPLICATE_VOTE = 1,
    /**
     * Light client attack
     *
     * @generated from protobuf enum value: MISBEHAVIOR_TYPE_LIGHT_CLIENT_ATTACK = 2;
     */
    LIGHT_CLIENT_ATTACK = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Request$Type extends MessageType<Request> {
    constructor() {
        super("cometbft.abci.v1.Request", [
            { no: 1, name: "echo", kind: "message", oneof: "value", T: () => EchoRequest },
            { no: 2, name: "flush", kind: "message", oneof: "value", T: () => FlushRequest },
            { no: 3, name: "info", kind: "message", oneof: "value", T: () => InfoRequest },
            { no: 5, name: "init_chain", kind: "message", oneof: "value", T: () => InitChainRequest },
            { no: 6, name: "query", kind: "message", oneof: "value", T: () => QueryRequest },
            { no: 8, name: "check_tx", kind: "message", oneof: "value", T: () => CheckTxRequest },
            { no: 11, name: "commit", kind: "message", oneof: "value", T: () => CommitRequest },
            { no: 12, name: "list_snapshots", kind: "message", oneof: "value", T: () => ListSnapshotsRequest },
            { no: 13, name: "offer_snapshot", kind: "message", oneof: "value", T: () => OfferSnapshotRequest },
            { no: 14, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => LoadSnapshotChunkRequest },
            { no: 15, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ApplySnapshotChunkRequest },
            { no: 16, name: "prepare_proposal", kind: "message", oneof: "value", T: () => PrepareProposalRequest },
            { no: 17, name: "process_proposal", kind: "message", oneof: "value", T: () => ProcessProposalRequest },
            { no: 18, name: "extend_vote", kind: "message", oneof: "value", T: () => ExtendVoteRequest },
            { no: 19, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => VerifyVoteExtensionRequest },
            { no: 20, name: "finalize_block", kind: "message", oneof: "value", T: () => FinalizeBlockRequest }
        ]);
    }
    create(value?: PartialMessage<Request>): Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Request): Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.EchoRequest echo */ 1:
                    message.value = {
                        oneofKind: "echo",
                        echo: EchoRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).echo)
                    };
                    break;
                case /* cometbft.abci.v1.FlushRequest flush */ 2:
                    message.value = {
                        oneofKind: "flush",
                        flush: FlushRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).flush)
                    };
                    break;
                case /* cometbft.abci.v1.InfoRequest info */ 3:
                    message.value = {
                        oneofKind: "info",
                        info: InfoRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).info)
                    };
                    break;
                case /* cometbft.abci.v1.InitChainRequest init_chain */ 5:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: InitChainRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).initChain)
                    };
                    break;
                case /* cometbft.abci.v1.QueryRequest query */ 6:
                    message.value = {
                        oneofKind: "query",
                        query: QueryRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).query)
                    };
                    break;
                case /* cometbft.abci.v1.CheckTxRequest check_tx */ 8:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: CheckTxRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).checkTx)
                    };
                    break;
                case /* cometbft.abci.v1.CommitRequest commit */ 11:
                    message.value = {
                        oneofKind: "commit",
                        commit: CommitRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).commit)
                    };
                    break;
                case /* cometbft.abci.v1.ListSnapshotsRequest list_snapshots */ 12:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: ListSnapshotsRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).listSnapshots)
                    };
                    break;
                case /* cometbft.abci.v1.OfferSnapshotRequest offer_snapshot */ 13:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: OfferSnapshotRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).offerSnapshot)
                    };
                    break;
                case /* cometbft.abci.v1.LoadSnapshotChunkRequest load_snapshot_chunk */ 14:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: LoadSnapshotChunkRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).loadSnapshotChunk)
                    };
                    break;
                case /* cometbft.abci.v1.ApplySnapshotChunkRequest apply_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: ApplySnapshotChunkRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).applySnapshotChunk)
                    };
                    break;
                case /* cometbft.abci.v1.PrepareProposalRequest prepare_proposal */ 16:
                    message.value = {
                        oneofKind: "prepareProposal",
                        prepareProposal: PrepareProposalRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).prepareProposal)
                    };
                    break;
                case /* cometbft.abci.v1.ProcessProposalRequest process_proposal */ 17:
                    message.value = {
                        oneofKind: "processProposal",
                        processProposal: ProcessProposalRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).processProposal)
                    };
                    break;
                case /* cometbft.abci.v1.ExtendVoteRequest extend_vote */ 18:
                    message.value = {
                        oneofKind: "extendVote",
                        extendVote: ExtendVoteRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).extendVote)
                    };
                    break;
                case /* cometbft.abci.v1.VerifyVoteExtensionRequest verify_vote_extension */ 19:
                    message.value = {
                        oneofKind: "verifyVoteExtension",
                        verifyVoteExtension: VerifyVoteExtensionRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).verifyVoteExtension)
                    };
                    break;
                case /* cometbft.abci.v1.FinalizeBlockRequest finalize_block */ 20:
                    message.value = {
                        oneofKind: "finalizeBlock",
                        finalizeBlock: FinalizeBlockRequest.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).finalizeBlock)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.EchoRequest echo = 1; */
        if (message.value.oneofKind === "echo")
            EchoRequest.internalBinaryWrite(message.value.echo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.FlushRequest flush = 2; */
        if (message.value.oneofKind === "flush")
            FlushRequest.internalBinaryWrite(message.value.flush, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.InfoRequest info = 3; */
        if (message.value.oneofKind === "info")
            InfoRequest.internalBinaryWrite(message.value.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.InitChainRequest init_chain = 5; */
        if (message.value.oneofKind === "initChain")
            InitChainRequest.internalBinaryWrite(message.value.initChain, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.QueryRequest query = 6; */
        if (message.value.oneofKind === "query")
            QueryRequest.internalBinaryWrite(message.value.query, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.CheckTxRequest check_tx = 8; */
        if (message.value.oneofKind === "checkTx")
            CheckTxRequest.internalBinaryWrite(message.value.checkTx, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.CommitRequest commit = 11; */
        if (message.value.oneofKind === "commit")
            CommitRequest.internalBinaryWrite(message.value.commit, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ListSnapshotsRequest list_snapshots = 12; */
        if (message.value.oneofKind === "listSnapshots")
            ListSnapshotsRequest.internalBinaryWrite(message.value.listSnapshots, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.OfferSnapshotRequest offer_snapshot = 13; */
        if (message.value.oneofKind === "offerSnapshot")
            OfferSnapshotRequest.internalBinaryWrite(message.value.offerSnapshot, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.LoadSnapshotChunkRequest load_snapshot_chunk = 14; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            LoadSnapshotChunkRequest.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ApplySnapshotChunkRequest apply_snapshot_chunk = 15; */
        if (message.value.oneofKind === "applySnapshotChunk")
            ApplySnapshotChunkRequest.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.PrepareProposalRequest prepare_proposal = 16; */
        if (message.value.oneofKind === "prepareProposal")
            PrepareProposalRequest.internalBinaryWrite(message.value.prepareProposal, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ProcessProposalRequest process_proposal = 17; */
        if (message.value.oneofKind === "processProposal")
            ProcessProposalRequest.internalBinaryWrite(message.value.processProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ExtendVoteRequest extend_vote = 18; */
        if (message.value.oneofKind === "extendVote")
            ExtendVoteRequest.internalBinaryWrite(message.value.extendVote, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.VerifyVoteExtensionRequest verify_vote_extension = 19; */
        if (message.value.oneofKind === "verifyVoteExtension")
            VerifyVoteExtensionRequest.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.FinalizeBlockRequest finalize_block = 20; */
        if (message.value.oneofKind === "finalizeBlock")
            FinalizeBlockRequest.internalBinaryWrite(message.value.finalizeBlock, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.Request
 */
export const Request = new Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoRequest$Type extends MessageType<EchoRequest> {
    constructor() {
        super("cometbft.abci.v1.EchoRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoRequest>): EchoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EchoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoRequest): EchoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.EchoRequest
 */
export const EchoRequest = new EchoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlushRequest$Type extends MessageType<FlushRequest> {
    constructor() {
        super("cometbft.abci.v1.FlushRequest", []);
    }
    create(value?: PartialMessage<FlushRequest>): FlushRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FlushRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlushRequest): FlushRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlushRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.FlushRequest
 */
export const FlushRequest = new FlushRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoRequest$Type extends MessageType<InfoRequest> {
    constructor() {
        super("cometbft.abci.v1.InfoRequest", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "p2p_version", kind: "scalar", jsonName: "p2pVersion", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "abci_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InfoRequest>): InfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.blockVersion = 0n;
        message.p2PVersion = 0n;
        message.abciVersion = "";
        if (value !== undefined)
            reflectionMergePartial<InfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InfoRequest): InfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* uint64 block_version */ 2:
                    message.blockVersion = reader.uint64().toBigInt();
                    break;
                case /* uint64 p2p_version */ 3:
                    message.p2PVersion = reader.uint64().toBigInt();
                    break;
                case /* string abci_version */ 4:
                    message.abciVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* uint64 block_version = 2; */
        if (message.blockVersion !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.blockVersion);
        /* uint64 p2p_version = 3; */
        if (message.p2PVersion !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.p2PVersion);
        /* string abci_version = 4; */
        if (message.abciVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.abciVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.InfoRequest
 */
export const InfoRequest = new InfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitChainRequest$Type extends MessageType<InitChainRequest> {
    constructor() {
        super("cometbft.abci.v1.InitChainRequest", [
            { no: 1, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 2, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 4, name: "validators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 5, name: "app_state_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "initial_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<InitChainRequest>): InitChainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = "";
        message.validators = [];
        message.appStateBytes = new Uint8Array(0);
        message.initialHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<InitChainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitChainRequest): InitChainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp time */ 1:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string chain_id */ 2:
                    message.chainId = reader.string();
                    break;
                case /* cometbft.types.v1.ConsensusParams consensus_params */ 3:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated cometbft.abci.v1.ValidatorUpdate validators */ 4:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_state_bytes */ 5:
                    message.appStateBytes = reader.bytes();
                    break;
                case /* int64 initial_height */ 6:
                    message.initialHeight = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitChainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp time = 1; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string chain_id = 2; */
        if (message.chainId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chainId);
        /* cometbft.types.v1.ConsensusParams consensus_params = 3; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.ValidatorUpdate validators = 4; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_state_bytes = 5; */
        if (message.appStateBytes.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.appStateBytes);
        /* int64 initial_height = 6; */
        if (message.initialHeight !== 0n)
            writer.tag(6, WireType.Varint).int64(message.initialHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.InitChainRequest
 */
export const InitChainRequest = new InitChainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("cometbft.abci.v1.QueryRequest", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "prove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.path = "";
        message.height = 0n;
        message.prove = false;
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* bool prove */ 4:
                    message.prove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* int64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).int64(message.height);
        /* bool prove = 4; */
        if (message.prove !== false)
            writer.tag(4, WireType.Varint).bool(message.prove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckTxRequest$Type extends MessageType<CheckTxRequest> {
    constructor() {
        super("cometbft.abci.v1.CheckTxRequest", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["cometbft.abci.v1.CheckTxType", CheckTxType, "CHECK_TX_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<CheckTxRequest>): CheckTxRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tx = new Uint8Array(0);
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<CheckTxRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckTxRequest): CheckTxRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                case /* cometbft.abci.v1.CheckTxType type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckTxRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        /* cometbft.abci.v1.CheckTxType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.CheckTxRequest
 */
export const CheckTxRequest = new CheckTxRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitRequest$Type extends MessageType<CommitRequest> {
    constructor() {
        super("cometbft.abci.v1.CommitRequest", []);
    }
    create(value?: PartialMessage<CommitRequest>): CommitRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CommitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitRequest): CommitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.CommitRequest
 */
export const CommitRequest = new CommitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSnapshotsRequest$Type extends MessageType<ListSnapshotsRequest> {
    constructor() {
        super("cometbft.abci.v1.ListSnapshotsRequest", []);
    }
    create(value?: PartialMessage<ListSnapshotsRequest>): ListSnapshotsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListSnapshotsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSnapshotsRequest): ListSnapshotsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSnapshotsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ListSnapshotsRequest
 */
export const ListSnapshotsRequest = new ListSnapshotsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OfferSnapshotRequest$Type extends MessageType<OfferSnapshotRequest> {
    constructor() {
        super("cometbft.abci.v1.OfferSnapshotRequest", [
            { no: 1, name: "snapshot", kind: "message", T: () => Snapshot },
            { no: 2, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<OfferSnapshotRequest>): OfferSnapshotRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<OfferSnapshotRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OfferSnapshotRequest): OfferSnapshotRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.Snapshot snapshot */ 1:
                    message.snapshot = Snapshot.internalBinaryRead(reader, reader.uint32(), options, message.snapshot);
                    break;
                case /* bytes app_hash */ 2:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OfferSnapshotRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.Snapshot snapshot = 1; */
        if (message.snapshot)
            Snapshot.internalBinaryWrite(message.snapshot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 2; */
        if (message.appHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.OfferSnapshotRequest
 */
export const OfferSnapshotRequest = new OfferSnapshotRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadSnapshotChunkRequest$Type extends MessageType<LoadSnapshotChunkRequest> {
    constructor() {
        super("cometbft.abci.v1.LoadSnapshotChunkRequest", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunk", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoadSnapshotChunkRequest>): LoadSnapshotChunkRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.format = 0;
        message.chunk = 0;
        if (value !== undefined)
            reflectionMergePartial<LoadSnapshotChunkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadSnapshotChunkRequest): LoadSnapshotChunkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunk */ 3:
                    message.chunk = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadSnapshotChunkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunk = 3; */
        if (message.chunk !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.LoadSnapshotChunkRequest
 */
export const LoadSnapshotChunkRequest = new LoadSnapshotChunkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplySnapshotChunkRequest$Type extends MessageType<ApplySnapshotChunkRequest> {
    constructor() {
        super("cometbft.abci.v1.ApplySnapshotChunkRequest", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplySnapshotChunkRequest>): ApplySnapshotChunkRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0;
        message.chunk = new Uint8Array(0);
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<ApplySnapshotChunkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplySnapshotChunkRequest): ApplySnapshotChunkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* bytes chunk */ 2:
                    message.chunk = reader.bytes();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplySnapshotChunkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).uint32(message.index);
        /* bytes chunk = 2; */
        if (message.chunk.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chunk);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ApplySnapshotChunkRequest
 */
export const ApplySnapshotChunkRequest = new ApplySnapshotChunkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareProposalRequest$Type extends MessageType<PrepareProposalRequest> {
    constructor() {
        super("cometbft.abci.v1.PrepareProposalRequest", [
            { no: 1, name: "max_tx_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "local_last_commit", kind: "message", T: () => ExtendedCommitInfo, options: { "gogoproto.nullable": false } },
            { no: 4, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 5, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareProposalRequest>): PrepareProposalRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxTxBytes = 0n;
        message.txs = [];
        message.misbehavior = [];
        message.height = 0n;
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PrepareProposalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareProposalRequest): PrepareProposalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 max_tx_bytes */ 1:
                    message.maxTxBytes = reader.int64().toBigInt();
                    break;
                case /* repeated bytes txs */ 2:
                    message.txs.push(reader.bytes());
                    break;
                case /* cometbft.abci.v1.ExtendedCommitInfo local_last_commit */ 3:
                    message.localLastCommit = ExtendedCommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.localLastCommit);
                    break;
                case /* repeated cometbft.abci.v1.Misbehavior misbehavior */ 4:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 height */ 5:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareProposalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 max_tx_bytes = 1; */
        if (message.maxTxBytes !== 0n)
            writer.tag(1, WireType.Varint).int64(message.maxTxBytes);
        /* repeated bytes txs = 2; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.txs[i]);
        /* cometbft.abci.v1.ExtendedCommitInfo local_last_commit = 3; */
        if (message.localLastCommit)
            ExtendedCommitInfo.internalBinaryWrite(message.localLastCommit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.Misbehavior misbehavior = 4; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.PrepareProposalRequest
 */
export const PrepareProposalRequest = new PrepareProposalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessProposalRequest$Type extends MessageType<ProcessProposalRequest> {
    constructor() {
        super("cometbft.abci.v1.ProcessProposalRequest", [
            { no: 1, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
            { no: 3, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessProposalRequest>): ProcessProposalRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txs = [];
        message.misbehavior = [];
        message.hash = new Uint8Array(0);
        message.height = 0n;
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ProcessProposalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessProposalRequest): ProcessProposalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes txs */ 1:
                    message.txs.push(reader.bytes());
                    break;
                case /* cometbft.abci.v1.CommitInfo proposed_last_commit */ 2:
                    message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
                    break;
                case /* repeated cometbft.abci.v1.Misbehavior misbehavior */ 3:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* int64 height */ 5:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessProposalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes txs = 1; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
        /* cometbft.abci.v1.CommitInfo proposed_last_commit = 2; */
        if (message.proposedLastCommit)
            CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.Misbehavior misbehavior = 3; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* int64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ProcessProposalRequest
 */
export const ProcessProposalRequest = new ProcessProposalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendVoteRequest$Type extends MessageType<ExtendVoteRequest> {
    constructor() {
        super("cometbft.abci.v1.ExtendVoteRequest", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 4, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "proposed_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
            { no: 6, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ExtendVoteRequest>): ExtendVoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = new Uint8Array(0);
        message.height = 0n;
        message.txs = [];
        message.misbehavior = [];
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ExtendVoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendVoteRequest): ExtendVoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* int64 height */ 2:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 3:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* repeated bytes txs */ 4:
                    message.txs.push(reader.bytes());
                    break;
                case /* cometbft.abci.v1.CommitInfo proposed_last_commit */ 5:
                    message.proposedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.proposedLastCommit);
                    break;
                case /* repeated cometbft.abci.v1.Misbehavior misbehavior */ 6:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendVoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* int64 height = 2; */
        if (message.height !== 0n)
            writer.tag(2, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 3; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes txs = 4; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.txs[i]);
        /* cometbft.abci.v1.CommitInfo proposed_last_commit = 5; */
        if (message.proposedLastCommit)
            CommitInfo.internalBinaryWrite(message.proposedLastCommit, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.Misbehavior misbehavior = 6; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ExtendVoteRequest
 */
export const ExtendVoteRequest = new ExtendVoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyVoteExtensionRequest$Type extends MessageType<VerifyVoteExtensionRequest> {
    constructor() {
        super("cometbft.abci.v1.VerifyVoteExtensionRequest", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "validator_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "vote_extension", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyVoteExtensionRequest>): VerifyVoteExtensionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = new Uint8Array(0);
        message.validatorAddress = new Uint8Array(0);
        message.height = 0n;
        message.voteExtension = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<VerifyVoteExtensionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyVoteExtensionRequest): VerifyVoteExtensionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* bytes validator_address */ 2:
                    message.validatorAddress = reader.bytes();
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* bytes vote_extension */ 4:
                    message.voteExtension = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyVoteExtensionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* bytes validator_address = 2; */
        if (message.validatorAddress.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.validatorAddress);
        /* int64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).int64(message.height);
        /* bytes vote_extension = 4; */
        if (message.voteExtension.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.voteExtension);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.VerifyVoteExtensionRequest
 */
export const VerifyVoteExtensionRequest = new VerifyVoteExtensionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalizeBlockRequest$Type extends MessageType<FinalizeBlockRequest> {
    constructor() {
        super("cometbft.abci.v1.FinalizeBlockRequest", [
            { no: 1, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "decided_last_commit", kind: "message", T: () => CommitInfo, options: { "gogoproto.nullable": false } },
            { no: 3, name: "misbehavior", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misbehavior, options: { "gogoproto.nullable": false } },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "next_validators_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proposer_address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "syncing_to_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FinalizeBlockRequest>): FinalizeBlockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txs = [];
        message.misbehavior = [];
        message.hash = new Uint8Array(0);
        message.height = 0n;
        message.nextValidatorsHash = new Uint8Array(0);
        message.proposerAddress = new Uint8Array(0);
        message.syncingToHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<FinalizeBlockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinalizeBlockRequest): FinalizeBlockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes txs */ 1:
                    message.txs.push(reader.bytes());
                    break;
                case /* cometbft.abci.v1.CommitInfo decided_last_commit */ 2:
                    message.decidedLastCommit = CommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.decidedLastCommit);
                    break;
                case /* repeated cometbft.abci.v1.Misbehavior misbehavior */ 3:
                    message.misbehavior.push(Misbehavior.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* int64 height */ 5:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bytes next_validators_hash */ 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case /* bytes proposer_address */ 8:
                    message.proposerAddress = reader.bytes();
                    break;
                case /* int64 syncing_to_height */ 9:
                    message.syncingToHeight = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinalizeBlockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes txs = 1; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
        /* cometbft.abci.v1.CommitInfo decided_last_commit = 2; */
        if (message.decidedLastCommit)
            CommitInfo.internalBinaryWrite(message.decidedLastCommit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.Misbehavior misbehavior = 3; */
        for (let i = 0; i < message.misbehavior.length; i++)
            Misbehavior.internalBinaryWrite(message.misbehavior[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* int64 height = 5; */
        if (message.height !== 0n)
            writer.tag(5, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bytes next_validators_hash = 7; */
        if (message.nextValidatorsHash.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.nextValidatorsHash);
        /* bytes proposer_address = 8; */
        if (message.proposerAddress.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proposerAddress);
        /* int64 syncing_to_height = 9; */
        if (message.syncingToHeight !== 0n)
            writer.tag(9, WireType.Varint).int64(message.syncingToHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.FinalizeBlockRequest
 */
export const FinalizeBlockRequest = new FinalizeBlockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("cometbft.abci.v1.Response", [
            { no: 1, name: "exception", kind: "message", oneof: "value", T: () => ExceptionResponse },
            { no: 2, name: "echo", kind: "message", oneof: "value", T: () => EchoResponse },
            { no: 3, name: "flush", kind: "message", oneof: "value", T: () => FlushResponse },
            { no: 4, name: "info", kind: "message", oneof: "value", T: () => InfoResponse },
            { no: 6, name: "init_chain", kind: "message", oneof: "value", T: () => InitChainResponse },
            { no: 7, name: "query", kind: "message", oneof: "value", T: () => QueryResponse },
            { no: 9, name: "check_tx", kind: "message", oneof: "value", T: () => CheckTxResponse },
            { no: 12, name: "commit", kind: "message", oneof: "value", T: () => CommitResponse },
            { no: 13, name: "list_snapshots", kind: "message", oneof: "value", T: () => ListSnapshotsResponse },
            { no: 14, name: "offer_snapshot", kind: "message", oneof: "value", T: () => OfferSnapshotResponse },
            { no: 15, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => LoadSnapshotChunkResponse },
            { no: 16, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ApplySnapshotChunkResponse },
            { no: 17, name: "prepare_proposal", kind: "message", oneof: "value", T: () => PrepareProposalResponse },
            { no: 18, name: "process_proposal", kind: "message", oneof: "value", T: () => ProcessProposalResponse },
            { no: 19, name: "extend_vote", kind: "message", oneof: "value", T: () => ExtendVoteResponse },
            { no: 20, name: "verify_vote_extension", kind: "message", oneof: "value", T: () => VerifyVoteExtensionResponse },
            { no: 21, name: "finalize_block", kind: "message", oneof: "value", T: () => FinalizeBlockResponse }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.ExceptionResponse exception */ 1:
                    message.value = {
                        oneofKind: "exception",
                        exception: ExceptionResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).exception)
                    };
                    break;
                case /* cometbft.abci.v1.EchoResponse echo */ 2:
                    message.value = {
                        oneofKind: "echo",
                        echo: EchoResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).echo)
                    };
                    break;
                case /* cometbft.abci.v1.FlushResponse flush */ 3:
                    message.value = {
                        oneofKind: "flush",
                        flush: FlushResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).flush)
                    };
                    break;
                case /* cometbft.abci.v1.InfoResponse info */ 4:
                    message.value = {
                        oneofKind: "info",
                        info: InfoResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).info)
                    };
                    break;
                case /* cometbft.abci.v1.InitChainResponse init_chain */ 6:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: InitChainResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).initChain)
                    };
                    break;
                case /* cometbft.abci.v1.QueryResponse query */ 7:
                    message.value = {
                        oneofKind: "query",
                        query: QueryResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).query)
                    };
                    break;
                case /* cometbft.abci.v1.CheckTxResponse check_tx */ 9:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: CheckTxResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).checkTx)
                    };
                    break;
                case /* cometbft.abci.v1.CommitResponse commit */ 12:
                    message.value = {
                        oneofKind: "commit",
                        commit: CommitResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).commit)
                    };
                    break;
                case /* cometbft.abci.v1.ListSnapshotsResponse list_snapshots */ 13:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: ListSnapshotsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).listSnapshots)
                    };
                    break;
                case /* cometbft.abci.v1.OfferSnapshotResponse offer_snapshot */ 14:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: OfferSnapshotResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).offerSnapshot)
                    };
                    break;
                case /* cometbft.abci.v1.LoadSnapshotChunkResponse load_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: LoadSnapshotChunkResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).loadSnapshotChunk)
                    };
                    break;
                case /* cometbft.abci.v1.ApplySnapshotChunkResponse apply_snapshot_chunk */ 16:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: ApplySnapshotChunkResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).applySnapshotChunk)
                    };
                    break;
                case /* cometbft.abci.v1.PrepareProposalResponse prepare_proposal */ 17:
                    message.value = {
                        oneofKind: "prepareProposal",
                        prepareProposal: PrepareProposalResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).prepareProposal)
                    };
                    break;
                case /* cometbft.abci.v1.ProcessProposalResponse process_proposal */ 18:
                    message.value = {
                        oneofKind: "processProposal",
                        processProposal: ProcessProposalResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).processProposal)
                    };
                    break;
                case /* cometbft.abci.v1.ExtendVoteResponse extend_vote */ 19:
                    message.value = {
                        oneofKind: "extendVote",
                        extendVote: ExtendVoteResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).extendVote)
                    };
                    break;
                case /* cometbft.abci.v1.VerifyVoteExtensionResponse verify_vote_extension */ 20:
                    message.value = {
                        oneofKind: "verifyVoteExtension",
                        verifyVoteExtension: VerifyVoteExtensionResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).verifyVoteExtension)
                    };
                    break;
                case /* cometbft.abci.v1.FinalizeBlockResponse finalize_block */ 21:
                    message.value = {
                        oneofKind: "finalizeBlock",
                        finalizeBlock: FinalizeBlockResponse.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).finalizeBlock)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.ExceptionResponse exception = 1; */
        if (message.value.oneofKind === "exception")
            ExceptionResponse.internalBinaryWrite(message.value.exception, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.EchoResponse echo = 2; */
        if (message.value.oneofKind === "echo")
            EchoResponse.internalBinaryWrite(message.value.echo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.FlushResponse flush = 3; */
        if (message.value.oneofKind === "flush")
            FlushResponse.internalBinaryWrite(message.value.flush, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.InfoResponse info = 4; */
        if (message.value.oneofKind === "info")
            InfoResponse.internalBinaryWrite(message.value.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.InitChainResponse init_chain = 6; */
        if (message.value.oneofKind === "initChain")
            InitChainResponse.internalBinaryWrite(message.value.initChain, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.QueryResponse query = 7; */
        if (message.value.oneofKind === "query")
            QueryResponse.internalBinaryWrite(message.value.query, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.CheckTxResponse check_tx = 9; */
        if (message.value.oneofKind === "checkTx")
            CheckTxResponse.internalBinaryWrite(message.value.checkTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.CommitResponse commit = 12; */
        if (message.value.oneofKind === "commit")
            CommitResponse.internalBinaryWrite(message.value.commit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ListSnapshotsResponse list_snapshots = 13; */
        if (message.value.oneofKind === "listSnapshots")
            ListSnapshotsResponse.internalBinaryWrite(message.value.listSnapshots, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.OfferSnapshotResponse offer_snapshot = 14; */
        if (message.value.oneofKind === "offerSnapshot")
            OfferSnapshotResponse.internalBinaryWrite(message.value.offerSnapshot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.LoadSnapshotChunkResponse load_snapshot_chunk = 15; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            LoadSnapshotChunkResponse.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ApplySnapshotChunkResponse apply_snapshot_chunk = 16; */
        if (message.value.oneofKind === "applySnapshotChunk")
            ApplySnapshotChunkResponse.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.PrepareProposalResponse prepare_proposal = 17; */
        if (message.value.oneofKind === "prepareProposal")
            PrepareProposalResponse.internalBinaryWrite(message.value.prepareProposal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ProcessProposalResponse process_proposal = 18; */
        if (message.value.oneofKind === "processProposal")
            ProcessProposalResponse.internalBinaryWrite(message.value.processProposal, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.ExtendVoteResponse extend_vote = 19; */
        if (message.value.oneofKind === "extendVote")
            ExtendVoteResponse.internalBinaryWrite(message.value.extendVote, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.VerifyVoteExtensionResponse verify_vote_extension = 20; */
        if (message.value.oneofKind === "verifyVoteExtension")
            VerifyVoteExtensionResponse.internalBinaryWrite(message.value.verifyVoteExtension, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.abci.v1.FinalizeBlockResponse finalize_block = 21; */
        if (message.value.oneofKind === "finalizeBlock")
            FinalizeBlockResponse.internalBinaryWrite(message.value.finalizeBlock, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExceptionResponse$Type extends MessageType<ExceptionResponse> {
    constructor() {
        super("cometbft.abci.v1.ExceptionResponse", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExceptionResponse>): ExceptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ExceptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExceptionResponse): ExceptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExceptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ExceptionResponse
 */
export const ExceptionResponse = new ExceptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoResponse$Type extends MessageType<EchoResponse> {
    constructor() {
        super("cometbft.abci.v1.EchoResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoResponse>): EchoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EchoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoResponse): EchoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.EchoResponse
 */
export const EchoResponse = new EchoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlushResponse$Type extends MessageType<FlushResponse> {
    constructor() {
        super("cometbft.abci.v1.FlushResponse", []);
    }
    create(value?: PartialMessage<FlushResponse>): FlushResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FlushResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlushResponse): FlushResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlushResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.FlushResponse
 */
export const FlushResponse = new FlushResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoResponse$Type extends MessageType<InfoResponse> {
    constructor() {
        super("cometbft.abci.v1.InfoResponse", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "last_block_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "last_block_app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<InfoResponse>): InfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = "";
        message.version = "";
        message.appVersion = 0n;
        message.lastBlockHeight = 0n;
        message.lastBlockAppHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<InfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InfoResponse): InfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* uint64 app_version */ 3:
                    message.appVersion = reader.uint64().toBigInt();
                    break;
                case /* int64 last_block_height */ 4:
                    message.lastBlockHeight = reader.int64().toBigInt();
                    break;
                case /* bytes last_block_app_hash */ 5:
                    message.lastBlockAppHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* uint64 app_version = 3; */
        if (message.appVersion !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.appVersion);
        /* int64 last_block_height = 4; */
        if (message.lastBlockHeight !== 0n)
            writer.tag(4, WireType.Varint).int64(message.lastBlockHeight);
        /* bytes last_block_app_hash = 5; */
        if (message.lastBlockAppHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.lastBlockAppHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.InfoResponse
 */
export const InfoResponse = new InfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitChainResponse$Type extends MessageType<InitChainResponse> {
    constructor() {
        super("cometbft.abci.v1.InitChainResponse", [
            { no: 1, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 2, name: "validators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 3, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<InitChainResponse>): InitChainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validators = [];
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<InitChainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitChainResponse): InitChainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.types.v1.ConsensusParams consensus_params */ 1:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated cometbft.abci.v1.ValidatorUpdate validators */ 2:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_hash */ 3:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitChainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.types.v1.ConsensusParams consensus_params = 1; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.ValidatorUpdate validators = 2; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 3; */
        if (message.appHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.InitChainResponse
 */
export const InitChainResponse = new InitChainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("cometbft.abci.v1.QueryResponse", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proof_ops", kind: "message", T: () => ProofOps },
            { no: 9, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.log = "";
        message.info = "";
        message.index = 0n;
        message.key = new Uint8Array(0);
        message.value = new Uint8Array(0);
        message.height = 0n;
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 index */ 5:
                    message.index = reader.int64().toBigInt();
                    break;
                case /* bytes key */ 6:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 7:
                    message.value = reader.bytes();
                    break;
                case /* cometbft.crypto.v1.ProofOps proof_ops */ 8:
                    message.proofOps = ProofOps.internalBinaryRead(reader, reader.uint32(), options, message.proofOps);
                    break;
                case /* int64 height */ 9:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* string codespace */ 10:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 index = 5; */
        if (message.index !== 0n)
            writer.tag(5, WireType.Varint).int64(message.index);
        /* bytes key = 6; */
        if (message.key.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 7; */
        if (message.value.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.value);
        /* cometbft.crypto.v1.ProofOps proof_ops = 8; */
        if (message.proofOps)
            ProofOps.internalBinaryWrite(message.proofOps, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 9; */
        if (message.height !== 0n)
            writer.tag(9, WireType.Varint).int64(message.height);
        /* string codespace = 10; */
        if (message.codespace !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckTxResponse$Type extends MessageType<CheckTxResponse> {
    constructor() {
        super("cometbft.abci.v1.CheckTxResponse", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckTxResponse>): CheckTxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.data = new Uint8Array(0);
        message.log = "";
        message.info = "";
        message.gasWanted = 0n;
        message.gasUsed = 0n;
        message.events = [];
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial<CheckTxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckTxResponse): CheckTxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */ 5:
                    message.gasWanted = reader.int64().toBigInt();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"] */ 6:
                    message.gasUsed = reader.int64().toBigInt();
                    break;
                case /* repeated cometbft.abci.v1.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckTxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== 0n)
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== 0n)
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated cometbft.abci.v1.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.CheckTxResponse
 */
export const CheckTxResponse = new CheckTxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitResponse$Type extends MessageType<CommitResponse> {
    constructor() {
        super("cometbft.abci.v1.CommitResponse", [
            { no: 3, name: "retain_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CommitResponse>): CommitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.retainHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<CommitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitResponse): CommitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 retain_height */ 3:
                    message.retainHeight = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 retain_height = 3; */
        if (message.retainHeight !== 0n)
            writer.tag(3, WireType.Varint).int64(message.retainHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.CommitResponse
 */
export const CommitResponse = new CommitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSnapshotsResponse$Type extends MessageType<ListSnapshotsResponse> {
    constructor() {
        super("cometbft.abci.v1.ListSnapshotsResponse", [
            { no: 1, name: "snapshots", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Snapshot }
        ]);
    }
    create(value?: PartialMessage<ListSnapshotsResponse>): ListSnapshotsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snapshots = [];
        if (value !== undefined)
            reflectionMergePartial<ListSnapshotsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSnapshotsResponse): ListSnapshotsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cometbft.abci.v1.Snapshot snapshots */ 1:
                    message.snapshots.push(Snapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSnapshotsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cometbft.abci.v1.Snapshot snapshots = 1; */
        for (let i = 0; i < message.snapshots.length; i++)
            Snapshot.internalBinaryWrite(message.snapshots[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ListSnapshotsResponse
 */
export const ListSnapshotsResponse = new ListSnapshotsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OfferSnapshotResponse$Type extends MessageType<OfferSnapshotResponse> {
    constructor() {
        super("cometbft.abci.v1.OfferSnapshotResponse", [
            { no: 1, name: "result", kind: "enum", T: () => ["cometbft.abci.v1.OfferSnapshotResult", OfferSnapshotResult, "OFFER_SNAPSHOT_RESULT_"] }
        ]);
    }
    create(value?: PartialMessage<OfferSnapshotResponse>): OfferSnapshotResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        if (value !== undefined)
            reflectionMergePartial<OfferSnapshotResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OfferSnapshotResponse): OfferSnapshotResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.OfferSnapshotResult result */ 1:
                    message.result = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OfferSnapshotResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.OfferSnapshotResult result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.OfferSnapshotResponse
 */
export const OfferSnapshotResponse = new OfferSnapshotResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadSnapshotChunkResponse$Type extends MessageType<LoadSnapshotChunkResponse> {
    constructor() {
        super("cometbft.abci.v1.LoadSnapshotChunkResponse", [
            { no: 1, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<LoadSnapshotChunkResponse>): LoadSnapshotChunkResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chunk = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<LoadSnapshotChunkResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadSnapshotChunkResponse): LoadSnapshotChunkResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes chunk */ 1:
                    message.chunk = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadSnapshotChunkResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes chunk = 1; */
        if (message.chunk.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.LoadSnapshotChunkResponse
 */
export const LoadSnapshotChunkResponse = new LoadSnapshotChunkResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplySnapshotChunkResponse$Type extends MessageType<ApplySnapshotChunkResponse> {
    constructor() {
        super("cometbft.abci.v1.ApplySnapshotChunkResponse", [
            { no: 1, name: "result", kind: "enum", T: () => ["cometbft.abci.v1.ApplySnapshotChunkResult", ApplySnapshotChunkResult, "APPLY_SNAPSHOT_CHUNK_RESULT_"] },
            { no: 2, name: "refetch_chunks", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "reject_senders", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplySnapshotChunkResponse>): ApplySnapshotChunkResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.refetchChunks = [];
        message.rejectSenders = [];
        if (value !== undefined)
            reflectionMergePartial<ApplySnapshotChunkResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplySnapshotChunkResponse): ApplySnapshotChunkResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.ApplySnapshotChunkResult result */ 1:
                    message.result = reader.int32();
                    break;
                case /* repeated uint32 refetch_chunks */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.refetchChunks.push(reader.uint32());
                    else
                        message.refetchChunks.push(reader.uint32());
                    break;
                case /* repeated string reject_senders */ 3:
                    message.rejectSenders.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplySnapshotChunkResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.ApplySnapshotChunkResult result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* repeated uint32 refetch_chunks = 2; */
        if (message.refetchChunks.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.refetchChunks.length; i++)
                writer.uint32(message.refetchChunks[i]);
            writer.join();
        }
        /* repeated string reject_senders = 3; */
        for (let i = 0; i < message.rejectSenders.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.rejectSenders[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ApplySnapshotChunkResponse
 */
export const ApplySnapshotChunkResponse = new ApplySnapshotChunkResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareProposalResponse$Type extends MessageType<PrepareProposalResponse> {
    constructor() {
        super("cometbft.abci.v1.PrepareProposalResponse", [
            { no: 1, name: "txs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareProposalResponse>): PrepareProposalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.txs = [];
        if (value !== undefined)
            reflectionMergePartial<PrepareProposalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareProposalResponse): PrepareProposalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes txs */ 1:
                    message.txs.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareProposalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes txs = 1; */
        for (let i = 0; i < message.txs.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.txs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.PrepareProposalResponse
 */
export const PrepareProposalResponse = new PrepareProposalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessProposalResponse$Type extends MessageType<ProcessProposalResponse> {
    constructor() {
        super("cometbft.abci.v1.ProcessProposalResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["cometbft.abci.v1.ProcessProposalStatus", ProcessProposalStatus, "PROCESS_PROPOSAL_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<ProcessProposalResponse>): ProcessProposalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<ProcessProposalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessProposalResponse): ProcessProposalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.ProcessProposalStatus status */ 1:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessProposalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.ProcessProposalStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ProcessProposalResponse
 */
export const ProcessProposalResponse = new ProcessProposalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendVoteResponse$Type extends MessageType<ExtendVoteResponse> {
    constructor() {
        super("cometbft.abci.v1.ExtendVoteResponse", [
            { no: 1, name: "vote_extension", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ExtendVoteResponse>): ExtendVoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.voteExtension = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ExtendVoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendVoteResponse): ExtendVoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes vote_extension */ 1:
                    message.voteExtension = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendVoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes vote_extension = 1; */
        if (message.voteExtension.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.voteExtension);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ExtendVoteResponse
 */
export const ExtendVoteResponse = new ExtendVoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyVoteExtensionResponse$Type extends MessageType<VerifyVoteExtensionResponse> {
    constructor() {
        super("cometbft.abci.v1.VerifyVoteExtensionResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["cometbft.abci.v1.VerifyVoteExtensionStatus", VerifyVoteExtensionStatus, "VERIFY_VOTE_EXTENSION_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<VerifyVoteExtensionResponse>): VerifyVoteExtensionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<VerifyVoteExtensionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyVoteExtensionResponse): VerifyVoteExtensionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.VerifyVoteExtensionStatus status */ 1:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyVoteExtensionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.VerifyVoteExtensionStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.VerifyVoteExtensionResponse
 */
export const VerifyVoteExtensionResponse = new VerifyVoteExtensionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalizeBlockResponse$Type extends MessageType<FinalizeBlockResponse> {
    constructor() {
        super("cometbft.abci.v1.FinalizeBlockResponse", [
            { no: 1, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 2, name: "tx_results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExecTxResult },
            { no: 3, name: "validator_updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 4, name: "consensus_param_updates", kind: "message", T: () => ConsensusParams },
            { no: 5, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FinalizeBlockResponse>): FinalizeBlockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        message.txResults = [];
        message.validatorUpdates = [];
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<FinalizeBlockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinalizeBlockResponse): FinalizeBlockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cometbft.abci.v1.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated cometbft.abci.v1.ExecTxResult tx_results */ 2:
                    message.txResults.push(ExecTxResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated cometbft.abci.v1.ValidatorUpdate validator_updates */ 3:
                    message.validatorUpdates.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cometbft.types.v1.ConsensusParams consensus_param_updates */ 4:
                    message.consensusParamUpdates = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParamUpdates);
                    break;
                case /* bytes app_hash */ 5:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinalizeBlockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cometbft.abci.v1.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.ExecTxResult tx_results = 2; */
        for (let i = 0; i < message.txResults.length; i++)
            ExecTxResult.internalBinaryWrite(message.txResults[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated cometbft.abci.v1.ValidatorUpdate validator_updates = 3; */
        for (let i = 0; i < message.validatorUpdates.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validatorUpdates[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.types.v1.ConsensusParams consensus_param_updates = 4; */
        if (message.consensusParamUpdates)
            ConsensusParams.internalBinaryWrite(message.consensusParamUpdates, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 5; */
        if (message.appHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.FinalizeBlockResponse
 */
export const FinalizeBlockResponse = new FinalizeBlockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitInfo$Type extends MessageType<CommitInfo> {
    constructor() {
        super("cometbft.abci.v1.CommitInfo", [
            { no: 1, name: "round", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "votes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => VoteInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<CommitInfo>): CommitInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0;
        message.votes = [];
        if (value !== undefined)
            reflectionMergePartial<CommitInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitInfo): CommitInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32();
                    break;
                case /* repeated cometbft.abci.v1.VoteInfo votes */ 2:
                    message.votes.push(VoteInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 round = 1; */
        if (message.round !== 0)
            writer.tag(1, WireType.Varint).int32(message.round);
        /* repeated cometbft.abci.v1.VoteInfo votes = 2; */
        for (let i = 0; i < message.votes.length; i++)
            VoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.CommitInfo
 */
export const CommitInfo = new CommitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendedCommitInfo$Type extends MessageType<ExtendedCommitInfo> {
    constructor() {
        super("cometbft.abci.v1.ExtendedCommitInfo", [
            { no: 1, name: "round", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "votes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExtendedVoteInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<ExtendedCommitInfo>): ExtendedCommitInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.round = 0;
        message.votes = [];
        if (value !== undefined)
            reflectionMergePartial<ExtendedCommitInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendedCommitInfo): ExtendedCommitInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32();
                    break;
                case /* repeated cometbft.abci.v1.ExtendedVoteInfo votes */ 2:
                    message.votes.push(ExtendedVoteInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendedCommitInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 round = 1; */
        if (message.round !== 0)
            writer.tag(1, WireType.Varint).int32(message.round);
        /* repeated cometbft.abci.v1.ExtendedVoteInfo votes = 2; */
        for (let i = 0; i < message.votes.length; i++)
            ExtendedVoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ExtendedCommitInfo
 */
export const ExtendedCommitInfo = new ExtendedCommitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("cometbft.abci.v1.Event", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EventAttribute, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "attributes,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated cometbft.abci.v1.EventAttribute attributes */ 2:
                    message.attributes.push(EventAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated cometbft.abci.v1.EventAttribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            EventAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAttribute$Type extends MessageType<EventAttribute> {
    constructor() {
        super("cometbft.abci.v1.EventAttribute", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EventAttribute>): EventAttribute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        message.index = false;
        if (value !== undefined)
            reflectionMergePartial<EventAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAttribute): EventAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* bool index */ 3:
                    message.index = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* bool index = 3; */
        if (message.index !== false)
            writer.tag(3, WireType.Varint).bool(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.EventAttribute
 */
export const EventAttribute = new EventAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecTxResult$Type extends MessageType<ExecTxResult> {
    constructor() {
        super("cometbft.abci.v1.ExecTxResult", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExecTxResult>): ExecTxResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.data = new Uint8Array(0);
        message.log = "";
        message.info = "";
        message.gasWanted = 0n;
        message.gasUsed = 0n;
        message.events = [];
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial<ExecTxResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecTxResult): ExecTxResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"] */ 5:
                    message.gasWanted = reader.int64().toBigInt();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"] */ 6:
                    message.gasUsed = reader.int64().toBigInt();
                    break;
                case /* repeated cometbft.abci.v1.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecTxResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== 0n)
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== 0n)
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated cometbft.abci.v1.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ExecTxResult
 */
export const ExecTxResult = new ExecTxResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxResult$Type extends MessageType<TxResult> {
    constructor() {
        super("cometbft.abci.v1.TxResult", [
            { no: 1, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "result", kind: "message", T: () => ExecTxResult, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<TxResult>): TxResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.index = 0;
        message.tx = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TxResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxResult): TxResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 height */ 1:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* uint32 index */ 2:
                    message.index = reader.uint32();
                    break;
                case /* bytes tx */ 3:
                    message.tx = reader.bytes();
                    break;
                case /* cometbft.abci.v1.ExecTxResult result */ 4:
                    message.result = ExecTxResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).int64(message.height);
        /* uint32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.index);
        /* bytes tx = 3; */
        if (message.tx.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.tx);
        /* cometbft.abci.v1.ExecTxResult result = 4; */
        if (message.result)
            ExecTxResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.TxResult
 */
export const TxResult = new TxResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Validator$Type extends MessageType<Validator> {
    constructor() {
        super("cometbft.abci.v1.Validator", [
            { no: 1, name: "address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Validator>): Validator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = new Uint8Array(0);
        message.power = 0n;
        if (value !== undefined)
            reflectionMergePartial<Validator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Validator): Validator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes address */ 1:
                    message.address = reader.bytes();
                    break;
                case /* int64 power */ 3:
                    message.power = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Validator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes address = 1; */
        if (message.address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.address);
        /* int64 power = 3; */
        if (message.power !== 0n)
            writer.tag(3, WireType.Varint).int64(message.power);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.Validator
 */
export const Validator = new Validator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidatorUpdate$Type extends MessageType<ValidatorUpdate> {
    constructor() {
        super("cometbft.abci.v1.ValidatorUpdate", [
            { no: 2, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "pub_key_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "pub_key_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidatorUpdate>): ValidatorUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.power = 0n;
        message.pubKeyBytes = new Uint8Array(0);
        message.pubKeyType = "";
        if (value !== undefined)
            reflectionMergePartial<ValidatorUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorUpdate): ValidatorUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 power */ 2:
                    message.power = reader.int64().toBigInt();
                    break;
                case /* bytes pub_key_bytes */ 3:
                    message.pubKeyBytes = reader.bytes();
                    break;
                case /* string pub_key_type */ 4:
                    message.pubKeyType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidatorUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 power = 2; */
        if (message.power !== 0n)
            writer.tag(2, WireType.Varint).int64(message.power);
        /* bytes pub_key_bytes = 3; */
        if (message.pubKeyBytes.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.pubKeyBytes);
        /* string pub_key_type = 4; */
        if (message.pubKeyType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pubKeyType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ValidatorUpdate
 */
export const ValidatorUpdate = new ValidatorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoteInfo$Type extends MessageType<VoteInfo> {
    constructor() {
        super("cometbft.abci.v1.VoteInfo", [
            { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "block_id_flag", kind: "enum", T: () => ["cometbft.types.v1.BlockIDFlag", BlockIDFlag] }
        ]);
    }
    create(value?: PartialMessage<VoteInfo>): VoteInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blockIdFlag = 0;
        if (value !== undefined)
            reflectionMergePartial<VoteInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoteInfo): VoteInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.Validator validator */ 1:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* cometbft.types.v1.BlockIDFlag block_id_flag */ 3:
                    message.blockIdFlag = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoteInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.Validator validator = 1; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cometbft.types.v1.BlockIDFlag block_id_flag = 3; */
        if (message.blockIdFlag !== 0)
            writer.tag(3, WireType.Varint).int32(message.blockIdFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.VoteInfo
 */
export const VoteInfo = new VoteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendedVoteInfo$Type extends MessageType<ExtendedVoteInfo> {
    constructor() {
        super("cometbft.abci.v1.ExtendedVoteInfo", [
            { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "vote_extension", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "extension_signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "block_id_flag", kind: "enum", T: () => ["cometbft.types.v1.BlockIDFlag", BlockIDFlag] }
        ]);
    }
    create(value?: PartialMessage<ExtendedVoteInfo>): ExtendedVoteInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.voteExtension = new Uint8Array(0);
        message.extensionSignature = new Uint8Array(0);
        message.blockIdFlag = 0;
        if (value !== undefined)
            reflectionMergePartial<ExtendedVoteInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendedVoteInfo): ExtendedVoteInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.Validator validator */ 1:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* bytes vote_extension */ 3:
                    message.voteExtension = reader.bytes();
                    break;
                case /* bytes extension_signature */ 4:
                    message.extensionSignature = reader.bytes();
                    break;
                case /* cometbft.types.v1.BlockIDFlag block_id_flag */ 5:
                    message.blockIdFlag = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendedVoteInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.Validator validator = 1; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes vote_extension = 3; */
        if (message.voteExtension.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.voteExtension);
        /* bytes extension_signature = 4; */
        if (message.extensionSignature.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.extensionSignature);
        /* cometbft.types.v1.BlockIDFlag block_id_flag = 5; */
        if (message.blockIdFlag !== 0)
            writer.tag(5, WireType.Varint).int32(message.blockIdFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.ExtendedVoteInfo
 */
export const ExtendedVoteInfo = new ExtendedVoteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Misbehavior$Type extends MessageType<Misbehavior> {
    constructor() {
        super("cometbft.abci.v1.Misbehavior", [
            { no: 1, name: "type", kind: "enum", T: () => ["cometbft.abci.v1.MisbehaviorType", MisbehaviorType, "MISBEHAVIOR_TYPE_"] },
            { no: 2, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 5, name: "total_voting_power", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Misbehavior>): Misbehavior {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.height = 0n;
        message.totalVotingPower = 0n;
        if (value !== undefined)
            reflectionMergePartial<Misbehavior>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Misbehavior): Misbehavior {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cometbft.abci.v1.MisbehaviorType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* cometbft.abci.v1.Validator validator */ 2:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp time */ 4:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* int64 total_voting_power */ 5:
                    message.totalVotingPower = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Misbehavior, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cometbft.abci.v1.MisbehaviorType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* cometbft.abci.v1.Validator validator = 2; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 4; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_voting_power = 5; */
        if (message.totalVotingPower !== 0n)
            writer.tag(5, WireType.Varint).int64(message.totalVotingPower);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.Misbehavior
 */
export const Misbehavior = new Misbehavior$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Snapshot$Type extends MessageType<Snapshot> {
    constructor() {
        super("cometbft.abci.v1.Snapshot", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Snapshot>): Snapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.height = 0n;
        message.format = 0;
        message.chunks = 0;
        message.hash = new Uint8Array(0);
        message.metadata = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Snapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Snapshot): Snapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunks */ 3:
                    message.chunks = reader.uint32();
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* bytes metadata */ 5:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Snapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunks = 3; */
        if (message.chunks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunks);
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* bytes metadata = 5; */
        if (message.metadata.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.Snapshot
 */
export const Snapshot = new Snapshot$Type();
