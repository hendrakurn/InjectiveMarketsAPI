// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "goadesign_goagen_mito_api.proto" (package "mito_api", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.10.2, DO NOT EDIT.
//
// Mito API protocol buffer definition
//
// Command:
// $ goa gen github.com/MitoFinance/mito-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mito_api.GetVaultsRequest
 */
export interface GetVaultsRequest {
    /**
     * @generated from protobuf field: optional uint32 limit = 1
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional uint32 page_index = 2
     */
    pageIndex?: number;
    /**
     * @generated from protobuf field: optional uint64 code_id = 3
     */
    codeId?: bigint;
}
/**
 * @generated from protobuf message mito_api.GetVaultsResponse
 */
export interface GetVaultsResponse {
    /**
     * Vaults data response
     *
     * @generated from protobuf field: repeated mito_api.Vault vaults = 1
     */
    vaults: Vault[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.Vault
 */
export interface Vault {
    /**
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * @generated from protobuf field: uint64 code_id = 2
     */
    codeId: bigint;
    /**
     * @generated from protobuf field: string vault_name = 3
     */
    vaultName: string;
    /**
     * @generated from protobuf field: string market_id = 4
     */
    marketId: string;
    /**
     * @generated from protobuf field: double current_tvl = 5
     */
    currentTvl: number;
    /**
     * @generated from protobuf field: mito_api.Changes profits = 6
     */
    profits?: Changes;
    /**
     * @generated from protobuf field: uint64 updated_at = 7
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: string vault_type = 8
     */
    vaultType: string;
    /**
     * @generated from protobuf field: double lp_token_price = 9
     */
    lpTokenPrice: number;
    /**
     * @generated from protobuf field: mito_api.SubaccountBalance subaccount_info = 10
     */
    subaccountInfo?: SubaccountBalance;
    /**
     * @generated from protobuf field: string master_contract_address = 11
     */
    masterContractAddress: string;
    /**
     * @generated from protobuf field: string total_lp_amount = 12
     */
    totalLpAmount: string;
    /**
     * @generated from protobuf field: string slug = 13
     */
    slug: string;
    /**
     * @generated from protobuf field: sint64 created_at = 14
     */
    createdAt: bigint;
    /**
     * @generated from protobuf field: string notional_value_cap = 15
     */
    notionalValueCap: string;
    /**
     * @generated from protobuf field: mito_api.Changes tvl_changes = 16
     */
    tvlChanges?: Changes;
    /**
     * @generated from protobuf field: double apy = 17
     */
    apy: number;
    /**
     * @generated from protobuf field: double apy7_d = 18
     */
    apy7D: number;
    /**
     * @generated from protobuf field: double apy7_d_fq = 19
     */
    apy7DFq: number;
    /**
     * @generated from protobuf field: double apyue = 20
     */
    apyue: number;
    /**
     * @generated from protobuf field: double apy_v3 = 21
     */
    apyV3: number;
    /**
     * @generated from protobuf field: string registration_mode = 22
     */
    registrationMode: string;
}
/**
 * @generated from protobuf message mito_api.Changes
 */
export interface Changes {
    /**
     * @generated from protobuf field: double all_time_change = 1
     */
    allTimeChange: number;
    /**
     * @generated from protobuf field: optional double three_months_change = 2
     */
    threeMonthsChange?: number;
    /**
     * @generated from protobuf field: optional double one_month_change = 3
     */
    oneMonthChange?: number;
    /**
     * @generated from protobuf field: optional double one_day_change = 4
     */
    oneDayChange?: number;
    /**
     * @generated from protobuf field: optional double one_week_change = 5
     */
    oneWeekChange?: number;
    /**
     * @generated from protobuf field: optional double one_year_change = 6
     */
    oneYearChange?: number;
    /**
     * @generated from protobuf field: optional double three_years_change = 7
     */
    threeYearsChange?: number;
    /**
     * @generated from protobuf field: optional double six_months_change = 8
     */
    sixMonthsChange?: number;
}
/**
 * @generated from protobuf message mito_api.SubaccountBalance
 */
export interface SubaccountBalance {
    /**
     * @generated from protobuf field: string subaccount_id = 1
     */
    subaccountId: string;
    /**
     * @generated from protobuf field: repeated mito_api.DenomBalance balances = 2
     */
    balances: DenomBalance[];
}
/**
 * @generated from protobuf message mito_api.DenomBalance
 */
export interface DenomBalance {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string total_balance = 2
     */
    totalBalance: string;
    /**
     * @generated from protobuf field: optional string price = 3
     */
    price?: string;
    /**
     * @generated from protobuf field: optional sint64 updated_at = 4
     */
    updatedAt?: bigint;
    /**
     * @generated from protobuf field: optional string source = 5
     */
    source?: string;
}
/**
 * @generated from protobuf message mito_api.Pagination
 */
export interface Pagination {
    /**
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
}
/**
 * @generated from protobuf message mito_api.GetVaultRequest
 */
export interface GetVaultRequest {
    /**
     * @generated from protobuf field: optional string contract_address = 1
     */
    contractAddress?: string;
    /**
     * @generated from protobuf field: optional string slug = 2
     */
    slug?: string;
}
/**
 * @generated from protobuf message mito_api.GetVaultResponse
 */
export interface GetVaultResponse {
    /**
     * Vault data response, if query by slug, there can be multiple vaults matching
     * the condition
     *
     * @generated from protobuf field: repeated mito_api.Vault vault = 1
     */
    vault: Vault[];
}
/**
 * @generated from protobuf message mito_api.LPTokenPriceChartRequest
 */
export interface LPTokenPriceChartRequest {
    /**
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: optional uint64 from_time = 2
     */
    fromTime?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_time = 3
     */
    toTime?: bigint;
}
/**
 * @generated from protobuf message mito_api.LPTokenPriceChartResponse
 */
export interface LPTokenPriceChartResponse {
    /**
     * @generated from protobuf field: repeated mito_api.PriceSnapshot prices = 1
     */
    prices: PriceSnapshot[];
}
/**
 * @generated from protobuf message mito_api.PriceSnapshot
 */
export interface PriceSnapshot {
    /**
     * @generated from protobuf field: double price = 1
     */
    price: number;
    /**
     * @generated from protobuf field: uint64 updated_at = 2
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message mito_api.TVLChartRequest
 */
export interface TVLChartRequest {
    /**
     * @generated from protobuf field: string vault_address = 1
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: optional uint64 from_time = 2
     */
    fromTime?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_time = 3
     */
    toTime?: bigint;
}
/**
 * @generated from protobuf message mito_api.TVLChartResponse
 */
export interface TVLChartResponse {
    /**
     * @generated from protobuf field: repeated mito_api.PriceSnapshot prices = 1
     */
    prices: PriceSnapshot[];
}
/**
 * @generated from protobuf message mito_api.VaultsByHolderAddressRequest
 */
export interface VaultsByHolderAddressRequest {
    /**
     * @generated from protobuf field: optional uint32 limit = 1
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional uint32 page_index = 2
     */
    pageIndex?: number;
    /**
     * @generated from protobuf field: string holder_address = 3
     */
    holderAddress: string;
    /**
     * @generated from protobuf field: optional string vault_address = 4
     */
    vaultAddress?: string;
    /**
     * @generated from protobuf field: optional sint32 skip = 5
     */
    skip?: number;
}
/**
 * @generated from protobuf message mito_api.VaultsByHolderAddressResponse
 */
export interface VaultsByHolderAddressResponse {
    /**
     * @generated from protobuf field: repeated mito_api.Subscription subscriptions = 1
     */
    subscriptions: Subscription[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.Subscription
 */
export interface Subscription {
    /**
     * @generated from protobuf field: mito_api.Vault vault_info = 1
     */
    vaultInfo?: Vault;
    /**
     * @generated from protobuf field: string lp_amount = 2
     */
    lpAmount: string;
    /**
     * @generated from protobuf field: string holder_address = 3
     */
    holderAddress: string;
    /**
     * @generated from protobuf field: double lp_amount_percentage = 4
     */
    lpAmountPercentage: number;
}
/**
 * @generated from protobuf message mito_api.LPHoldersRequest
 */
export interface LPHoldersRequest {
    /**
     * @generated from protobuf field: optional uint32 limit = 1
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional uint32 page_index = 2
     */
    pageIndex?: number;
    /**
     * @generated from protobuf field: string vault_address = 3
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: optional string staking_contract_address = 4
     */
    stakingContractAddress?: string;
    /**
     * @generated from protobuf field: optional sint32 skip = 5
     */
    skip?: number;
}
/**
 * @generated from protobuf message mito_api.LPHoldersResponse
 */
export interface LPHoldersResponse {
    /**
     * @generated from protobuf field: repeated mito_api.Holders holders = 1
     */
    holders: Holders[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.Holders
 */
export interface Holders {
    /**
     * @generated from protobuf field: string holder_address = 1
     */
    holderAddress: string;
    /**
     * @generated from protobuf field: string vault_address = 2
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: string amount = 3
     */
    amount: string;
    /**
     * @generated from protobuf field: sint64 updated_at = 4
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: double lp_amount_percentage = 5
     */
    lpAmountPercentage: number;
    /**
     * @generated from protobuf field: sint64 redemption_lock_time = 6
     */
    redemptionLockTime: bigint;
    /**
     * @generated from protobuf field: string staked_amount = 7
     */
    stakedAmount: string;
}
/**
 * @generated from protobuf message mito_api.PortfolioRequest
 */
export interface PortfolioRequest {
    /**
     * @generated from protobuf field: string holder_address = 1
     */
    holderAddress: string;
    /**
     * @generated from protobuf field: optional string staking_contract_address = 2
     */
    stakingContractAddress?: string;
}
/**
 * @generated from protobuf message mito_api.PortfolioResponse
 */
export interface PortfolioResponse {
    /**
     * @generated from protobuf field: double total_value = 1
     */
    totalValue: number;
    /**
     * @generated from protobuf field: double pnl = 2
     */
    pnl: number;
    /**
     * @generated from protobuf field: repeated mito_api.PriceSnapshot total_value_chart = 3
     */
    totalValueChart: PriceSnapshot[];
    /**
     * @generated from protobuf field: repeated mito_api.PriceSnapshot pnl_chart = 4
     */
    pnlChart: PriceSnapshot[];
    /**
     * @generated from protobuf field: sint64 pnl_updated_at = 5
     */
    pnlUpdatedAt: bigint;
}
/**
 * @generated from protobuf message mito_api.LeaderboardRequest
 */
export interface LeaderboardRequest {
    /**
     * @generated from protobuf field: optional uint32 epoch_id = 1
     */
    epochId?: number;
}
/**
 * @generated from protobuf message mito_api.LeaderboardResponse
 */
export interface LeaderboardResponse {
    /**
     * @generated from protobuf field: repeated mito_api.LeaderboardEntry entries = 1
     */
    entries: LeaderboardEntry[];
    /**
     * @generated from protobuf field: sint64 snapshot_block = 2
     */
    snapshotBlock: bigint;
    /**
     * @generated from protobuf field: sint64 updated_at = 3
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: uint32 epoch_id = 4
     */
    epochId: number;
}
/**
 * @generated from protobuf message mito_api.LeaderboardEntry
 */
export interface LeaderboardEntry {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: double pnl = 2
     */
    pnl: number;
}
/**
 * @generated from protobuf message mito_api.LeaderboardEpochsRequest
 */
export interface LeaderboardEpochsRequest {
    /**
     * @generated from protobuf field: optional uint32 from_epoch_id = 1
     */
    fromEpochId?: number;
    /**
     * @generated from protobuf field: optional uint32 to_epoch_id = 2
     */
    toEpochId?: number;
    /**
     * @generated from protobuf field: optional uint32 limit = 3
     */
    limit?: number;
}
/**
 * @generated from protobuf message mito_api.LeaderboardEpochsResponse
 */
export interface LeaderboardEpochsResponse {
    /**
     * @generated from protobuf field: repeated mito_api.LeaderboardEpoch epochs = 1
     */
    epochs: LeaderboardEpoch[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.LeaderboardEpoch
 */
export interface LeaderboardEpoch {
    /**
     * @generated from protobuf field: uint32 epoch_id = 1
     */
    epochId: number;
    /**
     * @generated from protobuf field: sint64 start_at = 2
     */
    startAt: bigint;
    /**
     * @generated from protobuf field: sint64 end_at = 3
     */
    endAt: bigint;
    /**
     * @generated from protobuf field: bool is_live = 4
     */
    isLive: boolean;
}
/**
 * @generated from protobuf message mito_api.TransfersHistoryRequest
 */
export interface TransfersHistoryRequest {
    /**
     * @generated from protobuf field: optional string vault = 1
     */
    vault?: string;
    /**
     * @generated from protobuf field: optional string account = 2
     */
    account?: string;
    /**
     * @generated from protobuf field: optional uint32 limit = 3
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional uint32 from_number = 4
     */
    fromNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 to_number = 5
     */
    toNumber?: number;
}
/**
 * @generated from protobuf message mito_api.TransfersHistoryResponse
 */
export interface TransfersHistoryResponse {
    /**
     * @generated from protobuf field: repeated mito_api.Transfer transfers = 1
     */
    transfers: Transfer[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.Transfer
 */
export interface Transfer {
    /**
     * @generated from protobuf field: string lp_amount = 1
     */
    lpAmount: string;
    /**
     * @generated from protobuf field: repeated mito_api.Coin coins = 2
     */
    coins: Coin[];
    /**
     * @generated from protobuf field: string usd_value = 3
     */
    usdValue: string;
    /**
     * @generated from protobuf field: bool is_deposit = 4
     */
    isDeposit: boolean;
    /**
     * time in unix milli
     *
     * @generated from protobuf field: sint64 executed_at = 5
     */
    executedAt: bigint;
    /**
     * @generated from protobuf field: string account = 6
     */
    account: string;
    /**
     * @generated from protobuf field: string vault = 7
     */
    vault: string;
    /**
     * @generated from protobuf field: string tx_hash = 8
     */
    txHash: string;
    /**
     * @generated from protobuf field: uint32 tid_by_vault = 9
     */
    tidByVault: number;
    /**
     * @generated from protobuf field: uint32 tid_by_account = 10
     */
    tidByAccount: number;
}
/**
 * @generated from protobuf message mito_api.Coin
 */
export interface Coin {
    /**
     * @generated from protobuf field: string amount = 1
     */
    amount: string;
    /**
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
}
/**
 * @generated from protobuf message mito_api.GetStakingPoolsRequest
 */
export interface GetStakingPoolsRequest {
    /**
     * @generated from protobuf field: optional string staker = 1
     */
    staker?: string;
    /**
     * @generated from protobuf field: string staking_contract_address = 2
     */
    stakingContractAddress: string;
}
/**
 * @generated from protobuf message mito_api.GetStakingPoolsResponse
 */
export interface GetStakingPoolsResponse {
    /**
     * @generated from protobuf field: repeated mito_api.StakingPool pools = 1
     */
    pools: StakingPool[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.StakingPool
 */
export interface StakingPool {
    /**
     * @generated from protobuf field: string vault_name = 1
     */
    vaultName: string;
    /**
     * @generated from protobuf field: string vault_address = 2
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: string stake_denom = 3
     */
    stakeDenom: string;
    /**
     * @generated from protobuf field: repeated mito_api.Gauge gauges = 4
     */
    gauges: Gauge[];
    /**
     * @generated from protobuf field: double apr = 5
     */
    apr: number;
    /**
     * @generated from protobuf field: double total_liquidity = 6
     */
    totalLiquidity: number;
    /**
     * @generated from protobuf field: string staking_address = 7
     */
    stakingAddress: string;
    /**
     * denom => APR%, breakdown of staking APR
     *
     * @generated from protobuf field: map<string, double> apr_breakdown = 8
     */
    aprBreakdown: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message mito_api.Gauge
 */
export interface Gauge {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string owner = 2
     */
    owner: string;
    /**
     * @generated from protobuf field: sint64 start_timestamp = 3
     */
    startTimestamp: bigint;
    /**
     * @generated from protobuf field: sint64 end_timestamp = 4
     */
    endTimestamp: bigint;
    /**
     * @generated from protobuf field: repeated mito_api.Coin reward_tokens = 5
     */
    rewardTokens: Coin[];
    /**
     * @generated from protobuf field: uint32 last_distribution = 6
     */
    lastDistribution: number;
    /**
     * @generated from protobuf field: string status = 7
     */
    status: string;
}
/**
 * @generated from protobuf message mito_api.StakingRewardByAccountRequest
 */
export interface StakingRewardByAccountRequest {
    /**
     * @generated from protobuf field: string staker = 1
     */
    staker: string;
    /**
     * @generated from protobuf field: string staking_contract_address = 2
     */
    stakingContractAddress: string;
}
/**
 * @generated from protobuf message mito_api.StakingRewardByAccountResponse
 */
export interface StakingRewardByAccountResponse {
    /**
     * @generated from protobuf field: repeated mito_api.StakingReward rewards = 1
     */
    rewards: StakingReward[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.StakingReward
 */
export interface StakingReward {
    /**
     * @generated from protobuf field: string vault_name = 1
     */
    vaultName: string;
    /**
     * @generated from protobuf field: string vault_address = 2
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: mito_api.Coin staked_amount = 3
     */
    stakedAmount?: Coin;
    /**
     * @generated from protobuf field: double apr = 4
     */
    apr: number;
    /**
     * @generated from protobuf field: repeated mito_api.Coin claimable_rewards = 5
     */
    claimableRewards: Coin[];
    /**
     * @generated from protobuf field: sint64 lock_timestamp = 6
     */
    lockTimestamp: bigint;
    /**
     * @generated from protobuf field: mito_api.Coin locked_amount = 7
     */
    lockedAmount?: Coin;
}
/**
 * @generated from protobuf message mito_api.StakingHistoryRequest
 */
export interface StakingHistoryRequest {
    /**
     * @generated from protobuf field: optional uint32 from_number = 1
     */
    fromNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 to_number = 2
     */
    toNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 limit = 3
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional string staker = 4
     */
    staker?: string;
}
/**
 * @generated from protobuf message mito_api.StakingHistoryResponse
 */
export interface StakingHistoryResponse {
    /**
     * @generated from protobuf field: repeated mito_api.StakingActivity activities = 1
     */
    activities: StakingActivity[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.StakingActivity
 */
export interface StakingActivity {
    /**
     * @generated from protobuf field: mito_api.Coin stake_amount = 1
     */
    stakeAmount?: Coin;
    /**
     * @generated from protobuf field: string vault_address = 2
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: string action = 3
     */
    action: string;
    /**
     * @generated from protobuf field: string tx_hash = 4
     */
    txHash: string;
    /**
     * @generated from protobuf field: repeated mito_api.Coin rewarded_tokens = 5
     */
    rewardedTokens: Coin[];
    /**
     * @generated from protobuf field: sint64 timestamp = 6
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: string staker = 7
     */
    staker: string;
    /**
     * @generated from protobuf field: uint32 number_by_account = 8
     */
    numberByAccount: number;
}
/**
 * @generated from protobuf message mito_api.StakingAmountAtHeightRequest
 */
export interface StakingAmountAtHeightRequest {
    /**
     * @generated from protobuf field: string staking_contract_address = 1
     */
    stakingContractAddress: string;
    /**
     * @generated from protobuf field: string denom = 2
     */
    denom: string;
    /**
     * [Optional] Max block height, latest if not set
     *
     * @generated from protobuf field: optional uint64 height = 3
     */
    height?: bigint;
    /**
     * [Optional] Staker address
     *
     * @generated from protobuf field: optional string staker = 4
     */
    staker?: string;
    /**
     * @generated from protobuf field: optional sint32 skip = 5
     */
    skip?: number;
    /**
     * @generated from protobuf field: optional uint32 limit = 6
     */
    limit?: number;
}
/**
 * @generated from protobuf message mito_api.StakingAmountAtHeightResponse
 */
export interface StakingAmountAtHeightResponse {
    /**
     * @generated from protobuf field: repeated mito_api.StakingAmount stakers = 1
     */
    stakers: StakingAmount[];
}
/**
 * @generated from protobuf message mito_api.StakingAmount
 */
export interface StakingAmount {
    /**
     * @generated from protobuf field: string staker = 1
     */
    staker: string;
    /**
     * @generated from protobuf field: mito_api.Coin amount = 2
     */
    amount?: Coin;
    /**
     * @generated from protobuf field: uint64 latest_height = 3
     */
    latestHeight: bigint;
}
/**
 * @generated from protobuf message mito_api.StreamTransfersRequest
 */
export interface StreamTransfersRequest {
    /**
     * @generated from protobuf field: optional string vault = 1
     */
    vault?: string;
    /**
     * @generated from protobuf field: optional string account = 2
     */
    account?: string;
}
/**
 * @generated from protobuf message mito_api.StreamTransfersResponse
 */
export interface StreamTransfersResponse {
    /**
     * @generated from protobuf field: mito_api.Transfer data = 1
     */
    data?: Transfer;
    /**
     * Update type
     *
     * @generated from protobuf field: optional string op_type = 2
     */
    opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamVaultRequest
 */
export interface StreamVaultRequest {
    /**
     * @generated from protobuf field: string vault = 1
     */
    vault: string;
}
/**
 * @generated from protobuf message mito_api.StreamVaultResponse
 */
export interface StreamVaultResponse {
    /**
     * @generated from protobuf field: mito_api.Vault data = 1
     */
    data?: Vault;
    /**
     * Update type
     *
     * @generated from protobuf field: optional string op_type = 2
     */
    opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamHolderSubscriptionRequest
 */
export interface StreamHolderSubscriptionRequest {
    /**
     * @generated from protobuf field: string holder_address = 1
     */
    holderAddress: string;
    /**
     * @generated from protobuf field: optional string vault_address = 2
     */
    vaultAddress?: string;
    /**
     * @generated from protobuf field: string staking_contract_address = 3
     */
    stakingContractAddress: string;
}
/**
 * @generated from protobuf message mito_api.StreamHolderSubscriptionResponse
 */
export interface StreamHolderSubscriptionResponse {
    /**
     * @generated from protobuf field: mito_api.Subscription data = 1
     */
    data?: Subscription;
    /**
     * Update type
     *
     * @generated from protobuf field: optional string op_type = 2
     */
    opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamStakingRewardByAccountRequest
 */
export interface StreamStakingRewardByAccountRequest {
    /**
     * @generated from protobuf field: string staker = 1
     */
    staker: string;
    /**
     * @generated from protobuf field: string staking_contract_address = 2
     */
    stakingContractAddress: string;
}
/**
 * @generated from protobuf message mito_api.StreamStakingRewardByAccountResponse
 */
export interface StreamStakingRewardByAccountResponse {
    /**
     * @generated from protobuf field: mito_api.StakingReward data = 1
     */
    data?: StakingReward;
    /**
     * Update type
     *
     * @generated from protobuf field: optional string op_type = 2
     */
    opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamHistoricalStakingRequest
 */
export interface StreamHistoricalStakingRequest {
    /**
     * @generated from protobuf field: string staker = 1
     */
    staker: string;
    /**
     * @generated from protobuf field: string staking_contract_address = 2
     */
    stakingContractAddress: string;
}
/**
 * @generated from protobuf message mito_api.StreamHistoricalStakingResponse
 */
export interface StreamHistoricalStakingResponse {
    /**
     * @generated from protobuf field: mito_api.StakingActivity data = 1
     */
    data?: StakingActivity;
    /**
     * Update type
     *
     * @generated from protobuf field: optional string op_type = 2
     */
    opType?: string;
}
/**
 * @generated from protobuf message mito_api.HealthRequest
 */
export interface HealthRequest {
}
/**
 * @generated from protobuf message mito_api.HealthResponse
 */
export interface HealthResponse {
    /**
     * @generated from protobuf field: string version = 1
     */
    version: string;
    /**
     * @generated from protobuf field: string commit = 2
     */
    commit: string;
    /**
     * @generated from protobuf field: sint64 lastest_synced_block = 3
     */
    lastestSyncedBlock: bigint;
    /**
     * @generated from protobuf field: sint64 chain_height = 4
     */
    chainHeight: bigint;
    /**
     * @generated from protobuf field: string status = 5
     */
    status: string;
    /**
     * @generated from protobuf field: sint32 block_diff_threshold = 6
     */
    blockDiffThreshold: number;
}
/**
 * @generated from protobuf message mito_api.ExecutionRequest
 */
export interface ExecutionRequest {
    /**
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
}
/**
 * @generated from protobuf message mito_api.ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * @generated from protobuf field: sint64 current_block = 2
     */
    currentBlock: bigint;
    /**
     * @generated from protobuf field: sint64 last_executed_block = 3
     */
    lastExecutedBlock: bigint;
    /**
     * @generated from protobuf field: sint64 last_error_block = 4
     */
    lastErrorBlock: bigint;
    /**
     * @generated from protobuf field: repeated mito_api.ExecutionLog execution_logs = 5
     */
    executionLogs: ExecutionLog[];
    /**
     * @generated from protobuf field: mito_api.ExecutionLog last_error_log = 6
     */
    lastErrorLog?: ExecutionLog;
}
/**
 * @generated from protobuf message mito_api.ExecutionLog
 */
export interface ExecutionLog {
    /**
     * @generated from protobuf field: sint64 block = 1
     */
    block: bigint;
    /**
     * @generated from protobuf field: string response = 2
     */
    response: string;
    /**
     * @generated from protobuf field: string error = 3
     */
    error: string;
}
/**
 * @generated from protobuf message mito_api.MissionsRequest
 */
export interface MissionsRequest {
    /**
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message mito_api.MissionsResponse
 */
export interface MissionsResponse {
    /**
     * @generated from protobuf field: repeated mito_api.Mission data = 1
     */
    data: Mission[];
    /**
     * @generated from protobuf field: optional sint64 rank = 2
     */
    rank?: bigint;
}
/**
 * @generated from protobuf message mito_api.Mission
 */
export interface Mission {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: sint64 points = 2
     */
    points: bigint;
    /**
     * @generated from protobuf field: bool completed = 3
     */
    completed: boolean;
    /**
     * @generated from protobuf field: sint64 accrued_points = 4
     */
    accruedPoints: bigint;
    /**
     * @generated from protobuf field: sint64 updated_at = 5
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: double progress = 6
     */
    progress: number;
    /**
     * @generated from protobuf field: double expected = 7
     */
    expected: number;
}
/**
 * @generated from protobuf message mito_api.MissionLeaderboardRequest
 */
export interface MissionLeaderboardRequest {
    /**
     * @generated from protobuf field: optional string user_address = 1
     */
    userAddress?: string;
}
/**
 * @generated from protobuf message mito_api.MissionLeaderboardResponse
 */
export interface MissionLeaderboardResponse {
    /**
     * @generated from protobuf field: repeated mito_api.MissionLeaderboardEntry data = 1
     */
    data: MissionLeaderboardEntry[];
    /**
     * @generated from protobuf field: sint64 updated_at = 2
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: optional sint64 user_rank = 3
     */
    userRank?: bigint;
}
/**
 * @generated from protobuf message mito_api.MissionLeaderboardEntry
 */
export interface MissionLeaderboardEntry {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: sint64 accrued_points = 2
     */
    accruedPoints: bigint;
}
/**
 * @generated from protobuf message mito_api.ListIDOsRequest
 */
export interface ListIDOsRequest {
    /**
     * @generated from protobuf field: optional string status = 1
     */
    status?: string;
    /**
     * @generated from protobuf field: optional sint32 limit = 2
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional sint32 to_number = 3
     */
    toNumber?: number;
    /**
     * @generated from protobuf field: optional string account_address = 4
     */
    accountAddress?: string;
    /**
     * @generated from protobuf field: optional string owner_address = 5
     */
    ownerAddress?: string;
}
/**
 * @generated from protobuf message mito_api.ListIDOsResponse
 */
export interface ListIDOsResponse {
    /**
     * @generated from protobuf field: repeated mito_api.IDO idos = 1
     */
    idos: IDO[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.IDO
 */
export interface IDO {
    /**
     * @generated from protobuf field: sint64 start_time = 1
     */
    startTime: bigint;
    /**
     * @generated from protobuf field: sint64 end_time = 2
     */
    endTime: bigint;
    /**
     * @generated from protobuf field: string owner = 3
     */
    owner: string;
    /**
     * @generated from protobuf field: string status = 4
     */
    status: string;
    /**
     * @generated from protobuf field: mito_api.TokenInfo token_info = 5
     */
    tokenInfo?: TokenInfo;
    /**
     * @generated from protobuf field: string project_token_amount = 6
     */
    projectTokenAmount: string;
    /**
     * @generated from protobuf field: string quote_denom = 7
     */
    quoteDenom: string;
    /**
     * @generated from protobuf field: string target_amount_in_quote_denom = 8
     */
    targetAmountInQuoteDenom: string;
    /**
     * @generated from protobuf field: string target_amount_in_usd = 9
     */
    targetAmountInUsd: string;
    /**
     * @generated from protobuf field: string cap_per_address = 10
     */
    capPerAddress: string;
    /**
     * @generated from protobuf field: string contract_address = 11
     */
    contractAddress: string;
    /**
     * @generated from protobuf field: string subscribed_amount = 12
     */
    subscribedAmount: string;
    /**
     * @generated from protobuf field: double token_price = 13
     */
    tokenPrice: number;
    /**
     * @generated from protobuf field: bool is_account_white_listed = 14
     */
    isAccountWhiteListed: boolean;
    /**
     * @generated from protobuf field: string name = 15
     */
    name: string;
    /**
     * @generated from protobuf field: repeated mito_api.IDOProgress progress = 16
     */
    progress: IDOProgress[];
    /**
     * @generated from protobuf field: repeated mito_api.ArrayOfString stake_to_subscription = 17
     */
    stakeToSubscription: ArrayOfString[];
    /**
     * @generated from protobuf field: sint64 second_before_start_to_set_quote_price = 18
     */
    secondBeforeStartToSetQuotePrice: bigint;
    /**
     * @generated from protobuf field: bool use_whitelist = 19
     */
    useWhitelist: boolean;
    /**
     * @generated from protobuf field: string market_id = 20
     */
    marketId: string;
    /**
     * @generated from protobuf field: string vault_address = 21
     */
    vaultAddress: string;
    /**
     * @generated from protobuf field: bool is_launch_with_vault = 22
     */
    isLaunchWithVault: boolean;
    /**
     * @generated from protobuf field: bool is_vesting_schedule_enabled = 23
     */
    isVestingScheduleEnabled: boolean;
    /**
     * @generated from protobuf field: mito_api.InitParams init_params = 24
     */
    initParams?: InitParams;
    /**
     * @generated from protobuf field: string project_description = 25
     */
    projectDescription: string;
    /**
     * @generated from protobuf field: bool is_permissionless = 26
     */
    isPermissionless: boolean;
}
/**
 * @generated from protobuf message mito_api.TokenInfo
 */
export interface TokenInfo {
    /**
     * @generated from protobuf field: string denom = 1
     */
    denom: string;
    /**
     * @generated from protobuf field: string supply = 2
     */
    supply: string;
    /**
     * @generated from protobuf field: string symbol = 3
     */
    symbol: string;
    /**
     * @generated from protobuf field: sint32 decimal = 4
     */
    decimal: number;
    /**
     * @generated from protobuf field: string logo_url = 5
     */
    logoUrl: string;
}
/**
 * @generated from protobuf message mito_api.IDOProgress
 */
export interface IDOProgress {
    /**
     * @generated from protobuf field: string status = 1
     */
    status: string;
    /**
     * @generated from protobuf field: sint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message mito_api.ArrayOfString
 */
export interface ArrayOfString {
    /**
     * @generated from protobuf field: repeated string field = 1
     */
    field: string[];
}
/**
 * @generated from protobuf message mito_api.InitParams
 */
export interface InitParams {
    /**
     * @generated from protobuf field: mito_api.VestingConfigMap vesting_config = 1
     */
    vestingConfig?: VestingConfigMap;
}
/**
 * @generated from protobuf message mito_api.VestingConfigMap
 */
export interface VestingConfigMap {
    /**
     * @generated from protobuf field: mito_api.VestingConfig project_owner_quote = 1
     */
    projectOwnerQuote?: VestingConfig;
    /**
     * @generated from protobuf field: mito_api.VestingConfig project_owner_lp_tokens = 2
     */
    projectOwnerLpTokens?: VestingConfig;
    /**
     * @generated from protobuf field: mito_api.VestingConfig users_project_token = 3
     */
    usersProjectToken?: VestingConfig;
}
/**
 * @generated from protobuf message mito_api.VestingConfig
 */
export interface VestingConfig {
    /**
     * @generated from protobuf field: optional sint64 vesting_duration_seconds = 1
     */
    vestingDurationSeconds?: bigint;
    /**
     * @generated from protobuf field: optional sint64 vesting_start_delay_seconds = 2
     */
    vestingStartDelaySeconds?: bigint;
    /**
     * @generated from protobuf field: optional string schedule = 3
     */
    schedule?: string;
}
/**
 * @generated from protobuf message mito_api.GetIDORequest
 */
export interface GetIDORequest {
    /**
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * @generated from protobuf field: optional string account_address = 2
     */
    accountAddress?: string;
}
/**
 * @generated from protobuf message mito_api.GetIDOResponse
 */
export interface GetIDOResponse {
    /**
     * @generated from protobuf field: mito_api.IDO ido = 1
     */
    ido?: IDO;
}
/**
 * @generated from protobuf message mito_api.GetIDOSubscribersRequest
 */
export interface GetIDOSubscribersRequest {
    /**
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * @generated from protobuf field: optional sint32 limit = 2
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional sint32 skip = 3
     */
    skip?: number;
    /**
     * @generated from protobuf field: optional string sort_by = 4
     */
    sortBy?: string;
}
/**
 * @generated from protobuf message mito_api.GetIDOSubscribersResponse
 */
export interface GetIDOSubscribersResponse {
    /**
     * @generated from protobuf field: repeated mito_api.IDOSubscriber subscribers = 1
     */
    subscribers: IDOSubscriber[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
    /**
     * @generated from protobuf field: mito_api.TokenInfo token_info = 3
     */
    tokenInfo?: TokenInfo;
    /**
     * @generated from protobuf field: string quote_denom = 4
     */
    quoteDenom: string;
    /**
     * @generated from protobuf field: string market_id = 5
     */
    marketId: string;
}
/**
 * @generated from protobuf message mito_api.IDOSubscriber
 */
export interface IDOSubscriber {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: mito_api.Coin subscribed_coin = 2
     */
    subscribedCoin?: Coin;
    /**
     * @generated from protobuf field: sint64 last_subscribe_time = 3
     */
    lastSubscribeTime: bigint;
    /**
     * @generated from protobuf field: mito_api.Coin estimate_token_received = 4
     */
    estimateTokenReceived?: Coin;
    /**
     * @generated from protobuf field: mito_api.Coin estimate_lp_amount = 5
     */
    estimateLpAmount?: Coin;
    /**
     * @generated from protobuf field: mito_api.Coin estimate_refund_amount = 6
     */
    estimateRefundAmount?: Coin;
    /**
     * @generated from protobuf field: sint64 created_at = 7
     */
    createdAt: bigint;
}
/**
 * @generated from protobuf message mito_api.GetIDOSubscriptionRequest
 */
export interface GetIDOSubscriptionRequest {
    /**
     * Ido contract address
     *
     * @generated from protobuf field: string contract_address = 1
     */
    contractAddress: string;
    /**
     * Subscriber account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message mito_api.GetIDOSubscriptionResponse
 */
export interface GetIDOSubscriptionResponse {
    /**
     * @generated from protobuf field: mito_api.IDOSubscription subscription = 1
     */
    subscription?: IDOSubscription;
}
/**
 * @generated from protobuf message mito_api.IDOSubscription
 */
export interface IDOSubscription {
    /**
     * @generated from protobuf field: mito_api.Coin max_subscription_coin = 1
     */
    maxSubscriptionCoin?: Coin;
    /**
     * @generated from protobuf field: string committed_amount = 2
     */
    committedAmount: string;
    /**
     * @generated from protobuf field: double price = 3
     */
    price: number;
    /**
     * @generated from protobuf field: repeated mito_api.Coin claimable_coins = 4
     */
    claimableCoins: Coin[];
    /**
     * @generated from protobuf field: sint64 updated_at = 5
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: bool reward_claimed = 6
     */
    rewardClaimed: boolean;
    /**
     * @generated from protobuf field: mito_api.TokenInfo token_info = 7
     */
    tokenInfo?: TokenInfo;
    /**
     * @generated from protobuf field: string quote_denom = 8
     */
    quoteDenom: string;
    /**
     * @generated from protobuf field: string staked_amount = 9
     */
    stakedAmount: string;
    /**
     * @generated from protobuf field: optional string claim_tx_hash = 10
     */
    claimTxHash?: string;
    /**
     * @generated from protobuf field: repeated mito_api.Coin owner_claimable_coins = 11
     */
    ownerClaimableCoins: Coin[];
    /**
     * @generated from protobuf field: string market_id = 12
     */
    marketId: string;
    /**
     * @generated from protobuf field: string weight = 13
     */
    weight: string;
    /**
     * @generated from protobuf field: mito_api.IDOClaimedCoins claimed_coins = 14
     */
    claimedCoins?: IDOClaimedCoins;
}
/**
 * @generated from protobuf message mito_api.IDOClaimedCoins
 */
export interface IDOClaimedCoins {
    /**
     * @generated from protobuf field: repeated mito_api.Coin claimed_coins = 1
     */
    claimedCoins: Coin[];
    /**
     * @generated from protobuf field: sint64 updated_at = 2
     */
    updatedAt: bigint;
}
/**
 * @generated from protobuf message mito_api.GetIDOActivitiesRequest
 */
export interface GetIDOActivitiesRequest {
    /**
     * @generated from protobuf field: optional string contract_address = 1
     */
    contractAddress?: string;
    /**
     * @generated from protobuf field: optional string account_address = 2
     */
    accountAddress?: string;
    /**
     * @generated from protobuf field: optional sint32 limit = 3
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional string to_number = 4
     */
    toNumber?: string;
}
/**
 * @generated from protobuf message mito_api.GetIDOActivitiesResponse
 */
export interface GetIDOActivitiesResponse {
    /**
     * @generated from protobuf field: repeated mito_api.IDOSubscriptionActivity activities = 1
     */
    activities: IDOSubscriptionActivity[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.IDOSubscriptionActivity
 */
export interface IDOSubscriptionActivity {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: mito_api.Coin subscribed_coin = 2
     */
    subscribedCoin?: Coin;
    /**
     * @generated from protobuf field: double usd_value = 3
     */
    usdValue: number;
    /**
     * @generated from protobuf field: sint64 timestamp = 4
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: string tx_hash = 5
     */
    txHash: string;
}
/**
 * @generated from protobuf message mito_api.GetWhitelistRequest
 */
export interface GetWhitelistRequest {
    /**
     * @generated from protobuf field: string ido_address = 1
     */
    idoAddress: string;
    /**
     * @generated from protobuf field: optional sint32 skip = 2
     */
    skip?: number;
    /**
     * @generated from protobuf field: optional sint32 limit = 3
     */
    limit?: number;
}
/**
 * @generated from protobuf message mito_api.GetWhitelistResponse
 */
export interface GetWhitelistResponse {
    /**
     * @generated from protobuf field: optional string ido_address = 1
     */
    idoAddress?: string;
    /**
     * @generated from protobuf field: repeated mito_api.WhitelistAccount accounts = 2
     */
    accounts: WhitelistAccount[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 3
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.WhitelistAccount
 */
export interface WhitelistAccount {
    /**
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * @generated from protobuf field: sint64 updated_at = 2
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: string weight = 3
     */
    weight: string;
}
/**
 * @generated from protobuf message mito_api.TokenMetadataRequest
 */
export interface TokenMetadataRequest {
}
/**
 * @generated from protobuf message mito_api.TokenMetadataResponse
 */
export interface TokenMetadataResponse {
    /**
     * @generated from protobuf field: string data = 1
     */
    data: string;
}
/**
 * @generated from protobuf message mito_api.GetClaimReferencesRequest
 */
export interface GetClaimReferencesRequest {
    /**
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * @generated from protobuf field: string ido_address = 2
     */
    idoAddress: string;
    /**
     * @generated from protobuf field: optional sint32 skip = 3
     */
    skip?: number;
    /**
     * @generated from protobuf field: optional sint32 limit = 4
     */
    limit?: number;
}
/**
 * @generated from protobuf message mito_api.GetClaimReferencesResponse
 */
export interface GetClaimReferencesResponse {
    /**
     * @generated from protobuf field: repeated mito_api.ClaimReference claim_references = 1
     */
    claimReferences: ClaimReference[];
    /**
     * @generated from protobuf field: mito_api.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message mito_api.ClaimReference
 */
export interface ClaimReference {
    /**
     * @generated from protobuf field: string account_address = 1
     */
    accountAddress: string;
    /**
     * @generated from protobuf field: string cw_contract_address = 2
     */
    cwContractAddress: string;
    /**
     * @generated from protobuf field: string ido_contract_address = 3
     */
    idoContractAddress: string;
    /**
     * @generated from protobuf field: string start_vesting_time = 4
     */
    startVestingTime: string;
    /**
     * @generated from protobuf field: sint64 vesting_duration_seconds = 5
     */
    vestingDurationSeconds: bigint;
    /**
     * @generated from protobuf field: sint64 updated_at = 6
     */
    updatedAt: bigint;
    /**
     * @generated from protobuf field: string claimed_amount = 7
     */
    claimedAmount: string;
    /**
     * @generated from protobuf field: string claimable_amount = 8
     */
    claimableAmount: string;
    /**
     * @generated from protobuf field: string denom = 9
     */
    denom: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultsRequest$Type extends MessageType<GetVaultsRequest> {
    constructor() {
        super("mito_api.GetVaultsRequest", [
            { no: 1, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "page_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "code_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetVaultsRequest>): GetVaultsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetVaultsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultsRequest): GetVaultsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* optional uint32 page_index */ 2:
                    message.pageIndex = reader.uint32();
                    break;
                case /* optional uint64 code_id */ 3:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 limit = 1; */
        if (message.limit !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* optional uint32 page_index = 2; */
        if (message.pageIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.pageIndex);
        /* optional uint64 code_id = 3; */
        if (message.codeId !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.codeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetVaultsRequest
 */
export const GetVaultsRequest = new GetVaultsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultsResponse$Type extends MessageType<GetVaultsResponse> {
    constructor() {
        super("mito_api.GetVaultsResponse", [
            { no: 1, name: "vaults", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Vault },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetVaultsResponse>): GetVaultsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaults = [];
        if (value !== undefined)
            reflectionMergePartial<GetVaultsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultsResponse): GetVaultsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.Vault vaults */ 1:
                    message.vaults.push(Vault.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.Vault vaults = 1; */
        for (let i = 0; i < message.vaults.length; i++)
            Vault.internalBinaryWrite(message.vaults[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetVaultsResponse
 */
export const GetVaultsResponse = new GetVaultsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vault$Type extends MessageType<Vault> {
    constructor() {
        super("mito_api.Vault", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "vault_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "current_tvl", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "profits", kind: "message", T: () => Changes },
            { no: 7, name: "updated_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "vault_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "lp_token_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "subaccount_info", kind: "message", T: () => SubaccountBalance },
            { no: 11, name: "master_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "total_lp_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "slug", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "notional_value_cap", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "tvl_changes", kind: "message", T: () => Changes },
            { no: 17, name: "apy", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "apy7_d", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 19, name: "apy7_d_fq", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 20, name: "apyue", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 21, name: "apy_v3", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 22, name: "registration_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Vault>): Vault {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        message.codeId = 0n;
        message.vaultName = "";
        message.marketId = "";
        message.currentTvl = 0;
        message.updatedAt = 0n;
        message.vaultType = "";
        message.lpTokenPrice = 0;
        message.masterContractAddress = "";
        message.totalLpAmount = "";
        message.slug = "";
        message.createdAt = 0n;
        message.notionalValueCap = "";
        message.apy = 0;
        message.apy7D = 0;
        message.apy7DFq = 0;
        message.apyue = 0;
        message.apyV3 = 0;
        message.registrationMode = "";
        if (value !== undefined)
            reflectionMergePartial<Vault>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vault): Vault {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* uint64 code_id */ 2:
                    message.codeId = reader.uint64().toBigInt();
                    break;
                case /* string vault_name */ 3:
                    message.vaultName = reader.string();
                    break;
                case /* string market_id */ 4:
                    message.marketId = reader.string();
                    break;
                case /* double current_tvl */ 5:
                    message.currentTvl = reader.double();
                    break;
                case /* mito_api.Changes profits */ 6:
                    message.profits = Changes.internalBinaryRead(reader, reader.uint32(), options, message.profits);
                    break;
                case /* uint64 updated_at */ 7:
                    message.updatedAt = reader.uint64().toBigInt();
                    break;
                case /* string vault_type */ 8:
                    message.vaultType = reader.string();
                    break;
                case /* double lp_token_price */ 9:
                    message.lpTokenPrice = reader.double();
                    break;
                case /* mito_api.SubaccountBalance subaccount_info */ 10:
                    message.subaccountInfo = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.subaccountInfo);
                    break;
                case /* string master_contract_address */ 11:
                    message.masterContractAddress = reader.string();
                    break;
                case /* string total_lp_amount */ 12:
                    message.totalLpAmount = reader.string();
                    break;
                case /* string slug */ 13:
                    message.slug = reader.string();
                    break;
                case /* sint64 created_at */ 14:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* string notional_value_cap */ 15:
                    message.notionalValueCap = reader.string();
                    break;
                case /* mito_api.Changes tvl_changes */ 16:
                    message.tvlChanges = Changes.internalBinaryRead(reader, reader.uint32(), options, message.tvlChanges);
                    break;
                case /* double apy */ 17:
                    message.apy = reader.double();
                    break;
                case /* double apy7_d */ 18:
                    message.apy7D = reader.double();
                    break;
                case /* double apy7_d_fq */ 19:
                    message.apy7DFq = reader.double();
                    break;
                case /* double apyue */ 20:
                    message.apyue = reader.double();
                    break;
                case /* double apy_v3 */ 21:
                    message.apyV3 = reader.double();
                    break;
                case /* string registration_mode */ 22:
                    message.registrationMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vault, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* uint64 code_id = 2; */
        if (message.codeId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.codeId);
        /* string vault_name = 3; */
        if (message.vaultName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.vaultName);
        /* string market_id = 4; */
        if (message.marketId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.marketId);
        /* double current_tvl = 5; */
        if (message.currentTvl !== 0)
            writer.tag(5, WireType.Bit64).double(message.currentTvl);
        /* mito_api.Changes profits = 6; */
        if (message.profits)
            Changes.internalBinaryWrite(message.profits, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 updated_at = 7; */
        if (message.updatedAt !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.updatedAt);
        /* string vault_type = 8; */
        if (message.vaultType !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.vaultType);
        /* double lp_token_price = 9; */
        if (message.lpTokenPrice !== 0)
            writer.tag(9, WireType.Bit64).double(message.lpTokenPrice);
        /* mito_api.SubaccountBalance subaccount_info = 10; */
        if (message.subaccountInfo)
            SubaccountBalance.internalBinaryWrite(message.subaccountInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string master_contract_address = 11; */
        if (message.masterContractAddress !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.masterContractAddress);
        /* string total_lp_amount = 12; */
        if (message.totalLpAmount !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.totalLpAmount);
        /* string slug = 13; */
        if (message.slug !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.slug);
        /* sint64 created_at = 14; */
        if (message.createdAt !== 0n)
            writer.tag(14, WireType.Varint).sint64(message.createdAt);
        /* string notional_value_cap = 15; */
        if (message.notionalValueCap !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.notionalValueCap);
        /* mito_api.Changes tvl_changes = 16; */
        if (message.tvlChanges)
            Changes.internalBinaryWrite(message.tvlChanges, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* double apy = 17; */
        if (message.apy !== 0)
            writer.tag(17, WireType.Bit64).double(message.apy);
        /* double apy7_d = 18; */
        if (message.apy7D !== 0)
            writer.tag(18, WireType.Bit64).double(message.apy7D);
        /* double apy7_d_fq = 19; */
        if (message.apy7DFq !== 0)
            writer.tag(19, WireType.Bit64).double(message.apy7DFq);
        /* double apyue = 20; */
        if (message.apyue !== 0)
            writer.tag(20, WireType.Bit64).double(message.apyue);
        /* double apy_v3 = 21; */
        if (message.apyV3 !== 0)
            writer.tag(21, WireType.Bit64).double(message.apyV3);
        /* string registration_mode = 22; */
        if (message.registrationMode !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.registrationMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Vault
 */
export const Vault = new Vault$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Changes$Type extends MessageType<Changes> {
    constructor() {
        super("mito_api.Changes", [
            { no: 1, name: "all_time_change", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "three_months_change", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "one_month_change", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "one_day_change", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "one_week_change", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "one_year_change", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "three_years_change", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "six_months_change", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Changes>): Changes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allTimeChange = 0;
        if (value !== undefined)
            reflectionMergePartial<Changes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Changes): Changes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double all_time_change */ 1:
                    message.allTimeChange = reader.double();
                    break;
                case /* optional double three_months_change */ 2:
                    message.threeMonthsChange = reader.double();
                    break;
                case /* optional double one_month_change */ 3:
                    message.oneMonthChange = reader.double();
                    break;
                case /* optional double one_day_change */ 4:
                    message.oneDayChange = reader.double();
                    break;
                case /* optional double one_week_change */ 5:
                    message.oneWeekChange = reader.double();
                    break;
                case /* optional double one_year_change */ 6:
                    message.oneYearChange = reader.double();
                    break;
                case /* optional double three_years_change */ 7:
                    message.threeYearsChange = reader.double();
                    break;
                case /* optional double six_months_change */ 8:
                    message.sixMonthsChange = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Changes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double all_time_change = 1; */
        if (message.allTimeChange !== 0)
            writer.tag(1, WireType.Bit64).double(message.allTimeChange);
        /* optional double three_months_change = 2; */
        if (message.threeMonthsChange !== undefined)
            writer.tag(2, WireType.Bit64).double(message.threeMonthsChange);
        /* optional double one_month_change = 3; */
        if (message.oneMonthChange !== undefined)
            writer.tag(3, WireType.Bit64).double(message.oneMonthChange);
        /* optional double one_day_change = 4; */
        if (message.oneDayChange !== undefined)
            writer.tag(4, WireType.Bit64).double(message.oneDayChange);
        /* optional double one_week_change = 5; */
        if (message.oneWeekChange !== undefined)
            writer.tag(5, WireType.Bit64).double(message.oneWeekChange);
        /* optional double one_year_change = 6; */
        if (message.oneYearChange !== undefined)
            writer.tag(6, WireType.Bit64).double(message.oneYearChange);
        /* optional double three_years_change = 7; */
        if (message.threeYearsChange !== undefined)
            writer.tag(7, WireType.Bit64).double(message.threeYearsChange);
        /* optional double six_months_change = 8; */
        if (message.sixMonthsChange !== undefined)
            writer.tag(8, WireType.Bit64).double(message.sixMonthsChange);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Changes
 */
export const Changes = new Changes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubaccountBalance$Type extends MessageType<SubaccountBalance> {
    constructor() {
        super("mito_api.SubaccountBalance", [
            { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DenomBalance }
        ]);
    }
    create(value?: PartialMessage<SubaccountBalance>): SubaccountBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subaccountId = "";
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<SubaccountBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubaccountBalance): SubaccountBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subaccount_id */ 1:
                    message.subaccountId = reader.string();
                    break;
                case /* repeated mito_api.DenomBalance balances */ 2:
                    message.balances.push(DenomBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubaccountBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subaccount_id = 1; */
        if (message.subaccountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
        /* repeated mito_api.DenomBalance balances = 2; */
        for (let i = 0; i < message.balances.length; i++)
            DenomBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.SubaccountBalance
 */
export const SubaccountBalance = new SubaccountBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenomBalance$Type extends MessageType<DenomBalance> {
    constructor() {
        super("mito_api.DenomBalance", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "updated_at", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "source", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DenomBalance>): DenomBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.totalBalance = "";
        if (value !== undefined)
            reflectionMergePartial<DenomBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenomBalance): DenomBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string total_balance */ 2:
                    message.totalBalance = reader.string();
                    break;
                case /* optional string price */ 3:
                    message.price = reader.string();
                    break;
                case /* optional sint64 updated_at */ 4:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* optional string source */ 5:
                    message.source = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenomBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string total_balance = 2; */
        if (message.totalBalance !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.totalBalance);
        /* optional string price = 3; */
        if (message.price !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.price);
        /* optional sint64 updated_at = 4; */
        if (message.updatedAt !== undefined)
            writer.tag(4, WireType.Varint).sint64(message.updatedAt);
        /* optional string source = 5; */
        if (message.source !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.source);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.DenomBalance
 */
export const DenomBalance = new DenomBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pagination$Type extends MessageType<Pagination> {
    constructor() {
        super("mito_api.Pagination", [
            { no: 1, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Pagination>): Pagination {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0;
        if (value !== undefined)
            reflectionMergePartial<Pagination>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pagination): Pagination {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pagination, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total = 1; */
        if (message.total !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Pagination
 */
export const Pagination = new Pagination$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultRequest$Type extends MessageType<GetVaultRequest> {
    constructor() {
        super("mito_api.GetVaultRequest", [
            { no: 1, name: "contract_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "slug", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetVaultRequest>): GetVaultRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetVaultRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultRequest): GetVaultRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* optional string slug */ 2:
                    message.slug = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string contract_address = 1; */
        if (message.contractAddress !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* optional string slug = 2; */
        if (message.slug !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.slug);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetVaultRequest
 */
export const GetVaultRequest = new GetVaultRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVaultResponse$Type extends MessageType<GetVaultResponse> {
    constructor() {
        super("mito_api.GetVaultResponse", [
            { no: 1, name: "vault", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Vault }
        ]);
    }
    create(value?: PartialMessage<GetVaultResponse>): GetVaultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vault = [];
        if (value !== undefined)
            reflectionMergePartial<GetVaultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVaultResponse): GetVaultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.Vault vault */ 1:
                    message.vault.push(Vault.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVaultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.Vault vault = 1; */
        for (let i = 0; i < message.vault.length; i++)
            Vault.internalBinaryWrite(message.vault[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetVaultResponse
 */
export const GetVaultResponse = new GetVaultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LPTokenPriceChartRequest$Type extends MessageType<LPTokenPriceChartRequest> {
    constructor() {
        super("mito_api.LPTokenPriceChartRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "to_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LPTokenPriceChartRequest>): LPTokenPriceChartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        if (value !== undefined)
            reflectionMergePartial<LPTokenPriceChartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LPTokenPriceChartRequest): LPTokenPriceChartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* optional uint64 from_time */ 2:
                    message.fromTime = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 to_time */ 3:
                    message.toTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LPTokenPriceChartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* optional uint64 from_time = 2; */
        if (message.fromTime !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.fromTime);
        /* optional uint64 to_time = 3; */
        if (message.toTime !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.toTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LPTokenPriceChartRequest
 */
export const LPTokenPriceChartRequest = new LPTokenPriceChartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LPTokenPriceChartResponse$Type extends MessageType<LPTokenPriceChartResponse> {
    constructor() {
        super("mito_api.LPTokenPriceChartResponse", [
            { no: 1, name: "prices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceSnapshot }
        ]);
    }
    create(value?: PartialMessage<LPTokenPriceChartResponse>): LPTokenPriceChartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prices = [];
        if (value !== undefined)
            reflectionMergePartial<LPTokenPriceChartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LPTokenPriceChartResponse): LPTokenPriceChartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.PriceSnapshot prices */ 1:
                    message.prices.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LPTokenPriceChartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.PriceSnapshot prices = 1; */
        for (let i = 0; i < message.prices.length; i++)
            PriceSnapshot.internalBinaryWrite(message.prices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LPTokenPriceChartResponse
 */
export const LPTokenPriceChartResponse = new LPTokenPriceChartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceSnapshot$Type extends MessageType<PriceSnapshot> {
    constructor() {
        super("mito_api.PriceSnapshot", [
            { no: 1, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "updated_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PriceSnapshot>): PriceSnapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = 0;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<PriceSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceSnapshot): PriceSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double price */ 1:
                    message.price = reader.double();
                    break;
                case /* uint64 updated_at */ 2:
                    message.updatedAt = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double price = 1; */
        if (message.price !== 0)
            writer.tag(1, WireType.Bit64).double(message.price);
        /* uint64 updated_at = 2; */
        if (message.updatedAt !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.PriceSnapshot
 */
export const PriceSnapshot = new PriceSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TVLChartRequest$Type extends MessageType<TVLChartRequest> {
    constructor() {
        super("mito_api.TVLChartRequest", [
            { no: 1, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "to_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TVLChartRequest>): TVLChartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        if (value !== undefined)
            reflectionMergePartial<TVLChartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TVLChartRequest): TVLChartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_address */ 1:
                    message.vaultAddress = reader.string();
                    break;
                case /* optional uint64 from_time */ 2:
                    message.fromTime = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 to_time */ 3:
                    message.toTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TVLChartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_address = 1; */
        if (message.vaultAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
        /* optional uint64 from_time = 2; */
        if (message.fromTime !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.fromTime);
        /* optional uint64 to_time = 3; */
        if (message.toTime !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.toTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.TVLChartRequest
 */
export const TVLChartRequest = new TVLChartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TVLChartResponse$Type extends MessageType<TVLChartResponse> {
    constructor() {
        super("mito_api.TVLChartResponse", [
            { no: 1, name: "prices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceSnapshot }
        ]);
    }
    create(value?: PartialMessage<TVLChartResponse>): TVLChartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prices = [];
        if (value !== undefined)
            reflectionMergePartial<TVLChartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TVLChartResponse): TVLChartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.PriceSnapshot prices */ 1:
                    message.prices.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TVLChartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.PriceSnapshot prices = 1; */
        for (let i = 0; i < message.prices.length; i++)
            PriceSnapshot.internalBinaryWrite(message.prices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.TVLChartResponse
 */
export const TVLChartResponse = new TVLChartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VaultsByHolderAddressRequest$Type extends MessageType<VaultsByHolderAddressRequest> {
    constructor() {
        super("mito_api.VaultsByHolderAddressRequest", [
            { no: 1, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "page_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "holder_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "vault_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<VaultsByHolderAddressRequest>): VaultsByHolderAddressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.holderAddress = "";
        if (value !== undefined)
            reflectionMergePartial<VaultsByHolderAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VaultsByHolderAddressRequest): VaultsByHolderAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* optional uint32 page_index */ 2:
                    message.pageIndex = reader.uint32();
                    break;
                case /* string holder_address */ 3:
                    message.holderAddress = reader.string();
                    break;
                case /* optional string vault_address */ 4:
                    message.vaultAddress = reader.string();
                    break;
                case /* optional sint32 skip */ 5:
                    message.skip = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VaultsByHolderAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 limit = 1; */
        if (message.limit !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* optional uint32 page_index = 2; */
        if (message.pageIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.pageIndex);
        /* string holder_address = 3; */
        if (message.holderAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.holderAddress);
        /* optional string vault_address = 4; */
        if (message.vaultAddress !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.vaultAddress);
        /* optional sint32 skip = 5; */
        if (message.skip !== undefined)
            writer.tag(5, WireType.Varint).sint32(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.VaultsByHolderAddressRequest
 */
export const VaultsByHolderAddressRequest = new VaultsByHolderAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VaultsByHolderAddressResponse$Type extends MessageType<VaultsByHolderAddressResponse> {
    constructor() {
        super("mito_api.VaultsByHolderAddressResponse", [
            { no: 1, name: "subscriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Subscription },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<VaultsByHolderAddressResponse>): VaultsByHolderAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptions = [];
        if (value !== undefined)
            reflectionMergePartial<VaultsByHolderAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VaultsByHolderAddressResponse): VaultsByHolderAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.Subscription subscriptions */ 1:
                    message.subscriptions.push(Subscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VaultsByHolderAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.Subscription subscriptions = 1; */
        for (let i = 0; i < message.subscriptions.length; i++)
            Subscription.internalBinaryWrite(message.subscriptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.VaultsByHolderAddressResponse
 */
export const VaultsByHolderAddressResponse = new VaultsByHolderAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subscription$Type extends MessageType<Subscription> {
    constructor() {
        super("mito_api.Subscription", [
            { no: 1, name: "vault_info", kind: "message", T: () => Vault },
            { no: 2, name: "lp_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "holder_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "lp_amount_percentage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Subscription>): Subscription {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lpAmount = "";
        message.holderAddress = "";
        message.lpAmountPercentage = 0;
        if (value !== undefined)
            reflectionMergePartial<Subscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subscription): Subscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.Vault vault_info */ 1:
                    message.vaultInfo = Vault.internalBinaryRead(reader, reader.uint32(), options, message.vaultInfo);
                    break;
                case /* string lp_amount */ 2:
                    message.lpAmount = reader.string();
                    break;
                case /* string holder_address */ 3:
                    message.holderAddress = reader.string();
                    break;
                case /* double lp_amount_percentage */ 4:
                    message.lpAmountPercentage = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.Vault vault_info = 1; */
        if (message.vaultInfo)
            Vault.internalBinaryWrite(message.vaultInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string lp_amount = 2; */
        if (message.lpAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lpAmount);
        /* string holder_address = 3; */
        if (message.holderAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.holderAddress);
        /* double lp_amount_percentage = 4; */
        if (message.lpAmountPercentage !== 0)
            writer.tag(4, WireType.Bit64).double(message.lpAmountPercentage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Subscription
 */
export const Subscription = new Subscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LPHoldersRequest$Type extends MessageType<LPHoldersRequest> {
    constructor() {
        super("mito_api.LPHoldersRequest", [
            { no: 1, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "page_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "staking_contract_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LPHoldersRequest>): LPHoldersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        if (value !== undefined)
            reflectionMergePartial<LPHoldersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LPHoldersRequest): LPHoldersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* optional uint32 page_index */ 2:
                    message.pageIndex = reader.uint32();
                    break;
                case /* string vault_address */ 3:
                    message.vaultAddress = reader.string();
                    break;
                case /* optional string staking_contract_address */ 4:
                    message.stakingContractAddress = reader.string();
                    break;
                case /* optional sint32 skip */ 5:
                    message.skip = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LPHoldersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 limit = 1; */
        if (message.limit !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* optional uint32 page_index = 2; */
        if (message.pageIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.pageIndex);
        /* string vault_address = 3; */
        if (message.vaultAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.vaultAddress);
        /* optional string staking_contract_address = 4; */
        if (message.stakingContractAddress !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.stakingContractAddress);
        /* optional sint32 skip = 5; */
        if (message.skip !== undefined)
            writer.tag(5, WireType.Varint).sint32(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LPHoldersRequest
 */
export const LPHoldersRequest = new LPHoldersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LPHoldersResponse$Type extends MessageType<LPHoldersResponse> {
    constructor() {
        super("mito_api.LPHoldersResponse", [
            { no: 1, name: "holders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Holders },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<LPHoldersResponse>): LPHoldersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.holders = [];
        if (value !== undefined)
            reflectionMergePartial<LPHoldersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LPHoldersResponse): LPHoldersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.Holders holders */ 1:
                    message.holders.push(Holders.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LPHoldersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.Holders holders = 1; */
        for (let i = 0; i < message.holders.length; i++)
            Holders.internalBinaryWrite(message.holders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LPHoldersResponse
 */
export const LPHoldersResponse = new LPHoldersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Holders$Type extends MessageType<Holders> {
    constructor() {
        super("mito_api.Holders", [
            { no: 1, name: "holder_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "lp_amount_percentage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "redemption_lock_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "staked_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Holders>): Holders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.holderAddress = "";
        message.vaultAddress = "";
        message.amount = "";
        message.updatedAt = 0n;
        message.lpAmountPercentage = 0;
        message.redemptionLockTime = 0n;
        message.stakedAmount = "";
        if (value !== undefined)
            reflectionMergePartial<Holders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Holders): Holders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string holder_address */ 1:
                    message.holderAddress = reader.string();
                    break;
                case /* string vault_address */ 2:
                    message.vaultAddress = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                case /* sint64 updated_at */ 4:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* double lp_amount_percentage */ 5:
                    message.lpAmountPercentage = reader.double();
                    break;
                case /* sint64 redemption_lock_time */ 6:
                    message.redemptionLockTime = reader.sint64().toBigInt();
                    break;
                case /* string staked_amount */ 7:
                    message.stakedAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Holders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string holder_address = 1; */
        if (message.holderAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.holderAddress);
        /* string vault_address = 2; */
        if (message.vaultAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        /* sint64 updated_at = 4; */
        if (message.updatedAt !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.updatedAt);
        /* double lp_amount_percentage = 5; */
        if (message.lpAmountPercentage !== 0)
            writer.tag(5, WireType.Bit64).double(message.lpAmountPercentage);
        /* sint64 redemption_lock_time = 6; */
        if (message.redemptionLockTime !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.redemptionLockTime);
        /* string staked_amount = 7; */
        if (message.stakedAmount !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.stakedAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Holders
 */
export const Holders = new Holders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioRequest$Type extends MessageType<PortfolioRequest> {
    constructor() {
        super("mito_api.PortfolioRequest", [
            { no: 1, name: "holder_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "staking_contract_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PortfolioRequest>): PortfolioRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.holderAddress = "";
        if (value !== undefined)
            reflectionMergePartial<PortfolioRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioRequest): PortfolioRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string holder_address */ 1:
                    message.holderAddress = reader.string();
                    break;
                case /* optional string staking_contract_address */ 2:
                    message.stakingContractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string holder_address = 1; */
        if (message.holderAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.holderAddress);
        /* optional string staking_contract_address = 2; */
        if (message.stakingContractAddress !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.PortfolioRequest
 */
export const PortfolioRequest = new PortfolioRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioResponse$Type extends MessageType<PortfolioResponse> {
    constructor() {
        super("mito_api.PortfolioResponse", [
            { no: 1, name: "total_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "pnl", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "total_value_chart", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceSnapshot },
            { no: 4, name: "pnl_chart", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceSnapshot },
            { no: 5, name: "pnl_updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PortfolioResponse>): PortfolioResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalValue = 0;
        message.pnl = 0;
        message.totalValueChart = [];
        message.pnlChart = [];
        message.pnlUpdatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<PortfolioResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioResponse): PortfolioResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double total_value */ 1:
                    message.totalValue = reader.double();
                    break;
                case /* double pnl */ 2:
                    message.pnl = reader.double();
                    break;
                case /* repeated mito_api.PriceSnapshot total_value_chart */ 3:
                    message.totalValueChart.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated mito_api.PriceSnapshot pnl_chart */ 4:
                    message.pnlChart.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 pnl_updated_at */ 5:
                    message.pnlUpdatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double total_value = 1; */
        if (message.totalValue !== 0)
            writer.tag(1, WireType.Bit64).double(message.totalValue);
        /* double pnl = 2; */
        if (message.pnl !== 0)
            writer.tag(2, WireType.Bit64).double(message.pnl);
        /* repeated mito_api.PriceSnapshot total_value_chart = 3; */
        for (let i = 0; i < message.totalValueChart.length; i++)
            PriceSnapshot.internalBinaryWrite(message.totalValueChart[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated mito_api.PriceSnapshot pnl_chart = 4; */
        for (let i = 0; i < message.pnlChart.length; i++)
            PriceSnapshot.internalBinaryWrite(message.pnlChart[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sint64 pnl_updated_at = 5; */
        if (message.pnlUpdatedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.pnlUpdatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.PortfolioResponse
 */
export const PortfolioResponse = new PortfolioResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardRequest$Type extends MessageType<LeaderboardRequest> {
    constructor() {
        super("mito_api.LeaderboardRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardRequest>): LeaderboardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LeaderboardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardRequest): LeaderboardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 epoch_id */ 1:
                    message.epochId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 epoch_id = 1; */
        if (message.epochId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.epochId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardRequest
 */
export const LeaderboardRequest = new LeaderboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardResponse$Type extends MessageType<LeaderboardResponse> {
    constructor() {
        super("mito_api.LeaderboardResponse", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardEntry },
            { no: 2, name: "snapshot_block", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "epoch_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardResponse>): LeaderboardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        message.snapshotBlock = 0n;
        message.updatedAt = 0n;
        message.epochId = 0;
        if (value !== undefined)
            reflectionMergePartial<LeaderboardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardResponse): LeaderboardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.LeaderboardEntry entries */ 1:
                    message.entries.push(LeaderboardEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 snapshot_block */ 2:
                    message.snapshotBlock = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 3:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* uint32 epoch_id */ 4:
                    message.epochId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.LeaderboardEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            LeaderboardEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 snapshot_block = 2; */
        if (message.snapshotBlock !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.snapshotBlock);
        /* sint64 updated_at = 3; */
        if (message.updatedAt !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.updatedAt);
        /* uint32 epoch_id = 4; */
        if (message.epochId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.epochId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardResponse
 */
export const LeaderboardResponse = new LeaderboardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardEntry$Type extends MessageType<LeaderboardEntry> {
    constructor() {
        super("mito_api.LeaderboardEntry", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pnl", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardEntry>): LeaderboardEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.pnl = 0;
        if (value !== undefined)
            reflectionMergePartial<LeaderboardEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardEntry): LeaderboardEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* double pnl */ 2:
                    message.pnl = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* double pnl = 2; */
        if (message.pnl !== 0)
            writer.tag(2, WireType.Bit64).double(message.pnl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardEntry
 */
export const LeaderboardEntry = new LeaderboardEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardEpochsRequest$Type extends MessageType<LeaderboardEpochsRequest> {
    constructor() {
        super("mito_api.LeaderboardEpochsRequest", [
            { no: 1, name: "from_epoch_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "to_epoch_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardEpochsRequest>): LeaderboardEpochsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LeaderboardEpochsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardEpochsRequest): LeaderboardEpochsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 from_epoch_id */ 1:
                    message.fromEpochId = reader.uint32();
                    break;
                case /* optional uint32 to_epoch_id */ 2:
                    message.toEpochId = reader.uint32();
                    break;
                case /* optional uint32 limit */ 3:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardEpochsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 from_epoch_id = 1; */
        if (message.fromEpochId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.fromEpochId);
        /* optional uint32 to_epoch_id = 2; */
        if (message.toEpochId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.toEpochId);
        /* optional uint32 limit = 3; */
        if (message.limit !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardEpochsRequest
 */
export const LeaderboardEpochsRequest = new LeaderboardEpochsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardEpochsResponse$Type extends MessageType<LeaderboardEpochsResponse> {
    constructor() {
        super("mito_api.LeaderboardEpochsResponse", [
            { no: 1, name: "epochs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LeaderboardEpoch },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<LeaderboardEpochsResponse>): LeaderboardEpochsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochs = [];
        if (value !== undefined)
            reflectionMergePartial<LeaderboardEpochsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardEpochsResponse): LeaderboardEpochsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.LeaderboardEpoch epochs */ 1:
                    message.epochs.push(LeaderboardEpoch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardEpochsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.LeaderboardEpoch epochs = 1; */
        for (let i = 0; i < message.epochs.length; i++)
            LeaderboardEpoch.internalBinaryWrite(message.epochs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardEpochsResponse
 */
export const LeaderboardEpochsResponse = new LeaderboardEpochsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardEpoch$Type extends MessageType<LeaderboardEpoch> {
    constructor() {
        super("mito_api.LeaderboardEpoch", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "end_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "is_live", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardEpoch>): LeaderboardEpoch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = 0;
        message.startAt = 0n;
        message.endAt = 0n;
        message.isLive = false;
        if (value !== undefined)
            reflectionMergePartial<LeaderboardEpoch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardEpoch): LeaderboardEpoch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 epoch_id */ 1:
                    message.epochId = reader.uint32();
                    break;
                case /* sint64 start_at */ 2:
                    message.startAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_at */ 3:
                    message.endAt = reader.sint64().toBigInt();
                    break;
                case /* bool is_live */ 4:
                    message.isLive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardEpoch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 epoch_id = 1; */
        if (message.epochId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.epochId);
        /* sint64 start_at = 2; */
        if (message.startAt !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.startAt);
        /* sint64 end_at = 3; */
        if (message.endAt !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.endAt);
        /* bool is_live = 4; */
        if (message.isLive !== false)
            writer.tag(4, WireType.Varint).bool(message.isLive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardEpoch
 */
export const LeaderboardEpoch = new LeaderboardEpoch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransfersHistoryRequest$Type extends MessageType<TransfersHistoryRequest> {
    constructor() {
        super("mito_api.TransfersHistoryRequest", [
            { no: 1, name: "vault", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "from_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "to_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TransfersHistoryRequest>): TransfersHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TransfersHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransfersHistoryRequest): TransfersHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string vault */ 1:
                    message.vault = reader.string();
                    break;
                case /* optional string account */ 2:
                    message.account = reader.string();
                    break;
                case /* optional uint32 limit */ 3:
                    message.limit = reader.uint32();
                    break;
                case /* optional uint32 from_number */ 4:
                    message.fromNumber = reader.uint32();
                    break;
                case /* optional uint32 to_number */ 5:
                    message.toNumber = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransfersHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string vault = 1; */
        if (message.vault !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.vault);
        /* optional string account = 2; */
        if (message.account !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        /* optional uint32 limit = 3; */
        if (message.limit !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.limit);
        /* optional uint32 from_number = 4; */
        if (message.fromNumber !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.fromNumber);
        /* optional uint32 to_number = 5; */
        if (message.toNumber !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.toNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.TransfersHistoryRequest
 */
export const TransfersHistoryRequest = new TransfersHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransfersHistoryResponse$Type extends MessageType<TransfersHistoryResponse> {
    constructor() {
        super("mito_api.TransfersHistoryResponse", [
            { no: 1, name: "transfers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Transfer },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TransfersHistoryResponse>): TransfersHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transfers = [];
        if (value !== undefined)
            reflectionMergePartial<TransfersHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransfersHistoryResponse): TransfersHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.Transfer transfers */ 1:
                    message.transfers.push(Transfer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransfersHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.Transfer transfers = 1; */
        for (let i = 0; i < message.transfers.length; i++)
            Transfer.internalBinaryWrite(message.transfers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.TransfersHistoryResponse
 */
export const TransfersHistoryResponse = new TransfersHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transfer$Type extends MessageType<Transfer> {
    constructor() {
        super("mito_api.Transfer", [
            { no: 1, name: "lp_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "coins", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 3, name: "usd_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_deposit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "executed_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "vault", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "tid_by_vault", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "tid_by_account", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Transfer>): Transfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lpAmount = "";
        message.coins = [];
        message.usdValue = "";
        message.isDeposit = false;
        message.executedAt = 0n;
        message.account = "";
        message.vault = "";
        message.txHash = "";
        message.tidByVault = 0;
        message.tidByAccount = 0;
        if (value !== undefined)
            reflectionMergePartial<Transfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transfer): Transfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string lp_amount */ 1:
                    message.lpAmount = reader.string();
                    break;
                case /* repeated mito_api.Coin coins */ 2:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string usd_value */ 3:
                    message.usdValue = reader.string();
                    break;
                case /* bool is_deposit */ 4:
                    message.isDeposit = reader.bool();
                    break;
                case /* sint64 executed_at */ 5:
                    message.executedAt = reader.sint64().toBigInt();
                    break;
                case /* string account */ 6:
                    message.account = reader.string();
                    break;
                case /* string vault */ 7:
                    message.vault = reader.string();
                    break;
                case /* string tx_hash */ 8:
                    message.txHash = reader.string();
                    break;
                case /* uint32 tid_by_vault */ 9:
                    message.tidByVault = reader.uint32();
                    break;
                case /* uint32 tid_by_account */ 10:
                    message.tidByAccount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string lp_amount = 1; */
        if (message.lpAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.lpAmount);
        /* repeated mito_api.Coin coins = 2; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string usd_value = 3; */
        if (message.usdValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
        /* bool is_deposit = 4; */
        if (message.isDeposit !== false)
            writer.tag(4, WireType.Varint).bool(message.isDeposit);
        /* sint64 executed_at = 5; */
        if (message.executedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.executedAt);
        /* string account = 6; */
        if (message.account !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.account);
        /* string vault = 7; */
        if (message.vault !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.vault);
        /* string tx_hash = 8; */
        if (message.txHash !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.txHash);
        /* uint32 tid_by_vault = 9; */
        if (message.tidByVault !== 0)
            writer.tag(9, WireType.Varint).uint32(message.tidByVault);
        /* uint32 tid_by_account = 10; */
        if (message.tidByAccount !== 0)
            writer.tag(10, WireType.Varint).uint32(message.tidByAccount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Transfer
 */
export const Transfer = new Transfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Coin$Type extends MessageType<Coin> {
    constructor() {
        super("mito_api.Coin", [
            { no: 1, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Coin>): Coin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<Coin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coin): Coin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string amount */ 1:
                    message.amount = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string amount = 1; */
        if (message.amount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.amount);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Coin
 */
export const Coin = new Coin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStakingPoolsRequest$Type extends MessageType<GetStakingPoolsRequest> {
    constructor() {
        super("mito_api.GetStakingPoolsRequest", [
            { no: 1, name: "staker", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "staking_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetStakingPoolsRequest>): GetStakingPoolsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stakingContractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetStakingPoolsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStakingPoolsRequest): GetStakingPoolsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string staker */ 1:
                    message.staker = reader.string();
                    break;
                case /* string staking_contract_address */ 2:
                    message.stakingContractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStakingPoolsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string staker = 1; */
        if (message.staker !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.staker);
        /* string staking_contract_address = 2; */
        if (message.stakingContractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetStakingPoolsRequest
 */
export const GetStakingPoolsRequest = new GetStakingPoolsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStakingPoolsResponse$Type extends MessageType<GetStakingPoolsResponse> {
    constructor() {
        super("mito_api.GetStakingPoolsResponse", [
            { no: 1, name: "pools", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StakingPool },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetStakingPoolsResponse>): GetStakingPoolsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pools = [];
        if (value !== undefined)
            reflectionMergePartial<GetStakingPoolsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStakingPoolsResponse): GetStakingPoolsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.StakingPool pools */ 1:
                    message.pools.push(StakingPool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStakingPoolsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.StakingPool pools = 1; */
        for (let i = 0; i < message.pools.length; i++)
            StakingPool.internalBinaryWrite(message.pools[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetStakingPoolsResponse
 */
export const GetStakingPoolsResponse = new GetStakingPoolsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingPool$Type extends MessageType<StakingPool> {
    constructor() {
        super("mito_api.StakingPool", [
            { no: 1, name: "vault_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "stake_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "gauges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Gauge },
            { no: 5, name: "apr", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "total_liquidity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "staking_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "apr_breakdown", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } }
        ]);
    }
    create(value?: PartialMessage<StakingPool>): StakingPool {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultName = "";
        message.vaultAddress = "";
        message.stakeDenom = "";
        message.gauges = [];
        message.apr = 0;
        message.totalLiquidity = 0;
        message.stakingAddress = "";
        message.aprBreakdown = {};
        if (value !== undefined)
            reflectionMergePartial<StakingPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingPool): StakingPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_name */ 1:
                    message.vaultName = reader.string();
                    break;
                case /* string vault_address */ 2:
                    message.vaultAddress = reader.string();
                    break;
                case /* string stake_denom */ 3:
                    message.stakeDenom = reader.string();
                    break;
                case /* repeated mito_api.Gauge gauges */ 4:
                    message.gauges.push(Gauge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double apr */ 5:
                    message.apr = reader.double();
                    break;
                case /* double total_liquidity */ 6:
                    message.totalLiquidity = reader.double();
                    break;
                case /* string staking_address */ 7:
                    message.stakingAddress = reader.string();
                    break;
                case /* map<string, double> apr_breakdown */ 8:
                    this.binaryReadMap8(message.aprBreakdown, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: StakingPool["aprBreakdown"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StakingPool["aprBreakdown"] | undefined, val: StakingPool["aprBreakdown"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for mito_api.StakingPool.apr_breakdown");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: StakingPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_name = 1; */
        if (message.vaultName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultName);
        /* string vault_address = 2; */
        if (message.vaultAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
        /* string stake_denom = 3; */
        if (message.stakeDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stakeDenom);
        /* repeated mito_api.Gauge gauges = 4; */
        for (let i = 0; i < message.gauges.length; i++)
            Gauge.internalBinaryWrite(message.gauges[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* double apr = 5; */
        if (message.apr !== 0)
            writer.tag(5, WireType.Bit64).double(message.apr);
        /* double total_liquidity = 6; */
        if (message.totalLiquidity !== 0)
            writer.tag(6, WireType.Bit64).double(message.totalLiquidity);
        /* string staking_address = 7; */
        if (message.stakingAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.stakingAddress);
        /* map<string, double> apr_breakdown = 8; */
        for (let k of globalThis.Object.keys(message.aprBreakdown))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit64).double(message.aprBreakdown[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingPool
 */
export const StakingPool = new StakingPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gauge$Type extends MessageType<Gauge> {
    constructor() {
        super("mito_api.Gauge", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "end_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "reward_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 6, name: "last_distribution", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Gauge>): Gauge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.owner = "";
        message.startTimestamp = 0n;
        message.endTimestamp = 0n;
        message.rewardTokens = [];
        message.lastDistribution = 0;
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<Gauge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gauge): Gauge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string owner */ 2:
                    message.owner = reader.string();
                    break;
                case /* sint64 start_timestamp */ 3:
                    message.startTimestamp = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_timestamp */ 4:
                    message.endTimestamp = reader.sint64().toBigInt();
                    break;
                case /* repeated mito_api.Coin reward_tokens */ 5:
                    message.rewardTokens.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 last_distribution */ 6:
                    message.lastDistribution = reader.uint32();
                    break;
                case /* string status */ 7:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gauge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string owner = 2; */
        if (message.owner !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.owner);
        /* sint64 start_timestamp = 3; */
        if (message.startTimestamp !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.startTimestamp);
        /* sint64 end_timestamp = 4; */
        if (message.endTimestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.endTimestamp);
        /* repeated mito_api.Coin reward_tokens = 5; */
        for (let i = 0; i < message.rewardTokens.length; i++)
            Coin.internalBinaryWrite(message.rewardTokens[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 last_distribution = 6; */
        if (message.lastDistribution !== 0)
            writer.tag(6, WireType.Varint).uint32(message.lastDistribution);
        /* string status = 7; */
        if (message.status !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Gauge
 */
export const Gauge = new Gauge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingRewardByAccountRequest$Type extends MessageType<StakingRewardByAccountRequest> {
    constructor() {
        super("mito_api.StakingRewardByAccountRequest", [
            { no: 1, name: "staker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "staking_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StakingRewardByAccountRequest>): StakingRewardByAccountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staker = "";
        message.stakingContractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<StakingRewardByAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingRewardByAccountRequest): StakingRewardByAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string staker */ 1:
                    message.staker = reader.string();
                    break;
                case /* string staking_contract_address */ 2:
                    message.stakingContractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingRewardByAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string staker = 1; */
        if (message.staker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.staker);
        /* string staking_contract_address = 2; */
        if (message.stakingContractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingRewardByAccountRequest
 */
export const StakingRewardByAccountRequest = new StakingRewardByAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingRewardByAccountResponse$Type extends MessageType<StakingRewardByAccountResponse> {
    constructor() {
        super("mito_api.StakingRewardByAccountResponse", [
            { no: 1, name: "rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StakingReward },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<StakingRewardByAccountResponse>): StakingRewardByAccountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rewards = [];
        if (value !== undefined)
            reflectionMergePartial<StakingRewardByAccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingRewardByAccountResponse): StakingRewardByAccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.StakingReward rewards */ 1:
                    message.rewards.push(StakingReward.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingRewardByAccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.StakingReward rewards = 1; */
        for (let i = 0; i < message.rewards.length; i++)
            StakingReward.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingRewardByAccountResponse
 */
export const StakingRewardByAccountResponse = new StakingRewardByAccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingReward$Type extends MessageType<StakingReward> {
    constructor() {
        super("mito_api.StakingReward", [
            { no: 1, name: "vault_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "staked_amount", kind: "message", T: () => Coin },
            { no: 4, name: "apr", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "claimable_rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 6, name: "lock_timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "locked_amount", kind: "message", T: () => Coin }
        ]);
    }
    create(value?: PartialMessage<StakingReward>): StakingReward {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultName = "";
        message.vaultAddress = "";
        message.apr = 0;
        message.claimableRewards = [];
        message.lockTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StakingReward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingReward): StakingReward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault_name */ 1:
                    message.vaultName = reader.string();
                    break;
                case /* string vault_address */ 2:
                    message.vaultAddress = reader.string();
                    break;
                case /* mito_api.Coin staked_amount */ 3:
                    message.stakedAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.stakedAmount);
                    break;
                case /* double apr */ 4:
                    message.apr = reader.double();
                    break;
                case /* repeated mito_api.Coin claimable_rewards */ 5:
                    message.claimableRewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 lock_timestamp */ 6:
                    message.lockTimestamp = reader.sint64().toBigInt();
                    break;
                case /* mito_api.Coin locked_amount */ 7:
                    message.lockedAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lockedAmount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingReward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault_name = 1; */
        if (message.vaultName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vaultName);
        /* string vault_address = 2; */
        if (message.vaultAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
        /* mito_api.Coin staked_amount = 3; */
        if (message.stakedAmount)
            Coin.internalBinaryWrite(message.stakedAmount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* double apr = 4; */
        if (message.apr !== 0)
            writer.tag(4, WireType.Bit64).double(message.apr);
        /* repeated mito_api.Coin claimable_rewards = 5; */
        for (let i = 0; i < message.claimableRewards.length; i++)
            Coin.internalBinaryWrite(message.claimableRewards[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* sint64 lock_timestamp = 6; */
        if (message.lockTimestamp !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.lockTimestamp);
        /* mito_api.Coin locked_amount = 7; */
        if (message.lockedAmount)
            Coin.internalBinaryWrite(message.lockedAmount, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingReward
 */
export const StakingReward = new StakingReward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingHistoryRequest$Type extends MessageType<StakingHistoryRequest> {
    constructor() {
        super("mito_api.StakingHistoryRequest", [
            { no: 1, name: "from_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "to_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "staker", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StakingHistoryRequest>): StakingHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StakingHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingHistoryRequest): StakingHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 from_number */ 1:
                    message.fromNumber = reader.uint32();
                    break;
                case /* optional uint32 to_number */ 2:
                    message.toNumber = reader.uint32();
                    break;
                case /* optional uint32 limit */ 3:
                    message.limit = reader.uint32();
                    break;
                case /* optional string staker */ 4:
                    message.staker = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 from_number = 1; */
        if (message.fromNumber !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.fromNumber);
        /* optional uint32 to_number = 2; */
        if (message.toNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.toNumber);
        /* optional uint32 limit = 3; */
        if (message.limit !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.limit);
        /* optional string staker = 4; */
        if (message.staker !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.staker);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingHistoryRequest
 */
export const StakingHistoryRequest = new StakingHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingHistoryResponse$Type extends MessageType<StakingHistoryResponse> {
    constructor() {
        super("mito_api.StakingHistoryResponse", [
            { no: 1, name: "activities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StakingActivity },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<StakingHistoryResponse>): StakingHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activities = [];
        if (value !== undefined)
            reflectionMergePartial<StakingHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingHistoryResponse): StakingHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.StakingActivity activities */ 1:
                    message.activities.push(StakingActivity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.StakingActivity activities = 1; */
        for (let i = 0; i < message.activities.length; i++)
            StakingActivity.internalBinaryWrite(message.activities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingHistoryResponse
 */
export const StakingHistoryResponse = new StakingHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingActivity$Type extends MessageType<StakingActivity> {
    constructor() {
        super("mito_api.StakingActivity", [
            { no: 1, name: "stake_amount", kind: "message", T: () => Coin },
            { no: 2, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rewarded_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 6, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "staker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "number_by_account", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StakingActivity>): StakingActivity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vaultAddress = "";
        message.action = "";
        message.txHash = "";
        message.rewardedTokens = [];
        message.timestamp = 0n;
        message.staker = "";
        message.numberByAccount = 0;
        if (value !== undefined)
            reflectionMergePartial<StakingActivity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingActivity): StakingActivity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.Coin stake_amount */ 1:
                    message.stakeAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.stakeAmount);
                    break;
                case /* string vault_address */ 2:
                    message.vaultAddress = reader.string();
                    break;
                case /* string action */ 3:
                    message.action = reader.string();
                    break;
                case /* string tx_hash */ 4:
                    message.txHash = reader.string();
                    break;
                case /* repeated mito_api.Coin rewarded_tokens */ 5:
                    message.rewardedTokens.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 timestamp */ 6:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* string staker */ 7:
                    message.staker = reader.string();
                    break;
                case /* uint32 number_by_account */ 8:
                    message.numberByAccount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingActivity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.Coin stake_amount = 1; */
        if (message.stakeAmount)
            Coin.internalBinaryWrite(message.stakeAmount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string vault_address = 2; */
        if (message.vaultAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
        /* string action = 3; */
        if (message.action !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.action);
        /* string tx_hash = 4; */
        if (message.txHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.txHash);
        /* repeated mito_api.Coin rewarded_tokens = 5; */
        for (let i = 0; i < message.rewardedTokens.length; i++)
            Coin.internalBinaryWrite(message.rewardedTokens[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* sint64 timestamp = 6; */
        if (message.timestamp !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.timestamp);
        /* string staker = 7; */
        if (message.staker !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.staker);
        /* uint32 number_by_account = 8; */
        if (message.numberByAccount !== 0)
            writer.tag(8, WireType.Varint).uint32(message.numberByAccount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingActivity
 */
export const StakingActivity = new StakingActivity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingAmountAtHeightRequest$Type extends MessageType<StakingAmountAtHeightRequest> {
    constructor() {
        super("mito_api.StakingAmountAtHeightRequest", [
            { no: 1, name: "staking_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "staker", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "skip", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StakingAmountAtHeightRequest>): StakingAmountAtHeightRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stakingContractAddress = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<StakingAmountAtHeightRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingAmountAtHeightRequest): StakingAmountAtHeightRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string staking_contract_address */ 1:
                    message.stakingContractAddress = reader.string();
                    break;
                case /* string denom */ 2:
                    message.denom = reader.string();
                    break;
                case /* optional uint64 height */ 3:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* optional string staker */ 4:
                    message.staker = reader.string();
                    break;
                case /* optional sint32 skip */ 5:
                    message.skip = reader.sint32();
                    break;
                case /* optional uint32 limit */ 6:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingAmountAtHeightRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string staking_contract_address = 1; */
        if (message.stakingContractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.stakingContractAddress);
        /* string denom = 2; */
        if (message.denom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.denom);
        /* optional uint64 height = 3; */
        if (message.height !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.height);
        /* optional string staker = 4; */
        if (message.staker !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.staker);
        /* optional sint32 skip = 5; */
        if (message.skip !== undefined)
            writer.tag(5, WireType.Varint).sint32(message.skip);
        /* optional uint32 limit = 6; */
        if (message.limit !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingAmountAtHeightRequest
 */
export const StakingAmountAtHeightRequest = new StakingAmountAtHeightRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingAmountAtHeightResponse$Type extends MessageType<StakingAmountAtHeightResponse> {
    constructor() {
        super("mito_api.StakingAmountAtHeightResponse", [
            { no: 1, name: "stakers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StakingAmount }
        ]);
    }
    create(value?: PartialMessage<StakingAmountAtHeightResponse>): StakingAmountAtHeightResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stakers = [];
        if (value !== undefined)
            reflectionMergePartial<StakingAmountAtHeightResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingAmountAtHeightResponse): StakingAmountAtHeightResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.StakingAmount stakers */ 1:
                    message.stakers.push(StakingAmount.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingAmountAtHeightResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.StakingAmount stakers = 1; */
        for (let i = 0; i < message.stakers.length; i++)
            StakingAmount.internalBinaryWrite(message.stakers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingAmountAtHeightResponse
 */
export const StakingAmountAtHeightResponse = new StakingAmountAtHeightResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StakingAmount$Type extends MessageType<StakingAmount> {
    constructor() {
        super("mito_api.StakingAmount", [
            { no: 1, name: "staker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "message", T: () => Coin },
            { no: 3, name: "latest_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StakingAmount>): StakingAmount {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staker = "";
        message.latestHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<StakingAmount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StakingAmount): StakingAmount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string staker */ 1:
                    message.staker = reader.string();
                    break;
                case /* mito_api.Coin amount */ 2:
                    message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                case /* uint64 latest_height */ 3:
                    message.latestHeight = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StakingAmount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string staker = 1; */
        if (message.staker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.staker);
        /* mito_api.Coin amount = 2; */
        if (message.amount)
            Coin.internalBinaryWrite(message.amount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 latest_height = 3; */
        if (message.latestHeight !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.latestHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StakingAmount
 */
export const StakingAmount = new StakingAmount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTransfersRequest$Type extends MessageType<StreamTransfersRequest> {
    constructor() {
        super("mito_api.StreamTransfersRequest", [
            { no: 1, name: "vault", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTransfersRequest>): StreamTransfersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamTransfersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTransfersRequest): StreamTransfersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string vault */ 1:
                    message.vault = reader.string();
                    break;
                case /* optional string account */ 2:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string vault = 1; */
        if (message.vault !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.vault);
        /* optional string account = 2; */
        if (message.account !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamTransfersRequest
 */
export const StreamTransfersRequest = new StreamTransfersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTransfersResponse$Type extends MessageType<StreamTransfersResponse> {
    constructor() {
        super("mito_api.StreamTransfersResponse", [
            { no: 1, name: "data", kind: "message", T: () => Transfer },
            { no: 2, name: "op_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamTransfersResponse>): StreamTransfersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamTransfersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTransfersResponse): StreamTransfersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.Transfer data */ 1:
                    message.data = Transfer.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* optional string op_type */ 2:
                    message.opType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.Transfer data = 1; */
        if (message.data)
            Transfer.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string op_type = 2; */
        if (message.opType !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.opType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamTransfersResponse
 */
export const StreamTransfersResponse = new StreamTransfersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamVaultRequest$Type extends MessageType<StreamVaultRequest> {
    constructor() {
        super("mito_api.StreamVaultRequest", [
            { no: 1, name: "vault", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamVaultRequest>): StreamVaultRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vault = "";
        if (value !== undefined)
            reflectionMergePartial<StreamVaultRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamVaultRequest): StreamVaultRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vault */ 1:
                    message.vault = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamVaultRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vault = 1; */
        if (message.vault !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vault);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamVaultRequest
 */
export const StreamVaultRequest = new StreamVaultRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamVaultResponse$Type extends MessageType<StreamVaultResponse> {
    constructor() {
        super("mito_api.StreamVaultResponse", [
            { no: 1, name: "data", kind: "message", T: () => Vault },
            { no: 2, name: "op_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamVaultResponse>): StreamVaultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamVaultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamVaultResponse): StreamVaultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.Vault data */ 1:
                    message.data = Vault.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* optional string op_type */ 2:
                    message.opType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamVaultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.Vault data = 1; */
        if (message.data)
            Vault.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string op_type = 2; */
        if (message.opType !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.opType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamVaultResponse
 */
export const StreamVaultResponse = new StreamVaultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamHolderSubscriptionRequest$Type extends MessageType<StreamHolderSubscriptionRequest> {
    constructor() {
        super("mito_api.StreamHolderSubscriptionRequest", [
            { no: 1, name: "holder_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vault_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "staking_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamHolderSubscriptionRequest>): StreamHolderSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.holderAddress = "";
        message.stakingContractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<StreamHolderSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamHolderSubscriptionRequest): StreamHolderSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string holder_address */ 1:
                    message.holderAddress = reader.string();
                    break;
                case /* optional string vault_address */ 2:
                    message.vaultAddress = reader.string();
                    break;
                case /* string staking_contract_address */ 3:
                    message.stakingContractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamHolderSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string holder_address = 1; */
        if (message.holderAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.holderAddress);
        /* optional string vault_address = 2; */
        if (message.vaultAddress !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
        /* string staking_contract_address = 3; */
        if (message.stakingContractAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stakingContractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamHolderSubscriptionRequest
 */
export const StreamHolderSubscriptionRequest = new StreamHolderSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamHolderSubscriptionResponse$Type extends MessageType<StreamHolderSubscriptionResponse> {
    constructor() {
        super("mito_api.StreamHolderSubscriptionResponse", [
            { no: 1, name: "data", kind: "message", T: () => Subscription },
            { no: 2, name: "op_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamHolderSubscriptionResponse>): StreamHolderSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamHolderSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamHolderSubscriptionResponse): StreamHolderSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.Subscription data */ 1:
                    message.data = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* optional string op_type */ 2:
                    message.opType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamHolderSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.Subscription data = 1; */
        if (message.data)
            Subscription.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string op_type = 2; */
        if (message.opType !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.opType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamHolderSubscriptionResponse
 */
export const StreamHolderSubscriptionResponse = new StreamHolderSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamStakingRewardByAccountRequest$Type extends MessageType<StreamStakingRewardByAccountRequest> {
    constructor() {
        super("mito_api.StreamStakingRewardByAccountRequest", [
            { no: 1, name: "staker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "staking_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamStakingRewardByAccountRequest>): StreamStakingRewardByAccountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staker = "";
        message.stakingContractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<StreamStakingRewardByAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamStakingRewardByAccountRequest): StreamStakingRewardByAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string staker */ 1:
                    message.staker = reader.string();
                    break;
                case /* string staking_contract_address */ 2:
                    message.stakingContractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamStakingRewardByAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string staker = 1; */
        if (message.staker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.staker);
        /* string staking_contract_address = 2; */
        if (message.stakingContractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamStakingRewardByAccountRequest
 */
export const StreamStakingRewardByAccountRequest = new StreamStakingRewardByAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamStakingRewardByAccountResponse$Type extends MessageType<StreamStakingRewardByAccountResponse> {
    constructor() {
        super("mito_api.StreamStakingRewardByAccountResponse", [
            { no: 1, name: "data", kind: "message", T: () => StakingReward },
            { no: 2, name: "op_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamStakingRewardByAccountResponse>): StreamStakingRewardByAccountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamStakingRewardByAccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamStakingRewardByAccountResponse): StreamStakingRewardByAccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.StakingReward data */ 1:
                    message.data = StakingReward.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* optional string op_type */ 2:
                    message.opType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamStakingRewardByAccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.StakingReward data = 1; */
        if (message.data)
            StakingReward.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string op_type = 2; */
        if (message.opType !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.opType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamStakingRewardByAccountResponse
 */
export const StreamStakingRewardByAccountResponse = new StreamStakingRewardByAccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamHistoricalStakingRequest$Type extends MessageType<StreamHistoricalStakingRequest> {
    constructor() {
        super("mito_api.StreamHistoricalStakingRequest", [
            { no: 1, name: "staker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "staking_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamHistoricalStakingRequest>): StreamHistoricalStakingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staker = "";
        message.stakingContractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<StreamHistoricalStakingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamHistoricalStakingRequest): StreamHistoricalStakingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string staker */ 1:
                    message.staker = reader.string();
                    break;
                case /* string staking_contract_address */ 2:
                    message.stakingContractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamHistoricalStakingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string staker = 1; */
        if (message.staker !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.staker);
        /* string staking_contract_address = 2; */
        if (message.stakingContractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamHistoricalStakingRequest
 */
export const StreamHistoricalStakingRequest = new StreamHistoricalStakingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamHistoricalStakingResponse$Type extends MessageType<StreamHistoricalStakingResponse> {
    constructor() {
        super("mito_api.StreamHistoricalStakingResponse", [
            { no: 1, name: "data", kind: "message", T: () => StakingActivity },
            { no: 2, name: "op_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamHistoricalStakingResponse>): StreamHistoricalStakingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamHistoricalStakingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamHistoricalStakingResponse): StreamHistoricalStakingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.StakingActivity data */ 1:
                    message.data = StakingActivity.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* optional string op_type */ 2:
                    message.opType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamHistoricalStakingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.StakingActivity data = 1; */
        if (message.data)
            StakingActivity.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string op_type = 2; */
        if (message.opType !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.opType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.StreamHistoricalStakingResponse
 */
export const StreamHistoricalStakingResponse = new StreamHistoricalStakingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthRequest$Type extends MessageType<HealthRequest> {
    constructor() {
        super("mito_api.HealthRequest", []);
    }
    create(value?: PartialMessage<HealthRequest>): HealthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthRequest): HealthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.HealthRequest
 */
export const HealthRequest = new HealthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthResponse$Type extends MessageType<HealthResponse> {
    constructor() {
        super("mito_api.HealthResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "commit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "lastest_synced_block", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "chain_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "block_diff_threshold", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HealthResponse>): HealthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.commit = "";
        message.lastestSyncedBlock = 0n;
        message.chainHeight = 0n;
        message.status = "";
        message.blockDiffThreshold = 0;
        if (value !== undefined)
            reflectionMergePartial<HealthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthResponse): HealthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string commit */ 2:
                    message.commit = reader.string();
                    break;
                case /* sint64 lastest_synced_block */ 3:
                    message.lastestSyncedBlock = reader.sint64().toBigInt();
                    break;
                case /* sint64 chain_height */ 4:
                    message.chainHeight = reader.sint64().toBigInt();
                    break;
                case /* string status */ 5:
                    message.status = reader.string();
                    break;
                case /* sint32 block_diff_threshold */ 6:
                    message.blockDiffThreshold = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string commit = 2; */
        if (message.commit !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.commit);
        /* sint64 lastest_synced_block = 3; */
        if (message.lastestSyncedBlock !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.lastestSyncedBlock);
        /* sint64 chain_height = 4; */
        if (message.chainHeight !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.chainHeight);
        /* string status = 5; */
        if (message.status !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.status);
        /* sint32 block_diff_threshold = 6; */
        if (message.blockDiffThreshold !== 0)
            writer.tag(6, WireType.Varint).sint32(message.blockDiffThreshold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.HealthResponse
 */
export const HealthResponse = new HealthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutionRequest$Type extends MessageType<ExecutionRequest> {
    constructor() {
        super("mito_api.ExecutionRequest", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExecutionRequest>): ExecutionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<ExecutionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecutionRequest): ExecutionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecutionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.ExecutionRequest
 */
export const ExecutionRequest = new ExecutionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutionResponse$Type extends MessageType<ExecutionResponse> {
    constructor() {
        super("mito_api.ExecutionResponse", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "current_block", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_executed_block", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "last_error_block", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "execution_logs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExecutionLog },
            { no: 6, name: "last_error_log", kind: "message", T: () => ExecutionLog }
        ]);
    }
    create(value?: PartialMessage<ExecutionResponse>): ExecutionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        message.currentBlock = 0n;
        message.lastExecutedBlock = 0n;
        message.lastErrorBlock = 0n;
        message.executionLogs = [];
        if (value !== undefined)
            reflectionMergePartial<ExecutionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecutionResponse): ExecutionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* sint64 current_block */ 2:
                    message.currentBlock = reader.sint64().toBigInt();
                    break;
                case /* sint64 last_executed_block */ 3:
                    message.lastExecutedBlock = reader.sint64().toBigInt();
                    break;
                case /* sint64 last_error_block */ 4:
                    message.lastErrorBlock = reader.sint64().toBigInt();
                    break;
                case /* repeated mito_api.ExecutionLog execution_logs */ 5:
                    message.executionLogs.push(ExecutionLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.ExecutionLog last_error_log */ 6:
                    message.lastErrorLog = ExecutionLog.internalBinaryRead(reader, reader.uint32(), options, message.lastErrorLog);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecutionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* sint64 current_block = 2; */
        if (message.currentBlock !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.currentBlock);
        /* sint64 last_executed_block = 3; */
        if (message.lastExecutedBlock !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.lastExecutedBlock);
        /* sint64 last_error_block = 4; */
        if (message.lastErrorBlock !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.lastErrorBlock);
        /* repeated mito_api.ExecutionLog execution_logs = 5; */
        for (let i = 0; i < message.executionLogs.length; i++)
            ExecutionLog.internalBinaryWrite(message.executionLogs[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.ExecutionLog last_error_log = 6; */
        if (message.lastErrorLog)
            ExecutionLog.internalBinaryWrite(message.lastErrorLog, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.ExecutionResponse
 */
export const ExecutionResponse = new ExecutionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutionLog$Type extends MessageType<ExecutionLog> {
    constructor() {
        super("mito_api.ExecutionLog", [
            { no: 1, name: "block", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "response", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExecutionLog>): ExecutionLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.block = 0n;
        message.response = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ExecutionLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecutionLog): ExecutionLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 block */ 1:
                    message.block = reader.sint64().toBigInt();
                    break;
                case /* string response */ 2:
                    message.response = reader.string();
                    break;
                case /* string error */ 3:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecutionLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 block = 1; */
        if (message.block !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.block);
        /* string response = 2; */
        if (message.response !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.response);
        /* string error = 3; */
        if (message.error !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.ExecutionLog
 */
export const ExecutionLog = new ExecutionLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionsRequest$Type extends MessageType<MissionsRequest> {
    constructor() {
        super("mito_api.MissionsRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MissionsRequest>): MissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<MissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionsRequest): MissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.MissionsRequest
 */
export const MissionsRequest = new MissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionsResponse$Type extends MessageType<MissionsResponse> {
    constructor() {
        super("mito_api.MissionsResponse", [
            { no: 1, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Mission },
            { no: 2, name: "rank", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MissionsResponse>): MissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionsResponse): MissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.Mission data */ 1:
                    message.data.push(Mission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional sint64 rank */ 2:
                    message.rank = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.Mission data = 1; */
        for (let i = 0; i < message.data.length; i++)
            Mission.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional sint64 rank = 2; */
        if (message.rank !== undefined)
            writer.tag(2, WireType.Varint).sint64(message.rank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.MissionsResponse
 */
export const MissionsResponse = new MissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mission$Type extends MessageType<Mission> {
    constructor() {
        super("mito_api.Mission", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "points", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "completed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "accrued_points", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "progress", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "expected", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Mission>): Mission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.points = 0n;
        message.completed = false;
        message.accruedPoints = 0n;
        message.updatedAt = 0n;
        message.progress = 0;
        message.expected = 0;
        if (value !== undefined)
            reflectionMergePartial<Mission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Mission): Mission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* sint64 points */ 2:
                    message.points = reader.sint64().toBigInt();
                    break;
                case /* bool completed */ 3:
                    message.completed = reader.bool();
                    break;
                case /* sint64 accrued_points */ 4:
                    message.accruedPoints = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 5:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* double progress */ 6:
                    message.progress = reader.double();
                    break;
                case /* double expected */ 7:
                    message.expected = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Mission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* sint64 points = 2; */
        if (message.points !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.points);
        /* bool completed = 3; */
        if (message.completed !== false)
            writer.tag(3, WireType.Varint).bool(message.completed);
        /* sint64 accrued_points = 4; */
        if (message.accruedPoints !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.accruedPoints);
        /* sint64 updated_at = 5; */
        if (message.updatedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.updatedAt);
        /* double progress = 6; */
        if (message.progress !== 0)
            writer.tag(6, WireType.Bit64).double(message.progress);
        /* double expected = 7; */
        if (message.expected !== 0)
            writer.tag(7, WireType.Bit64).double(message.expected);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.Mission
 */
export const Mission = new Mission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionLeaderboardRequest$Type extends MessageType<MissionLeaderboardRequest> {
    constructor() {
        super("mito_api.MissionLeaderboardRequest", [
            { no: 1, name: "user_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MissionLeaderboardRequest>): MissionLeaderboardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MissionLeaderboardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionLeaderboardRequest): MissionLeaderboardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string user_address */ 1:
                    message.userAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionLeaderboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string user_address = 1; */
        if (message.userAddress !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.userAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.MissionLeaderboardRequest
 */
export const MissionLeaderboardRequest = new MissionLeaderboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionLeaderboardResponse$Type extends MessageType<MissionLeaderboardResponse> {
    constructor() {
        super("mito_api.MissionLeaderboardResponse", [
            { no: 1, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MissionLeaderboardEntry },
            { no: 2, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "user_rank", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MissionLeaderboardResponse>): MissionLeaderboardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<MissionLeaderboardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionLeaderboardResponse): MissionLeaderboardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.MissionLeaderboardEntry data */ 1:
                    message.data.push(MissionLeaderboardEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 updated_at */ 2:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* optional sint64 user_rank */ 3:
                    message.userRank = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionLeaderboardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.MissionLeaderboardEntry data = 1; */
        for (let i = 0; i < message.data.length; i++)
            MissionLeaderboardEntry.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 updated_at = 2; */
        if (message.updatedAt !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.updatedAt);
        /* optional sint64 user_rank = 3; */
        if (message.userRank !== undefined)
            writer.tag(3, WireType.Varint).sint64(message.userRank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.MissionLeaderboardResponse
 */
export const MissionLeaderboardResponse = new MissionLeaderboardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionLeaderboardEntry$Type extends MessageType<MissionLeaderboardEntry> {
    constructor() {
        super("mito_api.MissionLeaderboardEntry", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "accrued_points", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MissionLeaderboardEntry>): MissionLeaderboardEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.accruedPoints = 0n;
        if (value !== undefined)
            reflectionMergePartial<MissionLeaderboardEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionLeaderboardEntry): MissionLeaderboardEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* sint64 accrued_points */ 2:
                    message.accruedPoints = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionLeaderboardEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* sint64 accrued_points = 2; */
        if (message.accruedPoints !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.accruedPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.MissionLeaderboardEntry
 */
export const MissionLeaderboardEntry = new MissionLeaderboardEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListIDOsRequest$Type extends MessageType<ListIDOsRequest> {
    constructor() {
        super("mito_api.ListIDOsRequest", [
            { no: 1, name: "status", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "to_number", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "account_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "owner_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListIDOsRequest>): ListIDOsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListIDOsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListIDOsRequest): ListIDOsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string status */ 1:
                    message.status = reader.string();
                    break;
                case /* optional sint32 limit */ 2:
                    message.limit = reader.sint32();
                    break;
                case /* optional sint32 to_number */ 3:
                    message.toNumber = reader.sint32();
                    break;
                case /* optional string account_address */ 4:
                    message.accountAddress = reader.string();
                    break;
                case /* optional string owner_address */ 5:
                    message.ownerAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListIDOsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string status = 1; */
        if (message.status !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* optional sint32 limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.limit);
        /* optional sint32 to_number = 3; */
        if (message.toNumber !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.toNumber);
        /* optional string account_address = 4; */
        if (message.accountAddress !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.accountAddress);
        /* optional string owner_address = 5; */
        if (message.ownerAddress !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.ownerAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.ListIDOsRequest
 */
export const ListIDOsRequest = new ListIDOsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListIDOsResponse$Type extends MessageType<ListIDOsResponse> {
    constructor() {
        super("mito_api.ListIDOsResponse", [
            { no: 1, name: "idos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => IDO },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<ListIDOsResponse>): ListIDOsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.idos = [];
        if (value !== undefined)
            reflectionMergePartial<ListIDOsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListIDOsResponse): ListIDOsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.IDO idos */ 1:
                    message.idos.push(IDO.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListIDOsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.IDO idos = 1; */
        for (let i = 0; i < message.idos.length; i++)
            IDO.internalBinaryWrite(message.idos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.ListIDOsResponse
 */
export const ListIDOsResponse = new ListIDOsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IDO$Type extends MessageType<IDO> {
    constructor() {
        super("mito_api.IDO", [
            { no: 1, name: "start_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "token_info", kind: "message", T: () => TokenInfo },
            { no: 6, name: "project_token_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "target_amount_in_quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "target_amount_in_usd", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "cap_per_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "subscribed_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "token_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "is_account_white_listed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "progress", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => IDOProgress },
            { no: 17, name: "stake_to_subscription", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ArrayOfString },
            { no: 18, name: "second_before_start_to_set_quote_price", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "use_whitelist", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "vault_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "is_launch_with_vault", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "is_vesting_schedule_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "init_params", kind: "message", T: () => InitParams },
            { no: 25, name: "project_description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "is_permissionless", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IDO>): IDO {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startTime = 0n;
        message.endTime = 0n;
        message.owner = "";
        message.status = "";
        message.projectTokenAmount = "";
        message.quoteDenom = "";
        message.targetAmountInQuoteDenom = "";
        message.targetAmountInUsd = "";
        message.capPerAddress = "";
        message.contractAddress = "";
        message.subscribedAmount = "";
        message.tokenPrice = 0;
        message.isAccountWhiteListed = false;
        message.name = "";
        message.progress = [];
        message.stakeToSubscription = [];
        message.secondBeforeStartToSetQuotePrice = 0n;
        message.useWhitelist = false;
        message.marketId = "";
        message.vaultAddress = "";
        message.isLaunchWithVault = false;
        message.isVestingScheduleEnabled = false;
        message.projectDescription = "";
        message.isPermissionless = false;
        if (value !== undefined)
            reflectionMergePartial<IDO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IDO): IDO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 start_time */ 1:
                    message.startTime = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_time */ 2:
                    message.endTime = reader.sint64().toBigInt();
                    break;
                case /* string owner */ 3:
                    message.owner = reader.string();
                    break;
                case /* string status */ 4:
                    message.status = reader.string();
                    break;
                case /* mito_api.TokenInfo token_info */ 5:
                    message.tokenInfo = TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
                    break;
                case /* string project_token_amount */ 6:
                    message.projectTokenAmount = reader.string();
                    break;
                case /* string quote_denom */ 7:
                    message.quoteDenom = reader.string();
                    break;
                case /* string target_amount_in_quote_denom */ 8:
                    message.targetAmountInQuoteDenom = reader.string();
                    break;
                case /* string target_amount_in_usd */ 9:
                    message.targetAmountInUsd = reader.string();
                    break;
                case /* string cap_per_address */ 10:
                    message.capPerAddress = reader.string();
                    break;
                case /* string contract_address */ 11:
                    message.contractAddress = reader.string();
                    break;
                case /* string subscribed_amount */ 12:
                    message.subscribedAmount = reader.string();
                    break;
                case /* double token_price */ 13:
                    message.tokenPrice = reader.double();
                    break;
                case /* bool is_account_white_listed */ 14:
                    message.isAccountWhiteListed = reader.bool();
                    break;
                case /* string name */ 15:
                    message.name = reader.string();
                    break;
                case /* repeated mito_api.IDOProgress progress */ 16:
                    message.progress.push(IDOProgress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated mito_api.ArrayOfString stake_to_subscription */ 17:
                    message.stakeToSubscription.push(ArrayOfString.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 second_before_start_to_set_quote_price */ 18:
                    message.secondBeforeStartToSetQuotePrice = reader.sint64().toBigInt();
                    break;
                case /* bool use_whitelist */ 19:
                    message.useWhitelist = reader.bool();
                    break;
                case /* string market_id */ 20:
                    message.marketId = reader.string();
                    break;
                case /* string vault_address */ 21:
                    message.vaultAddress = reader.string();
                    break;
                case /* bool is_launch_with_vault */ 22:
                    message.isLaunchWithVault = reader.bool();
                    break;
                case /* bool is_vesting_schedule_enabled */ 23:
                    message.isVestingScheduleEnabled = reader.bool();
                    break;
                case /* mito_api.InitParams init_params */ 24:
                    message.initParams = InitParams.internalBinaryRead(reader, reader.uint32(), options, message.initParams);
                    break;
                case /* string project_description */ 25:
                    message.projectDescription = reader.string();
                    break;
                case /* bool is_permissionless */ 26:
                    message.isPermissionless = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IDO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 start_time = 1; */
        if (message.startTime !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.startTime);
        /* sint64 end_time = 2; */
        if (message.endTime !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.endTime);
        /* string owner = 3; */
        if (message.owner !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.owner);
        /* string status = 4; */
        if (message.status !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.status);
        /* mito_api.TokenInfo token_info = 5; */
        if (message.tokenInfo)
            TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string project_token_amount = 6; */
        if (message.projectTokenAmount !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.projectTokenAmount);
        /* string quote_denom = 7; */
        if (message.quoteDenom !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.quoteDenom);
        /* string target_amount_in_quote_denom = 8; */
        if (message.targetAmountInQuoteDenom !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.targetAmountInQuoteDenom);
        /* string target_amount_in_usd = 9; */
        if (message.targetAmountInUsd !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.targetAmountInUsd);
        /* string cap_per_address = 10; */
        if (message.capPerAddress !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.capPerAddress);
        /* string contract_address = 11; */
        if (message.contractAddress !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.contractAddress);
        /* string subscribed_amount = 12; */
        if (message.subscribedAmount !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.subscribedAmount);
        /* double token_price = 13; */
        if (message.tokenPrice !== 0)
            writer.tag(13, WireType.Bit64).double(message.tokenPrice);
        /* bool is_account_white_listed = 14; */
        if (message.isAccountWhiteListed !== false)
            writer.tag(14, WireType.Varint).bool(message.isAccountWhiteListed);
        /* string name = 15; */
        if (message.name !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.name);
        /* repeated mito_api.IDOProgress progress = 16; */
        for (let i = 0; i < message.progress.length; i++)
            IDOProgress.internalBinaryWrite(message.progress[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated mito_api.ArrayOfString stake_to_subscription = 17; */
        for (let i = 0; i < message.stakeToSubscription.length; i++)
            ArrayOfString.internalBinaryWrite(message.stakeToSubscription[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* sint64 second_before_start_to_set_quote_price = 18; */
        if (message.secondBeforeStartToSetQuotePrice !== 0n)
            writer.tag(18, WireType.Varint).sint64(message.secondBeforeStartToSetQuotePrice);
        /* bool use_whitelist = 19; */
        if (message.useWhitelist !== false)
            writer.tag(19, WireType.Varint).bool(message.useWhitelist);
        /* string market_id = 20; */
        if (message.marketId !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.marketId);
        /* string vault_address = 21; */
        if (message.vaultAddress !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.vaultAddress);
        /* bool is_launch_with_vault = 22; */
        if (message.isLaunchWithVault !== false)
            writer.tag(22, WireType.Varint).bool(message.isLaunchWithVault);
        /* bool is_vesting_schedule_enabled = 23; */
        if (message.isVestingScheduleEnabled !== false)
            writer.tag(23, WireType.Varint).bool(message.isVestingScheduleEnabled);
        /* mito_api.InitParams init_params = 24; */
        if (message.initParams)
            InitParams.internalBinaryWrite(message.initParams, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* string project_description = 25; */
        if (message.projectDescription !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.projectDescription);
        /* bool is_permissionless = 26; */
        if (message.isPermissionless !== false)
            writer.tag(26, WireType.Varint).bool(message.isPermissionless);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.IDO
 */
export const IDO = new IDO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenInfo$Type extends MessageType<TokenInfo> {
    constructor() {
        super("mito_api.TokenInfo", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "supply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "decimal", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "logo_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenInfo>): TokenInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.denom = "";
        message.supply = "";
        message.symbol = "";
        message.decimal = 0;
        message.logoUrl = "";
        if (value !== undefined)
            reflectionMergePartial<TokenInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenInfo): TokenInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* string supply */ 2:
                    message.supply = reader.string();
                    break;
                case /* string symbol */ 3:
                    message.symbol = reader.string();
                    break;
                case /* sint32 decimal */ 4:
                    message.decimal = reader.sint32();
                    break;
                case /* string logo_url */ 5:
                    message.logoUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* string supply = 2; */
        if (message.supply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.supply);
        /* string symbol = 3; */
        if (message.symbol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.symbol);
        /* sint32 decimal = 4; */
        if (message.decimal !== 0)
            writer.tag(4, WireType.Varint).sint32(message.decimal);
        /* string logo_url = 5; */
        if (message.logoUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.logoUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.TokenInfo
 */
export const TokenInfo = new TokenInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IDOProgress$Type extends MessageType<IDOProgress> {
    constructor() {
        super("mito_api.IDOProgress", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<IDOProgress>): IDOProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<IDOProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IDOProgress): IDOProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* sint64 timestamp */ 2:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IDOProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* sint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.IDOProgress
 */
export const IDOProgress = new IDOProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArrayOfString$Type extends MessageType<ArrayOfString> {
    constructor() {
        super("mito_api.ArrayOfString", [
            { no: 1, name: "field", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ArrayOfString>): ArrayOfString {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = [];
        if (value !== undefined)
            reflectionMergePartial<ArrayOfString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArrayOfString): ArrayOfString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string field */ 1:
                    message.field.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArrayOfString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string field = 1; */
        for (let i = 0; i < message.field.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.field[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.ArrayOfString
 */
export const ArrayOfString = new ArrayOfString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitParams$Type extends MessageType<InitParams> {
    constructor() {
        super("mito_api.InitParams", [
            { no: 1, name: "vesting_config", kind: "message", T: () => VestingConfigMap }
        ]);
    }
    create(value?: PartialMessage<InitParams>): InitParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<InitParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitParams): InitParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.VestingConfigMap vesting_config */ 1:
                    message.vestingConfig = VestingConfigMap.internalBinaryRead(reader, reader.uint32(), options, message.vestingConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.VestingConfigMap vesting_config = 1; */
        if (message.vestingConfig)
            VestingConfigMap.internalBinaryWrite(message.vestingConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.InitParams
 */
export const InitParams = new InitParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VestingConfigMap$Type extends MessageType<VestingConfigMap> {
    constructor() {
        super("mito_api.VestingConfigMap", [
            { no: 1, name: "project_owner_quote", kind: "message", T: () => VestingConfig },
            { no: 2, name: "project_owner_lp_tokens", kind: "message", T: () => VestingConfig },
            { no: 3, name: "users_project_token", kind: "message", T: () => VestingConfig }
        ]);
    }
    create(value?: PartialMessage<VestingConfigMap>): VestingConfigMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VestingConfigMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VestingConfigMap): VestingConfigMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.VestingConfig project_owner_quote */ 1:
                    message.projectOwnerQuote = VestingConfig.internalBinaryRead(reader, reader.uint32(), options, message.projectOwnerQuote);
                    break;
                case /* mito_api.VestingConfig project_owner_lp_tokens */ 2:
                    message.projectOwnerLpTokens = VestingConfig.internalBinaryRead(reader, reader.uint32(), options, message.projectOwnerLpTokens);
                    break;
                case /* mito_api.VestingConfig users_project_token */ 3:
                    message.usersProjectToken = VestingConfig.internalBinaryRead(reader, reader.uint32(), options, message.usersProjectToken);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VestingConfigMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.VestingConfig project_owner_quote = 1; */
        if (message.projectOwnerQuote)
            VestingConfig.internalBinaryWrite(message.projectOwnerQuote, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.VestingConfig project_owner_lp_tokens = 2; */
        if (message.projectOwnerLpTokens)
            VestingConfig.internalBinaryWrite(message.projectOwnerLpTokens, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.VestingConfig users_project_token = 3; */
        if (message.usersProjectToken)
            VestingConfig.internalBinaryWrite(message.usersProjectToken, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.VestingConfigMap
 */
export const VestingConfigMap = new VestingConfigMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VestingConfig$Type extends MessageType<VestingConfig> {
    constructor() {
        super("mito_api.VestingConfig", [
            { no: 1, name: "vesting_duration_seconds", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "vesting_start_delay_seconds", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "schedule", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VestingConfig>): VestingConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VestingConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VestingConfig): VestingConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint64 vesting_duration_seconds */ 1:
                    message.vestingDurationSeconds = reader.sint64().toBigInt();
                    break;
                case /* optional sint64 vesting_start_delay_seconds */ 2:
                    message.vestingStartDelaySeconds = reader.sint64().toBigInt();
                    break;
                case /* optional string schedule */ 3:
                    message.schedule = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VestingConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint64 vesting_duration_seconds = 1; */
        if (message.vestingDurationSeconds !== undefined)
            writer.tag(1, WireType.Varint).sint64(message.vestingDurationSeconds);
        /* optional sint64 vesting_start_delay_seconds = 2; */
        if (message.vestingStartDelaySeconds !== undefined)
            writer.tag(2, WireType.Varint).sint64(message.vestingStartDelaySeconds);
        /* optional string schedule = 3; */
        if (message.schedule !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.schedule);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.VestingConfig
 */
export const VestingConfig = new VestingConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDORequest$Type extends MessageType<GetIDORequest> {
    constructor() {
        super("mito_api.GetIDORequest", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIDORequest>): GetIDORequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetIDORequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDORequest): GetIDORequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* optional string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDORequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* optional string account_address = 2; */
        if (message.accountAddress !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDORequest
 */
export const GetIDORequest = new GetIDORequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDOResponse$Type extends MessageType<GetIDOResponse> {
    constructor() {
        super("mito_api.GetIDOResponse", [
            { no: 1, name: "ido", kind: "message", T: () => IDO }
        ]);
    }
    create(value?: PartialMessage<GetIDOResponse>): GetIDOResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetIDOResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDOResponse): GetIDOResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.IDO ido */ 1:
                    message.ido = IDO.internalBinaryRead(reader, reader.uint32(), options, message.ido);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDOResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.IDO ido = 1; */
        if (message.ido)
            IDO.internalBinaryWrite(message.ido, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDOResponse
 */
export const GetIDOResponse = new GetIDOResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDOSubscribersRequest$Type extends MessageType<GetIDOSubscribersRequest> {
    constructor() {
        super("mito_api.GetIDOSubscribersRequest", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "skip", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "sort_by", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIDOSubscribersRequest>): GetIDOSubscribersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetIDOSubscribersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDOSubscribersRequest): GetIDOSubscribersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* optional sint32 limit */ 2:
                    message.limit = reader.sint32();
                    break;
                case /* optional sint32 skip */ 3:
                    message.skip = reader.sint32();
                    break;
                case /* optional string sort_by */ 4:
                    message.sortBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDOSubscribersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* optional sint32 limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.limit);
        /* optional sint32 skip = 3; */
        if (message.skip !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.skip);
        /* optional string sort_by = 4; */
        if (message.sortBy !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.sortBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDOSubscribersRequest
 */
export const GetIDOSubscribersRequest = new GetIDOSubscribersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDOSubscribersResponse$Type extends MessageType<GetIDOSubscribersResponse> {
    constructor() {
        super("mito_api.GetIDOSubscribersResponse", [
            { no: 1, name: "subscribers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => IDOSubscriber },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination },
            { no: 3, name: "token_info", kind: "message", T: () => TokenInfo },
            { no: 4, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIDOSubscribersResponse>): GetIDOSubscribersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscribers = [];
        message.quoteDenom = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<GetIDOSubscribersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDOSubscribersResponse): GetIDOSubscribersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.IDOSubscriber subscribers */ 1:
                    message.subscribers.push(IDOSubscriber.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* mito_api.TokenInfo token_info */ 3:
                    message.tokenInfo = TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
                    break;
                case /* string quote_denom */ 4:
                    message.quoteDenom = reader.string();
                    break;
                case /* string market_id */ 5:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDOSubscribersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.IDOSubscriber subscribers = 1; */
        for (let i = 0; i < message.subscribers.length; i++)
            IDOSubscriber.internalBinaryWrite(message.subscribers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.TokenInfo token_info = 3; */
        if (message.tokenInfo)
            TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string quote_denom = 4; */
        if (message.quoteDenom !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
        /* string market_id = 5; */
        if (message.marketId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDOSubscribersResponse
 */
export const GetIDOSubscribersResponse = new GetIDOSubscribersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IDOSubscriber$Type extends MessageType<IDOSubscriber> {
    constructor() {
        super("mito_api.IDOSubscriber", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscribed_coin", kind: "message", T: () => Coin },
            { no: 3, name: "last_subscribe_time", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "estimate_token_received", kind: "message", T: () => Coin },
            { no: 5, name: "estimate_lp_amount", kind: "message", T: () => Coin },
            { no: 6, name: "estimate_refund_amount", kind: "message", T: () => Coin },
            { no: 7, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<IDOSubscriber>): IDOSubscriber {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.lastSubscribeTime = 0n;
        message.createdAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<IDOSubscriber>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IDOSubscriber): IDOSubscriber {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* mito_api.Coin subscribed_coin */ 2:
                    message.subscribedCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.subscribedCoin);
                    break;
                case /* sint64 last_subscribe_time */ 3:
                    message.lastSubscribeTime = reader.sint64().toBigInt();
                    break;
                case /* mito_api.Coin estimate_token_received */ 4:
                    message.estimateTokenReceived = Coin.internalBinaryRead(reader, reader.uint32(), options, message.estimateTokenReceived);
                    break;
                case /* mito_api.Coin estimate_lp_amount */ 5:
                    message.estimateLpAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.estimateLpAmount);
                    break;
                case /* mito_api.Coin estimate_refund_amount */ 6:
                    message.estimateRefundAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.estimateRefundAmount);
                    break;
                case /* sint64 created_at */ 7:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IDOSubscriber, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* mito_api.Coin subscribed_coin = 2; */
        if (message.subscribedCoin)
            Coin.internalBinaryWrite(message.subscribedCoin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sint64 last_subscribe_time = 3; */
        if (message.lastSubscribeTime !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.lastSubscribeTime);
        /* mito_api.Coin estimate_token_received = 4; */
        if (message.estimateTokenReceived)
            Coin.internalBinaryWrite(message.estimateTokenReceived, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Coin estimate_lp_amount = 5; */
        if (message.estimateLpAmount)
            Coin.internalBinaryWrite(message.estimateLpAmount, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Coin estimate_refund_amount = 6; */
        if (message.estimateRefundAmount)
            Coin.internalBinaryWrite(message.estimateRefundAmount, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* sint64 created_at = 7; */
        if (message.createdAt !== 0n)
            writer.tag(7, WireType.Varint).sint64(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.IDOSubscriber
 */
export const IDOSubscriber = new IDOSubscriber$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDOSubscriptionRequest$Type extends MessageType<GetIDOSubscriptionRequest> {
    constructor() {
        super("mito_api.GetIDOSubscriptionRequest", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIDOSubscriptionRequest>): GetIDOSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractAddress = "";
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetIDOSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDOSubscriptionRequest): GetIDOSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDOSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDOSubscriptionRequest
 */
export const GetIDOSubscriptionRequest = new GetIDOSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDOSubscriptionResponse$Type extends MessageType<GetIDOSubscriptionResponse> {
    constructor() {
        super("mito_api.GetIDOSubscriptionResponse", [
            { no: 1, name: "subscription", kind: "message", T: () => IDOSubscription }
        ]);
    }
    create(value?: PartialMessage<GetIDOSubscriptionResponse>): GetIDOSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetIDOSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDOSubscriptionResponse): GetIDOSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.IDOSubscription subscription */ 1:
                    message.subscription = IDOSubscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDOSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.IDOSubscription subscription = 1; */
        if (message.subscription)
            IDOSubscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDOSubscriptionResponse
 */
export const GetIDOSubscriptionResponse = new GetIDOSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IDOSubscription$Type extends MessageType<IDOSubscription> {
    constructor() {
        super("mito_api.IDOSubscription", [
            { no: 1, name: "max_subscription_coin", kind: "message", T: () => Coin },
            { no: 2, name: "committed_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "claimable_coins", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 5, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "reward_claimed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "token_info", kind: "message", T: () => TokenInfo },
            { no: 8, name: "quote_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "staked_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "claim_tx_hash", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "owner_claimable_coins", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 12, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "weight", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "claimed_coins", kind: "message", T: () => IDOClaimedCoins }
        ]);
    }
    create(value?: PartialMessage<IDOSubscription>): IDOSubscription {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.committedAmount = "";
        message.price = 0;
        message.claimableCoins = [];
        message.updatedAt = 0n;
        message.rewardClaimed = false;
        message.quoteDenom = "";
        message.stakedAmount = "";
        message.ownerClaimableCoins = [];
        message.marketId = "";
        message.weight = "";
        if (value !== undefined)
            reflectionMergePartial<IDOSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IDOSubscription): IDOSubscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mito_api.Coin max_subscription_coin */ 1:
                    message.maxSubscriptionCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.maxSubscriptionCoin);
                    break;
                case /* string committed_amount */ 2:
                    message.committedAmount = reader.string();
                    break;
                case /* double price */ 3:
                    message.price = reader.double();
                    break;
                case /* repeated mito_api.Coin claimable_coins */ 4:
                    message.claimableCoins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 updated_at */ 5:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* bool reward_claimed */ 6:
                    message.rewardClaimed = reader.bool();
                    break;
                case /* mito_api.TokenInfo token_info */ 7:
                    message.tokenInfo = TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
                    break;
                case /* string quote_denom */ 8:
                    message.quoteDenom = reader.string();
                    break;
                case /* string staked_amount */ 9:
                    message.stakedAmount = reader.string();
                    break;
                case /* optional string claim_tx_hash */ 10:
                    message.claimTxHash = reader.string();
                    break;
                case /* repeated mito_api.Coin owner_claimable_coins */ 11:
                    message.ownerClaimableCoins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string market_id */ 12:
                    message.marketId = reader.string();
                    break;
                case /* string weight */ 13:
                    message.weight = reader.string();
                    break;
                case /* mito_api.IDOClaimedCoins claimed_coins */ 14:
                    message.claimedCoins = IDOClaimedCoins.internalBinaryRead(reader, reader.uint32(), options, message.claimedCoins);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IDOSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mito_api.Coin max_subscription_coin = 1; */
        if (message.maxSubscriptionCoin)
            Coin.internalBinaryWrite(message.maxSubscriptionCoin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string committed_amount = 2; */
        if (message.committedAmount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.committedAmount);
        /* double price = 3; */
        if (message.price !== 0)
            writer.tag(3, WireType.Bit64).double(message.price);
        /* repeated mito_api.Coin claimable_coins = 4; */
        for (let i = 0; i < message.claimableCoins.length; i++)
            Coin.internalBinaryWrite(message.claimableCoins[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sint64 updated_at = 5; */
        if (message.updatedAt !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.updatedAt);
        /* bool reward_claimed = 6; */
        if (message.rewardClaimed !== false)
            writer.tag(6, WireType.Varint).bool(message.rewardClaimed);
        /* mito_api.TokenInfo token_info = 7; */
        if (message.tokenInfo)
            TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string quote_denom = 8; */
        if (message.quoteDenom !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.quoteDenom);
        /* string staked_amount = 9; */
        if (message.stakedAmount !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.stakedAmount);
        /* optional string claim_tx_hash = 10; */
        if (message.claimTxHash !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.claimTxHash);
        /* repeated mito_api.Coin owner_claimable_coins = 11; */
        for (let i = 0; i < message.ownerClaimableCoins.length; i++)
            Coin.internalBinaryWrite(message.ownerClaimableCoins[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string market_id = 12; */
        if (message.marketId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.marketId);
        /* string weight = 13; */
        if (message.weight !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.weight);
        /* mito_api.IDOClaimedCoins claimed_coins = 14; */
        if (message.claimedCoins)
            IDOClaimedCoins.internalBinaryWrite(message.claimedCoins, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.IDOSubscription
 */
export const IDOSubscription = new IDOSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IDOClaimedCoins$Type extends MessageType<IDOClaimedCoins> {
    constructor() {
        super("mito_api.IDOClaimedCoins", [
            { no: 1, name: "claimed_coins", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Coin },
            { no: 2, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<IDOClaimedCoins>): IDOClaimedCoins {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.claimedCoins = [];
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<IDOClaimedCoins>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IDOClaimedCoins): IDOClaimedCoins {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.Coin claimed_coins */ 1:
                    message.claimedCoins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 updated_at */ 2:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IDOClaimedCoins, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.Coin claimed_coins = 1; */
        for (let i = 0; i < message.claimedCoins.length; i++)
            Coin.internalBinaryWrite(message.claimedCoins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 updated_at = 2; */
        if (message.updatedAt !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.IDOClaimedCoins
 */
export const IDOClaimedCoins = new IDOClaimedCoins$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDOActivitiesRequest$Type extends MessageType<GetIDOActivitiesRequest> {
    constructor() {
        super("mito_api.GetIDOActivitiesRequest", [
            { no: 1, name: "contract_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "to_number", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIDOActivitiesRequest>): GetIDOActivitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetIDOActivitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDOActivitiesRequest): GetIDOActivitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* optional string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                case /* optional sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                case /* optional string to_number */ 4:
                    message.toNumber = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDOActivitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string contract_address = 1; */
        if (message.contractAddress !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* optional string account_address = 2; */
        if (message.accountAddress !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        /* optional sint32 limit = 3; */
        if (message.limit !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        /* optional string to_number = 4; */
        if (message.toNumber !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.toNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDOActivitiesRequest
 */
export const GetIDOActivitiesRequest = new GetIDOActivitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIDOActivitiesResponse$Type extends MessageType<GetIDOActivitiesResponse> {
    constructor() {
        super("mito_api.GetIDOActivitiesResponse", [
            { no: 1, name: "activities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => IDOSubscriptionActivity },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetIDOActivitiesResponse>): GetIDOActivitiesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activities = [];
        if (value !== undefined)
            reflectionMergePartial<GetIDOActivitiesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIDOActivitiesResponse): GetIDOActivitiesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.IDOSubscriptionActivity activities */ 1:
                    message.activities.push(IDOSubscriptionActivity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIDOActivitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.IDOSubscriptionActivity activities = 1; */
        for (let i = 0; i < message.activities.length; i++)
            IDOSubscriptionActivity.internalBinaryWrite(message.activities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetIDOActivitiesResponse
 */
export const GetIDOActivitiesResponse = new GetIDOActivitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IDOSubscriptionActivity$Type extends MessageType<IDOSubscriptionActivity> {
    constructor() {
        super("mito_api.IDOSubscriptionActivity", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscribed_coin", kind: "message", T: () => Coin },
            { no: 3, name: "usd_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<IDOSubscriptionActivity>): IDOSubscriptionActivity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.usdValue = 0;
        message.timestamp = 0n;
        message.txHash = "";
        if (value !== undefined)
            reflectionMergePartial<IDOSubscriptionActivity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IDOSubscriptionActivity): IDOSubscriptionActivity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* mito_api.Coin subscribed_coin */ 2:
                    message.subscribedCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.subscribedCoin);
                    break;
                case /* double usd_value */ 3:
                    message.usdValue = reader.double();
                    break;
                case /* sint64 timestamp */ 4:
                    message.timestamp = reader.sint64().toBigInt();
                    break;
                case /* string tx_hash */ 5:
                    message.txHash = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IDOSubscriptionActivity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* mito_api.Coin subscribed_coin = 2; */
        if (message.subscribedCoin)
            Coin.internalBinaryWrite(message.subscribedCoin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double usd_value = 3; */
        if (message.usdValue !== 0)
            writer.tag(3, WireType.Bit64).double(message.usdValue);
        /* sint64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.timestamp);
        /* string tx_hash = 5; */
        if (message.txHash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.txHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.IDOSubscriptionActivity
 */
export const IDOSubscriptionActivity = new IDOSubscriptionActivity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWhitelistRequest$Type extends MessageType<GetWhitelistRequest> {
    constructor() {
        super("mito_api.GetWhitelistRequest", [
            { no: 1, name: "ido_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "skip", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "limit", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetWhitelistRequest>): GetWhitelistRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.idoAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetWhitelistRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWhitelistRequest): GetWhitelistRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ido_address */ 1:
                    message.idoAddress = reader.string();
                    break;
                case /* optional sint32 skip */ 2:
                    message.skip = reader.sint32();
                    break;
                case /* optional sint32 limit */ 3:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWhitelistRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ido_address = 1; */
        if (message.idoAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.idoAddress);
        /* optional sint32 skip = 2; */
        if (message.skip !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.skip);
        /* optional sint32 limit = 3; */
        if (message.limit !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetWhitelistRequest
 */
export const GetWhitelistRequest = new GetWhitelistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWhitelistResponse$Type extends MessageType<GetWhitelistResponse> {
    constructor() {
        super("mito_api.GetWhitelistResponse", [
            { no: 1, name: "ido_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "accounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WhitelistAccount },
            { no: 3, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetWhitelistResponse>): GetWhitelistResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accounts = [];
        if (value !== undefined)
            reflectionMergePartial<GetWhitelistResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWhitelistResponse): GetWhitelistResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string ido_address */ 1:
                    message.idoAddress = reader.string();
                    break;
                case /* repeated mito_api.WhitelistAccount accounts */ 2:
                    message.accounts.push(WhitelistAccount.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 3:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWhitelistResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string ido_address = 1; */
        if (message.idoAddress !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.idoAddress);
        /* repeated mito_api.WhitelistAccount accounts = 2; */
        for (let i = 0; i < message.accounts.length; i++)
            WhitelistAccount.internalBinaryWrite(message.accounts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 3; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetWhitelistResponse
 */
export const GetWhitelistResponse = new GetWhitelistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WhitelistAccount$Type extends MessageType<WhitelistAccount> {
    constructor() {
        super("mito_api.WhitelistAccount", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "weight", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WhitelistAccount>): WhitelistAccount {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.updatedAt = 0n;
        message.weight = "";
        if (value !== undefined)
            reflectionMergePartial<WhitelistAccount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WhitelistAccount): WhitelistAccount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* sint64 updated_at */ 2:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string weight */ 3:
                    message.weight = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WhitelistAccount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* sint64 updated_at = 2; */
        if (message.updatedAt !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.updatedAt);
        /* string weight = 3; */
        if (message.weight !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.weight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.WhitelistAccount
 */
export const WhitelistAccount = new WhitelistAccount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenMetadataRequest$Type extends MessageType<TokenMetadataRequest> {
    constructor() {
        super("mito_api.TokenMetadataRequest", []);
    }
    create(value?: PartialMessage<TokenMetadataRequest>): TokenMetadataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TokenMetadataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenMetadataRequest): TokenMetadataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenMetadataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.TokenMetadataRequest
 */
export const TokenMetadataRequest = new TokenMetadataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenMetadataResponse$Type extends MessageType<TokenMetadataResponse> {
    constructor() {
        super("mito_api.TokenMetadataResponse", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenMetadataResponse>): TokenMetadataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<TokenMetadataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenMetadataResponse): TokenMetadataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenMetadataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.TokenMetadataResponse
 */
export const TokenMetadataResponse = new TokenMetadataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClaimReferencesRequest$Type extends MessageType<GetClaimReferencesRequest> {
    constructor() {
        super("mito_api.GetClaimReferencesRequest", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ido_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "skip", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "limit", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetClaimReferencesRequest>): GetClaimReferencesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.idoAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetClaimReferencesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClaimReferencesRequest): GetClaimReferencesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* string ido_address */ 2:
                    message.idoAddress = reader.string();
                    break;
                case /* optional sint32 skip */ 3:
                    message.skip = reader.sint32();
                    break;
                case /* optional sint32 limit */ 4:
                    message.limit = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClaimReferencesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* string ido_address = 2; */
        if (message.idoAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.idoAddress);
        /* optional sint32 skip = 3; */
        if (message.skip !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.skip);
        /* optional sint32 limit = 4; */
        if (message.limit !== undefined)
            writer.tag(4, WireType.Varint).sint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetClaimReferencesRequest
 */
export const GetClaimReferencesRequest = new GetClaimReferencesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClaimReferencesResponse$Type extends MessageType<GetClaimReferencesResponse> {
    constructor() {
        super("mito_api.GetClaimReferencesResponse", [
            { no: 1, name: "claim_references", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClaimReference },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetClaimReferencesResponse>): GetClaimReferencesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.claimReferences = [];
        if (value !== undefined)
            reflectionMergePartial<GetClaimReferencesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClaimReferencesResponse): GetClaimReferencesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mito_api.ClaimReference claim_references */ 1:
                    message.claimReferences.push(ClaimReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mito_api.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClaimReferencesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mito_api.ClaimReference claim_references = 1; */
        for (let i = 0; i < message.claimReferences.length; i++)
            ClaimReference.internalBinaryWrite(message.claimReferences[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mito_api.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.GetClaimReferencesResponse
 */
export const GetClaimReferencesResponse = new GetClaimReferencesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClaimReference$Type extends MessageType<ClaimReference> {
    constructor() {
        super("mito_api.ClaimReference", [
            { no: 1, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cw_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ido_contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "start_vesting_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "vesting_duration_seconds", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "claimed_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "claimable_amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClaimReference>): ClaimReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountAddress = "";
        message.cwContractAddress = "";
        message.idoContractAddress = "";
        message.startVestingTime = "";
        message.vestingDurationSeconds = 0n;
        message.updatedAt = 0n;
        message.claimedAmount = "";
        message.claimableAmount = "";
        message.denom = "";
        if (value !== undefined)
            reflectionMergePartial<ClaimReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClaimReference): ClaimReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_address */ 1:
                    message.accountAddress = reader.string();
                    break;
                case /* string cw_contract_address */ 2:
                    message.cwContractAddress = reader.string();
                    break;
                case /* string ido_contract_address */ 3:
                    message.idoContractAddress = reader.string();
                    break;
                case /* string start_vesting_time */ 4:
                    message.startVestingTime = reader.string();
                    break;
                case /* sint64 vesting_duration_seconds */ 5:
                    message.vestingDurationSeconds = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 6:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* string claimed_amount */ 7:
                    message.claimedAmount = reader.string();
                    break;
                case /* string claimable_amount */ 8:
                    message.claimableAmount = reader.string();
                    break;
                case /* string denom */ 9:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClaimReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_address = 1; */
        if (message.accountAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
        /* string cw_contract_address = 2; */
        if (message.cwContractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cwContractAddress);
        /* string ido_contract_address = 3; */
        if (message.idoContractAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.idoContractAddress);
        /* string start_vesting_time = 4; */
        if (message.startVestingTime !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.startVestingTime);
        /* sint64 vesting_duration_seconds = 5; */
        if (message.vestingDurationSeconds !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.vestingDurationSeconds);
        /* sint64 updated_at = 6; */
        if (message.updatedAt !== 0n)
            writer.tag(6, WireType.Varint).sint64(message.updatedAt);
        /* string claimed_amount = 7; */
        if (message.claimedAmount !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.claimedAmount);
        /* string claimable_amount = 8; */
        if (message.claimableAmount !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.claimableAmount);
        /* string denom = 9; */
        if (message.denom !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mito_api.ClaimReference
 */
export const ClaimReference = new ClaimReference$Type();
/**
 * @generated ServiceType for protobuf service mito_api.MitoAPI
 */
export const MitoAPI = new ServiceType("mito_api.MitoAPI", [
    { name: "GetVaults", options: {}, I: GetVaultsRequest, O: GetVaultsResponse },
    { name: "GetVault", options: {}, I: GetVaultRequest, O: GetVaultResponse },
    { name: "LPTokenPriceChart", options: {}, I: LPTokenPriceChartRequest, O: LPTokenPriceChartResponse },
    { name: "TVLChart", options: {}, I: TVLChartRequest, O: TVLChartResponse },
    { name: "VaultsByHolderAddress", options: {}, I: VaultsByHolderAddressRequest, O: VaultsByHolderAddressResponse },
    { name: "LPHolders", options: {}, I: LPHoldersRequest, O: LPHoldersResponse },
    { name: "Portfolio", options: {}, I: PortfolioRequest, O: PortfolioResponse },
    { name: "Leaderboard", options: {}, I: LeaderboardRequest, O: LeaderboardResponse },
    { name: "LeaderboardEpochs", options: {}, I: LeaderboardEpochsRequest, O: LeaderboardEpochsResponse },
    { name: "TransfersHistory", options: {}, I: TransfersHistoryRequest, O: TransfersHistoryResponse },
    { name: "GetStakingPools", options: {}, I: GetStakingPoolsRequest, O: GetStakingPoolsResponse },
    { name: "StakingRewardByAccount", options: {}, I: StakingRewardByAccountRequest, O: StakingRewardByAccountResponse },
    { name: "StakingHistory", options: {}, I: StakingHistoryRequest, O: StakingHistoryResponse },
    { name: "StakingAmountAtHeight", options: {}, I: StakingAmountAtHeightRequest, O: StakingAmountAtHeightResponse },
    { name: "StreamTransfers", serverStreaming: true, options: {}, I: StreamTransfersRequest, O: StreamTransfersResponse },
    { name: "StreamVault", serverStreaming: true, options: {}, I: StreamVaultRequest, O: StreamVaultResponse },
    { name: "StreamHolderSubscription", serverStreaming: true, options: {}, I: StreamHolderSubscriptionRequest, O: StreamHolderSubscriptionResponse },
    { name: "StreamStakingRewardByAccount", serverStreaming: true, options: {}, I: StreamStakingRewardByAccountRequest, O: StreamStakingRewardByAccountResponse },
    { name: "StreamHistoricalStaking", serverStreaming: true, options: {}, I: StreamHistoricalStakingRequest, O: StreamHistoricalStakingResponse },
    { name: "Health", options: {}, I: HealthRequest, O: HealthResponse },
    { name: "Execution", options: {}, I: ExecutionRequest, O: ExecutionResponse },
    { name: "Missions", options: {}, I: MissionsRequest, O: MissionsResponse },
    { name: "MissionLeaderboard", options: {}, I: MissionLeaderboardRequest, O: MissionLeaderboardResponse },
    { name: "ListIDOs", options: {}, I: ListIDOsRequest, O: ListIDOsResponse },
    { name: "GetIDO", options: {}, I: GetIDORequest, O: GetIDOResponse },
    { name: "GetIDOSubscribers", options: {}, I: GetIDOSubscribersRequest, O: GetIDOSubscribersResponse },
    { name: "GetIDOSubscription", options: {}, I: GetIDOSubscriptionRequest, O: GetIDOSubscriptionResponse },
    { name: "GetIDOActivities", options: {}, I: GetIDOActivitiesRequest, O: GetIDOActivitiesResponse },
    { name: "GetWhitelist", options: {}, I: GetWhitelistRequest, O: GetWhitelistResponse },
    { name: "TokenMetadata", options: {}, I: TokenMetadataRequest, O: TokenMetadataResponse },
    { name: "GetClaimReferences", options: {}, I: GetClaimReferencesRequest, O: GetClaimReferencesResponse }
]);
